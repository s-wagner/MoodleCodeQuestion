import { y as ISnippetsService, _ as __decorate, a as __param, n as IFileService, l as ITextFileService } from './services2.js';
import * as monacoSuggest from 'monaco-editor/esm/vs/editor/contrib/suggest/browser/suggest.js';
import { bU as IUserDataProfileService, bL as ILifecycleService } from './missing-services.js';
import { $ as isStringArray, p as parse, j as getNodeType, R as Range } from './polyfill.js';
import { extname as extname$1, basename as basename$1 } from 'monaco-editor/esm/vs/base/common/path.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
import { isEqualOrParent, extname, basename, relativePath, joinPath } from 'monaco-editor/esm/vs/base/common/resources.js';
import { IdleValue } from 'monaco-editor/esm/vs/base/common/async.js';
import { isObject } from 'monaco-editor/esm/vs/base/common/types.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { SnippetParser, Placeholder, Variable, Text } from 'monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetParser.js';
import { tail, insertInto } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { KnownSnippetVariableNames } from 'monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetVariables.js';
import { E as ExtensionsRegistry } from './extensionsRegistry.js';
import { l as languagesExtPoint } from './languageService.js';
import { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { getWordAtText } from 'monaco-editor/esm/vs/editor/common/core/wordHelper.js';
import { isPatternInWord } from 'monaco-editor/esm/vs/base/common/filters.js';
import { compare, firstNonWhitespaceIndex, compareSubstring, isFalsyOrWhitespace } from 'monaco-editor/esm/vs/base/common/strings.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { ILanguageConfigurationService } from 'monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js';
import { MarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { I as IExtensionResourceLoaderService } from './extensionResourceLoader.js';
import { DisposableStore, combinedDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
function setSnippetSuggestSupport (support) {
  if (monacoSuggest.setSnippetSuggestSupport != null) {
    monacoSuggest.setSnippetSuggestSupport(support);
  } else {
    console.error(
`setSnippetSuggestSupport does not exist in monaco-editor.
It's treeshaked out of monaco editor and needs to be reintroduced.
If you're using webpack, you can add a loader that will polyfill it:
\`\`\`
{
  test: /node_modules\\/monaco-editor\\//,
  loader: 'vscode/webpack-loader'
}
\`\`\`
`);
  }
}
class SnippetBodyInsights {
    constructor(body) {
        this.isBogous = false;
        this.isTrivial = false;
        this.usesClipboardVariable = false;
        this.usesSelectionVariable = false;
        this.codeSnippet = body;
        const textmateSnippet = ( (new SnippetParser())).parse(body, false);
        const placeholders = ( (new Map()));
        let placeholderMax = 0;
        for (const placeholder of textmateSnippet.placeholders) {
            placeholderMax = Math.max(placeholderMax, placeholder.index);
        }
        if (textmateSnippet.placeholders.length === 0) {
            this.isTrivial = true;
        }
        else if (placeholderMax === 0) {
            const last = tail(textmateSnippet.children);
            this.isTrivial = last instanceof Placeholder && last.isFinalTabstop;
        }
        const stack = [...textmateSnippet.children];
        while (stack.length > 0) {
            const marker = stack.shift();
            if (marker instanceof Variable) {
                if (marker.children.length === 0 && !KnownSnippetVariableNames[marker.name]) {
                    const index = placeholders.has(marker.name) ? placeholders.get(marker.name) : ++placeholderMax;
                    placeholders.set(marker.name, index);
                    const synthetic = ( (new Placeholder(index))).appendChild(( (new Text(marker.name))));
                    textmateSnippet.replace(marker, [synthetic]);
                    this.isBogous = true;
                }
                switch (marker.name) {
                    case 'CLIPBOARD':
                        this.usesClipboardVariable = true;
                        break;
                    case 'SELECTION':
                    case 'TM_SELECTED_TEXT':
                        this.usesSelectionVariable = true;
                        break;
                }
            }
            else {
                stack.push(...marker.children);
            }
        }
        if (this.isBogous) {
            this.codeSnippet = textmateSnippet.toTextmateString();
        }
    }
}
class Snippet {
    constructor(isFileTemplate, scopes, name, prefix, description, body, source, snippetSource, snippetIdentifier, extensionId) {
        this.isFileTemplate = isFileTemplate;
        this.scopes = scopes;
        this.name = name;
        this.prefix = prefix;
        this.description = description;
        this.body = body;
        this.source = source;
        this.snippetSource = snippetSource;
        this.snippetIdentifier = snippetIdentifier;
        this.extensionId = extensionId;
        this.prefixLow = prefix.toLowerCase();
        this._bodyInsights = ( (new IdleValue(() => ( (new SnippetBodyInsights(this.body))))));
    }
    get codeSnippet() {
        return this._bodyInsights.value.codeSnippet;
    }
    get isBogous() {
        return this._bodyInsights.value.isBogous;
    }
    get isTrivial() {
        return this._bodyInsights.value.isTrivial;
    }
    get needsClipboard() {
        return this._bodyInsights.value.usesClipboardVariable;
    }
    get usesSelection() {
        return this._bodyInsights.value.usesSelectionVariable;
    }
}
function isJsonSerializedSnippet(thing) {
    return isObject(thing) && Boolean(thing.body);
}
class SnippetFile {
    constructor(source, location, defaultScopes, _extension, _fileService, _extensionResourceLoaderService) {
        this.source = source;
        this.location = location;
        this.defaultScopes = defaultScopes;
        this._extension = _extension;
        this._fileService = _fileService;
        this._extensionResourceLoaderService = _extensionResourceLoaderService;
        this.data = [];
        this.isGlobalSnippets = extname$1(location.path) === '.code-snippets';
        this.isUserSnippets = !this._extension;
    }
    select(selector, bucket) {
        if (this.isGlobalSnippets || !this.isUserSnippets) {
            this._scopeSelect(selector, bucket);
        }
        else {
            this._filepathSelect(selector, bucket);
        }
    }
    _filepathSelect(selector, bucket) {
        if (selector + '.json' === basename$1(this.location.path)) {
            bucket.push(...this.data);
        }
    }
    _scopeSelect(selector, bucket) {
        for (const snippet of this.data) {
            const len = snippet.scopes.length;
            if (len === 0) {
                bucket.push(snippet);
            }
            else {
                for (let i = 0; i < len; i++) {
                    if (snippet.scopes[i] === selector) {
                        bucket.push(snippet);
                        break;
                    }
                }
            }
        }
        const idx = selector.lastIndexOf('.');
        if (idx >= 0) {
            this._scopeSelect(selector.substring(0, idx), bucket);
        }
    }
    async _load() {
        if (this._extension) {
            return this._extensionResourceLoaderService.readExtensionResource(this.location);
        }
        else {
            const content = await this._fileService.readFile(this.location);
            return (
                 (content.value.toString())
            );
        }
    }
    load() {
        if (!this._loadPromise) {
            this._loadPromise = Promise.resolve(this._load()).then(content => {
                const data = parse(content);
                if (getNodeType(data) === 'object') {
                    for (const [name, scopeOrTemplate] of Object.entries(data)) {
                        if (isJsonSerializedSnippet(scopeOrTemplate)) {
                            this._parseSnippet(name, scopeOrTemplate, this.data);
                        }
                        else {
                            for (const [name, template] of Object.entries(scopeOrTemplate)) {
                                this._parseSnippet(name, template, this.data);
                            }
                        }
                    }
                }
                return this;
            });
        }
        return this._loadPromise;
    }
    reset() {
        this._loadPromise = undefined;
        this.data.length = 0;
    }
    _parseSnippet(name, snippet, bucket) {
        let { isFileTemplate, prefix, body, description } = snippet;
        if (!prefix) {
            prefix = '';
        }
        if (Array.isArray(body)) {
            body = body.join('\n');
        }
        if (typeof body !== 'string') {
            return;
        }
        if (Array.isArray(description)) {
            description = description.join('\n');
        }
        let scopes;
        if (this.defaultScopes) {
            scopes = this.defaultScopes;
        }
        else if (typeof snippet.scope === 'string') {
            scopes = ( (snippet.scope.split(',').map(s => s.trim()))).filter(Boolean);
        }
        else {
            scopes = [];
        }
        let source;
        if (this._extension) {
            source = this._extension.displayName || this._extension.name;
        }
        else if (this.source === 2 ) {
            source = ( (localize('source.workspaceSnippetGlobal', "Workspace Snippet")));
        }
        else {
            if (this.isGlobalSnippets) {
                source = ( (localize('source.userSnippetGlobal', "Global User Snippet")));
            }
            else {
                source = ( (localize('source.userSnippet', "User Snippet")));
            }
        }
        for (const _prefix of Iterable.wrap(prefix)) {
            bucket.push(( (new Snippet(
                Boolean(isFileTemplate),
                scopes,
                name,
                _prefix,
                description,
                body,
                source,
                this.source,
                this._extension ? `${relativePath(this._extension.extensionLocation, this.location)}/${name}` : `${basename$1(this.location.path)}/${name}`,
                this._extension?.identifier
            ))));
        }
    }
}
const markSnippetAsUsed = '_snippet.markAsUsed';
CommandsRegistry.registerCommand(markSnippetAsUsed, (accessor, ...args) => {
    const snippetsService = accessor.get(ISnippetsService);
    const [first] = args;
    if (first instanceof Snippet) {
        snippetsService.updateUsageTimestamp(first);
    }
});
class SnippetCompletion {
    constructor(snippet, range) {
        this.snippet = snippet;
        this.label = { label: snippet.prefix, description: snippet.name };
        this.detail = ( (localize(
            'detail.snippet',
            "{0} ({1})",
            snippet.description || snippet.name,
            snippet.source
        )));
        this.insertText = snippet.codeSnippet;
        this.extensionId = snippet.extensionId;
        this.range = range;
        this.sortText = `${snippet.snippetSource === 3  ? 'z' : 'a'}-${snippet.prefix}`;
        this.kind = 27 ;
        this.insertTextRules = 4 ;
        this.command = { id: markSnippetAsUsed, title: '', arguments: [snippet] };
    }
    resolve() {
        this.documentation = ( (new MarkdownString())).appendCodeblock('', SnippetParser.asInsertText(this.snippet.codeSnippet));
        return this;
    }
    static compareByLabel(a, b) {
        return compare(a.label.label, b.label.label);
    }
}
let SnippetCompletionProvider = class SnippetCompletionProvider {
    constructor(_languageService, _snippets, _languageConfigurationService) {
        this._languageService = _languageService;
        this._snippets = _snippets;
        this._languageConfigurationService = _languageConfigurationService;
        this._debugDisplayName = 'snippetCompletions';
    }
    async provideCompletionItems(model, position, context) {
        const sw = ( (new StopWatch(true)));
        const languageId = this._getLanguageIdAtPosition(model, position);
        const languageConfig = this._languageConfigurationService.getLanguageConfiguration(languageId);
        const snippets = ( (new Set(await this._snippets.getSnippets(languageId))));
        const lineContentLow = model.getLineContent(position.lineNumber).toLowerCase();
        const wordUntil = model.getWordUntilPosition(position).word.toLowerCase();
        const suggestions = [];
        const columnOffset = position.column - 1;
        const triggerCharacterLow = context.triggerCharacter?.toLowerCase() ?? '';
        snippet: for (const snippet of snippets) {
            if (context.triggerKind === 1  && !snippet.prefixLow.startsWith(triggerCharacterLow)) {
                continue snippet;
            }
            const word = getWordAtText(1, languageConfig.getWordDefinition(), snippet.prefixLow, 0);
            if (wordUntil && word && !isPatternInWord(wordUntil, 0, wordUntil.length, snippet.prefixLow, 0, snippet.prefixLow.length)) {
                continue snippet;
            }
            const minPos = firstNonWhitespaceIndex(snippet.prefixLow) === 0
                ? Math.max(0, model.getLineFirstNonWhitespaceColumn(position.lineNumber) - 1)
                : 0;
            column: for (let pos = Math.max(minPos, columnOffset - snippet.prefixLow.length); pos < lineContentLow.length; pos++) {
                if (!isPatternInWord(lineContentLow, pos, columnOffset, snippet.prefixLow, 0, snippet.prefixLow.length)) {
                    continue column;
                }
                const prefixRestLen = snippet.prefixLow.length - (columnOffset - pos);
                const endsWithPrefixRest = compareSubstring(lineContentLow, snippet.prefixLow, columnOffset, columnOffset + prefixRestLen, columnOffset - pos);
                const startPosition = position.with(undefined, pos + 1);
                if (wordUntil && position.equals(startPosition)) {
                    continue snippet;
                }
                let endColumn = endsWithPrefixRest === 0 ? position.column + prefixRestLen : position.column;
                if (columnOffset < lineContentLow.length) {
                    const autoClosingPairs = languageConfig.getAutoClosingPairs();
                    const standardAutoClosingPairConditionals = autoClosingPairs.autoClosingPairsCloseSingleChar.get(lineContentLow[columnOffset]);
                    if (standardAutoClosingPairConditionals?.some(p =>
                    p.open === lineContentLow[startPosition.column - 1] &&
                        snippet.prefix.startsWith(p.open) &&
                        snippet.prefix[snippet.prefix.length - 1] === p.close)) {
                        endColumn++;
                    }
                }
                const replace = Range.fromPositions(startPosition, { lineNumber: position.lineNumber, column: endColumn });
                const insert = replace.setEndPosition(position.lineNumber, position.column);
                suggestions.push(( (new SnippetCompletion(snippet, { replace, insert }))));
                snippets.delete(snippet);
                break;
            }
        }
        if (!triggerCharacterLow) {
            const endsInWhitespace = /\s/.test(lineContentLow[position.column - 2]);
            if (endsInWhitespace || !lineContentLow ) {
                for (const snippet of snippets) {
                    const insert = Range.fromPositions(position);
                    const replace = lineContentLow.indexOf(snippet.prefixLow, columnOffset) === columnOffset ? insert.setEndPosition(position.lineNumber, position.column + snippet.prefixLow.length) : insert;
                    suggestions.push(( (new SnippetCompletion(snippet, { replace, insert }))));
                }
            }
        }
        suggestions.sort(SnippetCompletion.compareByLabel);
        for (let i = 0; i < suggestions.length; i++) {
            const item = suggestions[i];
            let to = i + 1;
            for (; to < suggestions.length && item.label === suggestions[to].label; to++) {
                suggestions[to].label.label = ( (localize(
                    'snippetSuggest.longLabel',
                    "{0}, {1}",
                    suggestions[to].label.label,
                    suggestions[to].snippet.name
                )));
            }
            if (to > i + 1) {
                suggestions[i].label.label = ( (localize(
                    'snippetSuggest.longLabel',
                    "{0}, {1}",
                    suggestions[i].label.label,
                    suggestions[i].snippet.name
                )));
                i = to;
            }
        }
        return {
            suggestions,
            duration: sw.elapsed()
        };
    }
    resolveCompletionItem(item) {
        return (item instanceof SnippetCompletion) ? item.resolve() : item;
    }
    _getLanguageIdAtPosition(model, position) {
        model.tokenization.tokenizeIfCheap(position.lineNumber);
        let languageId = model.getLanguageIdAtPosition(position.lineNumber, position.column);
        if (!this._languageService.getLanguageName(languageId)) {
            languageId = model.getLanguageId();
        }
        return languageId;
    }
};
SnippetCompletionProvider = ( (__decorate([
    ( (__param(0, ILanguageService))),
    ( (__param(1, ISnippetsService))),
    ( (__param(2, ILanguageConfigurationService)))
], SnippetCompletionProvider)));
var snippetExt;
( ((function(snippetExt) {
    function toValidSnippet(extension, snippet, languageService) {
        if (isFalsyOrWhitespace(snippet.path)) {
            extension.collector.error(( (localize(
                'invalid.path.0',
                "Expected string in `contributes.{0}.path`. Provided value: {1}",
                extension.description.name,
                String(snippet.path)
            ))));
            return null;
        }
        if (isFalsyOrWhitespace(snippet.language) && !snippet.path.endsWith('.code-snippets')) {
            extension.collector.error(( (localize(
                'invalid.language.0',
                "When omitting the language, the value of `contributes.{0}.path` must be a `.code-snippets`-file. Provided value: {1}",
                extension.description.name,
                String(snippet.path)
            ))));
            return null;
        }
        if (!isFalsyOrWhitespace(snippet.language) && !languageService.isRegisteredLanguageId(snippet.language)) {
            extension.collector.error(( (localize(
                'invalid.language',
                "Unknown language in `contributes.{0}.language`. Provided value: {1}",
                extension.description.name,
                String(snippet.language)
            ))));
            return null;
        }
        const extensionLocation = extension.description.extensionLocation;
        const snippetLocation = joinPath(extensionLocation, snippet.path);
        if (!isEqualOrParent(snippetLocation, extensionLocation)) {
            extension.collector.error(( (localize(
                'invalid.path.1',
                "Expected `contributes.{0}.path` ({1}) to be included inside extension's folder ({2}). This might make the extension non-portable.",
                extension.description.name,
                snippetLocation.path,
                extensionLocation.path
            ))));
            return null;
        }
        return {
            language: snippet.language,
            location: snippetLocation
        };
    }
    snippetExt.toValidSnippet = toValidSnippet;
    snippetExt.snippetsContribution = {
        description: ( (localize('vscode.extension.contributes.snippets', 'Contributes snippets.'))),
        type: 'array',
        defaultSnippets: [{ body: [{ language: '', path: '' }] }],
        items: {
            type: 'object',
            defaultSnippets: [{ body: { language: '${1:id}', path: './snippets/${2:id}.json.' } }],
            properties: {
                language: {
                    description: ( (localize(
                        'vscode.extension.contributes.snippets-language',
                        'Language identifier for which this snippet is contributed to.'
                    ))),
                    type: 'string'
                },
                path: {
                    description: ( (localize(
                        'vscode.extension.contributes.snippets-path',
                        'Path of the snippets file. The path is relative to the extension folder and typically starts with \'./snippets/\'.'
                    ))),
                    type: 'string'
                }
            }
        }
    };
    snippetExt.point = ( (ExtensionsRegistry.registerExtensionPoint({
        extensionPoint: 'snippets',
        deps: [languagesExtPoint],
        jsonSchema: snippetExt.snippetsContribution
    })));
})(snippetExt || (snippetExt = {}))));
function watch(service, resource, callback) {
    return combinedDisposable(service.watch(resource), service.onDidFilesChange(e => {
        if (e.affects(resource)) {
            callback();
        }
    }));
}
let SnippetEnablement = class SnippetEnablement {
    constructor(_storageService) {
        this._storageService = _storageService;
        const raw = _storageService.get(SnippetEnablement._key, 0 , '');
        let data;
        try {
            data = JSON.parse(raw);
        }
        catch { }
        this._ignored = isStringArray(data) ? ( (new Set(data))) : ( (new Set()));
    }
    isIgnored(id) {
        return this._ignored.has(id);
    }
    updateIgnored(id, value) {
        let changed = false;
        if (this._ignored.has(id) && !value) {
            this._ignored.delete(id);
            changed = true;
        }
        else if (!this._ignored.has(id) && value) {
            this._ignored.add(id);
            changed = true;
        }
        if (changed) {
            this._storageService.store(SnippetEnablement._key, JSON.stringify(Array.from(this._ignored)), 0 , 0 );
        }
    }
};
SnippetEnablement._key = 'snippets.ignoredSnippets';
SnippetEnablement = ( (__decorate([
    ( (__param(0, IStorageService)))
], SnippetEnablement)));
let SnippetUsageTimestamps = class SnippetUsageTimestamps {
    constructor(_storageService) {
        this._storageService = _storageService;
        const raw = _storageService.get(SnippetUsageTimestamps._key, 0 , '');
        let data;
        try {
            data = JSON.parse(raw);
        }
        catch {
            data = [];
        }
        this._usages = Array.isArray(data) ? ( (new Map(data))) : ( (new Map()));
    }
    getUsageTimestamp(id) {
        return this._usages.get(id);
    }
    updateUsageTimestamp(id) {
        this._usages.delete(id);
        this._usages.set(id, Date.now());
        const all = [...this._usages].slice(-100);
        this._storageService.store(SnippetUsageTimestamps._key, JSON.stringify(all), 0 , 0 );
    }
};
SnippetUsageTimestamps._key = 'snippets.usageTimestamps';
SnippetUsageTimestamps = ( (__decorate([
    ( (__param(0, IStorageService)))
], SnippetUsageTimestamps)));
let SnippetsService = class SnippetsService {
    constructor(_environmentService, _userDataProfileService, _contextService, _languageService, _logService, _fileService, _textfileService, _extensionResourceLoaderService, lifecycleService, instantiationService, languageConfigurationService) {
        this._environmentService = _environmentService;
        this._userDataProfileService = _userDataProfileService;
        this._contextService = _contextService;
        this._languageService = _languageService;
        this._logService = _logService;
        this._fileService = _fileService;
        this._textfileService = _textfileService;
        this._extensionResourceLoaderService = _extensionResourceLoaderService;
        this._disposables = ( (new DisposableStore()));
        this._pendingWork = [];
        this._files = ( (new ResourceMap()));
        this._pendingWork.push(Promise.resolve(lifecycleService.when(3 ).then(() => {
            this._initExtensionSnippets();
            this._initUserSnippets();
            this._initWorkspaceSnippets();
        })));
        setSnippetSuggestSupport(( (new SnippetCompletionProvider(this._languageService, this, languageConfigurationService))));
        this._enablement = instantiationService.createInstance(SnippetEnablement);
        this._usageTimestamps = instantiationService.createInstance(SnippetUsageTimestamps);
    }
    dispose() {
        this._disposables.dispose();
    }
    isEnabled(snippet) {
        return !this._enablement.isIgnored(snippet.snippetIdentifier);
    }
    updateEnablement(snippet, enabled) {
        this._enablement.updateIgnored(snippet.snippetIdentifier, !enabled);
    }
    updateUsageTimestamp(snippet) {
        this._usageTimestamps.updateUsageTimestamp(snippet.snippetIdentifier);
    }
    _joinSnippets() {
        const promises = this._pendingWork.slice(0);
        this._pendingWork.length = 0;
        return Promise.all(promises);
    }
    async getSnippetFiles() {
        await this._joinSnippets();
        return (
             (this._files.values())
        );
    }
    async getSnippets(languageId, opts) {
        await this._joinSnippets();
        const result = [];
        const promises = [];
        if (languageId) {
            if (this._languageService.isRegisteredLanguageId(languageId)) {
                for (const file of ( (this._files.values()))) {
                    promises.push(file.load()
                        .then(file => file.select(languageId, result))
                        .catch(err => this._logService.error(err, ( (file.location.toString())))));
                }
            }
        }
        else {
            for (const file of ( (this._files.values()))) {
                promises.push(file.load()
                    .then(file => insertInto(result, result.length, file.data))
                    .catch(err => this._logService.error(err, ( (file.location.toString())))));
            }
        }
        await Promise.all(promises);
        return this._filterAndSortSnippets(result, opts);
    }
    getSnippetsSync(languageId, opts) {
        const result = [];
        if (this._languageService.isRegisteredLanguageId(languageId)) {
            for (const file of ( (this._files.values()))) {
                file.load().catch(_err => { });
                file.select(languageId, result);
            }
        }
        return this._filterAndSortSnippets(result, opts);
    }
    _filterAndSortSnippets(snippets, opts) {
        const result = [];
        for (const snippet of snippets) {
            if (!snippet.prefix && !opts?.includeNoPrefixSnippets) {
                continue;
            }
            if (!this.isEnabled(snippet) && !opts?.includeDisabledSnippets) {
                continue;
            }
            if (typeof opts?.fileTemplateSnippets === 'boolean' && opts.fileTemplateSnippets !== snippet.isFileTemplate) {
                continue;
            }
            result.push(snippet);
        }
        return result.sort((a, b) => {
            let result = 0;
            if (!opts?.noRecencySort) {
                const val1 = this._usageTimestamps.getUsageTimestamp(a.snippetIdentifier) ?? -1;
                const val2 = this._usageTimestamps.getUsageTimestamp(b.snippetIdentifier) ?? -1;
                result = val2 - val1;
            }
            if (result === 0) {
                result = this._compareSnippet(a, b);
            }
            return result;
        });
    }
    _compareSnippet(a, b) {
        if (a.snippetSource < b.snippetSource) {
            return -1;
        }
        else if (a.snippetSource > b.snippetSource) {
            return 1;
        }
        else if (a.source < b.source) {
            return -1;
        }
        else if (a.source > b.source) {
            return 1;
        }
        else if (a.name > b.name) {
            return 1;
        }
        else if (a.name < b.name) {
            return -1;
        }
        else {
            return 0;
        }
    }
    _initExtensionSnippets() {
        snippetExt.point.setHandler(extensions => {
            for (const [key, value] of this._files) {
                if (value.source === 3 ) {
                    this._files.delete(key);
                }
            }
            for (const extension of extensions) {
                for (const contribution of extension.value) {
                    const validContribution = snippetExt.toValidSnippet(extension, contribution, this._languageService);
                    if (!validContribution) {
                        continue;
                    }
                    const file = this._files.get(validContribution.location);
                    if (file) {
                        if (file.defaultScopes) {
                            file.defaultScopes.push(validContribution.language);
                        }
                        else {
                            file.defaultScopes = [];
                        }
                    }
                    else {
                        const file = ( (new SnippetFile(
                            3 ,
                            validContribution.location,
                            validContribution.language ? [validContribution.language] : undefined,
                            extension.description,
                            this._fileService,
                            this._extensionResourceLoaderService
                        )));
                        this._files.set(file.location, file);
                        if (this._environmentService.isExtensionDevelopment) {
                            file.load().then(file => {
                                if (file.data.some(snippet => snippet.isBogous)) {
                                    extension.collector.warn(( (localize(
                                        'badVariableUse',
                                        "One or more snippets from the extension '{0}' very likely confuse snippet-variables and snippet-placeholders (see https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax for more details)",
                                        extension.description.name
                                    ))));
                                }
                            }, err => {
                                extension.collector.warn(( (localize(
                                    'badFile',
                                    "The snippet file \"{0}\" could not be read.",
                                     (file.location.toString())
                                ))));
                            });
                        }
                    }
                }
            }
        });
    }
    _initWorkspaceSnippets() {
        const disposables = ( (new DisposableStore()));
        const updateWorkspaceSnippets = () => {
            disposables.clear();
            this._pendingWork.push(this._initWorkspaceFolderSnippets(this._contextService.getWorkspace(), disposables));
        };
        this._disposables.add(disposables);
        this._disposables.add(this._contextService.onDidChangeWorkspaceFolders(updateWorkspaceSnippets));
        this._disposables.add(this._contextService.onDidChangeWorkbenchState(updateWorkspaceSnippets));
        updateWorkspaceSnippets();
    }
    async _initWorkspaceFolderSnippets(workspace, bucket) {
        const promises = ( (workspace.folders.map(async (folder) => {
            const snippetFolder = folder.toResource('.vscode');
            const value = await this._fileService.exists(snippetFolder);
            if (value) {
                this._initFolderSnippets(2 , snippetFolder, bucket);
            }
            else {
                bucket.add(this._fileService.onDidFilesChange(e => {
                    if (e.contains(snippetFolder, 1 )) {
                        this._initFolderSnippets(2 , snippetFolder, bucket);
                    }
                }));
            }
        })));
        await Promise.all(promises);
    }
    async _initUserSnippets() {
        const disposables = ( (new DisposableStore()));
        const updateUserSnippets = async () => {
            disposables.clear();
            const userSnippetsFolder = this._userDataProfileService.currentProfile.snippetsHome;
            await this._fileService.createFolder(userSnippetsFolder);
            await this._initFolderSnippets(1 , userSnippetsFolder, disposables);
        };
        this._disposables.add(disposables);
        this._disposables.add(this._userDataProfileService.onDidChangeCurrentProfile(e => e.join((async () => {
            if (e.preserveData) {
                await this._fileService.copy(e.previous.snippetsHome, e.profile.snippetsHome);
            }
            this._pendingWork.push(updateUserSnippets());
        })())));
        await updateUserSnippets();
    }
    _initFolderSnippets(source, folder, bucket) {
        const disposables = ( (new DisposableStore()));
        const addFolderSnippets = async () => {
            disposables.clear();
            if (!(await this._fileService.exists(folder))) {
                return;
            }
            try {
                const stat = await this._fileService.resolve(folder);
                for (const entry of stat.children || []) {
                    disposables.add(this._addSnippetFile(entry.resource, source));
                }
            }
            catch (err) {
                this._logService.error(`Failed snippets from folder '${( ( folder.toString()))}'`, err);
            }
        };
        bucket.add(this._textfileService.files.onDidSave(e => {
            if (isEqualOrParent(e.model.resource, folder)) {
                addFolderSnippets();
            }
        }));
        bucket.add(watch(this._fileService, folder, addFolderSnippets));
        bucket.add(disposables);
        return addFolderSnippets();
    }
    _addSnippetFile(uri, source) {
        const ext = extname(uri);
        if (source === 1  && ext === '.json') {
            const langName = basename(uri).replace(/\.json/, '');
            this._files.set(uri, ( (new SnippetFile(
                source,
                uri,
                [langName],
                undefined,
                this._fileService,
                this._extensionResourceLoaderService
            ))));
        }
        else if (ext === '.code-snippets') {
            this._files.set(uri, ( (new SnippetFile(
                source,
                uri,
                undefined,
                undefined,
                this._fileService,
                this._extensionResourceLoaderService
            ))));
        }
        return {
            dispose: () => this._files.delete(uri)
        };
    }
};
SnippetsService = ( (__decorate([
    ( (__param(0, IEnvironmentService))),
    ( (__param(1, IUserDataProfileService))),
    ( (__param(2, IWorkspaceContextService))),
    ( (__param(3, ILanguageService))),
    ( (__param(4, ILogService))),
    ( (__param(5, IFileService))),
    ( (__param(6, ITextFileService))),
    ( (__param(7, IExtensionResourceLoaderService))),
    ( (__param(8, ILifecycleService))),
    ( (__param(9, IInstantiationService))),
    ( (__param(10, ILanguageConfigurationService)))
], SnippetsService)));
function getNonWhitespacePrefix(model, position) {
    const MAX_PREFIX_LENGTH = 100;
    const line = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
    const minChIndex = Math.max(0, line.length - MAX_PREFIX_LENGTH);
    for (let chIndex = line.length - 1; chIndex >= minChIndex; chIndex--) {
        const ch = line.charAt(chIndex);
        if (/\s/.test(ch)) {
            return line.substr(chIndex + 1);
        }
    }
    if (minChIndex === 0) {
        return line;
    }
    return '';
}
export { SnippetsService as S, SnippetCompletion as a, getNonWhitespacePrefix as g };
