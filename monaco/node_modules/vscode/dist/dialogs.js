import { n, o as onServicesInitialized } from './polyfill.js';
import { bM as AbstractDialogHandler } from './missing-services.js';
import { _ as __decorate, a as __param, e as IProductService, o as IWorkbenchEnvironmentService, E as Emitter } from './services2.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { Widget } from 'monaco-editor/esm/vs/base/browser/ui/widget.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { B as ButtonBar, a as ButtonWithDescription } from './button.js';
import { m as mnemonicButtonLabel } from './labels.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { EventHelper, $, hide, addDisposableListener, EventType, clearNode, isAncestor, show } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { InputBox } from 'monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js';
import { ActionBar } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js';
import { Action } from 'monaco-editor/esm/vs/base/common/actions.js';
import { isMacintosh, isLinux, isWindows } from 'monaco-editor/esm/vs/base/common/platform.js';
import { StandardKeyboardEvent } from 'monaco-editor/esm/vs/base/browser/keyboardEvent.js';
import { MarkdownRenderer } from 'monaco-editor/esm/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js';
import Severity from 'monaco-editor/esm/vs/base/common/severity.js';
import { defaultButtonStyles, defaultCheckboxStyles, defaultInputBoxStyles, defaultDialogStyles } from 'monaco-editor/esm/vs/platform/theme/browser/defaultStyles.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { ILayoutService } from 'monaco-editor/esm/vs/platform/layout/browser/layoutService.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { IDialogService } from 'monaco-editor/esm/vs/platform/dialogs/common/dialogs.js';
import { DeferredPromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { g as getServiceOverride$1 } from './layout.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
var css$1 = ".monaco-custom-toggle{border:1px solid transparent;border-radius:3px;box-sizing:border-box;cursor:pointer;float:left;height:20px;margin-left:2px;overflow:hidden;padding:1px;user-select:none;-webkit-user-select:none;width:20px}.monaco-custom-toggle:hover{background-color:var(--vscode-inputOption-hoverBackground)}.hc-black .monaco-custom-toggle:hover,.hc-light .monaco-custom-toggle:hover{border:1px dashed var(--vscode-focusBorder)}.hc-black .monaco-custom-toggle,.hc-black .monaco-custom-toggle:hover,.hc-light .monaco-custom-toggle,.hc-light .monaco-custom-toggle:hover{background:none}.monaco-custom-toggle.monaco-checkbox{background-size:16px!important;border:1px solid transparent;border-radius:3px;height:18px;margin-left:0;margin-right:9px;opacity:1;padding:0;width:18px}.monaco-custom-toggle.monaco-checkbox:not(.checked):before{visibility:hidden}";
n(css$1,{});
const unthemedToggleStyles = {
    inputActiveOptionBorder: '#007ACC00',
    inputActiveOptionForeground: '#FFFFFF',
    inputActiveOptionBackground: '#0E639C50'
};
class Toggle extends Widget {
    constructor(opts) {
        super();
        this._onChange = this._register(( (new Emitter())));
        this.onChange = this._onChange.event;
        this._onKeyDown = this._register(( (new Emitter())));
        this.onKeyDown = this._onKeyDown.event;
        this._opts = opts;
        this._checked = this._opts.isChecked;
        const classes = ['monaco-custom-toggle'];
        if (this._opts.icon) {
            this._icon = this._opts.icon;
            classes.push(...ThemeIcon.asClassNameArray(this._icon));
        }
        if (this._opts.actionClassName) {
            classes.push(...this._opts.actionClassName.split(' '));
        }
        if (this._checked) {
            classes.push('checked');
        }
        this.domNode = document.createElement('div');
        this.domNode.title = this._opts.title;
        this.domNode.classList.add(...classes);
        if (!this._opts.notFocusable) {
            this.domNode.tabIndex = 0;
        }
        this.domNode.setAttribute('role', 'checkbox');
        this.domNode.setAttribute('aria-checked', String(this._checked));
        this.domNode.setAttribute('aria-label', this._opts.title);
        this.applyStyles();
        this.onclick(this.domNode, (ev) => {
            if (this.enabled) {
                this.checked = !this._checked;
                this._onChange.fire(false);
                ev.preventDefault();
            }
        });
        this._register(this.ignoreGesture(this.domNode));
        this.onkeydown(this.domNode, (keyboardEvent) => {
            if (keyboardEvent.keyCode === 10  || keyboardEvent.keyCode === 3 ) {
                this.checked = !this._checked;
                this._onChange.fire(true);
                keyboardEvent.preventDefault();
                keyboardEvent.stopPropagation();
                return;
            }
            this._onKeyDown.fire(keyboardEvent);
        });
    }
    get enabled() {
        return this.domNode.getAttribute('aria-disabled') !== 'true';
    }
    focus() {
        this.domNode.focus();
    }
    get checked() {
        return this._checked;
    }
    set checked(newIsChecked) {
        this._checked = newIsChecked;
        this.domNode.setAttribute('aria-checked', String(this._checked));
        this.domNode.classList.toggle('checked', this._checked);
        this.applyStyles();
    }
    setIcon(icon) {
        if (this._icon) {
            this.domNode.classList.remove(...ThemeIcon.asClassNameArray(this._icon));
        }
        this._icon = icon;
        if (this._icon) {
            this.domNode.classList.add(...ThemeIcon.asClassNameArray(this._icon));
        }
    }
    width() {
        return 2  + 2  + 2  + 16 ;
    }
    applyStyles() {
        if (this.domNode) {
            this.domNode.style.borderColor = (this._checked && this._opts.inputActiveOptionBorder) || '';
            this.domNode.style.color = (this._checked && this._opts.inputActiveOptionForeground) || 'inherit';
            this.domNode.style.backgroundColor = (this._checked && this._opts.inputActiveOptionBackground) || '';
        }
    }
    enable() {
        this.domNode.setAttribute('aria-disabled', String(false));
    }
    disable() {
        this.domNode.setAttribute('aria-disabled', String(true));
    }
    setTitle(newTitle) {
        this.domNode.title = newTitle;
        this.domNode.setAttribute('aria-label', newTitle);
    }
}
class Checkbox extends Widget {
    constructor(title, isChecked, styles) {
        super();
        this.title = title;
        this.isChecked = isChecked;
        this.checkbox = ( (new Toggle(
            { title: this.title, isChecked: this.isChecked, icon: Codicon.check, actionClassName: 'monaco-checkbox', ...unthemedToggleStyles }
        )));
        this.domNode = this.checkbox.domNode;
        this.styles = styles;
        this.applyStyles();
        this._register(this.checkbox.onChange(() => this.applyStyles()));
    }
    get checked() {
        return this.checkbox.checked;
    }
    set checked(newIsChecked) {
        this.checkbox.checked = newIsChecked;
        this.applyStyles();
    }
    focus() {
        this.domNode.focus();
    }
    hasFocus() {
        return this.domNode === document.activeElement;
    }
    applyStyles() {
        this.domNode.style.color = this.styles.checkboxForeground || '';
        this.domNode.style.backgroundColor = this.styles.checkboxBackground || '';
        this.domNode.style.borderColor = this.styles.checkboxBorder || '';
    }
}
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const month = day * 30;
const year = day * 365;
function fromNow(date, appendAgoLabel, useFullTimeWords, disallowNow) {
    if (typeof date !== 'number') {
        date = date.getTime();
    }
    const seconds = Math.round((( (new Date())).getTime() - date) / 1000);
    if (seconds < -30) {
        return (
             (localize(
                'date.fromNow.in',
                'in {0}',
                fromNow(( (new Date())).getTime() + seconds * 1000, false)
            ))
        );
    }
    if (!disallowNow && seconds < 30) {
        return (
             (localize('date.fromNow.now', 'now'))
        );
    }
    let value;
    if (seconds < minute) {
        value = seconds;
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.seconds.singular.ago.fullWord', '{0} second ago', value)))
                    : ( (localize('date.fromNow.seconds.singular.ago', '{0} sec ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.seconds.plural.ago.fullWord', '{0} seconds ago', value)))
                    : ( (localize('date.fromNow.seconds.plural.ago', '{0} secs ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.seconds.singular.fullWord', '{0} second', value)))
                    : ( (localize('date.fromNow.seconds.singular', '{0} sec', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.seconds.plural.fullWord', '{0} seconds', value)))
                    : ( (localize('date.fromNow.seconds.plural', '{0} secs', value)));
            }
        }
    }
    if (seconds < hour) {
        value = Math.floor(seconds / minute);
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.minutes.singular.ago.fullWord', '{0} minute ago', value)))
                    : ( (localize('date.fromNow.minutes.singular.ago', '{0} min ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.minutes.plural.ago.fullWord', '{0} minutes ago', value)))
                    : ( (localize('date.fromNow.minutes.plural.ago', '{0} mins ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.minutes.singular.fullWord', '{0} minute', value)))
                    : ( (localize('date.fromNow.minutes.singular', '{0} min', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.minutes.plural.fullWord', '{0} minutes', value)))
                    : ( (localize('date.fromNow.minutes.plural', '{0} mins', value)));
            }
        }
    }
    if (seconds < day) {
        value = Math.floor(seconds / hour);
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.hours.singular.ago.fullWord', '{0} hour ago', value)))
                    : ( (localize('date.fromNow.hours.singular.ago', '{0} hr ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.hours.plural.ago.fullWord', '{0} hours ago', value)))
                    : ( (localize('date.fromNow.hours.plural.ago', '{0} hrs ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.hours.singular.fullWord', '{0} hour', value)))
                    : ( (localize('date.fromNow.hours.singular', '{0} hr', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.hours.plural.fullWord', '{0} hours', value)))
                    : ( (localize('date.fromNow.hours.plural', '{0} hrs', value)));
            }
        }
    }
    if (seconds < week) {
        value = Math.floor(seconds / day);
        if (appendAgoLabel) {
            return value === 1
                ? ( (localize('date.fromNow.days.singular.ago', '{0} day ago', value)))
                : ( (localize('date.fromNow.days.plural.ago', '{0} days ago', value)));
        }
        else {
            return value === 1
                ? ( (localize('date.fromNow.days.singular', '{0} day', value)))
                : ( (localize('date.fromNow.days.plural', '{0} days', value)));
        }
    }
    if (seconds < month) {
        value = Math.floor(seconds / week);
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.weeks.singular.ago.fullWord', '{0} week ago', value)))
                    : ( (localize('date.fromNow.weeks.singular.ago', '{0} wk ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.weeks.plural.ago.fullWord', '{0} weeks ago', value)))
                    : ( (localize('date.fromNow.weeks.plural.ago', '{0} wks ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.weeks.singular.fullWord', '{0} week', value)))
                    : ( (localize('date.fromNow.weeks.singular', '{0} wk', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.weeks.plural.fullWord', '{0} weeks', value)))
                    : ( (localize('date.fromNow.weeks.plural', '{0} wks', value)));
            }
        }
    }
    if (seconds < year) {
        value = Math.floor(seconds / month);
        if (appendAgoLabel) {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.months.singular.ago.fullWord', '{0} month ago', value)))
                    : ( (localize('date.fromNow.months.singular.ago', '{0} mo ago', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.months.plural.ago.fullWord', '{0} months ago', value)))
                    : ( (localize('date.fromNow.months.plural.ago', '{0} mos ago', value)));
            }
        }
        else {
            if (value === 1) {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.months.singular.fullWord', '{0} month', value)))
                    : ( (localize('date.fromNow.months.singular', '{0} mo', value)));
            }
            else {
                return useFullTimeWords
                    ? ( (localize('date.fromNow.months.plural.fullWord', '{0} months', value)))
                    : ( (localize('date.fromNow.months.plural', '{0} mos', value)));
            }
        }
    }
    value = Math.floor(seconds / year);
    if (appendAgoLabel) {
        if (value === 1) {
            return useFullTimeWords
                ? ( (localize('date.fromNow.years.singular.ago.fullWord', '{0} year ago', value)))
                : ( (localize('date.fromNow.years.singular.ago', '{0} yr ago', value)));
        }
        else {
            return useFullTimeWords
                ? ( (localize('date.fromNow.years.plural.ago.fullWord', '{0} years ago', value)))
                : ( (localize('date.fromNow.years.plural.ago', '{0} yrs ago', value)));
        }
    }
    else {
        if (value === 1) {
            return useFullTimeWords
                ? ( (localize('date.fromNow.years.singular.fullWord', '{0} year', value)))
                : ( (localize('date.fromNow.years.singular', '{0} yr', value)));
        }
        else {
            return useFullTimeWords
                ? ( (localize('date.fromNow.years.plural.fullWord', '{0} years', value)))
                : ( (localize('date.fromNow.years.plural', '{0} yrs', value)));
        }
    }
}
var css = ".monaco-dialog-modal-block{align-items:center;display:flex;height:100%;justify-content:center;left:0;position:fixed;top:0;width:100%;z-index:2600}.monaco-dialog-modal-block.dimmed{background:rgba(0,0,0,.3)}.monaco-dialog-box{display:flex;flex-direction:column-reverse;max-width:90vw;min-height:75px;min-width:500px;padding:10px;transform:translateZ(0);width:min-content}.monaco-dialog-box .dialog-toolbar-row{height:22px;padding-bottom:4px}.monaco-dialog-box .dialog-toolbar-row .actions-container{justify-content:flex-end}.monaco-dialog-box .dialog-message-row{align-items:center;display:flex;flex-grow:1;padding:0 10px}.monaco-dialog-box .dialog-message-row>.dialog-icon.codicon{align-self:baseline;flex:0 0 48px;font-size:48px;height:48px}.monaco-dialog-box .dialog-message-row .dialog-message-container{word-wrap:break-word;display:flex;flex-direction:column;overflow:hidden;padding-left:24px;text-overflow:ellipsis;user-select:text;-webkit-user-select:text;white-space:normal}.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message{word-wrap:break-word;align-items:center;display:flex;flex:1;font-size:18px;line-height:22px;margin-bottom:8px;min-height:48px;white-space:normal}.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message-detail{flex:1;line-height:22px}.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message a:focus{outline-style:solid;outline-width:1px}.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-checkbox-row{display:flex;padding:15px 0 0}.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-checkbox-row .dialog-checkbox-message{cursor:pointer;user-select:none;-webkit-user-select:none}.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message-input{display:flex;padding:15px 0 0}.monaco-dialog-box .dialog-message-row .dialog-message-container .dialog-message-input .monaco-inputbox{flex:1}.monaco-dialog-box code{font-family:var(--monaco-monospace-font)}.monaco-dialog-box>.dialog-buttons-row{align-items:center;display:flex;overflow:hidden;padding-right:1px;padding:20px 10px 10px;white-space:nowrap}.monaco-dialog-box>.dialog-buttons-row>.dialog-buttons{display:flex;justify-content:flex-end;margin-left:67px;overflow:hidden;width:100%}.monaco-dialog-box>.dialog-buttons-row>.dialog-buttons>.monaco-button{margin:4px 5px;outline-offset:2px!important;overflow:hidden;padding:5px 10px;text-overflow:ellipsis;width:fit-content}";
n(css,{});
class Dialog extends Disposable {
    constructor(container, message, buttons, options) {
        super();
        this.container = container;
        this.message = message;
        this.options = options;
        this.modalElement = this.container.appendChild($(`.monaco-dialog-modal-block.dimmed`));
        this.shadowElement = this.modalElement.appendChild($('.dialog-shadow'));
        this.element = this.shadowElement.appendChild($('.monaco-dialog-box'));
        this.element.setAttribute('role', 'dialog');
        this.element.tabIndex = -1;
        hide(this.element);
        this.buttonStyles = options.buttonStyles;
        if (Array.isArray(buttons) && buttons.length > 0) {
            this.buttons = buttons;
        }
        else if (!this.options.disableDefaultAction) {
            this.buttons = [( (localize('ok', "OK")))];
        }
        else {
            this.buttons = [];
        }
        const buttonsRowElement = this.element.appendChild($('.dialog-buttons-row'));
        this.buttonsContainer = buttonsRowElement.appendChild($('.dialog-buttons'));
        const messageRowElement = this.element.appendChild($('.dialog-message-row'));
        this.iconElement = messageRowElement.appendChild($('#monaco-dialog-icon.dialog-icon'));
        this.iconElement.setAttribute('aria-label', this.getIconAriaLabel());
        this.messageContainer = messageRowElement.appendChild($('.dialog-message-container'));
        if (this.options.detail || this.options.renderBody) {
            const messageElement = this.messageContainer.appendChild($('.dialog-message'));
            const messageTextElement = messageElement.appendChild($('#monaco-dialog-message-text.dialog-message-text'));
            messageTextElement.innerText = this.message;
        }
        this.messageDetailElement = this.messageContainer.appendChild($('#monaco-dialog-message-detail.dialog-message-detail'));
        if (this.options.detail || !this.options.renderBody) {
            this.messageDetailElement.innerText = this.options.detail ? this.options.detail : message;
        }
        else {
            this.messageDetailElement.style.display = 'none';
        }
        if (this.options.renderBody) {
            const customBody = this.messageContainer.appendChild($('#monaco-dialog-message-body.dialog-message-body'));
            this.options.renderBody(customBody);
            for (const el of this.messageContainer.querySelectorAll('a')) {
                el.tabIndex = 0;
            }
        }
        if (this.options.inputs) {
            this.inputs = ( (this.options.inputs.map(input => {
                const inputRowElement = this.messageContainer.appendChild($('.dialog-message-input'));
                const inputBox = this._register(( (new InputBox(inputRowElement, undefined, {
                    placeholder: input.placeholder,
                    type: input.type ?? 'text',
                    inputBoxStyles: options.inputBoxStyles
                }))));
                if (input.value) {
                    inputBox.value = input.value;
                }
                return inputBox;
            })));
        }
        else {
            this.inputs = [];
        }
        if (this.options.checkboxLabel) {
            const checkboxRowElement = this.messageContainer.appendChild($('.dialog-checkbox-row'));
            const checkbox = this.checkbox = this._register(( (new Checkbox(
                this.options.checkboxLabel,
                !!this.options.checkboxChecked,
                options.checkboxStyles
            ))));
            checkboxRowElement.appendChild(checkbox.domNode);
            const checkboxMessageElement = checkboxRowElement.appendChild($('.dialog-checkbox-message'));
            checkboxMessageElement.innerText = this.options.checkboxLabel;
            this._register(addDisposableListener(checkboxMessageElement, EventType.CLICK, () => checkbox.checked = !checkbox.checked));
        }
        const toolbarRowElement = this.element.appendChild($('.dialog-toolbar-row'));
        this.toolbarContainer = toolbarRowElement.appendChild($('.dialog-toolbar'));
        this.applyStyles();
    }
    getIconAriaLabel() {
        const typeLabel = ( (localize('dialogInfoMessage', 'Info')));
        return typeLabel;
    }
    updateMessage(message) {
        this.messageDetailElement.innerText = message;
    }
    async show() {
        this.focusToReturn = document.activeElement;
        return (
             (new Promise((resolve) => {
                clearNode(this.buttonsContainer);
                const buttonBar = this.buttonBar = this._register(( (new ButtonBar(this.buttonsContainer))));
                const buttonMap = this.rearrangeButtons(this.buttons, this.options.cancelId);
                buttonMap.forEach((entry, index) => {
                    const primary = buttonMap[index].index === 0;
                    const button = this.options.buttonDetails ? this._register(buttonBar.addButtonWithDescription({ title: true, secondary: !primary, ...this.buttonStyles })) : this._register(buttonBar.addButton({ title: true, secondary: !primary, ...this.buttonStyles }));
                    button.label = mnemonicButtonLabel(buttonMap[index].label, true);
                    if (button instanceof ButtonWithDescription) {
                        button.description = this.options.buttonDetails[buttonMap[index].index];
                    }
                    this._register(button.onDidClick(e => {
                        if (e) {
                            EventHelper.stop(e);
                        }
                        resolve({
                            button: buttonMap[index].index,
                            checkboxChecked: this.checkbox ? this.checkbox.checked : undefined,
                            values: this.inputs.length > 0 ? ( (this.inputs.map(input => input.value))) : undefined
                        });
                    }));
                });
                this._register(addDisposableListener(window, 'keydown', e => {
                    const evt = ( (new StandardKeyboardEvent(e)));
                    if (evt.equals(512 )) {
                        evt.preventDefault();
                    }
                    if (evt.equals(3 )) {
                        if (this.inputs.some(input => input.hasFocus())) {
                            EventHelper.stop(e);
                            resolve({
                                button: buttonMap.find(button => button.index !== this.options.cancelId)?.index ?? 0,
                                checkboxChecked: this.checkbox ? this.checkbox.checked : undefined,
                                values: this.inputs.length > 0 ? ( (this.inputs.map(input => input.value))) : undefined
                            });
                        }
                        return;
                    }
                    if (evt.equals(10 )) {
                        return;
                    }
                    let eventHandled = false;
                    if (evt.equals(2 ) || evt.equals(17 ) || evt.equals(1024  | 2 ) || evt.equals(15 )) {
                        const focusableElements = [];
                        let focusedIndex = -1;
                        if (this.messageContainer) {
                            const links = this.messageContainer.querySelectorAll('a');
                            for (const link of links) {
                                focusableElements.push(link);
                                if (link === document.activeElement) {
                                    focusedIndex = focusableElements.length - 1;
                                }
                            }
                        }
                        for (const input of this.inputs) {
                            focusableElements.push(input);
                            if (input.hasFocus()) {
                                focusedIndex = focusableElements.length - 1;
                            }
                        }
                        if (this.checkbox) {
                            focusableElements.push(this.checkbox);
                            if (this.checkbox.hasFocus()) {
                                focusedIndex = focusableElements.length - 1;
                            }
                        }
                        if (this.buttonBar) {
                            for (const button of this.buttonBar.buttons) {
                                focusableElements.push(button);
                                if (button.hasFocus()) {
                                    focusedIndex = focusableElements.length - 1;
                                }
                            }
                        }
                        if (evt.equals(2 ) || evt.equals(17 )) {
                            if (focusedIndex === -1) {
                                focusedIndex = 0;
                            }
                            const newFocusedIndex = (focusedIndex + 1) % focusableElements.length;
                            focusableElements[newFocusedIndex].focus();
                        }
                        else {
                            if (focusedIndex === -1) {
                                focusedIndex = focusableElements.length;
                            }
                            let newFocusedIndex = focusedIndex - 1;
                            if (newFocusedIndex === -1) {
                                newFocusedIndex = focusableElements.length - 1;
                            }
                            focusableElements[newFocusedIndex].focus();
                        }
                        eventHandled = true;
                    }
                    if (eventHandled) {
                        EventHelper.stop(e, true);
                    }
                    else if (this.options.keyEventProcessor) {
                        this.options.keyEventProcessor(evt);
                    }
                }, true));
                this._register(addDisposableListener(window, 'keyup', e => {
                    EventHelper.stop(e, true);
                    const evt = ( (new StandardKeyboardEvent(e)));
                    if (!this.options.disableCloseAction && evt.equals(9 )) {
                        resolve({
                            button: this.options.cancelId || 0,
                            checkboxChecked: this.checkbox ? this.checkbox.checked : undefined
                        });
                    }
                }, true));
                this._register(addDisposableListener(this.element, 'focusout', e => {
                    if (!!e.relatedTarget && !!this.element) {
                        if (!isAncestor(e.relatedTarget, this.element)) {
                            this.focusToReturn = e.relatedTarget;
                            if (e.target) {
                                e.target.focus();
                                EventHelper.stop(e, true);
                            }
                        }
                    }
                }, false));
                const spinModifierClassName = 'codicon-modifier-spin';
                this.iconElement.classList.remove(...ThemeIcon.asClassNameArray(Codicon.dialogError), ...ThemeIcon.asClassNameArray(Codicon.dialogWarning), ...ThemeIcon.asClassNameArray(Codicon.dialogInfo), ...ThemeIcon.asClassNameArray(Codicon.loading), spinModifierClassName);
                if (this.options.icon) {
                    this.iconElement.classList.add(...ThemeIcon.asClassNameArray(this.options.icon));
                }
                else {
                    switch (this.options.type) {
                        case 'error':
                            this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.dialogError));
                            break;
                        case 'warning':
                            this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.dialogWarning));
                            break;
                        case 'pending':
                            this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.loading), spinModifierClassName);
                            break;
                        case 'none':
                        case 'info':
                        case 'question':
                        default:
                            this.iconElement.classList.add(...ThemeIcon.asClassNameArray(Codicon.dialogInfo));
                            break;
                    }
                }
                if (!this.options.disableCloseAction) {
                    const actionBar = this._register(( (new ActionBar(this.toolbarContainer, {}))));
                    const action = this._register(( (new Action(
                        'dialog.close',
                         (localize('dialogClose', "Close Dialog")),
                        ThemeIcon.asClassName(Codicon.dialogClose),
                        true,
                        async () => {
                            resolve({
                                button: this.options.cancelId || 0,
                                checkboxChecked: this.checkbox ? this.checkbox.checked : undefined
                            });
                        }
                    ))));
                    actionBar.push(action, { icon: true, label: false });
                }
                this.applyStyles();
                this.element.setAttribute('aria-modal', 'true');
                this.element.setAttribute('aria-labelledby', 'monaco-dialog-icon monaco-dialog-message-text');
                this.element.setAttribute('aria-describedby', 'monaco-dialog-icon monaco-dialog-message-text monaco-dialog-message-detail monaco-dialog-message-body');
                show(this.element);
                if (this.inputs.length > 0) {
                    this.inputs[0].focus();
                    this.inputs[0].select();
                }
                else {
                    buttonMap.forEach((value, index) => {
                        if (value.index === 0) {
                            buttonBar.buttons[index].focus();
                        }
                    });
                }
            }))
        );
    }
    applyStyles() {
        const style = this.options.dialogStyles;
        const fgColor = style.dialogForeground;
        const bgColor = style.dialogBackground;
        const shadowColor = style.dialogShadow ? `0 0px 8px ${style.dialogShadow}` : '';
        const border = style.dialogBorder ? `1px solid ${style.dialogBorder}` : '';
        const linkFgColor = style.textLinkForeground;
        this.shadowElement.style.boxShadow = shadowColor;
        this.element.style.color = fgColor ?? '';
        this.element.style.backgroundColor = bgColor ?? '';
        this.element.style.border = border;
        if (linkFgColor) {
            for (const el of this.messageContainer.getElementsByTagName('a')) {
                el.style.color = linkFgColor;
            }
        }
        let color;
        switch (this.options.type) {
            case 'error':
                color = style.errorIconForeground;
                break;
            case 'warning':
                color = style.warningIconForeground;
                break;
            default:
                color = style.infoIconForeground;
                break;
        }
        if (color) {
            this.iconElement.style.color = color;
        }
    }
    dispose() {
        super.dispose();
        if (this.modalElement) {
            this.modalElement.remove();
            this.modalElement = undefined;
        }
        if (this.focusToReturn && isAncestor(this.focusToReturn, document.body)) {
            this.focusToReturn.focus();
            this.focusToReturn = undefined;
        }
    }
    rearrangeButtons(buttons, cancelId) {
        const buttonMap = ( (buttons.map((label, index) => ({ label, index }))));
        if (buttons.length < 2) {
            return buttonMap;
        }
        if (isMacintosh || isLinux) {
            if (typeof cancelId === 'number' && buttonMap[cancelId]) {
                const cancelButton = buttonMap.splice(cancelId, 1)[0];
                buttonMap.splice(1, 0, cancelButton);
            }
            buttonMap.reverse();
        }
        else if (isWindows) {
            if (typeof cancelId === 'number' && buttonMap[cancelId]) {
                const cancelButton = buttonMap.splice(cancelId, 1)[0];
                buttonMap.push(cancelButton);
            }
        }
        return buttonMap;
    }
}
let BrowserDialogHandler = class BrowserDialogHandler extends AbstractDialogHandler {
    constructor(logService, layoutService, keybindingService, instantiationService, productService, clipboardService) {
        super();
        this.logService = logService;
        this.layoutService = layoutService;
        this.keybindingService = keybindingService;
        this.instantiationService = instantiationService;
        this.productService = productService;
        this.clipboardService = clipboardService;
        this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
    }
    async prompt(prompt) {
        this.logService.trace('DialogService#prompt', prompt.message);
        const buttons = this.getPromptButtons(prompt);
        const { button, checkboxChecked } = await this.doShow(prompt.type, prompt.message, buttons, prompt.detail, prompt.cancelButton ? buttons.length - 1 : -1 , prompt.checkbox, undefined, typeof prompt?.custom === 'object' ? prompt.custom : undefined);
        return this.getPromptResult(prompt, button, checkboxChecked);
    }
    async confirm(confirmation) {
        this.logService.trace('DialogService#confirm', confirmation.message);
        const buttons = this.getConfirmationButtons(confirmation);
        const { button, checkboxChecked } = await this.doShow(confirmation.type ?? 'question', confirmation.message, buttons, confirmation.detail, buttons.length - 1, confirmation.checkbox, undefined, typeof confirmation?.custom === 'object' ? confirmation.custom : undefined);
        return { confirmed: button === 0, checkboxChecked };
    }
    async input(input) {
        this.logService.trace('DialogService#input', input.message);
        const buttons = this.getInputButtons(input);
        const { button, checkboxChecked, values } = await this.doShow(input.type ?? 'question', input.message, buttons, input.detail, buttons.length - 1, input?.checkbox, input.inputs);
        return { confirmed: button === 0, checkboxChecked, values };
    }
    async about() {
        const detailString = (useAgo) => {
            return (
                 (localize(
                    'aboutDetail',
                    "Version: {0}\nCommit: {1}\nDate: {2}\nBrowser: {3}",
                    this.productService.version || 'Unknown',
                    this.productService.commit || 'Unknown',
                    this.productService.date ? `${this.productService.date}${useAgo ? ' (' + fromNow(( new Date(this.productService.date)), true) + ')' : ''}` : 'Unknown',
                    navigator.userAgent
                ))
            );
        };
        const detail = detailString(true);
        const detailToCopy = detailString(false);
        const { button } = await this.doShow(Severity.Info, this.productService.nameLong, [
            ( (localize({ key: 'copy', comment: ['&& denotes a mnemonic'] }, "&&Copy"))),
            ( (localize('ok', "OK")))
        ], detail, 1);
        if (button === 0) {
            this.clipboardService.writeText(detailToCopy);
        }
    }
    async doShow(type, message, buttons, detail, cancelId, checkbox, inputs, customOptions) {
        const dialogDisposables = ( (new DisposableStore()));
        const renderBody = customOptions ? (parent) => {
            parent.classList.add(...(customOptions.classes || []));
            customOptions.markdownDetails?.forEach(markdownDetail => {
                const result = this.markdownRenderer.render(markdownDetail.markdown);
                parent.appendChild(result.element);
                result.element.classList.add(...(markdownDetail.classes || []));
                dialogDisposables.add(result);
            });
        } : undefined;
        const dialog = ( (new Dialog(this.layoutService.container, message, buttons, {
            detail,
            cancelId,
            type: this.getDialogType(type),
            keyEventProcessor: (event) => {
                const resolved = this.keybindingService.softDispatch(event, this.layoutService.container);
                if (resolved?.commandId) {
                    if (BrowserDialogHandler.ALLOWABLE_COMMANDS.indexOf(resolved.commandId) === -1) {
                        EventHelper.stop(event, true);
                    }
                }
            },
            renderBody,
            icon: customOptions?.icon,
            disableCloseAction: customOptions?.disableCloseAction,
            buttonDetails: customOptions?.buttonDetails,
            checkboxLabel: checkbox?.label,
            checkboxChecked: checkbox?.checked,
            inputs,
            buttonStyles: defaultButtonStyles,
            checkboxStyles: defaultCheckboxStyles,
            inputBoxStyles: defaultInputBoxStyles,
            dialogStyles: defaultDialogStyles
        })));
        dialogDisposables.add(dialog);
        const result = await dialog.show();
        dialogDisposables.dispose();
        return result;
    }
};
BrowserDialogHandler.ALLOWABLE_COMMANDS = [
    'copy',
    'cut',
    'editor.action.selectAll',
    'editor.action.clipboardCopyAction',
    'editor.action.clipboardCutAction',
    'editor.action.clipboardPasteAction'
];
BrowserDialogHandler = ( (__decorate([
    ( (__param(0, ILogService))),
    ( (__param(1, ILayoutService))),
    ( (__param(2, IKeybindingService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IProductService))),
    ( (__param(5, IClipboardService)))
], BrowserDialogHandler)));
let DialogHandlerContribution = class DialogHandlerContribution extends Disposable {
    constructor(dialogService, logService, layoutService, keybindingService, instantiationService, productService, clipboardService) {
        super();
        this.dialogService = dialogService;
        this.impl = ( (new BrowserDialogHandler(
            logService,
            layoutService,
            keybindingService,
            instantiationService,
            productService,
            clipboardService
        )));
        this.model = this.dialogService.model;
        this._register(this.model.onWillShowDialog(() => {
            if (!this.currentDialog) {
                this.processDialogs();
            }
        }));
        this.processDialogs();
    }
    async processDialogs() {
        while (this.model.dialogs.length) {
            this.currentDialog = this.model.dialogs[0];
            let result = undefined;
            if (this.currentDialog.args.confirmArgs) {
                const args = this.currentDialog.args.confirmArgs;
                result = await this.impl.confirm(args.confirmation);
            }
            else if (this.currentDialog.args.inputArgs) {
                const args = this.currentDialog.args.inputArgs;
                result = await this.impl.input(args.input);
            }
            else if (this.currentDialog.args.promptArgs) {
                const args = this.currentDialog.args.promptArgs;
                result = await this.impl.prompt(args.prompt);
            }
            else {
                await this.impl.about();
            }
            this.currentDialog.close(result);
            this.currentDialog = undefined;
        }
    }
};
DialogHandlerContribution = ( (__decorate([
    ( (__param(0, IDialogService))),
    ( (__param(1, ILogService))),
    ( (__param(2, ILayoutService))),
    ( (__param(3, IKeybindingService))),
    ( (__param(4, IInstantiationService))),
    ( (__param(5, IProductService))),
    ( (__param(6, IClipboardService)))
], DialogHandlerContribution)));
class DialogsModel extends Disposable {
    constructor() {
        super(...arguments);
        this.dialogs = [];
        this._onWillShowDialog = this._register(( (new Emitter())));
        this.onWillShowDialog = this._onWillShowDialog.event;
        this._onDidShowDialog = this._register(( (new Emitter())));
        this.onDidShowDialog = this._onDidShowDialog.event;
    }
    show(dialog) {
        const promise = ( (new DeferredPromise()));
        const item = {
            args: dialog,
            close: result => {
                this.dialogs.splice(0, 1);
                promise.complete(result);
                this._onDidShowDialog.fire();
            }
        };
        this.dialogs.push(item);
        this._onWillShowDialog.fire();
        return {
            item,
            result: promise.p
        };
    }
}
let DialogService = class DialogService extends Disposable {
    constructor(environmentService, logService) {
        super();
        this.environmentService = environmentService;
        this.logService = logService;
        this.model = this._register(( (new DialogsModel())));
        this.onWillShowDialog = this.model.onWillShowDialog;
        this.onDidShowDialog = this.model.onDidShowDialog;
    }
    skipDialogs() {
        if (this.environmentService.isExtensionDevelopment && this.environmentService.extensionTestsLocationURI) {
            return true;
        }
        return !!this.environmentService.enableSmokeTestDriver;
    }
    async confirm(confirmation) {
        if (this.skipDialogs()) {
            this.logService.trace('DialogService: refused to show confirmation dialog in tests.');
            return { confirmed: true };
        }
        const handle = this.model.show({ confirmArgs: { confirmation } });
        return await handle.result;
    }
    async prompt(prompt) {
        if (this.skipDialogs()) {
            throw new Error('DialogService: refused to show dialog in tests.');
        }
        const handle = this.model.show({ promptArgs: { prompt } });
        return await handle.result;
    }
    async input(input) {
        if (this.skipDialogs()) {
            throw new Error('DialogService: refused to show input dialog in tests.');
        }
        const handle = this.model.show({ inputArgs: { input } });
        return await handle.result;
    }
    async info(message, detail) {
        await this.prompt({ type: Severity.Info, message, detail });
    }
    async warn(message, detail) {
        await this.prompt({ type: Severity.Warning, message, detail });
    }
    async error(message, detail) {
        await this.prompt({ type: Severity.Error, message, detail });
    }
    async about() {
        if (this.skipDialogs()) {
            throw new Error('DialogService: refused to show about dialog in tests.');
        }
        const handle = this.model.show({});
        await handle.result;
    }
};
DialogService = ( (__decorate([
    ( (__param(0, IWorkbenchEnvironmentService))),
    ( (__param(1, ILogService)))
], DialogService)));
function initialize(instantiationService) {
    setTimeout(() => {
        instantiationService.createInstance(DialogHandlerContribution);
    });
}
function getServiceOverride(container) {
    onServicesInitialized(initialize);
    return {
        [( IDialogService.toString())]: new SyncDescriptor(DialogService),
        ...getServiceOverride$1(container)
    };
}
export { getServiceOverride as default };
