import * as vscode from 'vscode';
import * as monaco from 'monaco-editor';

declare enum Severity$1 {
    Ignore = 0,
    Info = 1,
    Warning = 2,
    Error = 3
}
declare namespace Severity$1 {
    /**
     * Parses 'error', 'warning', 'warn', 'info' in call casings
     * and falls back to ignore.
     */
    function fromValue(value: string): Severity$1;
    function toString(severity: Severity$1): string;
}

declare class SyncDescriptor<T> {
    readonly ctor: any;
    readonly staticArguments: any[];
    readonly supportsDelayedInstantiation: boolean;
    constructor(ctor: new (...args: any[]) => T, staticArguments?: any[], supportsDelayedInstantiation?: boolean);
}
interface SyncDescriptor0<T> {
    readonly ctor: new () => T;
}

declare class ServiceCollection {
    private _entries;
    constructor(...entries: [ServiceIdentifier<any>, any][]);
    set<T>(id: ServiceIdentifier<T>, instanceOrDescriptor: T | SyncDescriptor<T>): T | SyncDescriptor<T>;
    has(id: ServiceIdentifier<any>): boolean;
    get<T>(id: ServiceIdentifier<T>): T | SyncDescriptor<T>;
}

type BrandedService = {
    _serviceBrand: undefined;
};
interface IConstructorSignature<T, Args extends any[] = []> {
    new <Services extends BrandedService[]>(...args: [...Args, ...Services]): T;
}
interface ServicesAccessor {
    get<T>(id: ServiceIdentifier<T>): T;
}
/**
 * Given a list of arguments as a tuple, attempt to extract the leading, non-service arguments
 * to their own tuple.
 */
type GetLeadingNonServiceArgs<TArgs extends any[]> = TArgs extends [] ? [] : TArgs extends [...infer TFirst, BrandedService] ? GetLeadingNonServiceArgs<TFirst> : TArgs;
declare const IInstantiationService: ServiceIdentifier<IInstantiationService>;
interface IInstantiationService {
    readonly _serviceBrand: undefined;
    /**
     * Synchronously creates an instance that is denoted by the descriptor
     */
    createInstance<T>(descriptor: SyncDescriptor0<T>): T;
    createInstance<Ctor extends new (...args: any[]) => any, R extends InstanceType<Ctor>>(ctor: Ctor, ...args: GetLeadingNonServiceArgs<ConstructorParameters<Ctor>>): R;
    /**
     * Calls a function with a service accessor.
     */
    invokeFunction<R, TS extends any[] = []>(fn: (accessor: ServicesAccessor, ...args: TS) => R, ...args: TS): R;
    /**
     * Creates a child of this service which inherits all current services
     * and adds/overwrites the given services.
     */
    createChild(services: ServiceCollection): IInstantiationService;
}
/**
 * Identifies a service of type `T`.
 */
interface ServiceIdentifier<T> {
    (...args: any[]): void;
    type: T;
}

/**
 * An object that performs a cleanup operation when `.dispose()` is called.
 *
 * Some examples of how disposables are used:
 *
 * - An event listener that removes itself when `.dispose()` is called.
 * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.
 * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.
 */
interface IDisposable {
    dispose(): void;
}
/**
 * Manages a collection of disposable values.
 *
 * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an
 * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a
 * store that has already been disposed of.
 */
declare class DisposableStore implements IDisposable {
    static DISABLE_DISPOSED_WARNING: boolean;
    private readonly _toDispose;
    private _isDisposed;
    constructor();
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose(): void;
    /**
     * @return `true` if this object has been disposed of.
     */
    get isDisposed(): boolean;
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear(): void;
    /**
     * Add a new {@link IDisposable disposable} to the collection.
     */
    add<T extends IDisposable>(o: T): T;
}
/**
 * Abstract base class for a {@link IDisposable disposable} object.
 *
 * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.
 */
declare abstract class Disposable implements IDisposable {
    /**
     * A disposable that does nothing when it is disposed of.
     *
     * TODO: This should not be a static property.
     */
    static readonly None: Readonly<IDisposable>;
    protected readonly _store: DisposableStore;
    constructor();
    dispose(): void;
    /**
     * Adds `o` to the collection of disposables managed by this object.
     */
    protected _register<T extends IDisposable>(o: T): T;
}
/**
 * A safe disposable can be `unset` so that a leaked reference (listener)
 * can be cut-off.
 */
declare class SafeDisposable implements IDisposable {
    dispose: () => void;
    unset: () => void;
    isset: () => boolean;
    constructor();
    set(fn: Function): this;
}
interface IReference<T> extends IDisposable {
    readonly object: T;
}

interface CancellationToken {
    /**
     * A flag signalling is cancellation has been requested.
     */
    readonly isCancellationRequested: boolean;
    /**
     * An event which fires when cancellation is requested. This event
     * only ever fires `once` as cancellation can only happen once. Listeners
     * that are registered after cancellation will be called (next event loop run),
     * but also only once.
     *
     * @event
     */
    readonly onCancellationRequested: (listener: (e: any) => any, thisArgs?: any, disposables?: IDisposable[]) => IDisposable;
}
declare namespace CancellationToken {
    function isCancellationToken(thing: unknown): thing is CancellationToken;
    const None: Readonly<CancellationToken>;
    const Cancelled: Readonly<CancellationToken>;
}

declare class LinkedList<E> {
    private _first;
    private _last;
    private _size;
    get size(): number;
    isEmpty(): boolean;
    clear(): void;
    unshift(element: E): () => void;
    push(element: E): () => void;
    private _insert;
    shift(): E | undefined;
    pop(): E | undefined;
    private _remove;
    [Symbol.iterator](): Iterator<E>;
}

interface IObservable<T, TChange = void> {
    readonly TChange: TChange;
    /**
     * Reads the current value.
     *
     * Must not be called from {@link IObserver.handleChange}.
     */
    get(): T;
    /**
     * Adds an observer.
     */
    addObserver(observer: IObserver): void;
    removeObserver(observer: IObserver): void;
    /**
     * Subscribes the reader to this observable and returns the current value of this observable.
     */
    read(reader: IReader): T;
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    readonly debugName: string;
}
interface IReader {
    /**
     * Reports an observable that was read.
     *
     * Is called by {@link IObservable.read}.
     */
    subscribeTo<T>(observable: IObservable<T, any>): void;
}
interface IObserver {
    /**
     * Indicates that an update operation is about to begin.
     *
     * During an update, invariants might not hold for subscribed observables and
     * change events might be delayed.
     * However, all changes must be reported before all update operations are over.
     */
    beginUpdate<T>(observable: IObservable<T>): void;
    /**
     * Is called by a subscribed observable immediately after it notices a change.
     *
     * When {@link IObservable.get} returns and no change has been reported,
     * there has been no change for that observable.
     *
     * Implementations must not call into other observables!
     * The change should be processed when {@link IObserver.endUpdate} is called.
     */
    handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
    /**
     * Indicates that an update operation has completed.
     */
    endUpdate<T>(observable: IObservable<T>): void;
}

/**
 * Can be passed into the Delayed to defer using a microtask
 * */
declare const MicrotaskDelay: unique symbol;

/**
 * An event with zero or one parameters that can be subscribed to. The event is a function itself.
 */
type Event$1<T> = vscode.Event<T>
declare namespace Event$1 {
    const None: Event$1<any>;
    /**
     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared
     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a
     * result of merging events and to try prevent race conditions that could arise when using related deferred and
     * non-deferred events.
     *
     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work
     * (eg. latency of keypress to text rendered).
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function defer(event: Event$1<unknown>, disposable?: DisposableStore): Event$1<void>;
    /**
     * Given an event, returns another event which only fires once.
     *
     * @param event The event source for the new event.
     */
    function once<T>(event: Event$1<T>): Event$1<T>;
    /**
     * Maps an event of one type into an event of another type using a mapping function, similar to how
     * `Array.prototype.map` works.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param map The mapping function.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function map<I, O>(event: Event$1<I>, map: (i: I) => O, disposable?: DisposableStore): Event$1<O>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function forEach<I>(event: Event$1<I>, each: (i: I) => void, disposable?: DisposableStore): Event$1<I>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function filter<T, U>(event: Event$1<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event$1<T>;
    function filter<T>(event: Event$1<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event$1<T>;
    function filter<T, R>(event: Event$1<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event$1<R>;
    /**
     * Given an event, returns the same event but typed as `Event<void>`.
     */
    function signal<T>(event: Event$1<T>): Event$1<void>;
    /**
     * Given a collection of events, returns a single event which emits
     * whenever any of the provided events emit.
     */
    function any<T>(...events: Event$1<T>[]): Event$1<T>;
    function any(...events: Event$1<any>[]): Event$1<void>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function reduce<I, O>(event: Event$1<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event$1<O>;
    /**
     * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an
     * array event object of all events that fired.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The original event to debounce.
     * @param merge A function that reduces all events into a single event.
     * @param delay The number of milliseconds to debounce.
     * @param leading Whether to fire a leading event without debouncing.
     * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not
     * specified, some events could go missing. Use this if it's important that all events are processed, even if the
     * listener gets disposed before the debounced event fires.
     * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.
     * @param disposable A disposable store to register the debounce emitter to.
     */
    function debounce<T>(event: Event$1<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event$1<T>;
    function debounce<I, O>(event: Event$1<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event$1<O>;
    /**
     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function accumulate<T>(event: Event$1<T>, delay?: number, disposable?: DisposableStore): Event$1<T[]>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function latch<T>(event: Event$1<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event$1<T>;
    /**
     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @example
     * ```
     * const event = new EventEmitter<number | undefined>().event;
     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);
     * ```
     *
     * @param event The event source for the new event.
     * @param isT A function that determines what event is of the first type.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function split<T, U>(event: Event$1<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event$1<T>, Event$1<U>];
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function buffer<T>(event: Event$1<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event$1<T>;
    interface IChainableEvent<T> extends IDisposable {
        event: Event$1<T>;
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        latch(): IChainableEvent<T>;
        debounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;
        debounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
    }
    function chain<T>(event: Event$1<T>): IChainableEvent<T>;
    interface NodeEventEmitter {
        on(event: string | symbol, listener: Function): unknown;
        removeListener(event: string | symbol, listener: Function): unknown;
    }
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event$1<T>;
    interface DOMEventEmitter {
        addEventListener(event: string | symbol, listener: Function): void;
        removeEventListener(event: string | symbol, listener: Function): void;
    }
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event$1<T>;
    function toPromise<T>(event: Event$1<T>): Promise<T>;
    function runAndSubscribe<T>(event: Event$1<T>, handler: (e: T | undefined) => any): IDisposable;
    function runAndSubscribeWithStore<T>(event: Event$1<T>, handler: (e: T | undefined, disposableStore: DisposableStore) => any): IDisposable;
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event$1<T>;
}
interface EmitterOptions {
    /**
     * Optional function that's called *before* the very first listener is added
     */
    onWillAddFirstListener?: Function;
    /**
     * Optional function that's called *after* the very first listener is added
     */
    onDidAddFirstListener?: Function;
    /**
     * Optional function that's called after a listener is added
     */
    onDidAddListener?: Function;
    /**
     * Optional function that's called *after* remove the very last listener
     */
    onDidRemoveLastListener?: Function;
    /**
     * Optional function that's called *before* a listener is removed
     */
    onWillRemoveListener?: Function;
    /**
     * Number of listeners that are allowed before assuming a leak. Default to
     * a globally configured value
     *
     * @see setGlobalLeakWarningThreshold
     */
    leakWarningThreshold?: number;
    /**
     * Pass in a delivery queue, which is useful for ensuring
     * in order event delivery across multiple emitters.
     */
    deliveryQueue?: EventDeliveryQueue;
    /** ONLY enable this during development */
    _profName?: string;
}
declare class Stacktrace {
    readonly value: string;
    static create(): Stacktrace;
    private constructor();
    print(): void;
}
declare class Listener<T> {
    readonly callback: (e: T) => void;
    readonly callbackThis: any | undefined;
    readonly stack: Stacktrace | undefined;
    readonly subscription: SafeDisposable;
    constructor(callback: (e: T) => void, callbackThis: any | undefined, stack: Stacktrace | undefined);
    invoke(e: T): void;
}
/**
 * The Emitter can be used to expose an Event to the public
 * to fire it from the insides.
 * Sample:
    class Document {

        private readonly _onDidChange = new Emitter<(value:string)=>any>();

        public onDidChange = this._onDidChange.event;

        // getter-style
        // get onDidChange(): Event<(value:string)=>any> {
        // 	return this._onDidChange.event;
        // }

        private _doIt() {
            //...
            this._onDidChange.fire(value);
        }
    }
 */
declare class Emitter<T> {
    private readonly _options?;
    private readonly _leakageMon?;
    private readonly _perfMon?;
    private _disposed;
    private _event?;
    private _deliveryQueue?;
    protected _listeners?: LinkedList<Listener<T>>;
    constructor(options?: EmitterOptions);
    dispose(): void;
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event(): Event$1<T>;
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event: T): void;
    hasListeners(): boolean;
}
declare class EventDeliveryQueue {
    protected _queue: LinkedList<EventDeliveryQueueElement<any>>;
    get size(): number;
    push<T>(emitter: Emitter<T>, listener: Listener<T>, event: T): void;
    clear<T>(emitter: Emitter<T>): void;
    deliver(): void;
}
declare class EventDeliveryQueueElement<T = any> {
    readonly emitter: Emitter<T>;
    readonly listener: Listener<T>;
    readonly event: T;
    constructor(emitter: Emitter<T>, listener: Listener<T>, event: T);
}
interface IWaitUntil {
    token: CancellationToken;
    waitUntil(thenable: Promise<unknown>): void;
}

interface IAction {
    readonly id: string;
    label: string;
    tooltip: string;
    class: string | undefined;
    enabled: boolean;
    checked?: boolean;
    run(event?: unknown): unknown;
}
interface IActionRunner extends IDisposable {
    readonly onDidRun: Event$1<IRunEvent>;
    readonly onWillRun: Event$1<IRunEvent>;
    run(action: IAction, context?: unknown): unknown;
}
interface IRunEvent {
    readonly action: IAction;
    readonly error?: Error;
}
declare class SubmenuAction implements IAction {
    readonly id: string;
    readonly label: string;
    readonly class: string | undefined;
    readonly tooltip: string;
    readonly enabled: boolean;
    readonly checked: undefined;
    private readonly _actions;
    get actions(): readonly IAction[];
    constructor(id: string, label: string, actions: readonly IAction[], cssClass?: string);
    run(): Promise<void>;
}

declare const IProgressService: ServiceIdentifier<IProgressService>;
/**
 * A progress service that can be used to report progress to various locations of the UI.
 */
interface IProgressService {
    readonly _serviceBrand: undefined;
    withProgress<R>(options: IProgressOptions | IProgressDialogOptions | IProgressNotificationOptions | IProgressWindowOptions | IProgressCompositeOptions, task: (progress: IProgress<IProgressStep>) => Promise<R>, onDidCancel?: (choice?: number) => void): Promise<R>;
}
interface IProgressIndicator {
    /**
     * Show progress customized with the provided flags.
     */
    show(infinite: true, delay?: number): IProgressRunner;
    show(total: number, delay?: number): IProgressRunner;
    /**
     * Indicate progress for the duration of the provided promise. Progress will stop in
     * any case of promise completion, error or cancellation.
     */
    showWhile(promise: Promise<unknown>, delay?: number): Promise<void>;
}
declare const enum ProgressLocation {
    Explorer = 1,
    Scm = 3,
    Extensions = 5,
    Window = 10,
    Notification = 15,
    Dialog = 20
}
interface IProgressOptions {
    readonly location: ProgressLocation | string;
    readonly title?: string;
    readonly source?: string | {
        label: string;
        id: string;
    };
    readonly total?: number;
    readonly cancellable?: boolean;
    readonly buttons?: string[];
}
interface IProgressNotificationOptions extends IProgressOptions {
    readonly location: ProgressLocation.Notification;
    readonly primaryActions?: readonly IAction[];
    readonly secondaryActions?: readonly IAction[];
    readonly delay?: number;
    readonly silent?: boolean;
    readonly type?: 'syncing' | 'loading';
}
interface IProgressDialogOptions extends IProgressOptions {
    readonly delay?: number;
    readonly detail?: string;
    readonly sticky?: boolean;
}
interface IProgressWindowOptions extends IProgressOptions {
    readonly location: ProgressLocation.Window;
    readonly command?: string;
    readonly type?: 'syncing' | 'loading';
}
interface IProgressCompositeOptions extends IProgressOptions {
    readonly location: ProgressLocation.Explorer | ProgressLocation.Extensions | ProgressLocation.Scm | string;
    readonly delay?: number;
}
interface IProgressStep {
    message?: string;
    increment?: number;
    total?: number;
}
interface IProgressRunner {
    total(value: number): void;
    worked(value: number): void;
    done(): void;
}
interface IProgress<T> {
    report(item: T): void;
}

/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */
declare class URI implements UriComponents {
    static isUri(thing: any): thing is URI;
    /**
     * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.
     * The part before the first colon.
     */
    readonly scheme: string;
    /**
     * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.
     * The part between the first double slashes and the next slash.
     */
    readonly authority: string;
    /**
     * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly path: string;
    /**
     * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly query: string;
    /**
     * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly fragment: string;
    /**
     * @internal
     */
    protected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);
    /**
     * @internal
     */
    protected constructor(components: UriComponents);
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath(): string;
    with(change: {
        scheme?: string;
        authority?: string | null;
        path?: string | null;
        query?: string | null;
        fragment?: string | null;
    }): URI;
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value: string, _strict?: boolean): URI;
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path: string): URI;
    static from(components: {
        scheme: string;
        authority?: string;
        path?: string;
        query?: string;
        fragment?: string;
    }): URI;
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri: URI, ...pathFragment: string[]): URI;
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding?: boolean): string;
    toJSON(): UriComponents;
    static revive(data: UriComponents | URI): URI;
    static revive(data: UriComponents | URI | undefined): URI | undefined;
    static revive(data: UriComponents | URI | null): URI | null;
    static revive(data: UriComponents | URI | undefined | null): URI | undefined | null;
}
interface UriComponents {
    scheme: string;
    authority: string;
    path: string;
    query: string;
    fragment: string;
}

declare const enum ContextKeyExprType {
    False = 0,
    True = 1,
    Defined = 2,
    Not = 3,
    Equals = 4,
    NotEquals = 5,
    And = 6,
    Regex = 7,
    NotRegex = 8,
    Or = 9,
    In = 10,
    NotIn = 11,
    Greater = 12,
    GreaterEquals = 13,
    Smaller = 14,
    SmallerEquals = 15
}
interface IContextKeyExprMapper {
    mapDefined(key: string): ContextKeyExpression;
    mapNot(key: string): ContextKeyExpression;
    mapEquals(key: string, value: any): ContextKeyExpression;
    mapNotEquals(key: string, value: any): ContextKeyExpression;
    mapGreater(key: string, value: any): ContextKeyExpression;
    mapGreaterEquals(key: string, value: any): ContextKeyExpression;
    mapSmaller(key: string, value: any): ContextKeyExpression;
    mapSmallerEquals(key: string, value: any): ContextKeyExpression;
    mapRegex(key: string, regexp: RegExp | null): ContextKeyRegexExpr;
    mapIn(key: string, valueKey: string): ContextKeyInExpr;
    mapNotIn(key: string, valueKey: string): ContextKeyNotInExpr;
}
interface IContextKeyExpression {
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
type ContextKeyExpression = (ContextKeyFalseExpr | ContextKeyTrueExpr | ContextKeyDefinedExpr | ContextKeyNotExpr | ContextKeyEqualsExpr | ContextKeyNotEqualsExpr | ContextKeyRegexExpr | ContextKeyNotRegexExpr | ContextKeyAndExpr | ContextKeyOrExpr | ContextKeyInExpr | ContextKeyNotInExpr | ContextKeyGreaterExpr | ContextKeyGreaterEqualsExpr | ContextKeySmallerExpr | ContextKeySmallerEqualsExpr);
declare class ContextKeyFalseExpr implements IContextKeyExpression {
    static INSTANCE: ContextKeyFalseExpr;
    readonly type = ContextKeyExprType.False;
    protected constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyTrueExpr implements IContextKeyExpression {
    static INSTANCE: ContextKeyTrueExpr;
    readonly type = ContextKeyExprType.True;
    protected constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyDefinedExpr implements IContextKeyExpression {
    readonly key: string;
    private negated;
    static create(key: string, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Defined;
    protected constructor(key: string, negated: ContextKeyExpression | null);
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyEqualsExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Equals;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyInExpr implements IContextKeyExpression {
    private readonly key;
    private readonly valueKey;
    static create(key: string, valueKey: string): ContextKeyInExpr;
    readonly type = ContextKeyExprType.In;
    private negated;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyInExpr;
    negate(): ContextKeyExpression;
}
declare class ContextKeyNotInExpr implements IContextKeyExpression {
    private readonly key;
    private readonly valueKey;
    static create(key: string, valueKey: string): ContextKeyNotInExpr;
    readonly type = ContextKeyExprType.NotIn;
    private readonly _negated;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyNotEqualsExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.NotEquals;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyNotExpr implements IContextKeyExpression {
    private readonly key;
    private negated;
    static create(key: string, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Not;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyGreaterExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, _value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Greater;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyGreaterEqualsExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, _value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.GreaterEquals;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeySmallerExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, _value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Smaller;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeySmallerEqualsExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, _value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.SmallerEquals;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyRegexExpr implements IContextKeyExpression {
    private readonly key;
    private readonly regexp;
    static create(key: string, regexp: RegExp | null): ContextKeyRegexExpr;
    readonly type = ContextKeyExprType.Regex;
    private negated;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyRegexExpr;
    negate(): ContextKeyExpression;
}
declare class ContextKeyNotRegexExpr implements IContextKeyExpression {
    private readonly _actual;
    static create(actual: ContextKeyRegexExpr): ContextKeyExpression;
    readonly type = ContextKeyExprType.NotRegex;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyAndExpr implements IContextKeyExpression {
    readonly expr: ContextKeyExpression[];
    private negated;
    static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined;
    readonly type = ContextKeyExprType.And;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    private static _normalizeArr;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyOrExpr implements IContextKeyExpression {
    readonly expr: ContextKeyExpression[];
    private negated;
    static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined;
    readonly type = ContextKeyExprType.Or;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    private static _normalizeArr;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
type ContextKeyValue = null | undefined | boolean | number | string | Array<null | undefined | boolean | number | string> | Record<string, null | undefined | boolean | number | string>;
interface IContext {
    getValue<T extends ContextKeyValue = ContextKeyValue>(key: string): T | undefined;
}
interface IContextKey<T extends ContextKeyValue = ContextKeyValue> {
    set(value: T): void;
    reset(): void;
    get(): T | undefined;
}
interface IContextKeyServiceTarget {
    parentElement: IContextKeyServiceTarget | null;
    setAttribute(attr: string, value: string): void;
    removeAttribute(attr: string): void;
    hasAttribute(attr: string): boolean;
    getAttribute(attr: string): string | null;
}
interface IReadableSet<T> {
    has(value: T): boolean;
}
interface IContextKeyChangeEvent {
    affectsSome(keys: IReadableSet<string>): boolean;
    allKeysContainedIn(keys: IReadableSet<string>): boolean;
}
declare const IContextKeyService: ServiceIdentifier<IContextKeyService>;
interface IContextKeyService {
    readonly _serviceBrand: undefined;
    dispose(): void;
    onDidChangeContext: Event$1<IContextKeyChangeEvent>;
    bufferChangeEvents(callback: Function): void;
    createKey<T extends ContextKeyValue>(key: string, defaultValue: T | undefined): IContextKey<T>;
    contextMatchesRules(rules: ContextKeyExpression | undefined): boolean;
    getContextKeyValue<T>(key: string): T | undefined;
    createScoped(target: IContextKeyServiceTarget): IContextKeyService;
    createOverlay(overlay: Iterable<[string, any]>): IContextKeyService;
    getContext(target: IContextKeyServiceTarget | null): IContext;
    updateParent(parentContextKeyService: IContextKeyService): void;
}

type IconIdentifier = string;
interface ThemeColor {
    id: string;
}
declare namespace ThemeColor {
    function isThemeColor(obj: any): obj is ThemeColor;
}
interface ThemeIcon {
    readonly id: string;
    readonly color?: ThemeColor;
}
declare namespace ThemeIcon {
    const iconNameSegment = "[A-Za-z0-9]+";
    const iconNameExpression = "[A-Za-z0-9-]+";
    const iconModifierExpression = "~[A-Za-z]+";
    const iconNameCharacter = "[A-Za-z0-9~-]";
    function asClassNameArray(icon: ThemeIcon): string[];
    function asClassName(icon: ThemeIcon): string;
    function asCSSSelector(icon: ThemeIcon): string;
    function isThemeIcon(obj: any): obj is ThemeIcon;
    function fromString(str: string): ThemeIcon | undefined;
    function fromId(id: string): ThemeIcon;
    function modify(icon: ThemeIcon, modifier: 'disabled' | 'spin' | undefined): ThemeIcon;
    function getModifier(icon: ThemeIcon): string | undefined;
    function isEqual(ti1: ThemeIcon, ti2: ThemeIcon): boolean;
}

declare const Categories: Readonly<{
    View: {
        value: string;
        original: string;
    };
    Help: {
        value: string;
        original: string;
    };
    Test: {
        value: string;
        original: string;
    };
    Preferences: {
        value: string;
        original: string;
    };
    Developer: {
        value: string;
        original: string;
    };
}>;

interface ILocalizedString {
    /**
     * The localized value of the string.
     */
    value: string;
    /**
     * The original (non localized value of the string)
     */
    original: string;
}
interface ICommandActionTitle extends ILocalizedString {
    /**
     * The title with a mnemonic designation. && precedes the mnemonic.
     */
    mnemonicTitle?: string;
}
type Icon = {
    dark?: URI;
    light?: URI;
} | ThemeIcon;
interface ICommandActionToggleInfo {
    /**
     * The condition that marks the action as toggled.
     */
    condition: ContextKeyExpression;
    icon?: Icon;
    tooltip?: string;
    /**
     * The title that goes well with a a check mark, e.g "(check) Line Numbers" vs "Toggle Line Numbers"
     */
    title?: string;
    /**
     * Like title but with a mnemonic designation.
     */
    mnemonicTitle?: string;
}
interface ICommandActionSource {
    readonly id: string;
    readonly title: string;
}
interface ICommandAction {
    id: string;
    title: string | ICommandActionTitle;
    shortTitle?: string | ICommandActionTitle;
    category?: keyof typeof Categories | ILocalizedString | string;
    tooltip?: string | ILocalizedString;
    icon?: Icon;
    source?: ICommandActionSource;
    precondition?: ContextKeyExpression;
    /**
     * The action is a toggle action. Define the context key expression that reflects its toggle-state
     * or define toggle-info including an icon and a title that goes well with a checkmark.
     */
    toggled?: ContextKeyExpression | ICommandActionToggleInfo;
}

interface IDebugParams {
    port: number | null;
    break: boolean;
}
interface IExtensionHostDebugParams extends IDebugParams {
    debugId?: string;
    env?: Record<string, string>;
}
/**
 * Type of extension.
 *
 * **NOTE**: This is defined in `platform/environment` because it can appear as a CLI argument.
 */
type ExtensionKind = 'ui' | 'workspace' | 'web';
declare const IEnvironmentService: ServiceIdentifier<IEnvironmentService>;
/**
 * A basic environment service that can be used in various processes,
 * such as main, renderer and shared process. Use subclasses of this
 * service for specific environment.
 */
interface IEnvironmentService {
    readonly _serviceBrand: undefined;
    stateResource: URI;
    userRoamingDataHome: URI;
    keyboardLayoutResource: URI;
    argvResource: URI;
    untitledWorkspacesHome: URI;
    workspaceStorageHome: URI;
    localHistoryHome: URI;
    cacheHome: URI;
    userDataSyncHome: URI;
    userDataSyncLogResource: URI;
    sync: 'on' | 'off' | undefined;
    continueOn?: string;
    editSessionId?: string;
    editSessionsLogResource: URI;
    debugExtensionHost: IExtensionHostDebugParams;
    isExtensionDevelopment: boolean;
    disableExtensions: boolean | string[];
    enableExtensions?: readonly string[];
    extensionDevelopmentLocationURI?: URI[];
    extensionDevelopmentKind?: ExtensionKind[];
    extensionTestsLocationURI?: URI;
    logsPath: string;
    logLevel?: string;
    extensionLogLevel?: [string, string][];
    verbose: boolean;
    isBuilt: boolean;
    disableTelemetry: boolean;
    telemetryLogResource: URI;
    serviceMachineIdResource: URI;
    policyFile?: URI;
}

interface ICommand {
    command: string;
    title: string | ILocalizedString;
    category?: string | ILocalizedString;
}
interface IConfigurationProperty {
    description: string;
    type: string | string[];
    default?: any;
}
interface IConfiguration {
    id?: string;
    order?: number;
    title?: string;
    properties: {
        [key: string]: IConfigurationProperty;
    };
}
interface IDebugger$1 {
    label?: string;
    type: string;
    runtime?: string;
}
interface IGrammar {
    language: string;
}
interface IJSONValidation {
    fileMatch: string | string[];
    url: string;
}
interface IKeyBinding {
    command: string;
    key: string;
    when?: string;
    mac?: string;
    linux?: string;
    win?: string;
}
interface ILanguage {
    id: string;
    extensions: string[];
    aliases: string[];
}
interface IMenu$1 {
    command: string;
    alt?: string;
    when?: string;
    group?: string;
}
interface ISnippet {
    language: string;
}
interface ITheme {
    label: string;
}
interface IViewContainer {
    id: string;
    title: string;
}
interface IView$4 {
    id: string;
    name: string;
}
interface IColor$1 {
    id: string;
    description: string;
    defaults: {
        light: string;
        dark: string;
        highContrast: string;
    };
}
interface IWebviewEditor {
    readonly viewType: string;
    readonly priority: string;
    readonly selector: readonly {
        readonly filenamePattern?: string;
    }[];
}
interface ICodeActionContributionAction {
    readonly kind: string;
    readonly title: string;
    readonly description?: string;
}
interface ICodeActionContribution {
    readonly languages: readonly string[];
    readonly actions: readonly ICodeActionContributionAction[];
}
interface IAuthenticationContribution {
    readonly id: string;
    readonly label: string;
}
interface IWalkthroughStep {
    readonly id: string;
    readonly title: string;
    readonly description: string | undefined;
    readonly media: {
        image: string | {
            dark: string;
            light: string;
            hc: string;
        };
        altText: string;
        markdown?: never;
        svg?: never;
    } | {
        markdown: string;
        image?: never;
        svg?: never;
    } | {
        svg: string;
        altText: string;
        markdown?: never;
        image?: never;
    };
    readonly completionEvents?: string[];
    /** @deprecated use `completionEvents: 'onCommand:...'` */
    readonly doneOn?: {
        command: string;
    };
    readonly when?: string;
}
interface IWalkthrough {
    readonly id: string;
    readonly title: string;
    readonly icon?: string;
    readonly description: string;
    readonly steps: IWalkthroughStep[];
    readonly featuredFor: string[] | undefined;
    readonly when?: string;
}
interface IStartEntry {
    readonly title: string;
    readonly description: string;
    readonly command: string;
    readonly when?: string;
    readonly category: 'file' | 'folder' | 'notebook';
}
interface INotebookEntry {
    readonly type: string;
    readonly displayName: string;
}
interface INotebookRendererContribution {
    readonly id: string;
    readonly displayName: string;
    readonly mimeTypes: string[];
}
interface ITranslation {
    id: string;
    path: string;
}
interface ILocalizationContribution {
    languageId: string;
    languageName?: string;
    localizedLanguageName?: string;
    translations: ITranslation[];
    minimalTranslations?: {
        [key: string]: string;
    };
}
interface IExtensionContributions {
    commands?: ICommand[];
    configuration?: IConfiguration | IConfiguration[];
    debuggers?: IDebugger$1[];
    grammars?: IGrammar[];
    jsonValidation?: IJSONValidation[];
    keybindings?: IKeyBinding[];
    languages?: ILanguage[];
    menus?: {
        [context: string]: IMenu$1[];
    };
    snippets?: ISnippet[];
    themes?: ITheme[];
    iconThemes?: ITheme[];
    productIconThemes?: ITheme[];
    viewsContainers?: {
        [location: string]: IViewContainer[];
    };
    views?: {
        [location: string]: IView$4[];
    };
    colors?: IColor$1[];
    localizations?: ILocalizationContribution[];
    readonly customEditors?: readonly IWebviewEditor[];
    readonly codeActions?: readonly ICodeActionContribution[];
    authentication?: IAuthenticationContribution[];
    walkthroughs?: IWalkthrough[];
    startEntries?: IStartEntry[];
    readonly notebooks?: INotebookEntry[];
    readonly notebookRenderer?: INotebookRendererContribution[];
}
interface IExtensionCapabilities {
    readonly virtualWorkspaces?: ExtensionVirtualWorkspaceSupport$1;
    readonly untrustedWorkspaces?: ExtensionUntrustedWorkspaceSupport$1;
}
type LimitedWorkspaceSupportType = 'limited';
type ExtensionUntrustedWorkspaceSupport$1 = {
    supported: true;
} | {
    supported: false;
    description: string;
} | {
    supported: LimitedWorkspaceSupportType;
    description: string;
    restrictedConfigurations?: string[];
};
type ExtensionVirtualWorkspaceSupport$1 = boolean | {
    supported: true;
} | {
    supported: false | LimitedWorkspaceSupportType;
    description: string;
};
interface IRelaxedExtensionManifest {
    name: string;
    displayName?: string;
    publisher: string;
    version: string;
    engines: {
        readonly vscode: string;
    };
    description?: string;
    main?: string;
    browser?: string;
    preview?: boolean;
    l10n?: string;
    icon?: string;
    categories?: string[];
    keywords?: string[];
    activationEvents?: string[];
    extensionDependencies?: string[];
    extensionPack?: string[];
    extensionKind?: ExtensionKind | ExtensionKind[];
    contributes?: IExtensionContributions;
    repository?: {
        url: string;
    };
    bugs?: {
        url: string;
    };
    enabledApiProposals?: readonly string[];
    api?: string;
    scripts?: {
        [key: string]: string;
    };
    capabilities?: IExtensionCapabilities;
}
declare const enum TargetPlatform {
    WIN32_X64 = "win32-x64",
    WIN32_IA32 = "win32-ia32",
    WIN32_ARM64 = "win32-arm64",
    LINUX_X64 = "linux-x64",
    LINUX_ARM64 = "linux-arm64",
    LINUX_ARMHF = "linux-armhf",
    ALPINE_X64 = "alpine-x64",
    ALPINE_ARM64 = "alpine-arm64",
    DARWIN_X64 = "darwin-x64",
    DARWIN_ARM64 = "darwin-arm64",
    WEB = "web",
    UNIVERSAL = "universal",
    UNKNOWN = "unknown",
    UNDEFINED = "undefined"
}
/**
 * **!Do not construct directly!**
 *
 * **!Only static methods because it gets serialized!**
 *
 * This represents the "canonical" version for an extension identifier. Extension ids
 * have to be case-insensitive (due to the marketplace), but we must ensure case
 * preservation because the extension API is already public at this time.
 *
 * For example, given an extension with the publisher `"Hello"` and the name `"World"`,
 * its canonical extension identifier is `"Hello.World"`. This extension could be
 * referenced in some other extension's dependencies using the string `"hello.world"`.
 *
 * To make matters more complicated, an extension can optionally have an UUID. When two
 * extensions have the same UUID, they are considered equal even if their identifier is different.
 */
declare class ExtensionIdentifier {
    readonly value: string;
    private readonly _lower;
    constructor(value: string);
    static equals(a: ExtensionIdentifier | string | null | undefined, b: ExtensionIdentifier | string | null | undefined): boolean;
    /**
     * Gives the value by which to index (for equality).
     */
    static toKey(id: ExtensionIdentifier | string): string;
}
interface IRelaxedExtensionDescription extends IRelaxedExtensionManifest {
    id?: string;
    identifier: ExtensionIdentifier;
    uuid?: string;
    targetPlatform: TargetPlatform;
    isBuiltin: boolean;
    isUserBuiltin: boolean;
    isUnderDevelopment: boolean;
    extensionLocation: URI;
    browserNlsBundleUris?: {
        [language: string]: URI;
    };
}
type IExtensionDescription = Readonly<IRelaxedExtensionDescription>;

type Severity = Severity$1;
type NotificationMessage = string | Error;
interface INotificationProperties {
    /**
     * Sticky notifications are not automatically removed after a certain timeout. By
     * default, notifications with primary actions and severity error are always sticky.
     */
    readonly sticky?: boolean;
    /**
     * Silent notifications are not shown to the user unless the notification center
     * is opened. The status bar will still indicate all number of notifications to
     * catch some attention.
     */
    readonly silent?: boolean;
    /**
     * Adds an action to never show the notification again. The choice will be persisted
     * such as future requests will not cause the notification to show again.
     */
    readonly neverShowAgain?: INeverShowAgainOptions;
}
declare enum NeverShowAgainScope {
    /**
     * Will never show this notification on the current workspace again.
     */
    WORKSPACE = 0,
    /**
     * Will never show this notification on any workspace of the same
     * profile again.
     */
    PROFILE = 1,
    /**
     * Will never show this notification on any workspace across all
     * profiles again.
     */
    APPLICATION = 2
}
interface INeverShowAgainOptions {
    /**
     * The id is used to persist the selection of not showing the notification again.
     */
    readonly id: string;
    /**
     * By default the action will show up as primary action. Setting this to true will
     * make it a secondary action instead.
     */
    readonly isSecondary?: boolean;
    /**
     * Whether to persist the choice in the current workspace or for all workspaces. By
     * default it will be persisted for all workspaces across all profiles
     * (= `NeverShowAgainScope.APPLICATION`).
     */
    readonly scope?: NeverShowAgainScope;
}
interface INotification extends INotificationProperties {
    /**
     * The id of the notification. If provided, will be used to compare
     * notifications with others to decide whether a notification is
     * duplicate or not.
     */
    readonly id?: string;
    /**
     * The severity of the notification. Either `Info`, `Warning` or `Error`.
     */
    readonly severity: Severity;
    /**
     * The message of the notification. This can either be a `string` or `Error`. Messages
     * can optionally include links in the format: `[text](link)`
     */
    readonly message: NotificationMessage;
    /**
     * The source of the notification appears as additional information.
     */
    readonly source?: string | {
        label: string;
        id: string;
    };
    /**
     * Actions to show as part of the notification. Primary actions show up as
     * buttons as part of the message and will close the notification once clicked.
     *
     * Secondary actions are meant to provide additional configuration or context
     * for the notification and will show up less prominent. A notification does not
     * close automatically when invoking a secondary action.
     *
     * **Note:** If your intent is to show a message with actions to the user, consider
     * the `INotificationService.prompt()` method instead which are optimized for
     * this usecase and much easier to use!
     */
    actions?: INotificationActions;
    /**
     * The initial set of progress properties for the notification. To update progress
     * later on, access the `INotificationHandle.progress` property.
     */
    readonly progress?: INotificationProgressProperties;
}
interface INotificationActions {
    /**
     * Primary actions show up as buttons as part of the message and will close
     * the notification once clicked.
     *
     * Pass `ActionWithMenuAction` for an action that has additional menu actions.
     */
    readonly primary?: readonly IAction[];
    /**
     * Secondary actions are meant to provide additional configuration or context
     * for the notification and will show up less prominent. A notification does not
     * close automatically when invoking a secondary action.
     */
    readonly secondary?: readonly IAction[];
}
interface INotificationProgressProperties {
    /**
     * Causes the progress bar to spin infinitley.
     */
    readonly infinite?: boolean;
    /**
     * Indicate the total amount of work.
     */
    readonly total?: number;
    /**
     * Indicate that a specific chunk of work is done.
     */
    readonly worked?: number;
}
interface INotificationProgress {
    /**
     * Causes the progress bar to spin infinitley.
     */
    infinite(): void;
    /**
     * Indicate the total amount of work.
     */
    total(value: number): void;
    /**
     * Indicate that a specific chunk of work is done.
     */
    worked(value: number): void;
    /**
     * Indicate that the long running operation is done.
     */
    done(): void;
}
interface INotificationHandle {
    /**
     * Will be fired once the notification is closed.
     */
    readonly onDidClose: Event$1<void>;
    /**
     * Will be fired whenever the visibility of the notification changes.
     * A notification can either be visible as toast or inside the notification
     * center if it is visible.
     */
    readonly onDidChangeVisibility: Event$1<boolean>;
    /**
     * Allows to indicate progress on the notification even after the
     * notification is already visible.
     */
    readonly progress: INotificationProgress;
    /**
     * Allows to update the severity of the notification.
     */
    updateSeverity(severity: Severity): void;
    /**
     * Allows to update the message of the notification even after the
     * notification is already visible.
     */
    updateMessage(message: NotificationMessage): void;
    /**
     * Allows to update the actions of the notification even after the
     * notification is already visible.
     */
    updateActions(actions?: INotificationActions): void;
    /**
     * Hide the notification and remove it from the notification center.
     */
    close(): void;
}
interface IBasePromptChoice {
    /**
     * Label to show for the choice to the user.
     */
    readonly label: string;
    /**
     * Whether to keep the notification open after the choice was selected
     * by the user. By default, will close the notification upon click.
     */
    readonly keepOpen?: boolean;
    /**
     * Triggered when the user selects the choice.
     */
    run: () => void;
}
interface IPromptChoice extends IBasePromptChoice {
    /**
     * Primary choices show up as buttons in the notification below the message.
     * Secondary choices show up under the gear icon in the header of the notification.
     */
    readonly isSecondary?: boolean;
}
interface IPromptChoiceWithMenu extends IPromptChoice {
    /**
     * Additional choices those will be shown in the dropdown menu for this choice.
     */
    readonly menu: IBasePromptChoice[];
    /**
     * Menu is not supported on secondary choices
     */
    readonly isSecondary: false | undefined;
}
interface IPromptOptions extends INotificationProperties {
    /**
     * Will be called if the user closed the notification without picking
     * any of the provided choices.
     */
    onCancel?: () => void;
}
interface IStatusMessageOptions {
    /**
     * An optional timeout after which the status message should show. By default
     * the status message will show immediately.
     */
    readonly showAfter?: number;
    /**
     * An optional timeout after which the status message is to be hidden. By default
     * the status message will not hide until another status message is displayed.
     */
    readonly hideAfter?: number;
}
declare enum NotificationsFilter {
    /**
     * No filter is enabled.
     */
    OFF = 0,
    /**
     * All notifications are configured as silent. See
     * `INotificationProperties.silent` for more info.
     */
    SILENT = 1,
    /**
     * All notifications are silent except error notifications.
    */
    ERROR = 2
}
declare const INotificationService: ServiceIdentifier<INotificationService>;
/**
 * A service to bring up notifications and non-modal prompts.
 *
 * Note: use the `IDialogService` for a modal way to ask the user for input.
 */
interface INotificationService {
    readonly _serviceBrand: undefined;
    /**
     * The DND mode can be enabled or disabled
     * and will result in all info and warning
     * notifications to be silent.
     */
    doNotDisturbMode: boolean;
    /**
     * Emitted when a new notification is added.
     */
    readonly onDidAddNotification: Event$1<INotification>;
    /**
     * Emitted when a notification is removed.
     */
    readonly onDidRemoveNotification: Event$1<INotification>;
    /**
     * Emitted when a do not disturb mode has changed.
     */
    readonly onDidChangeDoNotDisturbMode: Event$1<void>;
    /**
     * Show the provided notification to the user. The returned `INotificationHandle`
     * can be used to control the notification afterwards.
     *
     * **Note:** If your intent is to show a message with actions to the user, consider
     * the `INotificationService.prompt()` method instead which are optimized for
     * this usecase and much easier to use!
     *
     * @returns a handle on the notification to e.g. hide it or update message, buttons, etc.
     */
    notify(notification: INotification): INotificationHandle;
    /**
     * A convenient way of reporting infos. Use the `INotificationService.notify`
     * method if you need more control over the notification.
     */
    info(message: NotificationMessage | NotificationMessage[]): void;
    /**
     * A convenient way of reporting warnings. Use the `INotificationService.notify`
     * method if you need more control over the notification.
     */
    warn(message: NotificationMessage | NotificationMessage[]): void;
    /**
     * A convenient way of reporting errors. Use the `INotificationService.notify`
     * method if you need more control over the notification.
     */
    error(message: NotificationMessage | NotificationMessage[]): void;
    /**
     * Shows a prompt in the notification area with the provided choices. The prompt
     * is non-modal. If you want to show a modal dialog instead, use `IDialogService`.
     *
     * @param severity the severity of the notification. Either `Info`, `Warning` or `Error`.
     * @param message the message to show as status.
     * @param choices options to be chosen from.
     * @param options provides some optional configuration options.
     *
     * @returns a handle on the notification to e.g. hide it or update message, buttons, etc.
     */
    prompt(severity: Severity, message: string, choices: (IPromptChoice | IPromptChoiceWithMenu)[], options?: IPromptOptions): INotificationHandle;
    /**
     * Shows a status message in the status area with the provided text.
     *
     * @param message the message to show as status
     * @param options provides some optional configuration options
     *
     * @returns a disposable to hide the status message
     */
    status(message: NotificationMessage, options?: IStatusMessageOptions): IDisposable;
}

declare const IWorkspaceContextService: ServiceIdentifier<IWorkspaceContextService>;
interface IWorkspaceContextService {
    readonly _serviceBrand: undefined;
    /**
     * An event which fires on workbench state changes.
     */
    readonly onDidChangeWorkbenchState: Event$1<WorkbenchState>;
    /**
     * An event which fires on workspace name changes.
     */
    readonly onDidChangeWorkspaceName: Event$1<void>;
    /**
     * An event which fires before workspace folders change.
     */
    readonly onWillChangeWorkspaceFolders: Event$1<IWorkspaceFoldersWillChangeEvent>;
    /**
     * An event which fires on workspace folders change.
     */
    readonly onDidChangeWorkspaceFolders: Event$1<IWorkspaceFoldersChangeEvent>;
    /**
     * Provides access to the complete workspace object.
     */
    getCompleteWorkspace(): Promise<IWorkspace>;
    /**
     * Provides access to the workspace object the window is running with.
     * Use `getCompleteWorkspace` to get complete workspace object.
     */
    getWorkspace(): IWorkspace;
    /**
     * Return the state of the workbench.
     *
     * WorkbenchState.EMPTY - if the workbench was opened with empty window or file
     * WorkbenchState.FOLDER - if the workbench was opened with a folder
     * WorkbenchState.WORKSPACE - if the workbench was opened with a workspace
     */
    getWorkbenchState(): WorkbenchState;
    /**
     * Returns the folder for the given resource from the workspace.
     * Can be null if there is no workspace or the resource is not inside the workspace.
     */
    getWorkspaceFolder(resource: URI): IWorkspaceFolder | null;
    /**
     * Return `true` if the current workspace has the given identifier or root URI otherwise `false`.
     */
    isCurrentWorkspace(workspaceIdOrFolder: IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | URI): boolean;
    /**
     * Returns if the provided resource is inside the workspace or not.
     */
    isInsideWorkspace(resource: URI): boolean;
}
interface IBaseWorkspaceIdentifier {
    /**
     * Every workspace (multi-root, single folder or empty)
     * has a unique identifier. It is not possible to open
     * a workspace with the same `id` in multiple windows
     */
    readonly id: string;
}
/**
 * A single folder workspace identifier is a path to a folder + id.
 */
interface ISingleFolderWorkspaceIdentifier extends IBaseWorkspaceIdentifier {
    /**
     * Folder path as `URI`.
     */
    readonly uri: URI;
}
/**
 * A multi-root workspace identifier is a path to a workspace file + id.
 */
interface IWorkspaceIdentifier extends IBaseWorkspaceIdentifier {
    /**
     * Workspace config file path as `URI`.
     */
    configPath: URI;
}
interface IEmptyWorkspaceIdentifier extends IBaseWorkspaceIdentifier {
}
type IAnyWorkspaceIdentifier = IWorkspaceIdentifier | ISingleFolderWorkspaceIdentifier | IEmptyWorkspaceIdentifier;
declare const enum WorkbenchState {
    EMPTY = 1,
    FOLDER = 2,
    WORKSPACE = 3
}
interface IWorkspaceFoldersWillChangeEvent {
    readonly changes: IWorkspaceFoldersChangeEvent;
    readonly fromCache: boolean;
    join(promise: Promise<void>): void;
}
interface IWorkspaceFoldersChangeEvent {
    added: IWorkspaceFolder[];
    removed: IWorkspaceFolder[];
    changed: IWorkspaceFolder[];
}
interface IWorkspace {
    /**
     * the unique identifier of the workspace.
     */
    readonly id: string;
    /**
     * Folders in the workspace.
     */
    readonly folders: IWorkspaceFolder[];
    /**
     * Transient workspaces are meant to go away after being used
     * once, e.g. a window reload of a transient workspace will
     * open an empty window.
     */
    readonly transient?: boolean;
    /**
     * the location of the workspace configuration
     */
    readonly configuration?: URI | null;
}
interface IWorkspaceFolderData {
    /**
     * The associated URI for this workspace folder.
     */
    readonly uri: URI;
    /**
     * The name of this workspace folder. Defaults to
     * the basename of its [uri-path](#Uri.path)
     */
    readonly name: string;
    /**
     * The ordinal number of this workspace folder.
     */
    readonly index: number;
}
interface IWorkspaceFolder extends IWorkspaceFolderData {
    /**
     * Given workspace folder relative path, returns the resource with the absolute path.
     */
    toResource: (relativePath: string) => URI;
}

interface IConfigurationOverrides {
    overrideIdentifier?: string | null;
    resource?: URI | null;
}
type IConfigurationUpdateOverrides = Omit<IConfigurationOverrides, 'overrideIdentifier'> & {
    overrideIdentifiers?: string[] | null;
};
declare const enum ConfigurationTarget {
    APPLICATION = 1,
    USER = 2,
    USER_LOCAL = 3,
    USER_REMOTE = 4,
    WORKSPACE = 5,
    WORKSPACE_FOLDER = 6,
    DEFAULT = 7,
    MEMORY = 8
}
interface IConfigurationChange {
    keys: string[];
    overrides: [string, string[]][];
}
interface IConfigurationChangeEvent {
    readonly source: ConfigurationTarget;
    readonly affectedKeys: ReadonlySet<string>;
    readonly change: IConfigurationChange;
    affectsConfiguration(configuration: string, overrides?: IConfigurationOverrides): boolean;
    readonly sourceConfig: any;
}
interface IConfigurationValue<T> {
    readonly defaultValue?: T;
    readonly applicationValue?: T;
    readonly userValue?: T;
    readonly userLocalValue?: T;
    readonly userRemoteValue?: T;
    readonly workspaceValue?: T;
    readonly workspaceFolderValue?: T;
    readonly memoryValue?: T;
    readonly policyValue?: T;
    readonly value?: T;
    readonly default?: {
        value?: T;
        override?: T;
    };
    readonly application?: {
        value?: T;
        override?: T;
    };
    readonly user?: {
        value?: T;
        override?: T;
    };
    readonly userLocal?: {
        value?: T;
        override?: T;
    };
    readonly userRemote?: {
        value?: T;
        override?: T;
    };
    readonly workspace?: {
        value?: T;
        override?: T;
    };
    readonly workspaceFolder?: {
        value?: T;
        override?: T;
    };
    readonly memory?: {
        value?: T;
        override?: T;
    };
    readonly policy?: {
        value?: T;
    };
    readonly overrideIdentifiers?: string[];
}
interface IConfigurationUpdateOptions {
    /**
     * If `true`, do not notifies the error to user by showing the message box. Default is `false`.
     */
    donotNotifyError?: boolean;
    /**
     * How to handle dirty file when updating the configuration.
     */
    handleDirtyFile?: 'save' | 'revert';
}
declare const IConfigurationService: ServiceIdentifier<IConfigurationService>;
interface IConfigurationService {
    readonly _serviceBrand: undefined;
    onDidChangeConfiguration: Event$1<IConfigurationChangeEvent>;
    getConfigurationData(): IConfigurationData | null;
    /**
     * Fetches the value of the section for the given overrides.
     * Value can be of native type or an object keyed off the section name.
     *
     * @param section - Section of the configuraion. Can be `null` or `undefined`.
     * @param overrides - Overrides that has to be applied while fetching
     *
     */
    getValue<T>(): T;
    getValue<T>(section: string): T;
    getValue<T>(overrides: IConfigurationOverrides): T;
    getValue<T>(section: string, overrides: IConfigurationOverrides): T;
    /**
     * Update a configuration value.
     *
     * Use `target` to update the configuration in a specific `ConfigurationTarget`.
     *
     * Use `overrides` to update the configuration for a resource or for override identifiers or both.
     *
     * Passing a resource through overrides will update the configuration in the workspace folder containing that resource.
     *
     * *Note 1:* Updating configuraiton to a default value will remove the configuration from the requested target. If not target is passed, it will be removed from all writeable targets.
     *
     * *Note 2:* Use `undefined` value to remove the configuration from the given target. If not target is passed, it will be removed from all writeable targets.
     *
     * Use `donotNotifyError` and set it to `true` to surpresss errors.
     *
     * @param key setting to be updated
     * @param value The new value
     */
    updateValue(key: string, value: any): Promise<void>;
    updateValue(key: string, value: any, target: ConfigurationTarget): Promise<void>;
    updateValue(key: string, value: any, overrides: IConfigurationOverrides | IConfigurationUpdateOverrides): Promise<void>;
    updateValue(key: string, value: any, overrides: IConfigurationOverrides | IConfigurationUpdateOverrides, target: ConfigurationTarget, options?: IConfigurationUpdateOptions): Promise<void>;
    inspect<T>(key: string, overrides?: IConfigurationOverrides): IConfigurationValue<Readonly<T>>;
    reloadConfiguration(target?: ConfigurationTarget | IWorkspaceFolder): Promise<void>;
    keys(): {
        default: string[];
        user: string[];
        workspace: string[];
        workspaceFolder: string[];
        memory?: string[];
    };
}
interface IConfigurationModel {
    contents: any;
    keys: string[];
    overrides: IOverrides[];
}
interface IOverrides {
    keys: string[];
    contents: any;
    identifiers: string[];
}
interface IConfigurationData {
    defaults: IConfigurationModel;
    policy: IConfigurationModel;
    application: IConfigurationModel;
    user: IConfigurationModel;
    workspace: IConfigurationModel;
    folders: [UriComponents, IConfigurationModel][];
}

interface MarkdownStringTrustedOptions {
    readonly enabledCommands: readonly string[];
}
interface IMarkdownString {
    readonly value: string;
    readonly isTrusted?: boolean | MarkdownStringTrustedOptions;
    readonly supportThemeIcons?: boolean;
    readonly supportHtml?: boolean;
    readonly baseUri?: UriComponents;
    uris?: {
        [href: string]: UriComponents;
    };
}

/**
 * A position in the editor. This interface is suitable for serialization.
 */
interface IPosition {
    /**
     * line number (starts at 1)
     */
    readonly lineNumber: number;
    /**
     * column (the first character in a line is between column 1 and column 2)
     */
    readonly column: number;
}
/**
 * A position in the editor.
 */
declare class Position$1 {
    /**
     * line number (starts at 1)
     */
    readonly lineNumber: number;
    /**
     * column (the first character in a line is between column 1 and column 2)
     */
    readonly column: number;
    constructor(lineNumber: number, column: number);
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber?: number, newColumn?: number): Position$1;
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber?: number, deltaColumn?: number): Position$1;
    /**
     * Test if this position equals other position
     */
    equals(other: IPosition): boolean;
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a: IPosition | null, b: IPosition | null): boolean;
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other: IPosition): boolean;
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a: IPosition, b: IPosition): boolean;
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other: IPosition): boolean;
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a: IPosition, b: IPosition): boolean;
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a: IPosition, b: IPosition): number;
    /**
     * Clone this position.
     */
    clone(): Position$1;
    /**
     * Convert to a human-readable representation.
     */
    toString(): string;
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos: IPosition): Position$1;
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj: any): obj is IPosition;
}

/**
 * A range in the editor. This interface is suitable for serialization.
 */
interface IRange {
    /**
     * Line number on which the range starts (starts at 1).
     */
    readonly startLineNumber: number;
    /**
     * Column on which the range starts in line `startLineNumber` (starts at 1).
     */
    readonly startColumn: number;
    /**
     * Line number on which the range ends.
     */
    readonly endLineNumber: number;
    /**
     * Column on which the range ends in line `endLineNumber`.
     */
    readonly endColumn: number;
}
/**
 * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
 */
declare class Range {
    /**
     * Line number on which the range starts (starts at 1).
     */
    readonly startLineNumber: number;
    /**
     * Column on which the range starts in line `startLineNumber` (starts at 1).
     */
    readonly startColumn: number;
    /**
     * Line number on which the range ends.
     */
    readonly endLineNumber: number;
    /**
     * Column on which the range ends in line `endLineNumber`.
     */
    readonly endColumn: number;
    constructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number);
    /**
     * Test if this range is empty.
     */
    isEmpty(): boolean;
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range: IRange): boolean;
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position: IPosition): boolean;
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range: IRange, position: IPosition): boolean;
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range: IRange, position: IPosition): boolean;
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range: IRange): boolean;
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range: IRange, otherRange: IRange): boolean;
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range: IRange): boolean;
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range: IRange, otherRange: IRange): boolean;
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range: IRange): Range;
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a: IRange, b: IRange): Range;
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range: IRange): Range | null;
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a: IRange, b: IRange): Range | null;
    /**
     * Test if this range equals other.
     */
    equalsRange(other: IRange | null | undefined): boolean;
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a: IRange | null | undefined, b: IRange | null | undefined): boolean;
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition(): Position$1;
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range: IRange): Position$1;
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition(): Position$1;
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range: IRange): Position$1;
    /**
     * Transform to a user presentable string representation.
     */
    toString(): string;
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber: number, endColumn: number): Range;
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber: number, startColumn: number): Range;
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart(): Range;
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range: IRange): Range;
    /**
     * Create a new empty range using this range's end position.
     */
    collapseToEnd(): Range;
    /**
     * Create a new empty range using this range's end position.
     */
    static collapseToEnd(range: IRange): Range;
    /**
     * Moves the range by the given amount of lines.
     */
    delta(lineCount: number): Range;
    static fromPositions(start: IPosition, end?: IPosition): Range;
    /**
     * Create a `Range` from an `IRange`.
     */
    static lift(range: undefined | null): null;
    static lift(range: IRange): Range;
    static lift(range: IRange | undefined | null): Range | null;
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj: any): obj is IRange;
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a: IRange, b: IRange): boolean;
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a: IRange, b: IRange): boolean;
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a: IRange | null | undefined, b: IRange | null | undefined): number;
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a: IRange, b: IRange): number;
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range: IRange): boolean;
    toJSON(): IRange;
}

/**
 * A single edit operation, that acts as a simple replace.
 * i.e. Replace text at `range` with `text` in model.
 */
interface ISingleEditOperation {
    /**
     * The range to replace. This can be empty to emulate a simple insert.
     */
    range: IRange;
    /**
     * The text to replace with. This can be null to emulate a simple delete.
     */
    text: string | null;
    /**
     * This indicates that this operation has "insert" semantics.
     * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
     */
    forceMoveMarkers?: boolean;
}

/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
interface ISelection {
    /**
     * The line number on which the selection has started.
     */
    readonly selectionStartLineNumber: number;
    /**
     * The column on `selectionStartLineNumber` where the selection has started.
     */
    readonly selectionStartColumn: number;
    /**
     * The line number on which the selection has ended.
     */
    readonly positionLineNumber: number;
    /**
     * The column on `positionLineNumber` where the selection has ended.
     */
    readonly positionColumn: number;
}
/**
 * The direction of a selection.
 */
declare const enum SelectionDirection {
    /**
     * The selection starts above where it ends.
     */
    LTR = 0,
    /**
     * The selection starts below where it ends.
     */
    RTL = 1
}
/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
declare class Selection extends Range {
    /**
     * The line number on which the selection has started.
     */
    readonly selectionStartLineNumber: number;
    /**
     * The column on `selectionStartLineNumber` where the selection has started.
     */
    readonly selectionStartColumn: number;
    /**
     * The line number on which the selection has ended.
     */
    readonly positionLineNumber: number;
    /**
     * The column on `positionLineNumber` where the selection has ended.
     */
    readonly positionColumn: number;
    constructor(selectionStartLineNumber: number, selectionStartColumn: number, positionLineNumber: number, positionColumn: number);
    /**
     * Transform to a human-readable representation.
     */
    toString(): string;
    /**
     * Test if equals other selection.
     */
    equalsSelection(other: ISelection): boolean;
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a: ISelection, b: ISelection): boolean;
    /**
     * Get directions (LTR or RTL).
     */
    getDirection(): SelectionDirection;
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber: number, endColumn: number): Selection;
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition(): Position$1;
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart(): Position$1;
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber: number, startColumn: number): Selection;
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start: IPosition, end?: IPosition): Selection;
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range: Range, direction: SelectionDirection): Selection;
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel: ISelection): Selection;
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a: ISelection[], b: ISelection[]): boolean;
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj: any): obj is ISelection;
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, direction: SelectionDirection): Selection;
}

declare class TextChange {
    readonly oldPosition: number;
    readonly oldText: string;
    readonly newPosition: number;
    readonly newText: string;
    get oldLength(): number;
    get oldEnd(): number;
    get newLength(): number;
    get newEnd(): number;
    constructor(oldPosition: number, oldText: string, newPosition: number, newText: string);
    toString(): string;
    private static _writeStringSize;
    private static _writeString;
    private static _readString;
    writeSize(): number;
    write(b: Uint8Array, offset: number): number;
    static read(b: Uint8Array, offset: number, dest: TextChange[]): number;
}

/**
 * A fast character classifier that uses a compact array for ASCII values.
 */
declare class CharacterClassifier<T extends number> {
    /**
     * Maintain a compact (fully initialized ASCII map for quickly classifying ASCII characters - used more often in code).
     */
    protected readonly _asciiMap: Uint8Array;
    /**
     * The entire map (sparse array).
     */
    protected readonly _map: Map<number, number>;
    protected readonly _defaultValue: number;
    constructor(_defaultValue: T);
    private static _createAsciiMap;
    set(charCode: number, _value: T): void;
    get(charCode: number): T;
    clear(): void;
}

declare const enum WordCharacterClass {
    Regular = 0,
    Whitespace = 1,
    WordSeparator = 2
}
declare class WordCharacterClassifier extends CharacterClassifier<WordCharacterClass> {
    constructor(wordSeparators: string);
}

declare class RGBA {
    _rgbaBrand: void;
    /**
     * Red: integer in [0-255]
     */
    readonly r: number;
    /**
     * Green: integer in [0-255]
     */
    readonly g: number;
    /**
     * Blue: integer in [0-255]
     */
    readonly b: number;
    /**
     * Alpha: float in [0-1]
     */
    readonly a: number;
    constructor(r: number, g: number, b: number, a?: number);
    static equals(a: RGBA, b: RGBA): boolean;
}
declare class HSLA {
    _hslaBrand: void;
    /**
     * Hue: integer in [0, 360]
     */
    readonly h: number;
    /**
     * Saturation: float in [0, 1]
     */
    readonly s: number;
    /**
     * Luminosity: float in [0, 1]
     */
    readonly l: number;
    /**
     * Alpha: float in [0, 1]
     */
    readonly a: number;
    constructor(h: number, s: number, l: number, a: number);
    static equals(a: HSLA, b: HSLA): boolean;
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h in the set [0, 360], s, and l in the set [0, 1].
     */
    static fromRGBA(rgba: RGBA): HSLA;
    private static _hue2rgb;
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     */
    static toRGBA(hsla: HSLA): RGBA;
}
declare class HSVA {
    _hsvaBrand: void;
    /**
     * Hue: integer in [0, 360]
     */
    readonly h: number;
    /**
     * Saturation: float in [0, 1]
     */
    readonly s: number;
    /**
     * Value: float in [0, 1]
     */
    readonly v: number;
    /**
     * Alpha: float in [0, 1]
     */
    readonly a: number;
    constructor(h: number, s: number, v: number, a: number);
    static equals(a: HSVA, b: HSVA): boolean;
    static fromRGBA(rgba: RGBA): HSVA;
    static toRGBA(hsva: HSVA): RGBA;
}
declare class Color {
    static fromHex(hex: string): Color;
    static equals(a: Color | null, b: Color | null): boolean;
    readonly rgba: RGBA;
    private _hsla?;
    get hsla(): HSLA;
    private _hsva?;
    get hsva(): HSVA;
    constructor(arg: RGBA | HSLA | HSVA);
    equals(other: Color | null): boolean;
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    getRelativeLuminance(): number;
    private static _relativeLuminanceForComponent;
    /**
     * http://www.w3.org/TR/WCAG20/#contrast-ratiodef
     * Returns the contrast ration number in the set [1, 21].
     */
    getContrastRatio(another: Color): number;
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if darker color otherwise 'false'
     */
    isDarker(): boolean;
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    isLighter(): boolean;
    isLighterThan(another: Color): boolean;
    isDarkerThan(another: Color): boolean;
    lighten(factor: number): Color;
    darken(factor: number): Color;
    transparent(factor: number): Color;
    isTransparent(): boolean;
    isOpaque(): boolean;
    opposite(): Color;
    blend(c: Color): Color;
    makeOpaque(opaqueBackground: Color): Color;
    flatten(...backgrounds: Color[]): Color;
    private static _flatten;
    private _toString?;
    toString(): string;
    static getLighterColor(of: Color, relative: Color, factor?: number): Color;
    static getDarkerColor(of: Color, relative: Color, factor?: number): Color;
    static readonly white: Color;
    static readonly black: Color;
    static readonly red: Color;
    static readonly blue: Color;
    static readonly green: Color;
    static readonly cyan: Color;
    static readonly lightgrey: Color;
    static readonly transparent: Color;
}
declare namespace Color {
    namespace Format {
        namespace CSS {
            function formatRGB(color: Color): string;
            function formatRGBA(color: Color): string;
            function formatHSL(color: Color): string;
            function formatHSLA(color: Color): string;
            /**
             * Formats the color as #RRGGBB
             */
            function formatHex(color: Color): string;
            /**
             * Formats the color as #RRGGBBAA
             * If 'compact' is set, colors without transparancy will be printed as #RRGGBB
             */
            function formatHexA(color: Color, compact?: boolean): string;
            /**
             * The default format will use HEX if opaque and RGBA otherwise.
             */
            function format(color: Color): string;
            /**
             * Converts an Hex color value to a Color.
             * returns r, g, and b are contained in the set [0, 255]
             * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).
             */
            function parseHex(hex: string): Color | null;
        }
    }
}

interface IDataTransferFile {
    readonly name: string;
    readonly uri?: URI;
    data(): Promise<Uint8Array>;
}
interface IDataTransferItem {
    readonly id: string;
    asString(): Thenable<string>;
    asFile(): IDataTransferFile | undefined;
    value: any;
}
declare class VSDataTransfer {
    private readonly _entries;
    get size(): number;
    has(mimeType: string): boolean;
    get(mimeType: string): IDataTransferItem | undefined;
    append(mimeType: string, value: IDataTransferItem): void;
    replace(mimeType: string, value: IDataTransferItem): void;
    delete(mimeType: string): void;
    entries(): Iterable<[string, IDataTransferItem]>;
    values(): Iterable<IDataTransferItem>;
    forEach(f: (value: IDataTransferItem, key: string) => void): void;
    private toKey;
}

/**
 * Open ended enum at runtime
 */
declare const enum LanguageId {
    Null = 0,
    PlainText = 1
}
/**
 * Open ended enum at runtime
 */
declare const enum ColorId {
    None = 0,
    DefaultForeground = 1,
    DefaultBackground = 2
}
/**
 * A standard token type.
 */
declare const enum StandardTokenType {
    Other = 0,
    Comment = 1,
    String = 2,
    RegEx = 3
}
/**
 */
interface ITokenPresentation {
    foreground: ColorId;
    italic: boolean;
    bold: boolean;
    underline: boolean;
    strikethrough: boolean;
}

/**
 *
 */
interface IRelatedInformation {
    resource: URI;
    message: string;
    startLineNumber: number;
    startColumn: number;
    endLineNumber: number;
    endColumn: number;
}
declare const enum MarkerTag {
    Unnecessary = 1,
    Deprecated = 2
}
declare enum MarkerSeverity {
    Hint = 1,
    Info = 2,
    Warning = 4,
    Error = 8
}
declare namespace MarkerSeverity {
    function compare(a: MarkerSeverity, b: MarkerSeverity): number;
    function toString(a: MarkerSeverity): string;
    function fromSeverity(severity: Severity$1): MarkerSeverity;
    function toSeverity(severity: MarkerSeverity): Severity$1;
}
interface IResourceMarker {
    resource: URI;
    marker: IMarkerData;
}
interface IMarker {
    owner: string;
    resource: URI;
    severity: MarkerSeverity;
    code?: string | {
        value: string;
        target: URI;
    };
    message: string;
    source?: string;
    startLineNumber: number;
    startColumn: number;
    endLineNumber: number;
    endColumn: number;
    modelVersionId?: number;
    relatedInformation?: IRelatedInformation[];
    tags?: MarkerTag[];
}
interface MarkerStatistics {
    errors: number;
    warnings: number;
    infos: number;
    unknowns: number;
}
/**
 * A structure defining a problem/warning/etc.
 */
interface IMarkerData {
    code?: string | {
        value: string;
        target: URI;
    };
    severity: MarkerSeverity;
    message: string;
    source?: string;
    startLineNumber: number;
    startColumn: number;
    endLineNumber: number;
    endColumn: number;
    modelVersionId?: number;
    relatedInformation?: IRelatedInformation[];
    tags?: MarkerTag[];
}
declare namespace IMarkerData {
    function makeKey(markerData: IMarkerData): string;
    function makeKeyOptionalMessage(markerData: IMarkerData, useMessage: boolean): string;
}
interface IMarkerService {
    readonly _serviceBrand: undefined;
    getStatistics(): MarkerStatistics;
    changeOne(owner: string, resource: URI, markers: IMarkerData[]): void;
    changeAll(owner: string, data: IResourceMarker[]): void;
    remove(owner: string, resources: URI[]): void;
    read(filter?: {
        owner?: string;
        resource?: URI;
        severities?: number;
        take?: number;
    }): IMarker[];
    readonly onMarkerChanged: Event$1<readonly URI[]>;
}
declare const IMarkerService: ServiceIdentifier<IMarkerService>;

/**
 * @internal
 */
interface ILanguageIdCodec {
    encodeLanguageId(languageId: string): LanguageId;
    decodeLanguageId(languageId: LanguageId): string;
}
/**
 * A provider result represents the values a provider, like the {@link HoverProvider},
 * may return. For once this is the actual result type `T`, like `Hover`, or a thenable that resolves
 * to that type `T`. In addition, `null` and `undefined` can be returned - either directly or from a
 * thenable.
 */
type ProviderResult<T> = T | undefined | null | Thenable<T | undefined | null>;
/**
 * A hover represents additional information for a symbol or word. Hovers are
 * rendered in a tooltip-like widget.
 */
interface Hover {
    /**
     * The contents of this hover.
     */
    contents: IMarkdownString[];
    /**
     * The range to which this hover applies. When missing, the
     * editor will use the range at the current position or the
     * current position itself.
     */
    range?: IRange;
}
/**
 * The hover provider interface defines the contract between extensions and
 * the [hover](https://code.visualstudio.com/docs/editor/intellisense)-feature.
 */
interface HoverProvider {
    /**
     * Provide a hover for the given position and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideHover(model: ITextModel, position: Position$1, token: CancellationToken): ProviderResult<Hover>;
}
/**
 * An evaluatable expression represents additional information for an expression in a document. Evaluatable expressions are
 * evaluated by a debugger or runtime and their result is rendered in a tooltip-like widget.
 * @internal
 */
interface EvaluatableExpression {
    /**
     * The range to which this expression applies.
     */
    range: IRange;
    /**
     * This expression overrides the expression extracted from the range.
     */
    expression?: string;
}
/**
 * The evaluatable expression provider interface defines the contract between extensions and
 * the debug hover.
 * @internal
 */
interface EvaluatableExpressionProvider {
    /**
     * Provide a hover for the given position and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideEvaluatableExpression(model: ITextModel, position: Position$1, token: CancellationToken): ProviderResult<EvaluatableExpression>;
}
/**
 * A value-object that contains contextual information when requesting inline values from a InlineValuesProvider.
 * @internal
 */
interface InlineValueContext {
    frameId: number;
    stoppedLocation: Range;
}
/**
 * Provide inline value as text.
 * @internal
 */
interface InlineValueText {
    type: 'text';
    range: IRange;
    text: string;
}
/**
 * Provide inline value through a variable lookup.
 * @internal
 */
interface InlineValueVariableLookup {
    type: 'variable';
    range: IRange;
    variableName?: string;
    caseSensitiveLookup: boolean;
}
/**
 * Provide inline value through an expression evaluation.
 * @internal
 */
interface InlineValueExpression {
    type: 'expression';
    range: IRange;
    expression?: string;
}
/**
 * Inline value information can be provided by different means:
 * - directly as a text value (class InlineValueText).
 * - as a name to use for a variable lookup (class InlineValueVariableLookup)
 * - as an evaluatable expression (class InlineValueEvaluatableExpression)
 * The InlineValue types combines all inline value types into one type.
 * @internal
 */
type InlineValue = InlineValueText | InlineValueVariableLookup | InlineValueExpression;
/**
 * The inline values provider interface defines the contract between extensions and
 * the debugger's inline values feature.
 * @internal
 */
interface InlineValuesProvider {
    /**
     */
    onDidChangeInlineValues?: Event$1<void> | undefined;
    /**
     * Provide the "inline values" for the given range and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideInlineValues(model: ITextModel, viewPort: Range, context: InlineValueContext, token: CancellationToken): ProviderResult<InlineValue[]>;
}
declare const enum CompletionItemKind {
    Method = 0,
    Function = 1,
    Constructor = 2,
    Field = 3,
    Variable = 4,
    Class = 5,
    Struct = 6,
    Interface = 7,
    Module = 8,
    Property = 9,
    Event = 10,
    Operator = 11,
    Unit = 12,
    Value = 13,
    Constant = 14,
    Enum = 15,
    EnumMember = 16,
    Keyword = 17,
    Text = 18,
    Color = 19,
    File = 20,
    Reference = 21,
    Customcolor = 22,
    Folder = 23,
    TypeParameter = 24,
    User = 25,
    Issue = 26,
    Snippet = 27
}
interface CompletionItemLabel {
    label: string;
    detail?: string;
    description?: string;
}
declare const enum CompletionItemTag {
    Deprecated = 1
}
declare const enum CompletionItemInsertTextRule {
    None = 0,
    /**
     * Adjust whitespace/indentation of multiline insert texts to
     * match the current line indentation.
     */
    KeepWhitespace = 1,
    /**
     * `insertText` is a snippet.
     */
    InsertAsSnippet = 4
}
interface CompletionItemRanges {
    insert: IRange;
    replace: IRange;
}
/**
 * A completion item represents a text snippet that is
 * proposed to complete text that is being typed.
 */
interface CompletionItem {
    /**
     * The label of this completion item. By default
     * this is also the text that is inserted when selecting
     * this completion.
     */
    label: string | CompletionItemLabel;
    /**
     * The kind of this completion item. Based on the kind
     * an icon is chosen by the editor.
     */
    kind: CompletionItemKind;
    /**
     * A modifier to the `kind` which affect how the item
     * is rendered, e.g. Deprecated is rendered with a strikeout
     */
    tags?: ReadonlyArray<CompletionItemTag>;
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string;
    /**
     * A human-readable string that represents a doc-comment.
     */
    documentation?: string | IMarkdownString;
    /**
     * A string that should be used when comparing this item
     * with other items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    sortText?: string;
    /**
     * A string that should be used when filtering a set of
     * completion items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    filterText?: string;
    /**
     * Select this item when showing. *Note* that only one completion item can be selected and
     * that the editor decides which item that is. The rule is that the *first* item of those
     * that match best is selected.
     */
    preselect?: boolean;
    /**
     * A string or snippet that should be inserted in a document when selecting
     * this completion.
     */
    insertText: string;
    /**
     * Additional rules (as bitmask) that should be applied when inserting
     * this completion.
     */
    insertTextRules?: CompletionItemInsertTextRule;
    /**
     * A range of text that should be replaced by this completion item.
     *
     * Defaults to a range from the start of the {@link TextDocument.getWordRangeAtPosition current word} to the
     * current position.
     *
     * *Note:* The range must be a {@link Range.isSingleLine single line} and it must
     * {@link Range.contains contain} the position at which completion has been {@link CompletionItemProvider.provideCompletionItems requested}.
     */
    range: IRange | CompletionItemRanges;
    /**
     * An optional set of characters that when pressed while this completion is active will accept it first and
     * then type that character. *Note* that all commit characters should have `length=1` and that superfluous
     * characters will be ignored.
     */
    commitCharacters?: string[];
    /**
     * An optional array of additional text edits that are applied when
     * selecting this completion. Edits must not overlap with the main edit
     * nor with themselves.
     */
    additionalTextEdits?: ISingleEditOperation[];
    /**
     * A command that should be run upon acceptance of this item.
     */
    command?: Command;
    /**
     * @internal
     */
    extensionId?: ExtensionIdentifier;
    /**
     * @internal
     */
    _id?: [number, number];
}
interface CompletionList {
    suggestions: CompletionItem[];
    incomplete?: boolean;
    dispose?(): void;
    /**
     * @internal
     */
    duration?: number;
}
/**
 * How a suggest provider was triggered.
 */
declare const enum CompletionTriggerKind {
    Invoke = 0,
    TriggerCharacter = 1,
    TriggerForIncompleteCompletions = 2
}
/**
 * Contains additional information about the context in which
 * {@link CompletionItemProvider.provideCompletionItems completion provider} is triggered.
 */
interface CompletionContext {
    /**
     * How the completion was triggered.
     */
    triggerKind: CompletionTriggerKind;
    /**
     * Character that triggered the completion item provider.
     *
     * `undefined` if provider was not triggered by a character.
     */
    triggerCharacter?: string;
}
/**
 * The completion item provider interface defines the contract between extensions and
 * the [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense).
 *
 * When computing *complete* completion items is expensive, providers can optionally implement
 * the `resolveCompletionItem`-function. In that case it is enough to return completion
 * items with a {@link CompletionItem.label label} from the
 * {@link CompletionItemProvider.provideCompletionItems provideCompletionItems}-function. Subsequently,
 * when a completion item is shown in the UI and gains focus this provider is asked to resolve
 * the item, like adding {@link CompletionItem.documentation doc-comment} or {@link CompletionItem.detail details}.
 */
interface CompletionItemProvider {
    /**
     * @internal
     */
    _debugDisplayName?: string;
    triggerCharacters?: string[];
    /**
     * Provide completion items for the given position and document.
     */
    provideCompletionItems(model: ITextModel, position: Position$1, context: CompletionContext, token: CancellationToken): ProviderResult<CompletionList>;
    /**
     * Given a completion item fill in more data, like {@link CompletionItem.documentation doc-comment}
     * or {@link CompletionItem.detail details}.
     *
     * The editor will only resolve a completion item once.
     */
    resolveCompletionItem?(item: CompletionItem, token: CancellationToken): ProviderResult<CompletionItem>;
}
/**
 * How an {@link InlineCompletionsProvider inline completion provider} was triggered.
 */
declare enum InlineCompletionTriggerKind {
    /**
     * Completion was triggered automatically while editing.
     * It is sufficient to return a single completion item in this case.
     */
    Automatic = 0,
    /**
     * Completion was triggered explicitly by a user gesture.
     * Return multiple completion items to enable cycling through them.
     */
    Explicit = 1
}
interface InlineCompletionContext {
    /**
     * How the completion was triggered.
     */
    readonly triggerKind: InlineCompletionTriggerKind;
    readonly selectedSuggestionInfo: SelectedSuggestionInfo | undefined;
}
interface SelectedSuggestionInfo {
    range: IRange;
    text: string;
    isSnippetText: boolean;
    completionKind: CompletionItemKind;
}
interface InlineCompletion {
    /**
     * The text to insert.
     * If the text contains a line break, the range must end at the end of a line.
     * If existing text should be replaced, the existing text must be a prefix of the text to insert.
     *
     * The text can also be a snippet. In that case, a preview with default parameters is shown.
     * When accepting the suggestion, the full snippet is inserted.
    */
    readonly insertText: string | {
        snippet: string;
    };
    /**
     * A text that is used to decide if this inline completion should be shown.
     * An inline completion is shown if the text to replace is a subword of the filter text.
     */
    readonly filterText?: string;
    /**
     * An optional array of additional text edits that are applied when
     * selecting this completion. Edits must not overlap with the main edit
     * nor with themselves.
     */
    readonly additionalTextEdits?: ISingleEditOperation[];
    /**
     * The range to replace.
     * Must begin and end on the same line.
    */
    readonly range?: IRange;
    readonly command?: Command;
    /**
     * If set to `true`, unopened closing brackets are removed and unclosed opening brackets are closed.
     * Defaults to `false`.
    */
    readonly completeBracketPairs?: boolean;
}
interface InlineCompletions<TItem extends InlineCompletion = InlineCompletion> {
    readonly items: readonly TItem[];
    /**
     * A list of commands associated with the inline completions of this list.
     */
    readonly commands?: Command[];
}
interface InlineCompletionsProvider<T extends InlineCompletions = InlineCompletions> {
    provideInlineCompletions(model: ITextModel, position: Position$1, context: InlineCompletionContext, token: CancellationToken): ProviderResult<T>;
    /**
     * Will be called when an item is shown.
    */
    handleItemDidShow?(completions: T, item: T['items'][number]): void;
    /**
     * Will be called when an item is partially accepted.
     */
    handlePartialAccept?(completions: T, item: T['items'][number], acceptedCharacters: number): void;
    /**
     * Will be called when a completions list is no longer in use and can be garbage-collected.
    */
    freeInlineCompletions(completions: T): void;
}
interface CodeAction {
    title: string;
    command?: Command;
    edit?: WorkspaceEdit;
    diagnostics?: IMarkerData[];
    kind?: string;
    isPreferred?: boolean;
    disabled?: string;
}
declare const enum CodeActionTriggerType {
    Invoke = 1,
    Auto = 2
}
/**
 * @internal
 */
interface CodeActionContext {
    only?: string;
    trigger: CodeActionTriggerType;
}
interface CodeActionList extends IDisposable {
    readonly actions: ReadonlyArray<CodeAction>;
}
/**
 * The code action interface defines the contract between extensions and
 * the [light bulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature.
 * @internal
 */
interface CodeActionProvider {
    displayName?: string;
    /**
     * Provide commands for the given document and range.
     */
    provideCodeActions(model: ITextModel, range: Range | Selection, context: CodeActionContext, token: CancellationToken): ProviderResult<CodeActionList>;
    /**
     * Given a code action fill in the edit. Will only invoked when missing.
     */
    resolveCodeAction?(codeAction: CodeAction, token: CancellationToken): ProviderResult<CodeAction>;
    /**
     * Optional list of CodeActionKinds that this provider returns.
     */
    readonly providedCodeActionKinds?: ReadonlyArray<string>;
    readonly documentation?: ReadonlyArray<{
        readonly kind: string;
        readonly command: Command;
    }>;
    /**
     * @internal
     */
    _getAdditionalMenuItems?(context: CodeActionContext, actions: readonly CodeAction[]): Command[];
}
/**
 * @internal
 */
interface DocumentPasteEdit {
    insertText: string | {
        snippet: string;
    };
    additionalEdit?: WorkspaceEdit;
}
/**
 * @internal
 */
interface DocumentPasteEditProvider {
    readonly pasteMimeTypes: readonly string[];
    prepareDocumentPaste?(model: ITextModel, ranges: readonly IRange[], dataTransfer: VSDataTransfer, token: CancellationToken): Promise<undefined | VSDataTransfer>;
    provideDocumentPasteEdits(model: ITextModel, ranges: readonly IRange[], dataTransfer: VSDataTransfer, token: CancellationToken): Promise<DocumentPasteEdit | undefined>;
}
/**
 * Represents a parameter of a callable-signature. A parameter can
 * have a label and a doc-comment.
 */
interface ParameterInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string | [number, number];
    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | IMarkdownString;
}
/**
 * Represents the signature of something callable. A signature
 * can have a label, like a function-name, a doc-comment, and
 * a set of parameters.
 */
interface SignatureInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string;
    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | IMarkdownString;
    /**
     * The parameters of this signature.
     */
    parameters: ParameterInformation[];
    /**
     * Index of the active parameter.
     *
     * If provided, this is used in place of `SignatureHelp.activeSignature`.
     */
    activeParameter?: number;
}
/**
 * Signature help represents the signature of something
 * callable. There can be multiple signatures but only one
 * active and only one active parameter.
 */
interface SignatureHelp {
    /**
     * One or more signatures.
     */
    signatures: SignatureInformation[];
    /**
     * The active signature.
     */
    activeSignature: number;
    /**
     * The active parameter of the active signature.
     */
    activeParameter: number;
}
interface SignatureHelpResult extends IDisposable {
    value: SignatureHelp;
}
declare enum SignatureHelpTriggerKind {
    Invoke = 1,
    TriggerCharacter = 2,
    ContentChange = 3
}
interface SignatureHelpContext {
    readonly triggerKind: SignatureHelpTriggerKind;
    readonly triggerCharacter?: string;
    readonly isRetrigger: boolean;
    readonly activeSignatureHelp?: SignatureHelp;
}
/**
 * The signature help provider interface defines the contract between extensions and
 * the [parameter hints](https://code.visualstudio.com/docs/editor/intellisense)-feature.
 */
interface SignatureHelpProvider {
    readonly signatureHelpTriggerCharacters?: ReadonlyArray<string>;
    readonly signatureHelpRetriggerCharacters?: ReadonlyArray<string>;
    /**
     * Provide help for the signature at the given position and document.
     */
    provideSignatureHelp(model: ITextModel, position: Position$1, token: CancellationToken, context: SignatureHelpContext): ProviderResult<SignatureHelpResult>;
}
/**
 * A document highlight kind.
 */
declare enum DocumentHighlightKind {
    /**
     * A textual occurrence.
     */
    Text = 0,
    /**
     * Read-access of a symbol, like reading a variable.
     */
    Read = 1,
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    Write = 2
}
/**
 * A document highlight is a range inside a text document which deserves
 * special attention. Usually a document highlight is visualized by changing
 * the background color of its range.
 */
interface DocumentHighlight {
    /**
     * The range this highlight applies to.
     */
    range: IRange;
    /**
     * The highlight kind, default is {@link DocumentHighlightKind.Text text}.
     */
    kind?: DocumentHighlightKind;
}
/**
 * The document highlight provider interface defines the contract between extensions and
 * the word-highlight-feature.
 */
interface DocumentHighlightProvider {
    /**
     * Provide a set of document highlights, like all occurrences of a variable or
     * all exit-points of a function.
     */
    provideDocumentHighlights(model: ITextModel, position: Position$1, token: CancellationToken): ProviderResult<DocumentHighlight[]>;
}
/**
 * The linked editing range provider interface defines the contract between extensions and
 * the linked editing feature.
 */
interface LinkedEditingRangeProvider {
    /**
     * Provide a list of ranges that can be edited together.
     */
    provideLinkedEditingRanges(model: ITextModel, position: Position$1, token: CancellationToken): ProviderResult<LinkedEditingRanges>;
}
/**
 * Represents a list of ranges that can be edited together along with a word pattern to describe valid contents.
 */
interface LinkedEditingRanges {
    /**
     * A list of ranges that can be edited together. The ranges must have
     * identical length and text content. The ranges cannot overlap
     */
    ranges: IRange[];
    /**
     * An optional word pattern that describes valid contents for the given ranges.
     * If no pattern is provided, the language configuration's word pattern will be used.
     */
    wordPattern?: RegExp;
}
/**
 * Value-object that contains additional information when
 * requesting references.
 */
interface ReferenceContext {
    /**
     * Include the declaration of the current symbol.
     */
    includeDeclaration: boolean;
}
/**
 * The reference provider interface defines the contract between extensions and
 * the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.
 */
interface ReferenceProvider {
    /**
     * Provide a set of project-wide references for the given position and document.
     */
    provideReferences(model: ITextModel, position: Position$1, context: ReferenceContext, token: CancellationToken): ProviderResult<Location[]>;
}
/**
 * Represents a location inside a resource, such as a line
 * inside a text file.
 */
interface Location {
    /**
     * The resource identifier of this location.
     */
    uri: URI;
    /**
     * The document range of this locations.
     */
    range: IRange;
}
interface LocationLink {
    /**
     * A range to select where this link originates from.
     */
    originSelectionRange?: IRange;
    /**
     * The target uri this link points to.
     */
    uri: URI;
    /**
     * The full range this link points to.
     */
    range: IRange;
    /**
     * A range to select this link points to. Must be contained
     * in `LocationLink.range`.
     */
    targetSelectionRange?: IRange;
}
type Definition = Location | Location[] | LocationLink[];
/**
 * The definition provider interface defines the contract between extensions and
 * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
 * and peek definition features.
 */
interface DefinitionProvider {
    /**
     * Provide the definition of the symbol at the given position and document.
     */
    provideDefinition(model: ITextModel, position: Position$1, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * The definition provider interface defines the contract between extensions and
 * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
 * and peek definition features.
 */
interface DeclarationProvider {
    /**
     * Provide the declaration of the symbol at the given position and document.
     */
    provideDeclaration(model: ITextModel, position: Position$1, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * The implementation provider interface defines the contract between extensions and
 * the go to implementation feature.
 */
interface ImplementationProvider {
    /**
     * Provide the implementation of the symbol at the given position and document.
     */
    provideImplementation(model: ITextModel, position: Position$1, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * The type definition provider interface defines the contract between extensions and
 * the go to type definition feature.
 */
interface TypeDefinitionProvider {
    /**
     * Provide the type definition of the symbol at the given position and document.
     */
    provideTypeDefinition(model: ITextModel, position: Position$1, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * A symbol kind.
 */
declare const enum SymbolKind {
    File = 0,
    Module = 1,
    Namespace = 2,
    Package = 3,
    Class = 4,
    Method = 5,
    Property = 6,
    Field = 7,
    Constructor = 8,
    Enum = 9,
    Interface = 10,
    Function = 11,
    Variable = 12,
    Constant = 13,
    String = 14,
    Number = 15,
    Boolean = 16,
    Array = 17,
    Object = 18,
    Key = 19,
    Null = 20,
    EnumMember = 21,
    Struct = 22,
    Event = 23,
    Operator = 24,
    TypeParameter = 25
}
declare const enum SymbolTag {
    Deprecated = 1
}
interface DocumentSymbol {
    name: string;
    detail: string;
    kind: SymbolKind;
    tags: ReadonlyArray<SymbolTag>;
    containerName?: string;
    range: IRange;
    selectionRange: IRange;
    children?: DocumentSymbol[];
}
/**
 * The document symbol provider interface defines the contract between extensions and
 * the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.
 */
interface DocumentSymbolProvider {
    displayName?: string;
    /**
     * Provide symbol information for the given document.
     */
    provideDocumentSymbols(model: ITextModel, token: CancellationToken): ProviderResult<DocumentSymbol[]>;
}
interface TextEdit {
    range: IRange;
    text: string;
    eol?: EndOfLineSequence;
}
/**
 * Interface used to format a model
 */
interface FormattingOptions {
    /**
     * Size of a tab in spaces.
     */
    tabSize: number;
    /**
     * Prefer spaces over tabs.
     */
    insertSpaces: boolean;
}
/**
 * The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.
 */
interface DocumentFormattingEditProvider {
    /**
     * @internal
     */
    readonly extensionId?: ExtensionIdentifier;
    readonly displayName?: string;
    /**
     * Provide formatting edits for a whole document.
     */
    provideDocumentFormattingEdits(model: ITextModel, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
}
/**
 * The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.
 */
interface DocumentRangeFormattingEditProvider {
    /**
     * @internal
     */
    readonly extensionId?: ExtensionIdentifier;
    readonly displayName?: string;
    /**
     * Provide formatting edits for a range in a document.
     *
     * The given range is a hint and providers can decide to format a smaller
     * or larger range. Often this is done by adjusting the start and end
     * of the range to full syntax nodes.
     */
    provideDocumentRangeFormattingEdits(model: ITextModel, range: Range, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
}
/**
 * The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.
 */
interface OnTypeFormattingEditProvider {
    /**
     * @internal
     */
    readonly extensionId?: ExtensionIdentifier;
    autoFormatTriggerCharacters: string[];
    /**
     * Provide formatting edits after a character has been typed.
     *
     * The given position and character should hint to the provider
     * what range the position to expand to, like find the matching `{`
     * when `}` has been entered.
     */
    provideOnTypeFormattingEdits(model: ITextModel, position: Position$1, ch: string, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
}
/**
 * @internal
 */
interface IInplaceReplaceSupportResult {
    value: string;
    range: IRange;
}
/**
 * A link inside the editor.
 */
interface ILink {
    range: IRange;
    url?: URI | string;
    tooltip?: string;
}
interface ILinksList {
    links: ILink[];
    dispose?(): void;
}
/**
 * A provider of links.
 */
interface LinkProvider {
    provideLinks(model: ITextModel, token: CancellationToken): ProviderResult<ILinksList>;
    resolveLink?: (link: ILink, token: CancellationToken) => ProviderResult<ILink>;
}
/**
 * A color in RGBA format.
 */
interface IColor {
    /**
     * The red component in the range [0-1].
     */
    readonly red: number;
    /**
     * The green component in the range [0-1].
     */
    readonly green: number;
    /**
     * The blue component in the range [0-1].
     */
    readonly blue: number;
    /**
     * The alpha component in the range [0-1].
     */
    readonly alpha: number;
}
/**
 * String representations for a color
 */
interface IColorPresentation {
    /**
     * The label of this color presentation. It will be shown on the color
     * picker header. By default this is also the text that is inserted when selecting
     * this color presentation.
     */
    label: string;
    /**
     * An {@link TextEdit edit} which is applied to a document when selecting
     * this presentation for the color.
     */
    textEdit?: TextEdit;
    /**
     * An optional array of additional {@link TextEdit text edits} that are applied when
     * selecting this color presentation.
     */
    additionalTextEdits?: TextEdit[];
}
/**
 * A color range is a range in a text model which represents a color.
 */
interface IColorInformation {
    /**
     * The range within the model.
     */
    range: IRange;
    /**
     * The color represented in this range.
     */
    color: IColor;
}
/**
 * A provider of colors for editor models.
 */
interface DocumentColorProvider {
    /**
     * Provides the color ranges for a specific model.
     */
    provideDocumentColors(model: ITextModel, token: CancellationToken): ProviderResult<IColorInformation[]>;
    /**
     * Provide the string representations for a color.
     */
    provideColorPresentations(model: ITextModel, colorInfo: IColorInformation, token: CancellationToken): ProviderResult<IColorPresentation[]>;
}
interface SelectionRange {
    range: IRange;
}
interface SelectionRangeProvider {
    /**
     * Provide ranges that should be selected from the given position.
     */
    provideSelectionRanges(model: ITextModel, positions: Position$1[], token: CancellationToken): ProviderResult<SelectionRange[][]>;
}
interface FoldingContext {
}
/**
 * A provider of folding ranges for editor models.
 */
interface FoldingRangeProvider {
    /**
     * @internal
     */
    readonly id?: string;
    /**
     * An optional event to signal that the folding ranges from this provider have changed.
     */
    onDidChange?: Event$1<this>;
    /**
     * Provides the folding ranges for a specific model.
     */
    provideFoldingRanges(model: ITextModel, context: FoldingContext, token: CancellationToken): ProviderResult<FoldingRange[]>;
}
interface FoldingRange {
    /**
     * The one-based start line of the range to fold. The folded area starts after the line's last character.
     */
    start: number;
    /**
     * The one-based end line of the range to fold. The folded area ends with the line's last character.
     */
    end: number;
    /**
     * Describes the {@link FoldingRangeKind Kind} of the folding range such as {@link FoldingRangeKind.Comment Comment} or
     * {@link FoldingRangeKind.Region Region}. The kind is used to categorize folding ranges and used by commands
     * like 'Fold all comments'. See
     * {@link FoldingRangeKind} for an enumeration of standardized kinds.
     */
    kind?: FoldingRangeKind;
}
declare class FoldingRangeKind {
    value: string;
    /**
     * Kind for folding range representing a comment. The value of the kind is 'comment'.
     */
    static readonly Comment: FoldingRangeKind;
    /**
     * Kind for folding range representing a import. The value of the kind is 'imports'.
     */
    static readonly Imports: FoldingRangeKind;
    /**
     * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
     * The value of the kind is 'region'.
     */
    static readonly Region: FoldingRangeKind;
    /**
     * Returns a {@link FoldingRangeKind} for the given value.
     *
     * @param value of the kind.
     */
    static fromValue(value: string): FoldingRangeKind;
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value: string);
}
interface WorkspaceEditMetadata {
    needsConfirmation: boolean;
    label: string;
    description?: string;
    /**
     * @internal
     */
    iconPath?: ThemeIcon | URI | {
        light: URI;
        dark: URI;
    };
}
interface WorkspaceFileEditOptions {
    overwrite?: boolean;
    ignoreIfNotExists?: boolean;
    ignoreIfExists?: boolean;
    recursive?: boolean;
    copy?: boolean;
    folder?: boolean;
    skipTrashBin?: boolean;
    maxSize?: number;
    contentsBase64?: string;
}
interface IWorkspaceFileEdit {
    oldResource?: URI;
    newResource?: URI;
    options?: WorkspaceFileEditOptions;
    metadata?: WorkspaceEditMetadata;
}
interface IWorkspaceTextEdit {
    resource: URI;
    textEdit: TextEdit & {
        insertAsSnippet?: boolean;
    };
    versionId: number | undefined;
    metadata?: WorkspaceEditMetadata;
}
interface WorkspaceEdit {
    edits: Array<IWorkspaceTextEdit | IWorkspaceFileEdit>;
}
interface Rejection {
    rejectReason?: string;
}
interface RenameLocation {
    range: IRange;
    text: string;
}
interface RenameProvider {
    provideRenameEdits(model: ITextModel, position: Position$1, newName: string, token: CancellationToken): ProviderResult<WorkspaceEdit & Rejection>;
    resolveRenameLocation?(model: ITextModel, position: Position$1, token: CancellationToken): ProviderResult<RenameLocation & Rejection>;
}
interface Command {
    id: string;
    title: string;
    tooltip?: string;
    arguments?: any[];
}
/**
 * @internal
 */
declare namespace Command {
    /**
     * @internal
     */
    function is(obj: any): obj is Command;
}
interface CodeLens {
    range: IRange;
    id?: string;
    command?: Command;
}
interface CodeLensList {
    lenses: CodeLens[];
    dispose(): void;
}
interface CodeLensProvider {
    onDidChange?: Event$1<this>;
    provideCodeLenses(model: ITextModel, token: CancellationToken): ProviderResult<CodeLensList>;
    resolveCodeLens?(model: ITextModel, codeLens: CodeLens, token: CancellationToken): ProviderResult<CodeLens>;
}
declare enum InlayHintKind {
    Type = 1,
    Parameter = 2
}
interface InlayHintLabelPart {
    label: string;
    tooltip?: string | IMarkdownString;
    command?: Command;
    location?: Location;
}
interface InlayHint {
    label: string | InlayHintLabelPart[];
    tooltip?: string | IMarkdownString;
    textEdits?: TextEdit[];
    position: IPosition;
    kind?: InlayHintKind;
    paddingLeft?: boolean;
    paddingRight?: boolean;
}
interface InlayHintList {
    hints: InlayHint[];
    dispose(): void;
}
interface InlayHintsProvider {
    displayName?: string;
    onDidChangeInlayHints?: Event$1<void>;
    provideInlayHints(model: ITextModel, range: Range, token: CancellationToken): ProviderResult<InlayHintList>;
    resolveInlayHint?(hint: InlayHint, token: CancellationToken): ProviderResult<InlayHint>;
}
interface SemanticTokensLegend {
    readonly tokenTypes: string[];
    readonly tokenModifiers: string[];
}
interface SemanticTokens {
    readonly resultId?: string;
    readonly data: Uint32Array;
}
interface SemanticTokensEdit {
    readonly start: number;
    readonly deleteCount: number;
    readonly data?: Uint32Array;
}
interface SemanticTokensEdits {
    readonly resultId?: string;
    readonly edits: SemanticTokensEdit[];
}
interface DocumentSemanticTokensProvider {
    onDidChange?: Event$1<void>;
    getLegend(): SemanticTokensLegend;
    provideDocumentSemanticTokens(model: ITextModel, lastResultId: string | null, token: CancellationToken): ProviderResult<SemanticTokens | SemanticTokensEdits>;
    releaseDocumentSemanticTokens(resultId: string | undefined): void;
}
interface DocumentRangeSemanticTokensProvider {
    getLegend(): SemanticTokensLegend;
    provideDocumentRangeSemanticTokens(model: ITextModel, range: Range, token: CancellationToken): ProviderResult<SemanticTokens>;
}
/**
 * @internal
 */
interface DocumentOnDropEdit {
    insertText: string | {
        snippet: string;
    };
    additionalEdit?: WorkspaceEdit;
}
/**
 * @internal
 */
interface DocumentOnDropEditProvider {
    provideDocumentOnDropEdits(model: ITextModel, position: IPosition, dataTransfer: VSDataTransfer, token: CancellationToken): ProviderResult<DocumentOnDropEdit>;
}

interface IViewLineTokens {
    equals(other: IViewLineTokens): boolean;
    getCount(): number;
    getForeground(tokenIndex: number): ColorId;
    getEndOffset(tokenIndex: number): number;
    getClassName(tokenIndex: number): string;
    getInlineStyle(tokenIndex: number, colorMap: string[]): string;
    getPresentation(tokenIndex: number): ITokenPresentation;
    findTokenIndexAtOffset(offset: number): number;
    getLineContent(): string;
    getMetadata(tokenIndex: number): number;
    getLanguageId(tokenIndex: number): string;
}
declare class LineTokens implements IViewLineTokens {
    _lineTokensBrand: void;
    private readonly _tokens;
    private readonly _tokensCount;
    private readonly _text;
    private readonly _languageIdCodec;
    static defaultTokenMetadata: number;
    static createEmpty(lineContent: string, decoder: ILanguageIdCodec): LineTokens;
    constructor(tokens: Uint32Array, text: string, decoder: ILanguageIdCodec);
    equals(other: IViewLineTokens): boolean;
    slicedEquals(other: LineTokens, sliceFromTokenIndex: number, sliceTokenCount: number): boolean;
    getLineContent(): string;
    getCount(): number;
    getStartOffset(tokenIndex: number): number;
    getMetadata(tokenIndex: number): number;
    getLanguageId(tokenIndex: number): string;
    getStandardTokenType(tokenIndex: number): StandardTokenType;
    getForeground(tokenIndex: number): ColorId;
    getClassName(tokenIndex: number): string;
    getInlineStyle(tokenIndex: number, colorMap: string[]): string;
    getPresentation(tokenIndex: number): ITokenPresentation;
    getEndOffset(tokenIndex: number): number;
    /**
     * Find the token containing offset `offset`.
     * @param offset The search offset
     * @return The index of the token containing the offset.
     */
    findTokenIndexAtOffset(offset: number): number;
    inflate(): IViewLineTokens;
    sliceAndInflate(startOffset: number, endOffset: number, deltaOffset: number): IViewLineTokens;
    static convertToEndOffset(tokens: Uint32Array, lineTextLength: number): void;
    static findIndexInTokensArray(tokens: Uint32Array, desiredIndex: number): number;
    /**
     * @pure
     * @param insertTokens Must be sorted by offset.
    */
    withInserted(insertTokens: {
        offset: number;
        text: string;
        tokenMetadata: number;
    }[]): LineTokens;
}

declare class ScopedLineTokens {
    _scopedLineTokensBrand: void;
    readonly languageId: string;
    private readonly _actual;
    private readonly _firstTokenIndex;
    private readonly _lastTokenIndex;
    readonly firstCharOffset: number;
    private readonly _lastCharOffset;
    constructor(actual: LineTokens, languageId: string, firstTokenIndex: number, lastTokenIndex: number, firstCharOffset: number, lastCharOffset: number);
    getLineContent(): string;
    getActualLineContentBefore(offset: number): string;
    getTokenCount(): number;
    findTokenIndexAtOffset(offset: number): number;
    getStandardTokenType(tokenIndex: number): StandardTokenType;
}

/**
 * Describes how comments for a language work.
 */
interface CommentRule {
    /**
     * The line comment token, like `// this is a comment`
     */
    lineComment?: string | null;
    /**
     * The block comment character pair, like `/* block comment *&#47;`
     */
    blockComment?: CharacterPair | null;
}
/**
 * The language configuration interface defines the contract between extensions and
 * various editor features, like automatic bracket insertion, automatic indentation etc.
 */
interface LanguageConfiguration {
    /**
     * The language's comment settings.
     */
    comments?: CommentRule;
    /**
     * The language's brackets.
     * This configuration implicitly affects pressing Enter around these brackets.
     */
    brackets?: CharacterPair[];
    /**
     * The language's word definition.
     * If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
     * to provide a word definition that uses exclusion of known separators.
     * e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
     *   /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
     */
    wordPattern?: RegExp;
    /**
     * The language's indentation settings.
     */
    indentationRules?: IndentationRule;
    /**
     * The language's rules to be evaluated when pressing Enter.
     */
    onEnterRules?: OnEnterRule[];
    /**
     * The language's auto closing pairs. The 'close' character is automatically inserted with the
     * 'open' character is typed. If not set, the configured brackets will be used.
     */
    autoClosingPairs?: IAutoClosingPairConditional[];
    /**
     * The language's surrounding pairs. When the 'open' character is typed on a selection, the
     * selected string is surrounded by the open and close characters. If not set, the autoclosing pairs
     * settings will be used.
     */
    surroundingPairs?: IAutoClosingPair[];
    /**
     * Defines a list of bracket pairs that are colorized depending on their nesting level.
     * If not set, the configured brackets will be used.
    */
    colorizedBracketPairs?: CharacterPair[];
    /**
     * Defines what characters must be after the cursor for bracket or quote autoclosing to occur when using the \'languageDefined\' autoclosing setting.
     *
     * This is typically the set of characters which can not start an expression, such as whitespace, closing brackets, non-unary operators, etc.
     */
    autoCloseBefore?: string;
    /**
     * The language's folding rules.
     */
    folding?: FoldingRules;
    /**
     * **Deprecated** Do not use.
     *
     * @deprecated Will be replaced by a better API soon.
     */
    __electricCharacterSupport?: {
        docComment?: IDocComment;
    };
}
/**
 * Describes indentation rules for a language.
 */
interface IndentationRule {
    /**
     * If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).
     */
    decreaseIndentPattern: RegExp;
    /**
     * If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).
     */
    increaseIndentPattern: RegExp;
    /**
     * If a line matches this pattern, then **only the next line** after it should be indented once.
     */
    indentNextLinePattern?: RegExp | null;
    /**
     * If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.
     */
    unIndentedLinePattern?: RegExp | null;
}
/**
 * Describes language specific folding markers such as '#region' and '#endregion'.
 * The start and end regexes will be tested against the contents of all lines and must be designed efficiently:
 * - the regex should start with '^'
 * - regexp flags (i, g) are ignored
 */
interface FoldingMarkers {
    start: RegExp;
    end: RegExp;
}
/**
 * Describes folding rules for a language.
 */
interface FoldingRules {
    /**
     * Used by the indentation based strategy to decide whether empty lines belong to the previous or the next block.
     * A language adheres to the off-side rule if blocks in that language are expressed by their indentation.
     * See [wikipedia](https://en.wikipedia.org/wiki/Off-side_rule) for more information.
     * If not set, `false` is used and empty lines belong to the previous block.
     */
    offSide?: boolean;
    /**
     * Region markers used by the language.
     */
    markers?: FoldingMarkers;
}
/**
 * Describes a rule to be evaluated when pressing Enter.
 */
interface OnEnterRule {
    /**
     * This rule will only execute if the text before the cursor matches this regular expression.
     */
    beforeText: RegExp;
    /**
     * This rule will only execute if the text after the cursor matches this regular expression.
     */
    afterText?: RegExp;
    /**
     * This rule will only execute if the text above the this line matches this regular expression.
     */
    previousLineText?: RegExp;
    /**
     * The action to execute.
     */
    action: EnterAction;
}
/**
 * Definition of documentation comments (e.g. Javadoc/JSdoc)
 */
interface IDocComment {
    /**
     * The string that starts a doc comment (e.g. '/**')
     */
    open: string;
    /**
     * The string that appears on the last line and closes the doc comment (e.g. ' * /').
     */
    close?: string;
}
/**
 * A tuple of two characters, like a pair of
 * opening and closing brackets.
 */
type CharacterPair = [string, string];
interface IAutoClosingPair {
    open: string;
    close: string;
}
interface IAutoClosingPairConditional extends IAutoClosingPair {
    notIn?: string[];
}
/**
 * Describes what to do with the indentation when pressing Enter.
 */
declare enum IndentAction {
    /**
     * Insert new line and copy the previous line's indentation.
     */
    None = 0,
    /**
     * Insert new line and indent once (relative to the previous line's indentation).
     */
    Indent = 1,
    /**
     * Insert two new lines:
     *  - the first one indented which will hold the cursor
     *  - the second one at the same indentation level
     */
    IndentOutdent = 2,
    /**
     * Insert new line and outdent once (relative to the previous line's indentation).
     */
    Outdent = 3
}
/**
 * Describes what to do when pressing Enter.
 */
interface EnterAction {
    /**
     * Describe what to do with the indentation.
     */
    indentAction: IndentAction;
    /**
     * Describes text to be appended after the new line and after the indentation.
     */
    appendText?: string;
    /**
     * Describes the number of characters to remove from the new line's indentation.
     */
    removeText?: number;
}
/**
 * @internal
 */
declare class StandardAutoClosingPairConditional {
    readonly open: string;
    readonly close: string;
    private readonly _inString;
    private readonly _inComment;
    private readonly _inRegEx;
    private _neutralCharacter;
    private _neutralCharacterSearched;
    constructor(source: IAutoClosingPairConditional);
    isOK(standardToken: StandardTokenType): boolean;
    shouldAutoClose(context: ScopedLineTokens, column: number): boolean;
    private _findNeutralCharacterInRange;
    /**
     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
     */
    findNeutralCharacter(): string | null;
}
/**
 * @internal
 */
declare class AutoClosingPairs {
    /** Key is first character of open */
    readonly autoClosingPairsOpenByStart: Map<string, StandardAutoClosingPairConditional[]>;
    /** Key is last character of open */
    readonly autoClosingPairsOpenByEnd: Map<string, StandardAutoClosingPairConditional[]>;
    /** Key is first character of close */
    readonly autoClosingPairsCloseByStart: Map<string, StandardAutoClosingPairConditional[]>;
    /** Key is last character of close */
    readonly autoClosingPairsCloseByEnd: Map<string, StandardAutoClosingPairConditional[]>;
    /** Key is close. Only has pairs that are a single character */
    readonly autoClosingPairsCloseSingleChar: Map<string, StandardAutoClosingPairConditional[]>;
    constructor(autoClosingPairs: StandardAutoClosingPairConditional[]);
}

/**
 * Captures all bracket related configurations for a single language.
 * Immutable.
*/
declare class LanguageBracketsConfiguration {
    readonly languageId: string;
    private readonly _openingBrackets;
    private readonly _closingBrackets;
    constructor(languageId: string, config: LanguageConfiguration);
    /**
     * No two brackets have the same bracket text.
    */
    get openingBrackets(): readonly OpeningBracketKind[];
    /**
     * No two brackets have the same bracket text.
    */
    get closingBrackets(): readonly ClosingBracketKind[];
    getOpeningBracketInfo(bracketText: string): OpeningBracketKind | undefined;
    getClosingBracketInfo(bracketText: string): ClosingBracketKind | undefined;
    getBracketInfo(bracketText: string): BracketKind | undefined;
}
type BracketKind = OpeningBracketKind | ClosingBracketKind;
declare class BracketKindBase {
    protected readonly config: LanguageBracketsConfiguration;
    readonly bracketText: string;
    constructor(config: LanguageBracketsConfiguration, bracketText: string);
    get languageId(): string;
}
declare class OpeningBracketKind extends BracketKindBase {
    readonly openedBrackets: ReadonlySet<ClosingBracketKind>;
    readonly isOpeningBracket = true;
    constructor(config: LanguageBracketsConfiguration, bracketText: string, openedBrackets: ReadonlySet<ClosingBracketKind>);
}
declare class ClosingBracketKind extends BracketKindBase {
    /**
     * Non empty array of all opening brackets this bracket closes.
    */
    readonly openingBrackets: ReadonlySet<OpeningBracketKind>;
    private readonly openingColorizedBrackets;
    readonly isOpeningBracket = false;
    constructor(config: LanguageBracketsConfiguration, bracketText: string, 
    /**
     * Non empty array of all opening brackets this bracket closes.
    */
    openingBrackets: ReadonlySet<OpeningBracketKind>, openingColorizedBrackets: ReadonlySet<OpeningBracketKind>);
    /**
     * Checks if this bracket closes the given other bracket.
     * If the bracket infos come from different configurations, this method will return false.
    */
    closes(other: OpeningBracketKind): boolean;
    closesColorized(other: OpeningBracketKind): boolean;
    getOpeningBrackets(): readonly OpeningBracketKind[];
}

declare class CharacterPairSupport {
    static readonly DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ";:.,=}])> \n\t";
    static readonly DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = "'\"`;:.,=}])> \n\t";
    static readonly DEFAULT_AUTOCLOSE_BEFORE_WHITESPACE = " \n\t";
    private readonly _autoClosingPairs;
    private readonly _surroundingPairs;
    private readonly _autoCloseBeforeForQuotes;
    private readonly _autoCloseBeforeForBrackets;
    constructor(config: LanguageConfiguration);
    getAutoClosingPairs(): StandardAutoClosingPairConditional[];
    getAutoCloseBeforeSet(forQuotes: boolean): string;
    getSurroundingPairs(): IAutoClosingPair[];
}

/**
 * Represents a grouping of colliding bracket pairs.
 *
 * Most of the times this contains a single bracket pair,
 * but sometimes this contains multiple bracket pairs in cases
 * where the same string appears as a closing bracket for multiple
 * bracket pairs, or the same string appears an opening bracket for
 * multiple bracket pairs.
 *
 * e.g. of a group containing a single pair:
 *   open: ['{'], close: ['}']
 *
 * e.g. of a group containing multiple pairs:
 *   open: ['if', 'for'], close: ['end', 'end']
 */
declare class RichEditBracket {
    _richEditBracketBrand: void;
    readonly languageId: string;
    /**
     * A 0-based consecutive unique identifier for this bracket pair.
     * If a language has 5 bracket pairs, out of which 2 are grouped together,
     * it is expected that the `index` goes from 0 to 4.
     */
    readonly index: number;
    /**
     * The open sequence for each bracket pair contained in this group.
     *
     * The open sequence at a specific index corresponds to the
     * closing sequence at the same index.
     *
     * [ open[i], closed[i] ] represent a bracket pair.
     */
    readonly open: string[];
    /**
     * The close sequence for each bracket pair contained in this group.
     *
     * The close sequence at a specific index corresponds to the
     * opening sequence at the same index.
     *
     * [ open[i], closed[i] ] represent a bracket pair.
     */
    readonly close: string[];
    /**
     * A regular expression that is useful to search for this bracket pair group in a string.
     *
     * This regular expression is built in a way that it is aware of the other bracket
     * pairs defined for the language, so it might match brackets from other groups.
     *
     * See the fine details in `getRegexForBracketPair`.
     */
    readonly forwardRegex: RegExp;
    /**
     * A regular expression that is useful to search for this bracket pair group in a string backwards.
     *
     * This regular expression is built in a way that it is aware of the other bracket
     * pairs defined for the language, so it might match brackets from other groups.
     *
     * See the fine defails in `getReversedRegexForBracketPair`.
     */
    readonly reversedRegex: RegExp;
    private readonly _openSet;
    private readonly _closeSet;
    constructor(languageId: string, index: number, open: string[], close: string[], forwardRegex: RegExp, reversedRegex: RegExp);
    /**
     * Check if the provided `text` is an open bracket in this group.
     */
    isOpen(text: string): boolean;
    /**
     * Check if the provided `text` is a close bracket in this group.
     */
    isClose(text: string): boolean;
    private static _toSet;
}
declare class RichEditBrackets {
    _richEditBracketsBrand: void;
    /**
     * All groups of brackets defined for this language.
     */
    readonly brackets: RichEditBracket[];
    /**
     * A regular expression that is useful to search for all bracket pairs in a string.
     *
     * See the fine details in `getRegexForBrackets`.
     */
    readonly forwardRegex: RegExp;
    /**
     * A regular expression that is useful to search for all bracket pairs in a string backwards.
     *
     * See the fine details in `getReversedRegexForBrackets`.
     */
    readonly reversedRegex: RegExp;
    /**
     * The length (i.e. str.length) for the longest bracket pair.
     */
    readonly maxBracketLength: number;
    /**
     * A map useful for decoding a regex match and finding which bracket group was matched.
     */
    readonly textIsBracket: {
        [text: string]: RichEditBracket;
    };
    /**
     * A set useful for decoding if a regex match is the open bracket of a bracket pair.
     */
    readonly textIsOpenBracket: {
        [text: string]: boolean;
    };
    constructor(languageId: string, _brackets: readonly CharacterPair[]);
}

/**
 * Interface used to support electric characters
 * @internal
 */
interface IElectricAction {
    matchOpenBracket: string;
}
declare class BracketElectricCharacterSupport {
    private readonly _richEditBrackets;
    constructor(richEditBrackets: RichEditBrackets | null);
    getElectricCharacters(): string[];
    onElectricCharacter(character: string, context: ScopedLineTokens, column: number): IElectricAction | null;
}

declare class IndentRulesSupport {
    private readonly _indentationRules;
    constructor(indentationRules: IndentationRule);
    shouldIncrease(text: string): boolean;
    shouldDecrease(text: string): boolean;
    shouldIndentNextLine(text: string): boolean;
    shouldIgnore(text: string): boolean;
    getIndentMetadata(text: string): number;
}

interface IAccessibilityInformation {
    label: string;
    role?: string;
}

/**
 * An interface for a JavaScript object that
 * acts a dictionary. The keys are strings.
 */
type IStringDictionary<V> = Record<string, V>;

type JSONSchemaType = 'string' | 'number' | 'integer' | 'boolean' | 'null' | 'array' | 'object';
interface IJSONSchema {
    id?: string;
    $id?: string;
    $schema?: string;
    type?: JSONSchemaType | JSONSchemaType[];
    title?: string;
    default?: any;
    definitions?: IJSONSchemaMap;
    description?: string;
    properties?: IJSONSchemaMap;
    patternProperties?: IJSONSchemaMap;
    additionalProperties?: boolean | IJSONSchema;
    minProperties?: number;
    maxProperties?: number;
    dependencies?: IJSONSchemaMap | {
        [prop: string]: string[];
    };
    items?: IJSONSchema | IJSONSchema[];
    minItems?: number;
    maxItems?: number;
    uniqueItems?: boolean;
    additionalItems?: boolean | IJSONSchema;
    pattern?: string;
    minLength?: number;
    maxLength?: number;
    minimum?: number;
    maximum?: number;
    exclusiveMinimum?: boolean | number;
    exclusiveMaximum?: boolean | number;
    multipleOf?: number;
    required?: string[];
    $ref?: string;
    anyOf?: IJSONSchema[];
    allOf?: IJSONSchema[];
    oneOf?: IJSONSchema[];
    not?: IJSONSchema;
    enum?: any[];
    format?: string;
    const?: any;
    contains?: IJSONSchema;
    propertyNames?: IJSONSchema;
    examples?: any[];
    $comment?: string;
    if?: IJSONSchema;
    then?: IJSONSchema;
    else?: IJSONSchema;
    unevaluatedProperties?: boolean | IJSONSchema;
    unevaluatedItems?: boolean | IJSONSchema;
    minContains?: number;
    maxContains?: number;
    deprecated?: boolean;
    dependentRequired?: {
        [prop: string]: string[];
    };
    dependentSchemas?: IJSONSchemaMap;
    $defs?: {
        [name: string]: IJSONSchema;
    };
    $anchor?: string;
    $recursiveRef?: string;
    $recursiveAnchor?: string;
    $vocabulary?: any;
    prefixItems?: IJSONSchema[];
    $dynamicRef?: string;
    $dynamicAnchor?: string;
    defaultSnippets?: IJSONSchemaSnippet[];
    errorMessage?: string;
    patternErrorMessage?: string;
    deprecationMessage?: string;
    markdownDeprecationMessage?: string;
    enumDescriptions?: string[];
    markdownEnumDescriptions?: string[];
    markdownDescription?: string;
    doNotSuggest?: boolean;
    suggestSortText?: string;
    allowComments?: boolean;
    allowTrailingCommas?: boolean;
}
interface IJSONSchemaMap {
    [name: string]: IJSONSchema;
}
interface IJSONSchemaSnippet {
    label?: string;
    description?: string;
    body?: any;
    bodyText?: string;
}

/**
 * Maps a line range in the original text model to a line range in the modified text model.
 */
declare class LineRangeMapping {
    /**
     * The line range in the original text model.
     */
    readonly originalRange: LineRange;
    /**
     * The line range in the modified text model.
     */
    readonly modifiedRange: LineRange;
    /**
     * If inner changes have not been computed, this is set to undefined.
     * Otherwise, it represents the character-level diff in this line range.
     * The original range of each range mapping should be contained in the original line range (same for modified).
     * Must not be an empty array.
     */
    readonly innerChanges: RangeMapping[] | undefined;
    constructor(originalRange: LineRange, modifiedRange: LineRange, innerChanges: RangeMapping[] | undefined);
    toString(): string;
}
/**
 * Maps a range in the original text model to a range in the modified text model.
 */
declare class RangeMapping {
    /**
     * The original range.
     */
    readonly originalRange: Range;
    /**
     * The modified range.
     */
    readonly modifiedRange: Range;
    constructor(originalRange: Range, modifiedRange: Range);
    toString(): string;
}
/**
 * A range of lines (1-based).
 */
declare class LineRange {
    /**
     * The start line number.
     */
    readonly startLineNumber: number;
    /**
     * The end line number (exclusive).
     */
    readonly endLineNumberExclusive: number;
    constructor(startLineNumber: number, endLineNumberExclusive: number);
    /**
     * Indicates if this line range is empty.
     */
    get isEmpty(): boolean;
    /**
     * Moves this line range by the given offset of line numbers.
     */
    delta(offset: number): LineRange;
    /**
     * The number of lines this line range spans.
     */
    get length(): number;
    /**
     * Creates a line range that combines this and the given line range.
     */
    join(other: LineRange): LineRange;
    toString(): string;
}

/**
 * A document diff provider computes the diff between two text models.
 */
interface IDocumentDiffProvider {
    /**
     * Computes the diff between the text models `original` and `modified`.
     */
    computeDiff(original: ITextModel, modified: ITextModel, options: IDocumentDiffProviderOptions): Promise<IDocumentDiff>;
    /**
     * Is fired when settings of the diff algorithm change that could alter the result of the diffing computation.
     * Any user of this provider should recompute the diff when this event is fired.
     */
    onDidChange: Event$1<void>;
}
/**
 * Options for the diff computation.
 */
interface IDocumentDiffProviderOptions {
    /**
     * When set to true, the diff should ignore whitespace changes.i
     */
    ignoreTrimWhitespace: boolean;
    /**
     * A diff computation should throw if it takes longer than this value.
     */
    maxComputationTimeMs: number;
}
/**
 * Represents a diff between two text models.
 */
interface IDocumentDiff {
    /**
     * If true, both text models are identical (byte-wise).
     */
    readonly identical: boolean;
    /**
     * If true, the diff computation timed out and the diff might not be accurate.
     */
    readonly quitEarly: boolean;
    /**
     * Maps all modified line ranges in the original to the corresponding line ranges in the modified text model.
     */
    readonly changes: LineRangeMapping[];
}

/**
 * Configuration options for auto closing quotes and brackets
 */
type EditorAutoClosingStrategy = 'always' | 'languageDefined' | 'beforeWhitespace' | 'never';
/**
 * Configuration options for auto wrapping quotes and brackets
 */
type EditorAutoSurroundStrategy = 'languageDefined' | 'quotes' | 'brackets' | 'never';
/**
 * Configuration options for typing over closing quotes or brackets
 */
type EditorAutoClosingEditStrategy = 'always' | 'auto' | 'never';
/**
 * Configuration options for auto indentation in the editor
 */
declare const enum EditorAutoIndentStrategy {
    None = 0,
    Keep = 1,
    Brackets = 2,
    Advanced = 3,
    Full = 4
}
/**
 * Configuration options for the editor.
 */
interface IEditorOptions$1 {
    /**
     * This editor is used inside a diff editor.
     */
    inDiffEditor?: boolean;
    /**
     * The aria label for the editor's textarea (when it is focused).
     */
    ariaLabel?: string;
    /**
     * The `tabindex` property of the editor's textarea
     */
    tabIndex?: number;
    /**
     * Render vertical lines at the specified columns.
     * Defaults to empty array.
     */
    rulers?: (number | IRulerOption)[];
    /**
     * A string containing the word separators used when doing word navigation.
     * Defaults to `~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?
     */
    wordSeparators?: string;
    /**
     * Enable Linux primary clipboard.
     * Defaults to true.
     */
    selectionClipboard?: boolean;
    /**
     * Control the rendering of line numbers.
     * If it is a function, it will be invoked when rendering a line number and the return value will be rendered.
     * Otherwise, if it is a truthy, line numbers will be rendered normally (equivalent of using an identity function).
     * Otherwise, line numbers will not be rendered.
     * Defaults to `on`.
     */
    lineNumbers?: LineNumbersType;
    /**
     * Controls the minimal number of visible leading and trailing lines surrounding the cursor.
     * Defaults to 0.
    */
    cursorSurroundingLines?: number;
    /**
     * Controls when `cursorSurroundingLines` should be enforced
     * Defaults to `default`, `cursorSurroundingLines` is not enforced when cursor position is changed
     * by mouse.
    */
    cursorSurroundingLinesStyle?: 'default' | 'all';
    /**
     * Render last line number when the file ends with a newline.
     * Defaults to 'on' for Windows and macOS and 'dimmed' for Linux.
    */
    renderFinalNewline?: 'on' | 'off' | 'dimmed';
    /**
     * Remove unusual line terminators like LINE SEPARATOR (LS), PARAGRAPH SEPARATOR (PS).
     * Defaults to 'prompt'.
     */
    unusualLineTerminators?: 'auto' | 'off' | 'prompt';
    /**
     * Should the corresponding line be selected when clicking on the line number?
     * Defaults to true.
     */
    selectOnLineNumbers?: boolean;
    /**
     * Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.
     * Defaults to 5.
     */
    lineNumbersMinChars?: number;
    /**
     * Enable the rendering of the glyph margin.
     * Defaults to true in vscode and to false in monaco-editor.
     */
    glyphMargin?: boolean;
    /**
     * The width reserved for line decorations (in px).
     * Line decorations are placed between line numbers and the editor content.
     * You can pass in a string in the format floating point followed by "ch". e.g. 1.3ch.
     * Defaults to 10.
     */
    lineDecorationsWidth?: number | string;
    /**
     * When revealing the cursor, a virtual padding (px) is added to the cursor, turning it into a rectangle.
     * This virtual padding ensures that the cursor gets revealed before hitting the edge of the viewport.
     * Defaults to 30 (px).
     */
    revealHorizontalRightPadding?: number;
    /**
     * Render the editor selection with rounded borders.
     * Defaults to true.
     */
    roundedSelection?: boolean;
    /**
     * Class name to be added to the editor.
     */
    extraEditorClassName?: string;
    /**
     * Should the editor be read only. See also `domReadOnly`.
     * Defaults to false.
     */
    readOnly?: boolean;
    /**
     * Should the textarea used for input use the DOM `readonly` attribute.
     * Defaults to false.
     */
    domReadOnly?: boolean;
    /**
     * Enable linked editing.
     * Defaults to false.
     */
    linkedEditing?: boolean;
    /**
     * deprecated, use linkedEditing instead
     */
    renameOnType?: boolean;
    /**
     * Should the editor render validation decorations.
     * Defaults to editable.
     */
    renderValidationDecorations?: 'editable' | 'on' | 'off';
    /**
     * Control the behavior and rendering of the scrollbars.
     */
    scrollbar?: IEditorScrollbarOptions;
    /**
     * Control the behavior of sticky scroll options
     */
    stickyScroll?: IEditorStickyScrollOptions;
    /**
     * Control the behavior and rendering of the minimap.
     */
    minimap?: IEditorMinimapOptions;
    /**
     * Control the behavior of the find widget.
     */
    find?: IEditorFindOptions;
    /**
     * Display overflow widgets as `fixed`.
     * Defaults to `false`.
     */
    fixedOverflowWidgets?: boolean;
    /**
     * The number of vertical lanes the overview ruler should render.
     * Defaults to 3.
     */
    overviewRulerLanes?: number;
    /**
     * Controls if a border should be drawn around the overview ruler.
     * Defaults to `true`.
     */
    overviewRulerBorder?: boolean;
    /**
     * Control the cursor animation style, possible values are 'blink', 'smooth', 'phase', 'expand' and 'solid'.
     * Defaults to 'blink'.
     */
    cursorBlinking?: 'blink' | 'smooth' | 'phase' | 'expand' | 'solid';
    /**
     * Zoom the font in the editor when using the mouse wheel in combination with holding Ctrl.
     * Defaults to false.
     */
    mouseWheelZoom?: boolean;
    /**
     * Control the mouse pointer style, either 'text' or 'default' or 'copy'
     * Defaults to 'text'
     */
    mouseStyle?: 'text' | 'default' | 'copy';
    /**
     * Enable smooth caret animation.
     * Defaults to 'off'.
     */
    cursorSmoothCaretAnimation?: 'off' | 'explicit' | 'on';
    /**
     * Control the cursor style, either 'block' or 'line'.
     * Defaults to 'line'.
     */
    cursorStyle?: 'line' | 'block' | 'underline' | 'line-thin' | 'block-outline' | 'underline-thin';
    /**
     * Control the width of the cursor when cursorStyle is set to 'line'
     */
    cursorWidth?: number;
    /**
     * Enable font ligatures.
     * Defaults to false.
     */
    fontLigatures?: boolean | string;
    /**
     * Enable font variations.
     * Defaults to false.
     */
    fontVariations?: boolean | string;
    /**
     * Disable the use of `transform: translate3d(0px, 0px, 0px)` for the editor margin and lines layers.
     * The usage of `transform: translate3d(0px, 0px, 0px)` acts as a hint for browsers to create an extra layer.
     * Defaults to false.
     */
    disableLayerHinting?: boolean;
    /**
     * Disable the optimizations for monospace fonts.
     * Defaults to false.
     */
    disableMonospaceOptimizations?: boolean;
    /**
     * Should the cursor be hidden in the overview ruler.
     * Defaults to false.
     */
    hideCursorInOverviewRuler?: boolean;
    /**
     * Enable that scrolling can go one screen size after the last line.
     * Defaults to true.
     */
    scrollBeyondLastLine?: boolean;
    /**
     * Enable that scrolling can go beyond the last column by a number of columns.
     * Defaults to 5.
     */
    scrollBeyondLastColumn?: number;
    /**
     * Enable that the editor animates scrolling to a position.
     * Defaults to false.
     */
    smoothScrolling?: boolean;
    /**
     * Enable that the editor will install a ResizeObserver to check if its container dom node size has changed.
     * Defaults to false.
     */
    automaticLayout?: boolean;
    /**
     * Control the wrapping of the editor.
     * When `wordWrap` = "off", the lines will never wrap.
     * When `wordWrap` = "on", the lines will wrap at the viewport width.
     * When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
     * When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
     * Defaults to "off".
     */
    wordWrap?: 'off' | 'on' | 'wordWrapColumn' | 'bounded';
    /**
     * Override the `wordWrap` setting.
     */
    wordWrapOverride1?: 'off' | 'on' | 'inherit';
    /**
     * Override the `wordWrapOverride1` setting.
     */
    wordWrapOverride2?: 'off' | 'on' | 'inherit';
    /**
     * Control the wrapping of the editor.
     * When `wordWrap` = "off", the lines will never wrap.
     * When `wordWrap` = "on", the lines will wrap at the viewport width.
     * When `wordWrap` = "wordWrapColumn", the lines will wrap at `wordWrapColumn`.
     * When `wordWrap` = "bounded", the lines will wrap at min(viewport width, wordWrapColumn).
     * Defaults to 80.
     */
    wordWrapColumn?: number;
    /**
     * Control indentation of wrapped lines. Can be: 'none', 'same', 'indent' or 'deepIndent'.
     * Defaults to 'same' in vscode and to 'none' in monaco-editor.
     */
    wrappingIndent?: 'none' | 'same' | 'indent' | 'deepIndent';
    /**
     * Controls the wrapping strategy to use.
     * Defaults to 'simple'.
     */
    wrappingStrategy?: 'simple' | 'advanced';
    /**
     * Configure word wrapping characters. A break will be introduced before these characters.
     */
    wordWrapBreakBeforeCharacters?: string;
    /**
     * Configure word wrapping characters. A break will be introduced after these characters.
     */
    wordWrapBreakAfterCharacters?: string;
    /**
     * Sets whether line breaks appear wherever the text would otherwise overflow its content box.
     * When wordBreak = 'normal', Use the default line break rule.
     * When wordBreak = 'keepAll', Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.
     */
    wordBreak?: 'normal' | 'keepAll';
    /**
     * Performance guard: Stop rendering a line after x characters.
     * Defaults to 10000.
     * Use -1 to never stop rendering
     */
    stopRenderingLineAfter?: number;
    /**
     * Configure the editor's hover.
     */
    hover?: IEditorHoverOptions;
    /**
     * Enable detecting links and making them clickable.
     * Defaults to true.
     */
    links?: boolean;
    /**
     * Enable inline color decorators and color picker rendering.
     */
    colorDecorators?: boolean;
    /**
     * Controls the max number of color decorators that can be rendered in an editor at once.
     */
    colorDecoratorsLimit?: number;
    /**
     * Control the behaviour of comments in the editor.
     */
    comments?: IEditorCommentsOptions;
    /**
     * Enable custom contextmenu.
     * Defaults to true.
     */
    contextmenu?: boolean;
    /**
     * A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.
     * Defaults to 1.
     */
    mouseWheelScrollSensitivity?: number;
    /**
     * FastScrolling mulitplier speed when pressing `Alt`
     * Defaults to 5.
     */
    fastScrollSensitivity?: number;
    /**
     * Enable that the editor scrolls only the predominant axis. Prevents horizontal drift when scrolling vertically on a trackpad.
     * Defaults to true.
     */
    scrollPredominantAxis?: boolean;
    /**
     * Enable that the selection with the mouse and keys is doing column selection.
     * Defaults to false.
     */
    columnSelection?: boolean;
    /**
     * The modifier to be used to add multiple cursors with the mouse.
     * Defaults to 'alt'
     */
    multiCursorModifier?: 'ctrlCmd' | 'alt';
    /**
     * Merge overlapping selections.
     * Defaults to true
     */
    multiCursorMergeOverlapping?: boolean;
    /**
     * Configure the behaviour when pasting a text with the line count equal to the cursor count.
     * Defaults to 'spread'.
     */
    multiCursorPaste?: 'spread' | 'full';
    /**
     * Controls the max number of text cursors that can be in an active editor at once.
     */
    multiCursorLimit?: number;
    /**
     * Configure the editor's accessibility support.
     * Defaults to 'auto'. It is best to leave this to 'auto'.
     */
    accessibilitySupport?: 'auto' | 'off' | 'on';
    /**
     * Controls the number of lines in the editor that can be read out by a screen reader
     */
    accessibilityPageSize?: number;
    /**
     * Suggest options.
     */
    suggest?: ISuggestOptions;
    inlineSuggest?: IInlineSuggestOptions;
    /**
     * Smart select options.
     */
    smartSelect?: ISmartSelectOptions;
    /**
     *
     */
    gotoLocation?: IGotoLocationOptions;
    /**
     * Enable quick suggestions (shadow suggestions)
     * Defaults to true.
     */
    quickSuggestions?: boolean | IQuickSuggestionsOptions;
    /**
     * Quick suggestions show delay (in ms)
     * Defaults to 10 (ms)
     */
    quickSuggestionsDelay?: number;
    /**
     * Controls the spacing around the editor.
     */
    padding?: IEditorPaddingOptions;
    /**
     * Parameter hint options.
     */
    parameterHints?: IEditorParameterHintOptions;
    /**
     * Options for auto closing brackets.
     * Defaults to language defined behavior.
     */
    autoClosingBrackets?: EditorAutoClosingStrategy;
    /**
     * Options for auto closing quotes.
     * Defaults to language defined behavior.
     */
    autoClosingQuotes?: EditorAutoClosingStrategy;
    /**
     * Options for pressing backspace near quotes or bracket pairs.
     */
    autoClosingDelete?: EditorAutoClosingEditStrategy;
    /**
     * Options for typing over closing quotes or brackets.
     */
    autoClosingOvertype?: EditorAutoClosingEditStrategy;
    /**
     * Options for auto surrounding.
     * Defaults to always allowing auto surrounding.
     */
    autoSurround?: EditorAutoSurroundStrategy;
    /**
     * Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.
     * Defaults to advanced.
     */
    autoIndent?: 'none' | 'keep' | 'brackets' | 'advanced' | 'full';
    /**
     * Emulate selection behaviour of tab characters when using spaces for indentation.
     * This means selection will stick to tab stops.
     */
    stickyTabStops?: boolean;
    /**
     * Enable format on type.
     * Defaults to false.
     */
    formatOnType?: boolean;
    /**
     * Enable format on paste.
     * Defaults to false.
     */
    formatOnPaste?: boolean;
    /**
     * Controls if the editor should allow to move selections via drag and drop.
     * Defaults to false.
     */
    dragAndDrop?: boolean;
    /**
     * Enable the suggestion box to pop-up on trigger characters.
     * Defaults to true.
     */
    suggestOnTriggerCharacters?: boolean;
    /**
     * Accept suggestions on ENTER.
     * Defaults to 'on'.
     */
    acceptSuggestionOnEnter?: 'on' | 'smart' | 'off';
    /**
     * Accept suggestions on provider defined characters.
     * Defaults to true.
     */
    acceptSuggestionOnCommitCharacter?: boolean;
    /**
     * Enable snippet suggestions. Default to 'true'.
     */
    snippetSuggestions?: 'top' | 'bottom' | 'inline' | 'none';
    /**
     * Copying without a selection copies the current line.
     */
    emptySelectionClipboard?: boolean;
    /**
     * Syntax highlighting is copied.
     */
    copyWithSyntaxHighlighting?: boolean;
    /**
     * The history mode for suggestions.
     */
    suggestSelection?: 'first' | 'recentlyUsed' | 'recentlyUsedByPrefix';
    /**
     * The font size for the suggest widget.
     * Defaults to the editor font size.
     */
    suggestFontSize?: number;
    /**
     * The line height for the suggest widget.
     * Defaults to the editor line height.
     */
    suggestLineHeight?: number;
    /**
     * Enable tab completion.
     */
    tabCompletion?: 'on' | 'off' | 'onlySnippets';
    /**
     * Enable selection highlight.
     * Defaults to true.
     */
    selectionHighlight?: boolean;
    /**
     * Enable semantic occurrences highlight.
     * Defaults to true.
     */
    occurrencesHighlight?: boolean;
    /**
     * Show code lens
     * Defaults to true.
     */
    codeLens?: boolean;
    /**
     * Code lens font family. Defaults to editor font family.
     */
    codeLensFontFamily?: string;
    /**
     * Code lens font size. Default to 90% of the editor font size
     */
    codeLensFontSize?: number;
    /**
     * Control the behavior and rendering of the code action lightbulb.
     */
    lightbulb?: IEditorLightbulbOptions;
    /**
     * Timeout for running code actions on save.
     */
    codeActionsOnSaveTimeout?: number;
    /**
     * Enable code folding.
     * Defaults to true.
     */
    folding?: boolean;
    /**
     * Selects the folding strategy. 'auto' uses the strategies contributed for the current document, 'indentation' uses the indentation based folding strategy.
     * Defaults to 'auto'.
     */
    foldingStrategy?: 'auto' | 'indentation';
    /**
     * Enable highlight for folded regions.
     * Defaults to true.
     */
    foldingHighlight?: boolean;
    /**
     * Auto fold imports folding regions.
     * Defaults to true.
     */
    foldingImportsByDefault?: boolean;
    /**
     * Maximum number of foldable regions.
     * Defaults to 5000.
     */
    foldingMaximumRegions?: number;
    /**
     * Controls whether the fold actions in the gutter stay always visible or hide unless the mouse is over the gutter.
     * Defaults to 'mouseover'.
     */
    showFoldingControls?: 'always' | 'never' | 'mouseover';
    /**
     * Controls whether clicking on the empty content after a folded line will unfold the line.
     * Defaults to false.
     */
    unfoldOnClickAfterEndOfLine?: boolean;
    /**
     * Enable highlighting of matching brackets.
     * Defaults to 'always'.
     */
    matchBrackets?: 'never' | 'near' | 'always';
    /**
     * Enable experimental whitespace rendering.
     * Defaults to 'svg'.
     */
    experimentalWhitespaceRendering?: 'svg' | 'font' | 'off';
    /**
     * Enable rendering of whitespace.
     * Defaults to 'selection'.
     */
    renderWhitespace?: 'none' | 'boundary' | 'selection' | 'trailing' | 'all';
    /**
     * Enable rendering of control characters.
     * Defaults to true.
     */
    renderControlCharacters?: boolean;
    /**
     * Enable rendering of current line highlight.
     * Defaults to all.
     */
    renderLineHighlight?: 'none' | 'gutter' | 'line' | 'all';
    /**
     * Control if the current line highlight should be rendered only the editor is focused.
     * Defaults to false.
     */
    renderLineHighlightOnlyWhenFocus?: boolean;
    /**
     * Inserting and deleting whitespace follows tab stops.
     */
    useTabStops?: boolean;
    /**
     * The font family
     */
    fontFamily?: string;
    /**
     * The font weight
     */
    fontWeight?: string;
    /**
     * The font size
     */
    fontSize?: number;
    /**
     * The line height
     */
    lineHeight?: number;
    /**
     * The letter spacing
     */
    letterSpacing?: number;
    /**
     * Controls fading out of unused variables.
     */
    showUnused?: boolean;
    /**
     * Controls whether to focus the inline editor in the peek widget by default.
     * Defaults to false.
     */
    peekWidgetDefaultFocus?: 'tree' | 'editor';
    /**
     * Controls whether the definition link opens element in the peek widget.
     * Defaults to false.
     */
    definitionLinkOpensInPeek?: boolean;
    /**
     * Controls strikethrough deprecated variables.
     */
    showDeprecated?: boolean;
    /**
     * Controls whether suggestions allow matches in the middle of the word instead of only at the beginning
     */
    matchOnWordStartOnly?: boolean;
    /**
     * Control the behavior and rendering of the inline hints.
     */
    inlayHints?: IEditorInlayHintsOptions;
    /**
     * Control if the editor should use shadow DOM.
     */
    useShadowDOM?: boolean;
    /**
     * Controls the behavior of editor guides.
    */
    guides?: IGuidesOptions;
    /**
     * Controls the behavior of the unicode highlight feature
     * (by default, ambiguous and invisible characters are highlighted).
     */
    unicodeHighlight?: IUnicodeHighlightOptions;
    /**
     * Configures bracket pair colorization (disabled by default).
    */
    bracketPairColorization?: IBracketPairColorizationOptions;
    /**
     * Controls dropping into the editor from an external source.
     *
     * When enabled, this shows a preview of the drop location and triggers an `onDropIntoEditor` event.
     */
    dropIntoEditor?: IDropIntoEditorOptions;
    /**
     * Controls whether the editor receives tabs or defers them to the workbench for navigation.
     */
    tabFocusMode?: boolean;
}
interface IDiffEditorBaseOptions {
    /**
     * Allow the user to resize the diff editor split view.
     * Defaults to true.
     */
    enableSplitViewResizing?: boolean;
    /**
     * Render the differences in two side-by-side editors.
     * Defaults to true.
     */
    renderSideBySide?: boolean;
    /**
     * Timeout in milliseconds after which diff computation is cancelled.
     * Defaults to 5000.
     */
    maxComputationTime?: number;
    /**
     * Maximum supported file size in MB.
     * Defaults to 50.
     */
    maxFileSize?: number;
    /**
     * Compute the diff by ignoring leading/trailing whitespace
     * Defaults to true.
     */
    ignoreTrimWhitespace?: boolean;
    /**
     * Render +/- indicators for added/deleted changes.
     * Defaults to true.
     */
    renderIndicators?: boolean;
    /**
     * Shows icons in the glyph margin to revert changes.
     * Default to true.
     */
    renderMarginRevertIcon?: boolean;
    /**
     * Original model should be editable?
     * Defaults to false.
     */
    originalEditable?: boolean;
    /**
     * Should the diff editor enable code lens?
     * Defaults to false.
     */
    diffCodeLens?: boolean;
    /**
     * Is the diff editor should render overview ruler
     * Defaults to true
     */
    renderOverviewRuler?: boolean;
    /**
     * Control the wrapping of the diff editor.
     */
    diffWordWrap?: 'off' | 'on' | 'inherit';
    /**
     * Diff Algorithm
    */
    diffAlgorithm?: 'smart' | 'experimental' | IDocumentDiffProvider;
}
/**
 * Configuration options for the diff editor.
 */
interface IDiffEditorOptions extends IEditorOptions$1, IDiffEditorBaseOptions {
}
/**
 * Configuration options for editor comments
 */
interface IEditorCommentsOptions {
    /**
     * Insert a space after the line comment token and inside the block comments tokens.
     * Defaults to true.
     */
    insertSpace?: boolean;
    /**
     * Ignore empty lines when inserting line comments.
     * Defaults to true.
     */
    ignoreEmptyLines?: boolean;
}
/**
 * Configuration options for editor find widget
 */
interface IEditorFindOptions {
    /**
    * Controls whether the cursor should move to find matches while typing.
    */
    cursorMoveOnType?: boolean;
    /**
     * Controls if we seed search string in the Find Widget with editor selection.
     */
    seedSearchStringFromSelection?: 'never' | 'always' | 'selection';
    /**
     * Controls if Find in Selection flag is turned on in the editor.
     */
    autoFindInSelection?: 'never' | 'always' | 'multiline';
    addExtraSpaceOnTop?: boolean;
    /**
     * @internal
     * Controls if the Find Widget should read or modify the shared find clipboard on macOS
     */
    globalFindClipboard?: boolean;
    /**
     * Controls whether the search result and diff result automatically restarts from the beginning (or the end) when no further matches can be found
     */
    loop?: boolean;
}
type GoToLocationValues = 'peek' | 'gotoAndPeek' | 'goto';
/**
 * Configuration options for go to location
 */
interface IGotoLocationOptions {
    multiple?: GoToLocationValues;
    multipleDefinitions?: GoToLocationValues;
    multipleTypeDefinitions?: GoToLocationValues;
    multipleDeclarations?: GoToLocationValues;
    multipleImplementations?: GoToLocationValues;
    multipleReferences?: GoToLocationValues;
    alternativeDefinitionCommand?: string;
    alternativeTypeDefinitionCommand?: string;
    alternativeDeclarationCommand?: string;
    alternativeImplementationCommand?: string;
    alternativeReferenceCommand?: string;
}
/**
 * Configuration options for editor hover
 */
interface IEditorHoverOptions {
    /**
     * Enable the hover.
     * Defaults to true.
     */
    enabled?: boolean;
    /**
     * Delay for showing the hover.
     * Defaults to 300.
     */
    delay?: number;
    /**
     * Is the hover sticky such that it can be clicked and its contents selected?
     * Defaults to true.
     */
    sticky?: boolean;
    /**
     * Should the hover be shown above the line if possible?
     * Defaults to false.
     */
    above?: boolean;
}
/**
 * Configuration options for editor lightbulb
 */
interface IEditorLightbulbOptions {
    /**
     * Enable the lightbulb code action.
     * Defaults to true.
     */
    enabled?: boolean;
}
interface IEditorStickyScrollOptions {
    /**
     * Enable the sticky scroll
     */
    enabled?: boolean;
    /**
     * Maximum number of sticky lines to show
     */
    maxLineCount?: number;
}
/**
 * Configuration options for editor inlayHints
 */
interface IEditorInlayHintsOptions {
    /**
     * Enable the inline hints.
     * Defaults to true.
     */
    enabled?: 'on' | 'off' | 'offUnlessPressed' | 'onUnlessPressed';
    /**
     * Font size of inline hints.
     * Default to 90% of the editor font size.
     */
    fontSize?: number;
    /**
     * Font family of inline hints.
     * Defaults to editor font family.
     */
    fontFamily?: string;
    /**
     * Enables the padding around the inlay hint.
     * Defaults to false.
     */
    padding?: boolean;
}
/**
 * Configuration options for editor minimap
 */
interface IEditorMinimapOptions {
    /**
     * Enable the rendering of the minimap.
     * Defaults to true.
     */
    enabled?: boolean;
    /**
     * Control the rendering of minimap.
     */
    autohide?: boolean;
    /**
     * Control the side of the minimap in editor.
     * Defaults to 'right'.
     */
    side?: 'right' | 'left';
    /**
     * Control the minimap rendering mode.
     * Defaults to 'actual'.
     */
    size?: 'proportional' | 'fill' | 'fit';
    /**
     * Control the rendering of the minimap slider.
     * Defaults to 'mouseover'.
     */
    showSlider?: 'always' | 'mouseover';
    /**
     * Render the actual text on a line (as opposed to color blocks).
     * Defaults to true.
     */
    renderCharacters?: boolean;
    /**
     * Limit the width of the minimap to render at most a certain number of columns.
     * Defaults to 120.
     */
    maxColumn?: number;
    /**
     * Relative size of the font in the minimap. Defaults to 1.
     */
    scale?: number;
}
/**
 * Configuration options for editor padding
 */
interface IEditorPaddingOptions {
    /**
     * Spacing between top edge of editor and first line.
     */
    top?: number;
    /**
     * Spacing between bottom edge of editor and last line.
     */
    bottom?: number;
}
/**
 * Configuration options for parameter hints
 */
interface IEditorParameterHintOptions {
    /**
     * Enable parameter hints.
     * Defaults to true.
     */
    enabled?: boolean;
    /**
     * Enable cycling of parameter hints.
     * Defaults to false.
     */
    cycle?: boolean;
}
type QuickSuggestionsValue = 'on' | 'inline' | 'off';
/**
 * Configuration options for quick suggestions
 */
interface IQuickSuggestionsOptions {
    other?: boolean | QuickSuggestionsValue;
    comments?: boolean | QuickSuggestionsValue;
    strings?: boolean | QuickSuggestionsValue;
}
type LineNumbersType = 'on' | 'off' | 'relative' | 'interval' | ((lineNumber: number) => string);
interface IRulerOption {
    readonly column: number;
    readonly color: string | null;
}
/**
 * Configuration options for editor scrollbars
 */
interface IEditorScrollbarOptions {
    /**
     * The size of arrows (if displayed).
     * Defaults to 11.
     * **NOTE**: This option cannot be updated using `updateOptions()`
     */
    arrowSize?: number;
    /**
     * Render vertical scrollbar.
     * Defaults to 'auto'.
     */
    vertical?: 'auto' | 'visible' | 'hidden';
    /**
     * Render horizontal scrollbar.
     * Defaults to 'auto'.
     */
    horizontal?: 'auto' | 'visible' | 'hidden';
    /**
     * Cast horizontal and vertical shadows when the content is scrolled.
     * Defaults to true.
     * **NOTE**: This option cannot be updated using `updateOptions()`
     */
    useShadows?: boolean;
    /**
     * Render arrows at the top and bottom of the vertical scrollbar.
     * Defaults to false.
     * **NOTE**: This option cannot be updated using `updateOptions()`
     */
    verticalHasArrows?: boolean;
    /**
     * Render arrows at the left and right of the horizontal scrollbar.
     * Defaults to false.
     * **NOTE**: This option cannot be updated using `updateOptions()`
     */
    horizontalHasArrows?: boolean;
    /**
     * Listen to mouse wheel events and react to them by scrolling.
     * Defaults to true.
     */
    handleMouseWheel?: boolean;
    /**
     * Always consume mouse wheel events (always call preventDefault() and stopPropagation() on the browser events).
     * Defaults to true.
     * **NOTE**: This option cannot be updated using `updateOptions()`
     */
    alwaysConsumeMouseWheel?: boolean;
    /**
     * Height in pixels for the horizontal scrollbar.
     * Defaults to 10 (px).
     */
    horizontalScrollbarSize?: number;
    /**
     * Width in pixels for the vertical scrollbar.
     * Defaults to 10 (px).
     */
    verticalScrollbarSize?: number;
    /**
     * Width in pixels for the vertical slider.
     * Defaults to `verticalScrollbarSize`.
     * **NOTE**: This option cannot be updated using `updateOptions()`
     */
    verticalSliderSize?: number;
    /**
     * Height in pixels for the horizontal slider.
     * Defaults to `horizontalScrollbarSize`.
     * **NOTE**: This option cannot be updated using `updateOptions()`
     */
    horizontalSliderSize?: number;
    /**
     * Scroll gutter clicks move by page vs jump to position.
     * Defaults to false.
     */
    scrollByPage?: boolean;
}
type InUntrustedWorkspace = 'inUntrustedWorkspace';
/**
 * Configuration options for unicode highlighting.
 */
interface IUnicodeHighlightOptions {
    /**
     * Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.
     */
    nonBasicASCII?: boolean | InUntrustedWorkspace;
    /**
     * Controls whether characters that just reserve space or have no width at all are highlighted.
     */
    invisibleCharacters?: boolean;
    /**
     * Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.
     */
    ambiguousCharacters?: boolean;
    /**
     * Controls whether characters in comments should also be subject to unicode highlighting.
     */
    includeComments?: boolean | InUntrustedWorkspace;
    /**
     * Controls whether characters in strings should also be subject to unicode highlighting.
     */
    includeStrings?: boolean | InUntrustedWorkspace;
    /**
     * Defines allowed characters that are not being highlighted.
     */
    allowedCharacters?: Record<string, true>;
    /**
     * Unicode characters that are common in allowed locales are not being highlighted.
     */
    allowedLocales?: Record<string | '_os' | '_vscode', true>;
}
interface IInlineSuggestOptions {
    /**
     * Enable or disable the rendering of automatic inline completions.
    */
    enabled?: boolean;
    /**
     * Configures the mode.
     * Use `prefix` to only show ghost text if the text to replace is a prefix of the suggestion text.
     * Use `subword` to only show ghost text if the replace text is a subword of the suggestion text.
     * Use `subwordSmart` to only show ghost text if the replace text is a subword of the suggestion text, but the subword must start after the cursor position.
     * Defaults to `prefix`.
    */
    mode?: 'prefix' | 'subword' | 'subwordSmart';
    showToolbar?: 'always' | 'onHover';
}
interface IBracketPairColorizationOptions {
    /**
     * Enable or disable bracket pair colorization.
    */
    enabled?: boolean;
    /**
     * Use independent color pool per bracket type.
    */
    independentColorPoolPerBracketType?: boolean;
}
interface IGuidesOptions {
    /**
     * Enable rendering of bracket pair guides.
     * Defaults to false.
    */
    bracketPairs?: boolean | 'active';
    /**
     * Enable rendering of vertical bracket pair guides.
     * Defaults to 'active'.
     */
    bracketPairsHorizontal?: boolean | 'active';
    /**
     * Enable highlighting of the active bracket pair.
     * Defaults to true.
    */
    highlightActiveBracketPair?: boolean;
    /**
     * Enable rendering of indent guides.
     * Defaults to true.
     */
    indentation?: boolean;
    /**
     * Enable highlighting of the active indent guide.
     * Defaults to true.
     */
    highlightActiveIndentation?: boolean | 'always';
}
/**
 * Configuration options for editor suggest widget
 */
interface ISuggestOptions {
    /**
     * Overwrite word ends on accept. Default to false.
     */
    insertMode?: 'insert' | 'replace';
    /**
     * Enable graceful matching. Defaults to true.
     */
    filterGraceful?: boolean;
    /**
     * Prevent quick suggestions when a snippet is active. Defaults to true.
     */
    snippetsPreventQuickSuggestions?: boolean;
    /**
     * Favors words that appear close to the cursor.
     */
    localityBonus?: boolean;
    /**
     * Enable using global storage for remembering suggestions.
     */
    shareSuggestSelections?: boolean;
    /**
     * Select suggestions when triggered via quick suggest or trigger characters
     */
    selectionMode?: 'always' | 'never' | 'whenTriggerCharacter' | 'whenQuickSuggestion';
    /**
     * Enable or disable icons in suggestions. Defaults to true.
     */
    showIcons?: boolean;
    /**
     * Enable or disable the suggest status bar.
     */
    showStatusBar?: boolean;
    /**
     * Enable or disable the rendering of the suggestion preview.
     */
    preview?: boolean;
    /**
     * Configures the mode of the preview.
    */
    previewMode?: 'prefix' | 'subword' | 'subwordSmart';
    /**
     * Show details inline with the label. Defaults to true.
     */
    showInlineDetails?: boolean;
    /**
     * Show method-suggestions.
     */
    showMethods?: boolean;
    /**
     * Show function-suggestions.
     */
    showFunctions?: boolean;
    /**
     * Show constructor-suggestions.
     */
    showConstructors?: boolean;
    /**
     * Show deprecated-suggestions.
     */
    showDeprecated?: boolean;
    /**
     * Controls whether suggestions allow matches in the middle of the word instead of only at the beginning
     */
    matchOnWordStartOnly?: boolean;
    /**
     * Show field-suggestions.
     */
    showFields?: boolean;
    /**
     * Show variable-suggestions.
     */
    showVariables?: boolean;
    /**
     * Show class-suggestions.
     */
    showClasses?: boolean;
    /**
     * Show struct-suggestions.
     */
    showStructs?: boolean;
    /**
     * Show interface-suggestions.
     */
    showInterfaces?: boolean;
    /**
     * Show module-suggestions.
     */
    showModules?: boolean;
    /**
     * Show property-suggestions.
     */
    showProperties?: boolean;
    /**
     * Show event-suggestions.
     */
    showEvents?: boolean;
    /**
     * Show operator-suggestions.
     */
    showOperators?: boolean;
    /**
     * Show unit-suggestions.
     */
    showUnits?: boolean;
    /**
     * Show value-suggestions.
     */
    showValues?: boolean;
    /**
     * Show constant-suggestions.
     */
    showConstants?: boolean;
    /**
     * Show enum-suggestions.
     */
    showEnums?: boolean;
    /**
     * Show enumMember-suggestions.
     */
    showEnumMembers?: boolean;
    /**
     * Show keyword-suggestions.
     */
    showKeywords?: boolean;
    /**
     * Show text-suggestions.
     */
    showWords?: boolean;
    /**
     * Show color-suggestions.
     */
    showColors?: boolean;
    /**
     * Show file-suggestions.
     */
    showFiles?: boolean;
    /**
     * Show reference-suggestions.
     */
    showReferences?: boolean;
    /**
     * Show folder-suggestions.
     */
    showFolders?: boolean;
    /**
     * Show typeParameter-suggestions.
     */
    showTypeParameters?: boolean;
    /**
     * Show issue-suggestions.
     */
    showIssues?: boolean;
    /**
     * Show user-suggestions.
     */
    showUsers?: boolean;
    /**
     * Show snippet-suggestions.
     */
    showSnippets?: boolean;
}
interface ISmartSelectOptions {
    selectLeadingAndTrailingWhitespace?: boolean;
}
/**
 * Configuration options for editor drop into behavior
 */
interface IDropIntoEditorOptions {
    /**
     * Enable the dropping into editor.
     * Defaults to true.
     */
    enabled?: boolean;
}

interface ILanguageExtensionPoint {
    id: string;
    extensions?: string[];
    filenames?: string[];
    filenamePatterns?: string[];
    firstLine?: string;
    aliases?: string[];
    mimetypes?: string[];
    configuration?: URI;
    /**
     * @internal
     */
    icon?: ILanguageIcon;
}
interface ILanguageSelection {
    readonly languageId: string;
    readonly onDidChange: Event$1<string>;
}
interface ILanguageNameIdPair {
    readonly languageName: string;
    readonly languageId: string;
}
interface ILanguageIcon {
    readonly light: URI;
    readonly dark: URI;
}
declare const ILanguageService: ServiceIdentifier<ILanguageService>;
interface ILanguageService {
    readonly _serviceBrand: undefined;
    /**
     * A codec which can encode and decode a string `languageId` as a number.
     */
    readonly languageIdCodec: ILanguageIdCodec;
    /**
     * An event emitted when a language is needed for the first time.
     */
    onDidEncounterLanguage: Event$1<string>;
    /**
     * An event emitted when languages have changed.
     */
    onDidChange: Event$1<void>;
    /**
     * Register a language.
     */
    registerLanguage(def: ILanguageExtensionPoint): IDisposable;
    /**
     * Check if `languageId` is registered.
     */
    isRegisteredLanguageId(languageId: string): boolean;
    /**
     * Get a list of all registered languages.
     */
    getRegisteredLanguageIds(): string[];
    /**
     * Get a list of all registered languages with a name.
     * If a language is explicitly registered without a name, it will not be part of the result.
     * The result is sorted using by name case insensitive.
     */
    getSortedRegisteredLanguageNames(): ILanguageNameIdPair[];
    /**
     * Get the preferred language name for a language.
     */
    getLanguageName(languageId: string): string | null;
    /**
     * Get the mimetype for a language.
     */
    getMimeType(languageId: string): string | null;
    /**
     * Get the default icon for the language.
     */
    getIcon(languageId: string): ILanguageIcon | null;
    /**
     * Get all file extensions for a language.
     */
    getExtensions(languageId: string): ReadonlyArray<string>;
    /**
     * Get all file names for a language.
     */
    getFilenames(languageId: string): ReadonlyArray<string>;
    /**
     * Get all language configuration files for a language.
     */
    getConfigurationFiles(languageId: string): ReadonlyArray<URI>;
    /**
     * Look up a language by its name case insensitive.
     */
    getLanguageIdByLanguageName(languageName: string): string | null;
    /**
     * Look up a language by its mime type.
     */
    getLanguageIdByMimeType(mimeType: string | null | undefined): string | null;
    /**
     * Guess the language id for a resource.
     */
    guessLanguageIdByFilepathOrFirstLine(resource: URI, firstLine?: string): string | null;
    /**
     * Will fall back to 'plaintext' if `languageId` is unknown.
     */
    createById(languageId: string | null | undefined): ILanguageSelection;
    /**
     * Will fall back to 'plaintext' if `mimeType` is unknown.
     */
    createByMimeType(mimeType: string | null | undefined): ILanguageSelection;
    /**
     * Will fall back to 'plaintext' if the `languageId` cannot be determined.
     */
    createByFilepathOrFirstLine(resource: URI | null, firstLine?: string): ILanguageSelection;
}

/**
 * Interface used to support insertion of mode specific comments.
 */
interface ICommentsConfiguration {
    lineCommentToken?: string;
    blockCommentStartToken?: string;
    blockCommentEndToken?: string;
}
declare class LanguageConfigurationServiceChangeEvent {
    readonly languageId: string | undefined;
    constructor(languageId: string | undefined);
    affects(languageId: string): boolean;
}
interface ILanguageConfigurationService {
    readonly _serviceBrand: undefined;
    onDidChange: Event$1<LanguageConfigurationServiceChangeEvent>;
    /**
     * @param priority Use a higher number for higher priority
     */
    register(languageId: string, configuration: LanguageConfiguration, priority?: number): IDisposable;
    getLanguageConfiguration(languageId: string): ResolvedLanguageConfiguration;
}
declare const ILanguageConfigurationService: ServiceIdentifier<ILanguageConfigurationService>;
/**
 * Immutable.
*/
declare class ResolvedLanguageConfiguration {
    readonly languageId: string;
    readonly underlyingConfig: LanguageConfiguration;
    private _brackets;
    private _electricCharacter;
    private readonly _onEnterSupport;
    readonly comments: ICommentsConfiguration | null;
    readonly characterPair: CharacterPairSupport;
    readonly wordDefinition: RegExp;
    readonly indentRulesSupport: IndentRulesSupport | null;
    readonly indentationRules: IndentationRule | undefined;
    readonly foldingRules: FoldingRules;
    readonly bracketsNew: LanguageBracketsConfiguration;
    constructor(languageId: string, underlyingConfig: LanguageConfiguration);
    getWordDefinition(): RegExp;
    get brackets(): RichEditBrackets | null;
    get electricCharacter(): BracketElectricCharacterSupport | null;
    onEnter(autoIndent: EditorAutoIndentStrategy, previousLineText: string, beforeEnterText: string, afterEnterText: string): EnterAction | null;
    getAutoClosingPairs(): AutoClosingPairs;
    getAutoCloseBeforeSet(forQuotes: boolean): string;
    getSurroundingPairs(): IAutoClosingPair[];
    private static _handleComments;
}

interface IModelContentChange {
    /**
     * The range that got replaced.
     */
    readonly range: IRange;
    /**
     * The offset of the range that got replaced.
     */
    readonly rangeOffset: number;
    /**
     * The length of the range that got replaced.
     */
    readonly rangeLength: number;
    /**
     * The new text for the range.
     */
    readonly text: string;
}
/**
 * An event describing that model decorations have changed.
 */
interface IModelDecorationsChangedEvent {
    readonly affectsMinimap: boolean;
    readonly affectsOverviewRuler: boolean;
}

declare class UndoRedoSource {
    private static _ID;
    readonly id: number;
    private order;
    constructor();
    nextOrder(): number;
    static None: UndoRedoSource;
}

/**
 * Vertical Lane in the overview ruler of the editor.
 */
declare enum OverviewRulerLane {
    Left = 1,
    Center = 2,
    Right = 4,
    Full = 7
}
/**
 * Position in the minimap to render the decoration.
 */
declare enum MinimapPosition {
    Inline = 1,
    Gutter = 2
}
interface IDecorationOptions {
    /**
     * CSS color to render.
     * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
     */
    color: string | ThemeColor | undefined;
    /**
     * CSS color to render.
     * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
     */
    darkColor?: string | ThemeColor;
}
/**
 * Options for rendering a model decoration in the overview ruler.
 */
interface IModelDecorationOverviewRulerOptions extends IDecorationOptions {
    /**
     * The position in the overview ruler.
     */
    position: OverviewRulerLane;
}
/**
 * Options for rendering a model decoration in the overview ruler.
 */
interface IModelDecorationMinimapOptions extends IDecorationOptions {
    /**
     * The position in the overview ruler.
     */
    position: MinimapPosition;
}
/**
 * Options for a model decoration.
 */
interface IModelDecorationOptions {
    /**
     * A debug description that can be used for inspecting model decorations.
     * @internal
     */
    description: string;
    /**
     * Customize the growing behavior of the decoration when typing at the edges of the decoration.
     * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
     */
    stickiness?: TrackedRangeStickiness;
    /**
     * CSS class name describing the decoration.
     */
    className?: string | null;
    blockClassName?: string | null;
    /**
     * Indicates if this block should be rendered after the last line.
     * In this case, the range must be empty and set to the last line.
     */
    blockIsAfterEnd?: boolean | null;
    /**
     * Message to be rendered when hovering over the glyph margin decoration.
     */
    glyphMarginHoverMessage?: IMarkdownString | IMarkdownString[] | null;
    /**
     * Array of MarkdownString to render as the decoration message.
     */
    hoverMessage?: IMarkdownString | IMarkdownString[] | null;
    /**
     * Should the decoration expand to encompass a whole line.
     */
    isWholeLine?: boolean;
    /**
     * Always render the decoration (even when the range it encompasses is collapsed).
     */
    showIfCollapsed?: boolean;
    /**
     * Collapse the decoration if its entire range is being replaced via an edit.
     * @internal
     */
    collapseOnReplaceEdit?: boolean;
    /**
     * Specifies the stack order of a decoration.
     * A decoration with greater stack order is always in front of a decoration with
     * a lower stack order when the decorations are on the same line.
     */
    zIndex?: number;
    /**
     * If set, render this decoration in the overview ruler.
     */
    overviewRuler?: IModelDecorationOverviewRulerOptions | null;
    /**
     * If set, render this decoration in the minimap.
     */
    minimap?: IModelDecorationMinimapOptions | null;
    /**
     * If set, the decoration will be rendered in the glyph margin with this CSS class name.
     */
    glyphMarginClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the lines decorations with this CSS class name.
     */
    linesDecorationsClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.
     */
    firstLineDecorationClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
     */
    marginClassName?: string | null;
    /**
     * If set, the decoration will be rendered inline with the text with this CSS class name.
     * Please use this only for CSS rules that must impact the text. For example, use `className`
     * to have a background color decoration.
     */
    inlineClassName?: string | null;
    /**
     * If there is an `inlineClassName` which affects letter spacing.
     */
    inlineClassNameAffectsLetterSpacing?: boolean;
    /**
     * If set, the decoration will be rendered before the text with this CSS class name.
     */
    beforeContentClassName?: string | null;
    /**
     * If set, the decoration will be rendered after the text with this CSS class name.
     */
    afterContentClassName?: string | null;
    /**
     * If set, text will be injected in the view after the range.
     */
    after?: InjectedTextOptions | null;
    /**
     * If set, text will be injected in the view before the range.
     */
    before?: InjectedTextOptions | null;
    /**
     * If set, this decoration will not be rendered for comment tokens.
     * @internal
    */
    hideInCommentTokens?: boolean | null;
    /**
     * If set, this decoration will not be rendered for string tokens.
     * @internal
    */
    hideInStringTokens?: boolean | null;
}
/**
 * Configures text that is injected into the view without changing the underlying document.
*/
interface InjectedTextOptions {
    /**
     * Sets the text to inject. Must be a single line.
     */
    readonly content: string;
    /**
     * If set, the decoration will be rendered inline with the text with this CSS class name.
     */
    readonly inlineClassName?: string | null;
    /**
     * If there is an `inlineClassName` which affects letter spacing.
     */
    readonly inlineClassNameAffectsLetterSpacing?: boolean;
    /**
     * This field allows to attach data to this injected text.
     * The data can be read when injected texts at a given position are queried.
     */
    readonly attachedData?: unknown;
    /**
     * Configures cursor stops around injected text.
     * Defaults to {@link InjectedTextCursorStops.Both}.
    */
    readonly cursorStops?: InjectedTextCursorStops | null;
}
declare enum InjectedTextCursorStops {
    Both = 0,
    Right = 1,
    Left = 2,
    None = 3
}
/**
 * New model decorations.
 */
interface IModelDeltaDecoration {
    /**
     * Range that this decoration covers.
     */
    range: IRange;
    /**
     * Options associated with this decoration.
     */
    options: IModelDecorationOptions;
}
/**
 * A decoration in the model.
 */
interface IModelDecoration {
    /**
     * Identifier for a decoration.
     */
    readonly id: string;
    /**
     * Identifier for a decoration's owner.
     */
    readonly ownerId: number;
    /**
     * Range that this decoration covers.
     */
    readonly range: Range;
    /**
     * Options associated with this decoration.
     */
    readonly options: IModelDecorationOptions;
}
/**
 * An accessor that can add, change or remove model decorations.
 * @internal
 */
interface IModelDecorationsChangeAccessor {
    /**
     * Add a new decoration.
     * @param range Range that this decoration covers.
     * @param options Options associated with this decoration.
     * @return An unique identifier associated with this decoration.
     */
    addDecoration(range: IRange, options: IModelDecorationOptions): string;
    /**
     * Change the range that an existing decoration covers.
     * @param id The unique identifier associated with the decoration.
     * @param newRange The new range that this decoration covers.
     */
    changeDecoration(id: string, newRange: IRange): void;
    /**
     * Change the options associated with an existing decoration.
     * @param id The unique identifier associated with the decoration.
     * @param newOptions The new options associated with this decoration.
     */
    changeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;
    /**
     * Remove an existing decoration.
     * @param id The unique identifier associated with the decoration.
     */
    removeDecoration(id: string): void;
    /**
     * Perform a minimum amount of operations, in order to transform the decorations
     * identified by `oldDecorations` to the decorations described by `newDecorations`
     * and returns the new identifiers associated with the resulting decorations.
     *
     * @param oldDecorations Array containing previous decorations identifiers.
     * @param newDecorations Array describing what decorations should result after the call.
     * @return An array containing the new decorations identifiers.
     */
    deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
}
/**
 * End of line character preference.
 */
declare const enum EndOfLinePreference {
    /**
     * Use the end of line character identified in the text buffer.
     */
    TextDefined = 0,
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 1,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 2
}
/**
 * The default end of line to use when instantiating models.
 */
declare const enum DefaultEndOfLine {
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 1,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 2
}
/**
 * End of line character preference.
 */
declare const enum EndOfLineSequence {
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 0,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 1
}
/**
 * An identifier for a single edit operation.
 * @internal
 */
interface ISingleEditOperationIdentifier {
    /**
     * Identifier major
     */
    major: number;
    /**
     * Identifier minor
     */
    minor: number;
}
/**
 * A single edit operation, that has an identifier.
 */
interface IIdentifiedSingleEditOperation extends ISingleEditOperation {
    /**
     * An identifier associated with this single edit operation.
     * @internal
     */
    identifier?: ISingleEditOperationIdentifier | null;
    /**
     * This indicates that this operation is inserting automatic whitespace
     * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.
     * @internal
     */
    isAutoWhitespaceEdit?: boolean;
    /**
     * This indicates that this operation is in a set of operations that are tracked and should not be "simplified".
     * @internal
     */
    _isTracked?: boolean;
}
interface IValidEditOperation {
    /**
     * An identifier associated with this single edit operation.
     * @internal
     */
    identifier: ISingleEditOperationIdentifier | null;
    /**
     * The range to replace. This can be empty to emulate a simple insert.
     */
    range: Range;
    /**
     * The text to replace with. This can be empty to emulate a simple delete.
     */
    text: string;
    /**
     * @internal
     */
    textChange: TextChange;
}
/**
 * @internal
 */
interface ITextModelCreationOptions {
    tabSize: number;
    indentSize: number | 'tabSize';
    insertSpaces: boolean;
    detectIndentation: boolean;
    trimAutoWhitespace: boolean;
    defaultEOL: DefaultEndOfLine;
    isForSimpleWidget: boolean;
    largeFileOptimizations: boolean;
    bracketPairColorizationOptions: BracketPairColorizationOptions;
}
interface BracketPairColorizationOptions {
    enabled: boolean;
    independentColorPoolPerBracketType: boolean;
}
declare class FindMatch {
    _findMatchBrand: void;
    readonly range: Range;
    readonly matches: string[] | null;
    /**
     * @internal
     */
    constructor(range: Range, matches: string[] | null);
}
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
 */
declare const enum TrackedRangeStickiness {
    AlwaysGrowsWhenTypingAtEdges = 0,
    NeverGrowsWhenTypingAtEdges = 1,
    GrowsOnlyWhenTypingBefore = 2,
    GrowsOnlyWhenTypingAfter = 3
}
/**
 * Text snapshot that works like an iterator.
 * Will try to return chunks of roughly ~64KB size.
 * Will return null when finished.
 */
interface ITextSnapshot {
    read(): string | null;
}
/**
 * A model.
 */
type ITextModel = monaco.editor.ITextModel
/**
 * @internal
 */
interface ITextBufferFactory {
    create(defaultEOL: DefaultEndOfLine): {
        textBuffer: ITextBuffer;
        disposable: IDisposable;
    };
    getFirstLineText(lengthLimit: number): string;
}
/**
 * @internal
 */
declare class ValidAnnotatedEditOperation implements IIdentifiedSingleEditOperation {
    readonly identifier: ISingleEditOperationIdentifier | null;
    readonly range: Range;
    readonly text: string | null;
    readonly forceMoveMarkers: boolean;
    readonly isAutoWhitespaceEdit: boolean;
    readonly _isTracked: boolean;
    constructor(identifier: ISingleEditOperationIdentifier | null, range: Range, text: string | null, forceMoveMarkers: boolean, isAutoWhitespaceEdit: boolean, _isTracked: boolean);
}
/**
 * @internal
 *
 * `lineNumber` is 1 based.
 */
interface IReadonlyTextBuffer {
    onDidChangeContent: Event$1<void>;
    equals(other: ITextBuffer): boolean;
    mightContainRTL(): boolean;
    mightContainUnusualLineTerminators(): boolean;
    resetMightContainUnusualLineTerminators(): void;
    mightContainNonBasicASCII(): boolean;
    getBOM(): string;
    getEOL(): string;
    getOffsetAt(lineNumber: number, column: number): number;
    getPositionAt(offset: number): Position$1;
    getRangeAt(offset: number, length: number): Range;
    getValueInRange(range: Range, eol: EndOfLinePreference): string;
    createSnapshot(preserveBOM: boolean): ITextSnapshot;
    getValueLengthInRange(range: Range, eol: EndOfLinePreference): number;
    getCharacterCountInRange(range: Range, eol: EndOfLinePreference): number;
    getLength(): number;
    getLineCount(): number;
    getLinesContent(): string[];
    getLineContent(lineNumber: number): string;
    getLineCharCode(lineNumber: number, index: number): number;
    getCharCode(offset: number): number;
    getLineLength(lineNumber: number): number;
    getLineFirstNonWhitespaceColumn(lineNumber: number): number;
    getLineLastNonWhitespaceColumn(lineNumber: number): number;
    findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[];
}
/**
 * @internal
 */
declare class SearchData {
    /**
     * The regex to search for. Always defined.
     */
    readonly regex: RegExp;
    /**
     * The word separator classifier.
     */
    readonly wordSeparators: WordCharacterClassifier | null;
    /**
     * The simple string to search for (if possible).
     */
    readonly simpleSearch: string | null;
    constructor(regex: RegExp, wordSeparators: WordCharacterClassifier | null, simpleSearch: string | null);
}
/**
 * @internal
 */
interface ITextBuffer extends IReadonlyTextBuffer {
    setEOL(newEOL: '\r\n' | '\n'): void;
    applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult;
}
/**
 * @internal
 */
declare class ApplyEditsResult {
    readonly reverseEdits: IValidEditOperation[] | null;
    readonly changes: IInternalModelContentChange[];
    readonly trimAutoWhitespaceLineNumbers: number[] | null;
    constructor(reverseEdits: IValidEditOperation[] | null, changes: IInternalModelContentChange[], trimAutoWhitespaceLineNumbers: number[] | null);
}
/**
 * @internal
 */
interface IInternalModelContentChange extends IModelContentChange {
    range: Range;
    forceMoveMarkers: boolean;
}

interface IEditorModel$1 {
    /**
     * Emitted when the model is about to be disposed.
     */
    readonly onWillDispose: Event$1<void>;
    /**
     * Resolves the model.
     */
    resolve(): Promise<void>;
    /**
     * Find out if the editor model was resolved or not.
     */
    isResolved(): boolean;
    /**
     * Find out if this model has been disposed.
     */
    isDisposed(): boolean;
    /**
     * Dispose associated resources
     */
    dispose(): void;
}
interface IBaseUntypedEditorInput {
    /**
     * Optional options to use when opening the input.
     */
    options?: IEditorOptions;
    /**
     * Label to show for the input.
     */
    readonly label?: string;
    /**
     * Description to show for the input.
     */
    readonly description?: string;
}
interface IBaseResourceEditorInput extends IBaseUntypedEditorInput {
    /**
     * Hint to indicate that this input should be treated as a
     * untitled file.
     *
     * Without this hint, the editor service will make a guess by
     * looking at the scheme of the resource(s).
     *
     * Use `forceUntitled: true` when you pass in a `resource` that
     * does not use the `untitled` scheme. The `resource` will then
     * be used as associated path when saving the untitled file.
     */
    readonly forceUntitled?: boolean;
}
interface IBaseTextResourceEditorInput extends IBaseResourceEditorInput {
    /**
     * Optional options to use when opening the text input.
     */
    options?: ITextEditorOptions;
    /**
     * The contents of the text input if known. If provided,
     * the input will not attempt to load the contents from
     * disk and may appear dirty.
     */
    contents?: string;
    /**
     * The encoding of the text input if known.
     */
    encoding?: string;
    /**
     * The identifier of the language id of the text input
     * if known to use when displaying the contents.
     */
    languageId?: string;
}
interface IResourceEditorInput extends IBaseResourceEditorInput {
    /**
     * The resource URI of the resource to open.
     */
    readonly resource: URI;
}
interface ITextResourceEditorInput extends IResourceEditorInput, IBaseTextResourceEditorInput {
    /**
     * Optional options to use when opening the text input.
     */
    options?: ITextEditorOptions;
}
/**
 * This identifier allows to uniquely identify an editor with a
 * resource, type and editor identifier.
 */
interface IResourceEditorInputIdentifier {
    /**
     * The type of the editor.
     */
    readonly typeId: string;
    /**
     * The identifier of the editor if provided.
     */
    readonly editorId: string | undefined;
    /**
     * The resource URI of the editor.
     */
    readonly resource: URI;
}
declare enum EditorActivation {
    /**
     * Activate the editor after it opened. This will automatically restore
     * the editor if it is minimized.
     */
    ACTIVATE = 1,
    /**
     * Only restore the editor if it is minimized but do not activate it.
     *
     * Note: will only work in combination with the `preserveFocus: true` option.
     * Otherwise, if focus moves into the editor, it will activate and restore
     * automatically.
     */
    RESTORE = 2,
    /**
     * Preserve the current active editor.
     *
     * Note: will only work in combination with the `preserveFocus: true` option.
     * Otherwise, if focus moves into the editor, it will activate and restore
     * automatically.
     */
    PRESERVE = 3
}
declare enum EditorResolution {
    /**
     * Displays a picker and allows the user to decide which editor to use.
     */
    PICK = 0,
    /**
     * Only exclusive editors are considered.
     */
    EXCLUSIVE_ONLY = 1
}
declare enum EditorOpenSource {
    /**
     * Default: the editor is opening via a programmatic call
     * to the editor service API.
     */
    API = 0,
    /**
     * Indicates that a user action triggered the opening, e.g.
     * via mouse or keyboard use.
     */
    USER = 1
}
interface IEditorOptions {
    /**
     * Tells the editor to not receive keyboard focus when the editor is being opened.
     *
     * Will also not activate the group the editor opens in unless the group is already
     * the active one. This behaviour can be overridden via the `activation` option.
     */
    preserveFocus?: boolean;
    /**
     * This option is only relevant if an editor is opened into a group that is not active
     * already and allows to control if the inactive group should become active, restored
     * or preserved.
     *
     * By default, the editor group will become active unless `preserveFocus` or `inactive`
     * is specified.
     */
    activation?: EditorActivation;
    /**
     * Tells the editor to reload the editor input in the editor even if it is identical to the one
     * already showing. By default, the editor will not reload the input if it is identical to the
     * one showing.
     */
    forceReload?: boolean;
    /**
     * Will reveal the editor if it is already opened and visible in any of the opened editor groups.
     *
     * Note that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfVisible?: boolean;
    /**
     * Will reveal the editor if it is already opened (even when not visible) in any of the opened editor groups.
     *
     * Note that this option is just a hint that might be ignored if the user wants to open an editor explicitly
     * to the side of another one or into a specific editor group.
     */
    revealIfOpened?: boolean;
    /**
     * An editor that is pinned remains in the editor stack even when another editor is being opened.
     * An editor that is not pinned will always get replaced by another editor that is not pinned.
     */
    pinned?: boolean;
    /**
     * An editor that is sticky moves to the beginning of the editors list within the group and will remain
     * there unless explicitly closed. Operations such as "Close All" will not close sticky editors.
     */
    sticky?: boolean;
    /**
     * The index in the document stack where to insert the editor into when opening.
     */
    index?: number;
    /**
     * An active editor that is opened will show its contents directly. Set to true to open an editor
     * in the background without loading its contents.
     *
     * Will also not activate the group the editor opens in unless the group is already
     * the active one. This behaviour can be overridden via the `activation` option.
     */
    inactive?: boolean;
    /**
     * Will not show an error in case opening the editor fails and thus allows to show a custom error
     * message as needed. By default, an error will be presented as notification if opening was not possible.
     */
    /**
     * In case of an error opening the editor, will not present this error to the user (e.g. by showing
     * a generic placeholder in the editor area). So it is up to the caller to provide error information
     * in that case.
     *
     * By default, an error when opening an editor will result in a placeholder editor that shows the error.
     * In certain cases a modal dialog may be presented to ask the user for further action.
     */
    ignoreError?: boolean;
    /**
     * Allows to override the editor that should be used to display the input:
     * - `undefined`: let the editor decide for itself
     * - `string`: specific override by id
     * - `EditorResolution`: specific override handling
     */
    override?: string | EditorResolution;
    /**
     * A optional hint to signal in which context the editor opens.
     *
     * If configured to be `EditorOpenSource.USER`, this hint can be
     * used in various places to control the experience. For example,
     * if the editor to open fails with an error, a notification could
     * inform about this in a modal dialog. If the editor opened through
     * some background task, the notification would show in the background,
     * not as a modal dialog.
     */
    source?: EditorOpenSource;
    /**
     * An optional property to signal that certain view state should be
     * applied when opening the editor.
     */
    viewState?: object;
}
interface ITextEditorSelection {
    readonly startLineNumber: number;
    readonly startColumn: number;
    readonly endLineNumber?: number;
    readonly endColumn?: number;
}
declare const enum TextEditorSelectionRevealType {
    /**
     * Option to scroll vertically or horizontally as necessary and reveal a range centered vertically.
     */
    Center = 0,
    /**
     * Option to scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
     */
    CenterIfOutsideViewport = 1,
    /**
     * Option to scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport, but not quite at the top.
     */
    NearTop = 2,
    /**
     * Option to scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport, but not quite at the top.
     * Only if it lies outside the viewport
     */
    NearTopIfOutsideViewport = 3
}
declare const enum TextEditorSelectionSource {
    /**
     * Programmatic source indicates a selection change that
     * was not triggered by the user via keyboard or mouse
     * but through text editor APIs.
     */
    PROGRAMMATIC = "api",
    /**
     * Navigation source indicates a selection change that
     * was caused via some command or UI component such as
     * an outline tree.
     */
    NAVIGATION = "code.navigation",
    /**
     * Jump source indicates a selection change that
     * was caused from within the text editor to another
     * location in the same or different text editor such
     * as "Go to definition".
     */
    JUMP = "code.jump"
}
interface ITextEditorOptions extends IEditorOptions {
    /**
     * Text editor selection.
     */
    selection?: ITextEditorSelection;
    /**
     * Option to control the text editor selection reveal type.
     * Defaults to TextEditorSelectionRevealType.Center
     */
    selectionRevealType?: TextEditorSelectionRevealType;
    /**
     * Source of the call that caused the selection.
     */
    selectionSource?: TextEditorSelectionSource | string;
}

declare const ITextModelService: ServiceIdentifier<ITextModelService>;
interface ITextModelService {
    readonly _serviceBrand: undefined;
    /**
     * Provided a resource URI, it will return a model reference
     * which should be disposed once not needed anymore.
     */
    createModelReference(resource: URI): Promise<IReference<IResolvedTextEditorModel>>;
    /**
     * Registers a specific `scheme` content provider.
     */
    registerTextModelContentProvider(scheme: string, provider: ITextModelContentProvider): IDisposable;
    /**
     * Check if the given resource can be resolved to a text model.
     */
    canHandleResource(resource: URI): boolean;
}
interface ITextModelContentProvider {
    /**
     * Given a resource, return the content of the resource as `ITextModel`.
     */
    provideTextContent(resource: URI): Promise<ITextModel | null> | null;
}
interface ITextEditorModel extends IEditorModel$1 {
    /**
     * Provides access to the underlying `ITextModel`.
     */
    readonly textEditorModel: ITextModel | null;
    /**
     * Creates a snapshot of the model's contents.
     */
    createSnapshot(this: IResolvedTextEditorModel): ITextSnapshot;
    createSnapshot(this: ITextEditorModel): ITextSnapshot | null;
    /**
     * Signals if this model is readonly or not.
     */
    isReadonly(): boolean;
    /**
     * The language id of the text model if known.
     */
    getLanguageId(): string | undefined;
}
interface IResolvedTextEditorModel extends ITextEditorModel {
    /**
     * Same as ITextEditorModel#textEditorModel, but never null.
     */
    readonly textEditorModel: ITextModel;
}

type ColorIdentifier = string;

type IconDefaults = ThemeIcon | IconDefinition;
interface IconDefinition {
    font?: IconFontContribution;
    fontCharacter: string;
}
interface IconContribution {
    readonly id: string;
    description: string | undefined;
    deprecationMessage?: string;
    readonly defaults: IconDefaults;
}
declare namespace IconContribution {
    function getDefinition(contribution: IconContribution, registry: IIconRegistry): IconDefinition | undefined;
}
interface IconFontContribution {
    readonly id: string;
    readonly definition: IconFontDefinition;
}
interface IconFontDefinition {
    readonly weight?: string;
    readonly style?: string;
    readonly src: IconFontSource[];
}
declare namespace IconFontDefinition {
    function toJSONObject(iconFont: IconFontDefinition): any;
    function fromJSONObject(json: any): IconFontDefinition | undefined;
}
interface IconFontSource {
    readonly location: URI;
    readonly format: string;
}
interface IIconRegistry {
    readonly onDidChange: Event$1<void>;
    /**
     * Register a icon to the registry.
     * @param id The icon id
     * @param defaults The default values
     * @param description The description
     */
    registerIcon(id: IconIdentifier, defaults: IconDefaults, description?: string): ThemeIcon;
    /**
     * Deregister a icon from the registry.
     */
    deregisterIcon(id: IconIdentifier): void;
    /**
     * Get all icon contributions
     */
    getIcons(): IconContribution[];
    /**
     * Get the icon for the given id
     */
    getIcon(id: IconIdentifier): IconContribution | undefined;
    /**
     * JSON schema for an object to assign icon values to one of the icon contributions.
     */
    getIconSchema(): IJSONSchema;
    /**
     * JSON schema to for a reference to a icon contribution.
     */
    getIconReferenceSchema(): IJSONSchema;
    /**
     * Register a icon font to the registry.
     * @param id The icon font id
     * @param definition The icon font definition
     */
    registerIconFont(id: string, definition: IconFontDefinition): IconFontDefinition;
    /**
     * Deregister an icon font to the registry.
     */
    deregisterIconFont(id: string): void;
    /**
     * Get the icon font for the given id
     */
    getIconFont(id: string): IconFontDefinition | undefined;
}

/**
 * Color scheme used by the OS and by color themes.
 */
declare enum ColorScheme {
    DARK = "dark",
    LIGHT = "light",
    HIGH_CONTRAST_DARK = "hcDark",
    HIGH_CONTRAST_LIGHT = "hcLight"
}

interface ITokenStyle {
    readonly foreground: number | undefined;
    readonly bold: boolean | undefined;
    readonly underline: boolean | undefined;
    readonly strikethrough: boolean | undefined;
    readonly italic: boolean | undefined;
}
interface IColorTheme {
    readonly type: ColorScheme;
    readonly label: string;
    /**
     * Resolves the color of the given color identifier. If the theme does not
     * specify the color, the default color is returned unless <code>useDefault</code> is set to false.
     * @param color the id of the color
     * @param useDefault specifies if the default color should be used. If not set, the default is used.
     */
    getColor(color: ColorIdentifier, useDefault?: boolean): Color | undefined;
    /**
     * Returns whether the theme defines a value for the color. If not, that means the
     * default color will be used.
     */
    defines(color: ColorIdentifier): boolean;
    /**
     * Returns the token style for a given classification. The result uses the <code>MetadataConsts</code> format
     */
    getTokenStyleMetadata(type: string, modifiers: string[], modelLanguage: string): ITokenStyle | undefined;
    /**
     * List of all colors used with tokens. <code>getTokenStyleMetadata</code> references the colors by index into this list.
     */
    readonly tokenColorMap: string[];
    /**
     * Defines whether semantic highlighting should be enabled for the theme.
     */
    readonly semanticHighlighting: boolean;
}
interface IFileIconTheme {
    readonly hasFileIcons: boolean;
    readonly hasFolderIcons: boolean;
    readonly hidesExplorerArrows: boolean;
}
interface IProductIconTheme {
    /**
     * Resolves the definition for the given icon as defined by the theme.
     *
     * @param iconContribution The icon
     */
    getIcon(iconContribution: IconContribution): IconDefinition | undefined;
}
declare const IThemeService: ServiceIdentifier<IThemeService>;
interface IThemeService {
    readonly _serviceBrand: undefined;
    getColorTheme(): IColorTheme;
    readonly onDidColorThemeChange: Event$1<IColorTheme>;
    getFileIconTheme(): IFileIconTheme;
    readonly onDidFileIconThemeChange: Event$1<IFileIconTheme>;
    getProductIconTheme(): IProductIconTheme;
    readonly onDidProductIconThemeChange: Event$1<IProductIconTheme>;
}
/**
 * Utility base class for all themable components.
 */
declare class Themable extends Disposable {
    protected themeService: IThemeService;
    protected theme: IColorTheme;
    constructor(themeService: IThemeService);
    protected onThemeChange(theme: IColorTheme): void;
    updateStyles(): void;
    protected getColor(id: string, modify?: (color: Color, theme: IColorTheme) => Color): string | null;
}

interface ReadableStreamEvents<T> {
    /**
     * The 'data' event is emitted whenever the stream is
     * relinquishing ownership of a chunk of data to a consumer.
     *
     * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN
     * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE
     * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST
     *
     * Use `listenStream` as a helper method to listen to
     * stream events in the right order.
     */
    on(event: 'data', callback: (data: T) => void): void;
    /**
     * Emitted when any error occurs.
     */
    on(event: 'error', callback: (err: Error) => void): void;
    /**
     * The 'end' event is emitted when there is no more data
     * to be consumed from the stream. The 'end' event will
     * not be emitted unless the data is completely consumed.
     */
    on(event: 'end', callback: () => void): void;
}
/**
 * A interface that emulates the API shape of a node.js readable
 * stream for use in native and web environments.
 */
interface ReadableStream<T> extends ReadableStreamEvents<T> {
    /**
     * Stops emitting any events until resume() is called.
     */
    pause(): void;
    /**
     * Starts emitting events again after pause() was called.
     */
    resume(): void;
    /**
     * Destroys the stream and stops emitting any event.
     */
    destroy(): void;
    /**
     * Allows to remove a listener that was previously added.
     */
    removeListener(event: string, callback: Function): void;
}
/**
 * A interface that emulates the API shape of a node.js readable
 * for use in native and web environments.
 */
interface Readable<T> {
    /**
     * Read data from the underlying source. Will return
     * null to indicate that no more data can be read.
     */
    read(): T | null;
}

declare class VSBuffer {
    /**
     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
     */
    static alloc(byteLength: number): VSBuffer;
    /**
     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
     * which is not transferrable.
     */
    static wrap(actual: Uint8Array): VSBuffer;
    /**
     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
     */
    static fromString(source: string, options?: {
        dontUseNodeBuffer?: boolean;
    }): VSBuffer;
    /**
     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
     */
    static fromByteArray(source: number[]): VSBuffer;
    /**
     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
     */
    static concat(buffers: VSBuffer[], totalLength?: number): VSBuffer;
    readonly buffer: Uint8Array;
    readonly byteLength: number;
    private constructor();
    /**
     * When running in a nodejs context, the backing store for the returned `VSBuffer` instance
     * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.
     */
    clone(): VSBuffer;
    toString(): string;
    slice(start?: number, end?: number): VSBuffer;
    set(array: VSBuffer, offset?: number): void;
    set(array: Uint8Array, offset?: number): void;
    set(array: ArrayBuffer, offset?: number): void;
    set(array: ArrayBufferView, offset?: number): void;
    set(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;
    readUInt32BE(offset: number): number;
    writeUInt32BE(value: number, offset: number): void;
    readUInt32LE(offset: number): number;
    writeUInt32LE(value: number, offset: number): void;
    readUInt8(offset: number): number;
    writeUInt8(value: number, offset: number): void;
}
interface VSBufferReadable extends Readable<VSBuffer> {
}
interface VSBufferReadableStream extends ReadableStream<VSBuffer> {
}

interface IRelativePattern {
    /**
     * A base file path to which this pattern will be matched against relatively.
     */
    readonly base: string;
    /**
     * A file glob pattern like `*.{ts,js}` that will be matched on file paths
     * relative to the base path.
     *
     * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,
     * the file glob pattern will match on `index.js`.
     */
    readonly pattern: string;
}

declare const IFileService: ServiceIdentifier<IFileService>;
interface IFileService {
    readonly _serviceBrand: undefined;
    /**
     * An event that is fired when a file system provider is added or removed
     */
    readonly onDidChangeFileSystemProviderRegistrations: Event$1<IFileSystemProviderRegistrationEvent>;
    /**
     * An event that is fired when a registered file system provider changes its capabilities.
     */
    readonly onDidChangeFileSystemProviderCapabilities: Event$1<IFileSystemProviderCapabilitiesChangeEvent>;
    /**
     * An event that is fired when a file system provider is about to be activated. Listeners
     * can join this event with a long running promise to help in the activation process.
     */
    readonly onWillActivateFileSystemProvider: Event$1<IFileSystemProviderActivationEvent>;
    /**
     * Registers a file system provider for a certain scheme.
     */
    registerProvider(scheme: string, provider: IFileSystemProvider): IDisposable;
    /**
     * Returns a file system provider for a certain scheme.
     */
    getProvider(scheme: string): IFileSystemProvider | undefined;
    /**
     * Tries to activate a provider with the given scheme.
     */
    activateProvider(scheme: string): Promise<void>;
    /**
     * Checks if this file service can handle the given resource by
     * first activating any extension that wants to be activated
     * on the provided resource scheme to include extensions that
     * contribute file system providers for the given resource.
     */
    canHandleResource(resource: URI): Promise<boolean>;
    /**
     * Checks if the file service has a registered provider for the
     * provided resource.
     *
     * Note: this does NOT account for contributed providers from
     * extensions that have not been activated yet. To include those,
     * consider to call `await fileService.canHandleResource(resource)`.
     */
    hasProvider(resource: URI): boolean;
    /**
     * Checks if the provider for the provided resource has the provided file system capability.
     */
    hasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean;
    /**
     * List the schemes and capabilities for registered file system providers
     */
    listCapabilities(): Iterable<{
        scheme: string;
        capabilities: FileSystemProviderCapabilities;
    }>;
    /**
     * Allows to listen for file changes. The event will fire for every file within the opened workspace
     * (if any) as well as all files that have been watched explicitly using the #watch() API.
     */
    readonly onDidFilesChange: Event$1<FileChangesEvent>;
    /**
     * An event that is fired upon successful completion of a certain file operation.
     */
    readonly onDidRunOperation: Event$1<FileOperationEvent>;
    /**
     * Resolve the properties of a file/folder identified by the resource. For a folder, children
     * information is resolved as well depending on the provided options. Use `stat()` method if
     * you do not need children information.
     *
     * If the optional parameter "resolveTo" is specified in options, the stat service is asked
     * to provide a stat object that should contain the full graph of folders up to all of the
     * target resources.
     *
     * If the optional parameter "resolveSingleChildDescendants" is specified in options,
     * the stat service is asked to automatically resolve child folders that only
     * contain a single element.
     *
     * If the optional parameter "resolveMetadata" is specified in options,
     * the stat will contain metadata information such as size, mtime and etag.
     */
    resolve(resource: URI, options: IResolveMetadataFileOptions): Promise<IFileStatWithMetadata>;
    resolve(resource: URI, options?: IResolveFileOptions): Promise<IFileStat>;
    /**
     * Same as `resolve()` but supports resolving multiple resources in parallel.
     *
     * If one of the resolve targets fails to resolve returns a fake `IFileStat` instead of
     * making the whole call fail.
     */
    resolveAll(toResolve: {
        resource: URI;
        options: IResolveMetadataFileOptions;
    }[]): Promise<IFileStatResult[]>;
    resolveAll(toResolve: {
        resource: URI;
        options?: IResolveFileOptions;
    }[]): Promise<IFileStatResult[]>;
    /**
     * Same as `resolve()` but without resolving the children of a folder if the
     * resource is pointing to a folder.
     */
    stat(resource: URI): Promise<IFileStatWithPartialMetadata>;
    /**
     * Finds out if a file/folder identified by the resource exists.
     */
    exists(resource: URI): Promise<boolean>;
    /**
     * Read the contents of the provided resource unbuffered.
     */
    readFile(resource: URI, options?: IReadFileOptions, token?: CancellationToken): Promise<IFileContent>;
    /**
     * Read the contents of the provided resource buffered as stream.
     */
    readFileStream(resource: URI, options?: IReadFileStreamOptions, token?: CancellationToken): Promise<IFileStreamContent>;
    /**
     * Updates the content replacing its previous value.
     *
     * Emits a `FileOperation.WRITE` file operation event when successful.
     */
    writeFile(resource: URI, bufferOrReadableOrStream: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: IWriteFileOptions): Promise<IFileStatWithMetadata>;
    /**
     * Moves the file/folder to a new path identified by the resource.
     *
     * The optional parameter overwrite can be set to replace an existing file at the location.
     *
     * Emits a `FileOperation.MOVE` file operation event when successful.
     */
    move(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;
    /**
     * Find out if a move operation is possible given the arguments. No changes on disk will
     * be performed. Returns an Error if the operation cannot be done.
     */
    canMove(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;
    /**
     * Copies the file/folder to a path identified by the resource. A folder is copied
     * recursively.
     *
     * Emits a `FileOperation.COPY` file operation event when successful.
     */
    copy(source: URI, target: URI, overwrite?: boolean): Promise<IFileStatWithMetadata>;
    /**
     * Find out if a copy operation is possible given the arguments. No changes on disk will
     * be performed. Returns an Error if the operation cannot be done.
     */
    canCopy(source: URI, target: URI, overwrite?: boolean): Promise<Error | true>;
    /**
     * Clones a file to a path identified by the resource. Folders are not supported.
     *
     * If the target path exists, it will be overwritten.
     */
    cloneFile(source: URI, target: URI): Promise<void>;
    /**
     * Creates a new file with the given path and optional contents. The returned promise
     * will have the stat model object as a result.
     *
     * The optional parameter content can be used as value to fill into the new file.
     *
     * Emits a `FileOperation.CREATE` file operation event when successful.
     */
    createFile(resource: URI, bufferOrReadableOrStream?: VSBuffer | VSBufferReadable | VSBufferReadableStream, options?: ICreateFileOptions): Promise<IFileStatWithMetadata>;
    /**
     * Find out if a file create operation is possible given the arguments. No changes on disk will
     * be performed. Returns an Error if the operation cannot be done.
     */
    canCreateFile(resource: URI, options?: ICreateFileOptions): Promise<Error | true>;
    /**
     * Creates a new folder with the given path. The returned promise
     * will have the stat model object as a result.
     *
     * Emits a `FileOperation.CREATE` file operation event when successful.
     */
    createFolder(resource: URI): Promise<IFileStatWithMetadata>;
    /**
     * Deletes the provided file. The optional useTrash parameter allows to
     * move the file to trash. The optional recursive parameter allows to delete
     * non-empty folders recursively.
     *
     * Emits a `FileOperation.DELETE` file operation event when successful.
     */
    del(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<void>;
    /**
     * Find out if a delete operation is possible given the arguments. No changes on disk will
     * be performed. Returns an Error if the operation cannot be done.
     */
    canDelete(resource: URI, options?: Partial<IFileDeleteOptions>): Promise<Error | true>;
    /**
     * An event that signals an error when watching for file changes.
     */
    readonly onDidWatchError: Event$1<Error>;
    /**
     * Allows to start a watcher that reports file/folder change events on the provided resource.
     *
     * Note: recursive file watching is not supported from this method. Only events from files
     * that are direct children of the provided resource will be reported.
     */
    watch(resource: URI, options?: IWatchOptions): IDisposable;
    /**
     * Frees up any resources occupied by this service.
     */
    dispose(): void;
}
interface IFileOverwriteOptions {
    /**
     * Set to `true` to overwrite a file if it exists. Will
     * throw an error otherwise if the file does exist.
     */
    readonly overwrite: boolean;
}
interface IFileUnlockOptions {
    /**
     * Set to `true` to try to remove any write locks the file might
     * have. A file that is write locked will throw an error for any
     * attempt to write to unless `unlock: true` is provided.
     */
    readonly unlock: boolean;
}
interface IFileReadLimits {
    /**
     * If the file exceeds the given size, an error of kind
     * `FILE_TOO_LARGE` will be thrown.
     */
    size?: number;
    /**
     * If the file exceeds the given size, an error of kind
     * `FILE_EXCEEDS_MEMORY_LIMIT` will be thrown.
     */
    memory?: number;
}
interface IFileReadStreamOptions {
    /**
     * Is an integer specifying where to begin reading from in the file. If position is undefined,
     * data will be read from the current file position.
     */
    readonly position?: number;
    /**
     * Is an integer specifying how many bytes to read from the file. By default, all bytes
     * will be read.
     */
    readonly length?: number;
    /**
     * If provided, the size of the file will be checked against the limits
     * and an error will be thrown if any limit is exceeded.
     */
    readonly limits?: IFileReadLimits;
}
interface IFileWriteOptions extends IFileOverwriteOptions, IFileUnlockOptions {
    /**
     * Set to `true` to create a file when it does not exist. Will
     * throw an error otherwise if the file does not exist.
     */
    readonly create: boolean;
}
type IFileOpenOptions = IFileOpenForReadOptions | IFileOpenForWriteOptions;
interface IFileOpenForReadOptions {
    /**
     * A hint that the file should be opened for reading only.
     */
    readonly create: false;
}
interface IFileOpenForWriteOptions extends IFileUnlockOptions {
    /**
     * A hint that the file should be opened for reading and writing.
     */
    readonly create: true;
}
interface IFileDeleteOptions {
    /**
     * Set to `true` to recursively delete any children of the file. This
     * only applies to folders and can lead to an error unless provided
     * if the folder is not empty.
     */
    readonly recursive: boolean;
    /**
     * Set to `true` to attempt to move the file to trash
     * instead of deleting it permanently from disk. This
     * option maybe not be supported on all providers.
     */
    readonly useTrash: boolean;
}
declare enum FileType {
    /**
     * File is unknown (neither file, directory nor symbolic link).
     */
    Unknown = 0,
    /**
     * File is a normal file.
     */
    File = 1,
    /**
     * File is a directory.
     */
    Directory = 2,
    /**
     * File is a symbolic link.
     *
     * Note: even when the file is a symbolic link, you can test for
     * `FileType.File` and `FileType.Directory` to know the type of
     * the target the link points to.
     */
    SymbolicLink = 64
}
declare enum FilePermission {
    /**
     * File is readonly.
     */
    Readonly = 1
}
interface IStat {
    /**
     * The file type.
     */
    readonly type: FileType;
    /**
     * The last modification date represented as millis from unix epoch.
     */
    readonly mtime: number;
    /**
     * The creation date represented as millis from unix epoch.
     */
    readonly ctime: number;
    /**
     * The size of the file in bytes.
     */
    readonly size: number;
    /**
     * The file permissions.
     */
    readonly permissions?: FilePermission;
}
interface IWatchOptions {
    /**
     * Set to `true` to watch for changes recursively in a folder
     * and all of its children.
     */
    readonly recursive: boolean;
    /**
     * A set of glob patterns or paths to exclude from watching.
     * Paths can be relative or absolute and when relative are
     * resolved against the watched folder. Glob patterns are
     * always matched relative to the watched folder.
     */
    excludes: string[];
    /**
     * An optional set of glob patterns or paths to include for
     * watching. If not provided, all paths are considered for
     * events.
     * Paths can be relative or absolute and when relative are
     * resolved against the watched folder. Glob patterns are
     * always matched relative to the watched folder.
     */
    includes?: Array<string | IRelativePattern>;
}
declare const enum FileSystemProviderCapabilities {
    /**
     * No capabilities.
     */
    None = 0,
    /**
     * Provider supports unbuffered read/write.
     */
    FileReadWrite = 2,
    /**
     * Provider supports open/read/write/close low level file operations.
     */
    FileOpenReadWriteClose = 4,
    /**
     * Provider supports stream based reading.
     */
    FileReadStream = 16,
    /**
     * Provider supports copy operation.
     */
    FileFolderCopy = 8,
    /**
     * Provider is path case sensitive.
     */
    PathCaseSensitive = 1024,
    /**
     * All files of the provider are readonly.
     */
    Readonly = 2048,
    /**
     * Provider supports to delete via trash.
     */
    Trash = 4096,
    /**
     * Provider support to unlock files for writing.
     */
    FileWriteUnlock = 8192,
    /**
     * Provider support to read files atomically. This implies the
     * provider provides the `FileReadWrite` capability too.
     */
    FileAtomicRead = 16384,
    /**
     * Provider support to clone files atomically.
     */
    FileClone = 32768
}
interface IFileSystemProvider {
    readonly capabilities: FileSystemProviderCapabilities;
    readonly onDidChangeCapabilities: Event$1<void>;
    readonly onDidChangeFile: Event$1<readonly IFileChange[]>;
    readonly onDidWatchError?: Event$1<string>;
    watch(resource: URI, opts: IWatchOptions): IDisposable;
    stat(resource: URI): Promise<IStat>;
    mkdir(resource: URI): Promise<void>;
    readdir(resource: URI): Promise<[string, FileType][]>;
    delete(resource: URI, opts: IFileDeleteOptions): Promise<void>;
    rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;
    copy?(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;
    readFile?(resource: URI): Promise<Uint8Array>;
    writeFile?(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void>;
    readFileStream?(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;
    open?(resource: URI, opts: IFileOpenOptions): Promise<number>;
    close?(fd: number): Promise<void>;
    read?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;
    write?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;
    cloneFile?(from: URI, to: URI): Promise<void>;
}
interface IFileSystemProviderRegistrationEvent {
    readonly added: boolean;
    readonly scheme: string;
    readonly provider?: IFileSystemProvider;
}
interface IFileSystemProviderCapabilitiesChangeEvent {
    readonly provider: IFileSystemProvider;
    readonly scheme: string;
}
interface IFileSystemProviderActivationEvent {
    readonly scheme: string;
    join(promise: Promise<void>): void;
}
declare const enum FileOperation {
    CREATE = 0,
    DELETE = 1,
    MOVE = 2,
    COPY = 3,
    WRITE = 4
}
interface IFileOperationEvent {
    readonly resource: URI;
    readonly operation: FileOperation;
    isOperation(operation: FileOperation.DELETE | FileOperation.WRITE): boolean;
    isOperation(operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY): this is IFileOperationEventWithMetadata;
}
interface IFileOperationEventWithMetadata extends IFileOperationEvent {
    readonly target: IFileStatWithMetadata;
}
declare class FileOperationEvent implements IFileOperationEvent {
    readonly resource: URI;
    readonly operation: FileOperation;
    readonly target?: IFileStatWithMetadata | undefined;
    constructor(resource: URI, operation: FileOperation.DELETE | FileOperation.WRITE);
    constructor(resource: URI, operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY, target: IFileStatWithMetadata);
    isOperation(operation: FileOperation.DELETE | FileOperation.WRITE): boolean;
    isOperation(operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY): this is IFileOperationEventWithMetadata;
}
/**
 * Possible changes that can occur to a file.
 */
declare const enum FileChangeType {
    UPDATED = 0,
    ADDED = 1,
    DELETED = 2
}
/**
 * Identifies a single change in a file.
 */
interface IFileChange {
    /**
     * The type of change that occurred to the file.
     */
    readonly type: FileChangeType;
    /**
     * The unified resource identifier of the file that changed.
     */
    readonly resource: URI;
}
declare class FileChangesEvent {
    private readonly added;
    private readonly updated;
    private readonly deleted;
    constructor(changes: readonly IFileChange[], ignorePathCasing: boolean);
    /**
     * Find out if the file change events match the provided resource.
     *
     * Note: when passing `FileChangeType.DELETED`, we consider a match
     * also when the parent of the resource got deleted.
     */
    contains(resource: URI, ...types: FileChangeType[]): boolean;
    /**
     * Find out if the file change events either match the provided
     * resource, or contain a child of this resource.
     */
    affects(resource: URI, ...types: FileChangeType[]): boolean;
    private doContains;
    /**
     * Returns if this event contains added files.
     */
    gotAdded(): boolean;
    /**
     * Returns if this event contains deleted files.
     */
    gotDeleted(): boolean;
    /**
     * Returns if this event contains updated files.
     */
    gotUpdated(): boolean;
    /**
     * @deprecated use the `contains` or `affects` method to efficiently find
     * out if the event relates to a given resource. these methods ensure:
     * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
     * - correctly handles `FileChangeType.DELETED` events
     */
    readonly rawAdded: URI[];
    /**
    * @deprecated use the `contains` or `affects` method to efficiently find
    * out if the event relates to a given resource. these methods ensure:
    * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
    * - correctly handles `FileChangeType.DELETED` events
    */
    readonly rawUpdated: URI[];
    /**
    * @deprecated use the `contains` or `affects` method to efficiently find
    * out if the event relates to a given resource. these methods ensure:
    * - that there is no expensive lookup needed (by using a `TernarySearchTree`)
    * - correctly handles `FileChangeType.DELETED` events
    */
    readonly rawDeleted: URI[];
}
interface IBaseFileStat {
    /**
     * The unified resource identifier of this file or folder.
     */
    readonly resource: URI;
    /**
     * The name which is the last segment
     * of the {{path}}.
     */
    readonly name: string;
    /**
     * The size of the file.
     *
     * The value may or may not be resolved as
     * it is optional.
     */
    readonly size?: number;
    /**
     * The last modification date represented as millis from unix epoch.
     *
     * The value may or may not be resolved as
     * it is optional.
     */
    readonly mtime?: number;
    /**
     * The creation date represented as millis from unix epoch.
     *
     * The value may or may not be resolved as
     * it is optional.
     */
    readonly ctime?: number;
    /**
     * A unique identifier that represents the
     * current state of the file or directory.
     *
     * The value may or may not be resolved as
     * it is optional.
     */
    readonly etag?: string;
    /**
     * The file is read-only.
     */
    readonly readonly?: boolean;
}
interface IBaseFileStatWithMetadata extends Required<IBaseFileStat> {
}
/**
 * A file resource with meta information and resolved children if any.
 */
interface IFileStat extends IBaseFileStat {
    /**
     * The resource is a file.
     */
    readonly isFile: boolean;
    /**
     * The resource is a directory.
     */
    readonly isDirectory: boolean;
    /**
     * The resource is a symbolic link. Note: even when the
     * file is a symbolic link, you can test for `FileType.File`
     * and `FileType.Directory` to know the type of the target
     * the link points to.
     */
    readonly isSymbolicLink: boolean;
    /**
     * The children of the file stat or undefined if none.
     */
    children: IFileStat[] | undefined;
}
interface IFileStatWithMetadata extends IFileStat, IBaseFileStatWithMetadata {
    readonly mtime: number;
    readonly ctime: number;
    readonly etag: string;
    readonly size: number;
    readonly readonly: boolean;
    readonly children: IFileStatWithMetadata[] | undefined;
}
interface IFileStatResult {
    readonly stat?: IFileStat;
    readonly success: boolean;
}
interface IFileStatWithPartialMetadata extends Omit<IFileStatWithMetadata, 'children'> {
}
interface IFileContent extends IBaseFileStatWithMetadata {
    /**
     * The content of a file as buffer.
     */
    readonly value: VSBuffer;
}
interface IFileStreamContent extends IBaseFileStatWithMetadata {
    /**
     * The content of a file as stream.
     */
    readonly value: VSBufferReadableStream;
}
interface IBaseReadFileOptions extends IFileReadStreamOptions {
    /**
     * The optional etag parameter allows to return early from resolving the resource if
     * the contents on disk match the etag. This prevents accumulated reading of resources
     * that have been read already with the same etag.
     * It is the task of the caller to makes sure to handle this error case from the promise.
     */
    readonly etag?: string;
}
interface IReadFileStreamOptions extends IBaseReadFileOptions {
}
interface IReadFileOptions extends IBaseReadFileOptions {
    /**
     * The optional `atomic` flag can be used to make sure
     * the `readFile` method is not running in parallel with
     * any `write` operations in the same process.
     *
     * Typically you should not need to use this flag but if
     * for example you are quickly reading a file right after
     * a file event occurred and the file changes a lot, there
     * is a chance that a read returns an empty or partial file
     * because a pending write has not finished yet.
     *
     * Note: this does not prevent the file from being written
     * to from a different process. If you need such atomic
     * operations, you better use a real database as storage.
     */
    readonly atomic?: boolean;
}
interface IWriteFileOptions {
    /**
     * The last known modification time of the file. This can be used to prevent dirty writes.
     */
    readonly mtime?: number;
    /**
     * The etag of the file. This can be used to prevent dirty writes.
     */
    readonly etag?: string;
    /**
     * Whether to attempt to unlock a file before writing.
     */
    readonly unlock?: boolean;
}
interface IResolveFileOptions {
    /**
     * Automatically continue resolving children of a directory until the provided resources
     * are found.
     */
    readonly resolveTo?: readonly URI[];
    /**
     * Automatically continue resolving children of a directory if the number of children is 1.
     */
    readonly resolveSingleChildDescendants?: boolean;
    /**
     * Will resolve mtime, ctime, size and etag of files if enabled. This can have a negative impact
     * on performance and thus should only be used when these values are required.
     */
    readonly resolveMetadata?: boolean;
}
interface IResolveMetadataFileOptions extends IResolveFileOptions {
    readonly resolveMetadata: true;
}
interface ICreateFileOptions {
    /**
     * Overwrite the file to create if it already exists on disk. Otherwise
     * an error will be thrown (FILE_MODIFIED_SINCE).
     */
    readonly overwrite?: boolean;
}

declare enum LogLevel {
    Off = 0,
    Trace = 1,
    Debug = 2,
    Info = 3,
    Warning = 4,
    Error = 5
}
interface ILogger extends IDisposable {
    onDidChangeLogLevel: Event$1<LogLevel>;
    getLevel(): LogLevel;
    setLevel(level: LogLevel): void;
    trace(message: string, ...args: any[]): void;
    debug(message: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
    error(message: string | Error, ...args: any[]): void;
    /**
     * An operation to flush the contents. Can be synchronous.
     */
    flush(): void;
}
declare const ILogService: ServiceIdentifier<ILogService>;
interface ILogService extends ILogger {
    readonly _serviceBrand: undefined;
}

interface IExtUri {
    /**
     * Compares two uris.
     *
     * @param uri1 Uri
     * @param uri2 Uri
     * @param ignoreFragment Ignore the fragment (defaults to `false`)
     */
    compare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;
    /**
     * Tests whether two uris are equal
     *
     * @param uri1 Uri
     * @param uri2 Uri
     * @param ignoreFragment Ignore the fragment (defaults to `false`)
     */
    isEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;
    /**
     * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.
     *
     * @param base A uri which is "longer" or at least same length as `parentCandidate`
     * @param parentCandidate A uri which is "shorter" or up to same length as `base`
     * @param ignoreFragment Ignore the fragment (defaults to `false`)
     */
    isEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;
    /**
     * Creates a key from a resource URI to be used to resource comparison and for resource maps.
     * @see {@link ResourceMap}
     * @param uri Uri
     * @param ignoreFragment Ignore the fragment (defaults to `false`)
     */
    getComparisonKey(uri: URI, ignoreFragment?: boolean): string;
    /**
     * Whether the casing of the path-component of the uri should be ignored.
     */
    ignorePathCasing(uri: URI): boolean;
    basenameOrAuthority(resource: URI): string;
    /**
     * Returns the basename of the path component of an uri.
     * @param resource
     */
    basename(resource: URI): string;
    /**
     * Returns the extension of the path component of an uri.
     * @param resource
     */
    extname(resource: URI): string;
    /**
     * Return a URI representing the directory of a URI path.
     *
     * @param resource The input URI.
     * @returns The URI representing the directory of the input URI.
     */
    dirname(resource: URI): URI;
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param resource The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    joinPath(resource: URI, ...pathFragment: string[]): URI;
    /**
     * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.
     *
     * @param resource The URI to normalize the path.
     * @returns The URI with the normalized path.
     */
    normalizePath(resource: URI): URI;
    /**
     *
     * @param from
     * @param to
     */
    relativePath(from: URI, to: URI): string | undefined;
    /**
     * Resolves an absolute or relative path against a base URI.
     * The path can be relative or absolute posix or a Windows path
     */
    resolvePath(base: URI, path: string): URI;
    /**
     * Returns true if the URI path is absolute.
     */
    isAbsolutePath(resource: URI): boolean;
    /**
     * Tests whether the two authorities are the same
     */
    isEqualAuthority(a1: string, a2: string): boolean;
    /**
     * Returns true if the URI path has a trailing path separator
     */
    hasTrailingPathSeparator(resource: URI, sep?: string): boolean;
    /**
     * Removes a trailing path separator, if there's one.
     * Important: Doesn't remove the first slash, it would make the URI invalid
     */
    removeTrailingPathSeparator(resource: URI, sep?: string): URI;
    /**
     * Adds a trailing path separator to the URI if there isn't one already.
     * For example, c:\ would be unchanged, but c:\users would become c:\users\
     */
    addTrailingPathSeparator(resource: URI, sep?: string): URI;
}

declare const IUriIdentityService: ServiceIdentifier<IUriIdentityService>;
interface IUriIdentityService {
    readonly _serviceBrand: undefined;
    /**
     * Uri extensions that are aware of casing.
     */
    readonly extUri: IExtUri;
    /**
     * Returns a canonical uri for the given resource. Different uris can point to the same
     * resource. That's because of casing or missing normalization, e.g the following uris
     * are different but refer to the same document (because windows paths are not case-sensitive)
     *
     * ```txt
     * file:///c:/foo/bar.txt
     * file:///c:/FOO/BAR.txt
     * ```
     *
     * This function should be invoked when feeding uris into the system that represent the truth,
     * e.g document uris or marker-to-document associations etc. This function should NOT be called
     * to pretty print a label nor to sanitize a uri.
     *
     * Samples:
     *
     * | in | out | |
     * |---|---|---|
     * | `file:///foo/bar/../bar` | `file:///foo/bar` | n/a |
     * | `file:///foo/bar/../bar#frag` | `file:///foo/bar#frag` | keep fragment |
     * | `file:///foo/BAR` | `file:///foo/bar` | assume ignore case |
     * | `file:///foo/bar/../BAR?q=2` | `file:///foo/BAR?q=2` | query makes it a different document |
     */
    asCanonicalUri(uri: URI): URI;
}

/**
 * Flags to indicate whether to use the default profile or not.
 */
type UseDefaultProfileFlags = {
    settings?: boolean;
    keybindings?: boolean;
    tasks?: boolean;
    snippets?: boolean;
    extensions?: boolean;
    uiState?: boolean;
};
interface IUserDataProfile {
    readonly id: string;
    readonly isDefault: boolean;
    readonly name: string;
    readonly shortName?: string;
    readonly location: URI;
    readonly globalStorageHome: URI;
    readonly settingsResource: URI;
    readonly keybindingsResource: URI;
    readonly tasksResource: URI;
    readonly snippetsHome: URI;
    readonly extensionsResource: URI;
    readonly useDefaultFlags?: UseDefaultProfileFlags;
    readonly isTransient?: boolean;
}

declare enum WillSaveStateReason {
    /**
     * No specific reason to save state.
     */
    NONE = 0,
    /**
     * A hint that the workbench is about to shutdown.
     */
    SHUTDOWN = 1
}
interface IWillSaveStateEvent {
    readonly reason: WillSaveStateReason;
}
declare const IStorageService: ServiceIdentifier<IStorageService>;
interface IStorageService {
    readonly _serviceBrand: undefined;
    /**
     * Emitted whenever data is updated or deleted.
     */
    readonly onDidChangeValue: Event$1<IStorageValueChangeEvent>;
    /**
     * Emitted whenever target of a storage entry changes.
     */
    readonly onDidChangeTarget: Event$1<IStorageTargetChangeEvent>;
    /**
     * Emitted when the storage is about to persist. This is the right time
     * to persist data to ensure it is stored before the application shuts
     * down.
     *
     * The will save state event allows to optionally ask for the reason of
     * saving the state, e.g. to find out if the state is saved due to a
     * shutdown.
     *
     * Note: this event may be fired many times, not only on shutdown to prevent
     * loss of state in situations where the shutdown is not sufficient to
     * persist the data properly.
     */
    readonly onWillSaveState: Event$1<IWillSaveStateEvent>;
    /**
     * Retrieve an element stored with the given key from storage. Use
     * the provided `defaultValue` if the element is `null` or `undefined`.
     *
     * @param scope allows to define the scope of the storage operation
     * to either the current workspace only, all workspaces or all profiles.
     */
    get(key: string, scope: StorageScope, fallbackValue: string): string;
    get(key: string, scope: StorageScope, fallbackValue?: string): string | undefined;
    /**
     * Retrieve an element stored with the given key from storage. Use
     * the provided `defaultValue` if the element is `null` or `undefined`.
     * The element will be converted to a `boolean`.
     *
     * @param scope allows to define the scope of the storage operation
     * to either the current workspace only, all workspaces or all profiles.
     */
    getBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;
    getBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined;
    /**
     * Retrieve an element stored with the given key from storage. Use
     * the provided `defaultValue` if the element is `null` or `undefined`.
     * The element will be converted to a `number` using `parseInt` with a
     * base of `10`.
     *
     * @param scope allows to define the scope of the storage operation
     * to either the current workspace only, all workspaces or all profiles.
     */
    getNumber(key: string, scope: StorageScope, fallbackValue: number): number;
    getNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined;
    /**
     * Store a value under the given key to storage. The value will be
     * converted to a `string`. Storing either `undefined` or `null` will
     * remove the entry under the key.
     *
     * @param scope allows to define the scope of the storage operation
     * to either the current workspace only, all workspaces or all profiles.
     *
     * @param target allows to define the target of the storage operation
     * to either the current machine or user.
     */
    store(key: string, value: string | boolean | number | undefined | null, scope: StorageScope, target: StorageTarget): void;
    /**
     * Delete an element stored under the provided key from storage.
     *
     * The scope argument allows to define the scope of the storage
     * operation to either the current workspace only, all workspaces
     * or all profiles.
     */
    remove(key: string, scope: StorageScope): void;
    /**
     * Returns all the keys used in the storage for the provided `scope`
     * and `target`.
     *
     * Note: this will NOT return all keys stored in the storage layer.
     * Some keys may not have an associated `StorageTarget` and thus
     * will be excluded from the results.
     *
     * @param scope allows to define the scope for the keys
     * to either the current workspace only, all workspaces or all profiles.
     *
     * @param target allows to define the target for the keys
     * to either the current machine or user.
     */
    keys(scope: StorageScope, target: StorageTarget): string[];
    /**
     * Log the contents of the storage to the console.
     */
    log(): void;
    /**
     * Returns true if the storage service handles the provided scope.
     */
    hasScope(scope: IAnyWorkspaceIdentifier | IUserDataProfile): boolean;
    /**
     * Switch storage to another workspace or profile. Optionally preserve the
     * current data to the new storage.
     */
    switch(to: IAnyWorkspaceIdentifier | IUserDataProfile, preserveData: boolean): Promise<void>;
    /**
     * Whether the storage for the given scope was created during this session or
     * existed before.
     */
    isNew(scope: StorageScope): boolean;
    /**
     * Allows to flush state, e.g. in cases where a shutdown is
     * imminent. This will send out the `onWillSaveState` to ask
     * everyone for latest state.
     *
     * @returns a `Promise` that can be awaited on when all updates
     * to the underlying storage have been flushed.
     */
    flush(reason?: WillSaveStateReason): Promise<void>;
}
declare const enum StorageScope {
    /**
     * The stored data will be scoped to all workspaces across all profiles.
     */
    APPLICATION = -1,
    /**
     * The stored data will be scoped to all workspaces of the same profile.
     */
    PROFILE = 0,
    /**
     * The stored data will be scoped to the current workspace.
     */
    WORKSPACE = 1
}
declare const enum StorageTarget {
    /**
     * The stored data is user specific and applies across machines.
     */
    USER = 0,
    /**
     * The stored data is machine specific.
     */
    MACHINE = 1
}
interface IStorageValueChangeEvent {
    /**
     * The scope for the storage entry that changed
     * or was removed.
     */
    readonly scope: StorageScope;
    /**
     * The `key` of the storage entry that was changed
     * or was removed.
     */
    readonly key: string;
    /**
     * The `target` can be `undefined` if a key is being
     * removed.
     */
    readonly target: StorageTarget | undefined;
}
interface IStorageTargetChangeEvent {
    /**
     * The scope for the target that changed. Listeners
     * should use `keys(scope, target)` to get an updated
     * list of keys for the given `scope` and `target`.
     */
    readonly scope: StorageScope;
}

/**
 * Virtual Key Codes, the value does not hold any inherent meaning.
 * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
 * But these are "more general", as they should work across browsers & OS`s.
 */
declare const enum KeyCode {
    DependsOnKbLayout = -1,
    /**
     * Placed first to cover the 0 value of the enum.
     */
    Unknown = 0,
    Backspace = 1,
    Tab = 2,
    Enter = 3,
    Shift = 4,
    Ctrl = 5,
    Alt = 6,
    PauseBreak = 7,
    CapsLock = 8,
    Escape = 9,
    Space = 10,
    PageUp = 11,
    PageDown = 12,
    End = 13,
    Home = 14,
    LeftArrow = 15,
    UpArrow = 16,
    RightArrow = 17,
    DownArrow = 18,
    Insert = 19,
    Delete = 20,
    Digit0 = 21,
    Digit1 = 22,
    Digit2 = 23,
    Digit3 = 24,
    Digit4 = 25,
    Digit5 = 26,
    Digit6 = 27,
    Digit7 = 28,
    Digit8 = 29,
    Digit9 = 30,
    KeyA = 31,
    KeyB = 32,
    KeyC = 33,
    KeyD = 34,
    KeyE = 35,
    KeyF = 36,
    KeyG = 37,
    KeyH = 38,
    KeyI = 39,
    KeyJ = 40,
    KeyK = 41,
    KeyL = 42,
    KeyM = 43,
    KeyN = 44,
    KeyO = 45,
    KeyP = 46,
    KeyQ = 47,
    KeyR = 48,
    KeyS = 49,
    KeyT = 50,
    KeyU = 51,
    KeyV = 52,
    KeyW = 53,
    KeyX = 54,
    KeyY = 55,
    KeyZ = 56,
    Meta = 57,
    ContextMenu = 58,
    F1 = 59,
    F2 = 60,
    F3 = 61,
    F4 = 62,
    F5 = 63,
    F6 = 64,
    F7 = 65,
    F8 = 66,
    F9 = 67,
    F10 = 68,
    F11 = 69,
    F12 = 70,
    F13 = 71,
    F14 = 72,
    F15 = 73,
    F16 = 74,
    F17 = 75,
    F18 = 76,
    F19 = 77,
    NumLock = 78,
    ScrollLock = 79,
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ';:' key
     */
    Semicolon = 80,
    /**
     * For any country/region, the '+' key
     * For the US standard keyboard, the '=+' key
     */
    Equal = 81,
    /**
     * For any country/region, the ',' key
     * For the US standard keyboard, the ',<' key
     */
    Comma = 82,
    /**
     * For any country/region, the '-' key
     * For the US standard keyboard, the '-_' key
     */
    Minus = 83,
    /**
     * For any country/region, the '.' key
     * For the US standard keyboard, the '.>' key
     */
    Period = 84,
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '/?' key
     */
    Slash = 85,
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '`~' key
     */
    Backquote = 86,
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '[{' key
     */
    BracketLeft = 87,
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '\|' key
     */
    Backslash = 88,
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ']}' key
     */
    BracketRight = 89,
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ''"' key
     */
    Quote = 90,
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     */
    OEM_8 = 91,
    /**
     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
     */
    IntlBackslash = 92,
    Numpad0 = 93,
    Numpad1 = 94,
    Numpad2 = 95,
    Numpad3 = 96,
    Numpad4 = 97,
    Numpad5 = 98,
    Numpad6 = 99,
    Numpad7 = 100,
    Numpad8 = 101,
    Numpad9 = 102,
    NumpadMultiply = 103,
    NumpadAdd = 104,
    NUMPAD_SEPARATOR = 105,
    NumpadSubtract = 106,
    NumpadDecimal = 107,
    NumpadDivide = 108,
    /**
     * Cover all key codes when IME is processing input.
     */
    KEY_IN_COMPOSITION = 109,
    ABNT_C1 = 110,
    ABNT_C2 = 111,
    AudioVolumeMute = 112,
    AudioVolumeUp = 113,
    AudioVolumeDown = 114,
    BrowserSearch = 115,
    BrowserHome = 116,
    BrowserBack = 117,
    BrowserForward = 118,
    MediaTrackNext = 119,
    MediaTrackPrevious = 120,
    MediaStop = 121,
    MediaPlayPause = 122,
    LaunchMediaPlayer = 123,
    LaunchMail = 124,
    LaunchApp2 = 125,
    /**
     * VK_CLEAR, 0x0C, CLEAR key
     */
    Clear = 126,
    /**
     * Placed last to cover the length of the enum.
     * Please do not depend on this value!
     */
    MAX_VALUE = 127
}
/**
 * keyboardEvent.code
 */
declare const enum ScanCode {
    DependsOnKbLayout = -1,
    None = 0,
    Hyper = 1,
    Super = 2,
    Fn = 3,
    FnLock = 4,
    Suspend = 5,
    Resume = 6,
    Turbo = 7,
    Sleep = 8,
    WakeUp = 9,
    KeyA = 10,
    KeyB = 11,
    KeyC = 12,
    KeyD = 13,
    KeyE = 14,
    KeyF = 15,
    KeyG = 16,
    KeyH = 17,
    KeyI = 18,
    KeyJ = 19,
    KeyK = 20,
    KeyL = 21,
    KeyM = 22,
    KeyN = 23,
    KeyO = 24,
    KeyP = 25,
    KeyQ = 26,
    KeyR = 27,
    KeyS = 28,
    KeyT = 29,
    KeyU = 30,
    KeyV = 31,
    KeyW = 32,
    KeyX = 33,
    KeyY = 34,
    KeyZ = 35,
    Digit1 = 36,
    Digit2 = 37,
    Digit3 = 38,
    Digit4 = 39,
    Digit5 = 40,
    Digit6 = 41,
    Digit7 = 42,
    Digit8 = 43,
    Digit9 = 44,
    Digit0 = 45,
    Enter = 46,
    Escape = 47,
    Backspace = 48,
    Tab = 49,
    Space = 50,
    Minus = 51,
    Equal = 52,
    BracketLeft = 53,
    BracketRight = 54,
    Backslash = 55,
    IntlHash = 56,
    Semicolon = 57,
    Quote = 58,
    Backquote = 59,
    Comma = 60,
    Period = 61,
    Slash = 62,
    CapsLock = 63,
    F1 = 64,
    F2 = 65,
    F3 = 66,
    F4 = 67,
    F5 = 68,
    F6 = 69,
    F7 = 70,
    F8 = 71,
    F9 = 72,
    F10 = 73,
    F11 = 74,
    F12 = 75,
    PrintScreen = 76,
    ScrollLock = 77,
    Pause = 78,
    Insert = 79,
    Home = 80,
    PageUp = 81,
    Delete = 82,
    End = 83,
    PageDown = 84,
    ArrowRight = 85,
    ArrowLeft = 86,
    ArrowDown = 87,
    ArrowUp = 88,
    NumLock = 89,
    NumpadDivide = 90,
    NumpadMultiply = 91,
    NumpadSubtract = 92,
    NumpadAdd = 93,
    NumpadEnter = 94,
    Numpad1 = 95,
    Numpad2 = 96,
    Numpad3 = 97,
    Numpad4 = 98,
    Numpad5 = 99,
    Numpad6 = 100,
    Numpad7 = 101,
    Numpad8 = 102,
    Numpad9 = 103,
    Numpad0 = 104,
    NumpadDecimal = 105,
    IntlBackslash = 106,
    ContextMenu = 107,
    Power = 108,
    NumpadEqual = 109,
    F13 = 110,
    F14 = 111,
    F15 = 112,
    F16 = 113,
    F17 = 114,
    F18 = 115,
    F19 = 116,
    F20 = 117,
    F21 = 118,
    F22 = 119,
    F23 = 120,
    F24 = 121,
    Open = 122,
    Help = 123,
    Select = 124,
    Again = 125,
    Undo = 126,
    Cut = 127,
    Copy = 128,
    Paste = 129,
    Find = 130,
    AudioVolumeMute = 131,
    AudioVolumeUp = 132,
    AudioVolumeDown = 133,
    NumpadComma = 134,
    IntlRo = 135,
    KanaMode = 136,
    IntlYen = 137,
    Convert = 138,
    NonConvert = 139,
    Lang1 = 140,
    Lang2 = 141,
    Lang3 = 142,
    Lang4 = 143,
    Lang5 = 144,
    Abort = 145,
    Props = 146,
    NumpadParenLeft = 147,
    NumpadParenRight = 148,
    NumpadBackspace = 149,
    NumpadMemoryStore = 150,
    NumpadMemoryRecall = 151,
    NumpadMemoryClear = 152,
    NumpadMemoryAdd = 153,
    NumpadMemorySubtract = 154,
    NumpadClear = 155,
    NumpadClearEntry = 156,
    ControlLeft = 157,
    ShiftLeft = 158,
    AltLeft = 159,
    MetaLeft = 160,
    ControlRight = 161,
    ShiftRight = 162,
    AltRight = 163,
    MetaRight = 164,
    BrightnessUp = 165,
    BrightnessDown = 166,
    MediaPlay = 167,
    MediaRecord = 168,
    MediaFastForward = 169,
    MediaRewind = 170,
    MediaTrackNext = 171,
    MediaTrackPrevious = 172,
    MediaStop = 173,
    Eject = 174,
    MediaPlayPause = 175,
    MediaSelect = 176,
    LaunchMail = 177,
    LaunchApp2 = 178,
    LaunchApp1 = 179,
    SelectTask = 180,
    LaunchScreenSaver = 181,
    BrowserSearch = 182,
    BrowserHome = 183,
    BrowserBack = 184,
    BrowserForward = 185,
    BrowserStop = 186,
    BrowserRefresh = 187,
    BrowserFavorites = 188,
    ZoomToggle = 189,
    MailReply = 190,
    MailForward = 191,
    MailSend = 192,
    MAX_VALUE = 193
}

type PlatformName = 'Web' | 'Windows' | 'Mac' | 'Linux';
declare const enum OperatingSystem {
    Windows = 1,
    Macintosh = 2,
    Linux = 3
}

interface Modifiers {
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly altKey: boolean;
    readonly metaKey: boolean;
}
/**
 * Represents a chord which uses the `keyCode` field of keyboard events.
 * A chord is a combination of keys pressed simultaneously.
 */
declare class KeyCodeChord implements Modifiers {
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly altKey: boolean;
    readonly metaKey: boolean;
    readonly keyCode: KeyCode;
    constructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean, keyCode: KeyCode);
    equals(other: Chord): boolean;
    getHashCode(): string;
    isModifierKey(): boolean;
    toKeybinding(): Keybinding;
    /**
     * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
     */
    isDuplicateModifierCase(): boolean;
}
/**
 * Represents a chord which uses the `code` field of keyboard events.
 * A chord is a combination of keys pressed simultaneously.
 */
declare class ScanCodeChord implements Modifiers {
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly altKey: boolean;
    readonly metaKey: boolean;
    readonly scanCode: ScanCode;
    constructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean, scanCode: ScanCode);
    equals(other: Chord): boolean;
    getHashCode(): string;
    /**
     * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
     */
    isDuplicateModifierCase(): boolean;
}
type Chord = KeyCodeChord | ScanCodeChord;
/**
 * A keybinding is a sequence of chords.
 */
declare class Keybinding {
    readonly chords: Chord[];
    constructor(chords: Chord[]);
    getHashCode(): string;
    equals(other: Keybinding | null): boolean;
}
declare class ResolvedChord {
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly altKey: boolean;
    readonly metaKey: boolean;
    readonly keyLabel: string | null;
    readonly keyAriaLabel: string | null;
    constructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean, keyLabel: string | null, keyAriaLabel: string | null);
}
type SingleModifierChord = 'ctrl' | 'shift' | 'alt' | 'meta';
/**
 * A resolved keybinding. Consists of one or multiple chords.
 */
declare abstract class ResolvedKeybinding {
    /**
     * This prints the binding in a format suitable for displaying in the UI.
     */
    abstract getLabel(): string | null;
    /**
     * This prints the binding in a format suitable for ARIA.
     */
    abstract getAriaLabel(): string | null;
    /**
     * This prints the binding in a format suitable for electron's accelerators.
     * See https://github.com/electron/electron/blob/master/docs/api/accelerator.md
     */
    abstract getElectronAccelerator(): string | null;
    /**
     * This prints the binding in a format suitable for user settings.
     */
    abstract getUserSettingsLabel(): string | null;
    /**
     * Is the user settings label reflecting the label?
     */
    abstract isWYSIWYG(): boolean;
    /**
     * Does the keybinding consist of more than one chord?
     */
    abstract hasMultipleChords(): boolean;
    /**
     * Returns the chords that comprise of the keybinding.
     */
    abstract getChords(): ResolvedChord[];
    /**
     * Returns the chords as strings useful for dispatching.
     * Returns null for modifier only chords.
     * @example keybinding "Shift" -> null
     * @example keybinding ("D" with shift == true) -> "shift+D"
     */
    abstract getDispatchChords(): (string | null)[];
    /**
     * Returns the modifier only chords as strings useful for dispatching.
     * Returns null for chords that contain more than one modifier or a regular key.
     * @example keybinding "Shift" -> "shift"
     * @example keybinding ("D" with shift == true") -> null
     */
    abstract getSingleModifierDispatchChords(): (SingleModifierChord | null)[];
}

interface IKeyboardEvent$1 {
    readonly _standardKeyboardEventBrand: true;
    readonly browserEvent: KeyboardEvent;
    readonly target: HTMLElement;
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly altKey: boolean;
    readonly metaKey: boolean;
    readonly altGraphKey: boolean;
    readonly keyCode: KeyCode;
    readonly code: string;
    /**
     * @internal
     */
    toKeyCodeChord(): KeyCodeChord;
    equals(keybinding: number): boolean;
    preventDefault(): void;
    stopPropagation(): void;
}

interface IMouseEvent {
    readonly browserEvent: MouseEvent;
    readonly leftButton: boolean;
    readonly middleButton: boolean;
    readonly rightButton: boolean;
    readonly buttons: number;
    readonly target: HTMLElement;
    readonly detail: number;
    readonly posx: number;
    readonly posy: number;
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly altKey: boolean;
    readonly metaKey: boolean;
    readonly timestamp: number;
    preventDefault(): void;
    stopPropagation(): void;
}

interface IDimension$1 {
    width: number;
    height: number;
}

/**
 * A model for the diff editor.
 */
interface IDiffEditorModel {
    /**
     * Original model.
     */
    original: ITextModel;
    /**
     * Modified model.
     */
    modified: ITextModel;
}
interface IEditorAction {
    readonly id: string;
    readonly label: string;
    readonly alias: string;
    isSupported(): boolean;
    run(): Promise<void>;
}
type IEditorModel = ITextModel | IDiffEditorModel;
/**
 * A (serializable) state of the cursors.
 */
interface ICursorState {
    inSelectionMode: boolean;
    selectionStart: IPosition;
    position: IPosition;
}
/**
 * A (serializable) state of the view.
 */
interface IViewState {
    /** written by previous versions */
    scrollTop?: number;
    /** written by previous versions */
    scrollTopWithoutViewZones?: number;
    scrollLeft: number;
    firstPosition: IPosition;
    firstPositionDeltaTop: number;
}
/**
 * A (serializable) state of the code editor.
 */
interface ICodeEditorViewState {
    cursorState: ICursorState[];
    viewState: IViewState;
    contributionsState: {
        [id: string]: any;
    };
}
/**
 * (Serializable) View state for the diff editor.
 */
interface IDiffEditorViewState {
    original: ICodeEditorViewState | null;
    modified: ICodeEditorViewState | null;
}
/**
 * An editor view state.
 */
type IEditorViewState = ICodeEditorViewState | IDiffEditorViewState;
declare const enum ScrollType {
    Smooth = 0,
    Immediate = 1
}
/**
 * An editor.
 */
interface IEditor {
    /**
     * An event emitted when the editor has been disposed.
     * @event
     */
    onDidDispose(listener: () => void): IDisposable;
    /**
     * Dispose the editor.
     */
    dispose(): void;
    /**
     * Get a unique id for this editor instance.
     */
    getId(): string;
    /**
     * Get the editor type. Please see `EditorType`.
     * This is to avoid an instanceof check
     */
    getEditorType(): string;
    /**
     * Update the editor's options after the editor has been created.
     */
    updateOptions(newOptions: IEditorOptions$1): void;
    /**
     * Indicates that the editor becomes visible.
     * @internal
     */
    onVisible(): void;
    /**
     * Indicates that the editor becomes hidden.
     * @internal
     */
    onHide(): void;
    /**
     * Instructs the editor to remeasure its container. This method should
     * be called when the container of the editor gets resized.
     *
     * If a dimension is passed in, the passed in value will be used.
     */
    layout(dimension?: IDimension$1): void;
    /**
     * Brings browser focus to the editor text
     */
    focus(): void;
    /**
     * Returns true if the text inside this editor is focused (i.e. cursor is blinking).
     */
    hasTextFocus(): boolean;
    /**
     * Returns all actions associated with this editor.
     */
    getSupportedActions(): IEditorAction[];
    /**
     * Saves current view state of the editor in a serializable object.
     */
    saveViewState(): IEditorViewState | null;
    /**
     * Restores the view state of the editor from a serializable object generated by `saveViewState`.
     */
    restoreViewState(state: IEditorViewState | null): void;
    /**
     * Given a position, returns a column number that takes tab-widths into account.
     */
    getVisibleColumnFromPosition(position: IPosition): number;
    /**
     * Given a position, returns a column number that takes tab-widths into account.
     * @internal
     */
    getStatusbarColumn(position: IPosition): number;
    /**
     * Returns the primary position of the cursor.
     */
    getPosition(): Position$1 | null;
    /**
     * Set the primary position of the cursor. This will remove any secondary cursors.
     * @param position New primary cursor's position
     * @param source Source of the call that caused the position
     */
    setPosition(position: IPosition, source?: string): void;
    /**
     * Scroll vertically as necessary and reveal a line.
     */
    revealLine(lineNumber: number, scrollType?: ScrollType): void;
    /**
     * Scroll vertically as necessary and reveal a line centered vertically.
     */
    revealLineInCenter(lineNumber: number, scrollType?: ScrollType): void;
    /**
     * Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
     */
    revealLineInCenterIfOutsideViewport(lineNumber: number, scrollType?: ScrollType): void;
    /**
     * Scroll vertically as necessary and reveal a line close to the top of the viewport,
     * optimized for viewing a code definition.
     */
    revealLineNearTop(lineNumber: number, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a position.
     */
    revealPosition(position: IPosition, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a position centered vertically.
     */
    revealPositionInCenter(position: IPosition, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
     */
    revealPositionInCenterIfOutsideViewport(position: IPosition, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a position close to the top of the viewport,
     * optimized for viewing a code definition.
     */
    revealPositionNearTop(position: IPosition, scrollType?: ScrollType): void;
    /**
     * Returns the primary selection of the editor.
     */
    getSelection(): Selection | null;
    /**
     * Returns all the selections of the editor.
     */
    getSelections(): Selection[] | null;
    /**
     * Set the primary selection of the editor. This will remove any secondary cursors.
     * @param selection The new selection
     * @param source Source of the call that caused the selection
     */
    setSelection(selection: IRange, source?: string): void;
    /**
     * Set the primary selection of the editor. This will remove any secondary cursors.
     * @param selection The new selection
     * @param source Source of the call that caused the selection
     */
    setSelection(selection: Range, source?: string): void;
    /**
     * Set the primary selection of the editor. This will remove any secondary cursors.
     * @param selection The new selection
     * @param source Source of the call that caused the selection
     */
    setSelection(selection: ISelection, source?: string): void;
    /**
     * Set the primary selection of the editor. This will remove any secondary cursors.
     * @param selection The new selection
     * @param source Source of the call that caused the selection
     */
    setSelection(selection: Selection, source?: string): void;
    /**
     * Set the selections for all the cursors of the editor.
     * Cursors will be removed or added, as necessary.
     * @param selections The new selection
     * @param source Source of the call that caused the selection
     */
    setSelections(selections: readonly ISelection[], source?: string): void;
    /**
     * Scroll vertically as necessary and reveal lines.
     */
    revealLines(startLineNumber: number, endLineNumber: number, scrollType?: ScrollType): void;
    /**
     * Scroll vertically as necessary and reveal lines centered vertically.
     */
    revealLinesInCenter(lineNumber: number, endLineNumber: number, scrollType?: ScrollType): void;
    /**
     * Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
     */
    revealLinesInCenterIfOutsideViewport(lineNumber: number, endLineNumber: number, scrollType?: ScrollType): void;
    /**
     * Scroll vertically as necessary and reveal lines close to the top of the viewport,
     * optimized for viewing a code definition.
     */
    revealLinesNearTop(lineNumber: number, endLineNumber: number, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range.
     */
    revealRange(range: IRange, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range centered vertically.
     */
    revealRangeInCenter(range: IRange, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range at the top of the viewport.
     */
    revealRangeAtTop(range: IRange, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
     */
    revealRangeInCenterIfOutsideViewport(range: IRange, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport,
     * optimized for viewing a code definition.
     */
    revealRangeNearTop(range: IRange, scrollType?: ScrollType): void;
    /**
     * Scroll vertically or horizontally as necessary and reveal a range close to the top of the viewport,
     * optimized for viewing a code definition. Only if it lies outside the viewport.
     */
    revealRangeNearTopIfOutsideViewport(range: IRange, scrollType?: ScrollType): void;
    /**
     * Directly trigger a handler or an editor action.
     * @param source The source of the call.
     * @param handlerId The id of the handler or the id of a contribution.
     * @param payload Extra data to be sent to the handler.
     */
    trigger(source: string | null | undefined, handlerId: string, payload: any): void;
    /**
     * Gets the current model attached to this editor.
     */
    getModel(): IEditorModel | null;
    /**
     * Sets the current model attached to this editor.
     * If the previous model was created by the editor via the value key in the options
     * literal object, it will be destroyed. Otherwise, if the previous model was set
     * via setModel, or the model key in the options literal object, the previous model
     * will not be destroyed.
     * It is safe to call setModel(null) to simply detach the current model from the editor.
     */
    setModel(model: IEditorModel | null): void;
    /**
     * Create a collection of decorations. All decorations added through this collection
     * will get the ownerId of the editor (meaning they will not show up in other editors).
     * These decorations will be automatically cleared when the editor's model changes.
     */
    createDecorationsCollection(decorations?: IModelDeltaDecoration[]): IEditorDecorationsCollection;
    /**
     * Change the decorations. All decorations added through this changeAccessor
     * will get the ownerId of the editor (meaning they will not show up in other
     * editors).
     * @see {@link ITextModel.changeDecorations}
     * @internal
     */
    changeDecorations(callback: (changeAccessor: IModelDecorationsChangeAccessor) => any): any;
}
/**
 * A diff editor.
 *
 * @internal
 */
interface IDiffEditor$1 extends IEditor {
    /**
     * Type the getModel() of IEditor.
     */
    getModel(): IDiffEditorModel | null;
    /**
     * Get the `original` editor.
     */
    getOriginalEditor(): IEditor;
    /**
     * Get the `modified` editor.
     */
    getModifiedEditor(): IEditor;
}
/**
 * A collection of decorations
 */
interface IEditorDecorationsCollection {
    /**
     * An event emitted when decorations change in the editor,
     * but the change is not caused by us setting or clearing the collection.
     */
    onDidChange: Event$1<IModelDecorationsChangedEvent>;
    /**
     * Get the decorations count.
     */
    length: number;
    /**
     * Get the range for a decoration.
     */
    getRange(index: number): Range | null;
    /**
     * Get all ranges for decorations.
     */
    getRanges(): Range[];
    /**
     * Determine if a decoration is in this collection.
     */
    has(decoration: IModelDecoration): boolean;
    /**
     * Replace all previous decorations with `newDecorations`.
     */
    set(newDecorations: IModelDeltaDecoration[]): void;
    /**
     * Remove all previous decorations.
     */
    clear(): void;
}
/**
 * @internal
 */
interface IThemeDecorationRenderOptions {
    backgroundColor?: string | ThemeColor;
    outline?: string;
    outlineColor?: string | ThemeColor;
    outlineStyle?: string;
    outlineWidth?: string;
    border?: string;
    borderColor?: string | ThemeColor;
    borderRadius?: string;
    borderSpacing?: string;
    borderStyle?: string;
    borderWidth?: string;
    fontStyle?: string;
    fontWeight?: string;
    fontSize?: string;
    textDecoration?: string;
    cursor?: string;
    color?: string | ThemeColor;
    opacity?: string;
    letterSpacing?: string;
    gutterIconPath?: UriComponents;
    gutterIconSize?: string;
    overviewRulerColor?: string | ThemeColor;
    /**
     * @deprecated
     */
    before?: IContentDecorationRenderOptions;
    /**
     * @deprecated
     */
    after?: IContentDecorationRenderOptions;
    /**
     * @deprecated
     */
    beforeInjectedText?: IContentDecorationRenderOptions & {
        affectsLetterSpacing?: boolean;
    };
    /**
     * @deprecated
     */
    afterInjectedText?: IContentDecorationRenderOptions & {
        affectsLetterSpacing?: boolean;
    };
}
/**
 * @internal
 */
interface IContentDecorationRenderOptions {
    contentText?: string;
    contentIconPath?: UriComponents;
    border?: string;
    borderColor?: string | ThemeColor;
    borderRadius?: string;
    fontStyle?: string;
    fontWeight?: string;
    fontSize?: string;
    fontFamily?: string;
    textDecoration?: string;
    color?: string | ThemeColor;
    backgroundColor?: string | ThemeColor;
    opacity?: string;
    verticalAlign?: string;
    margin?: string;
    padding?: string;
    width?: string;
    height?: string;
}
/**
 * @internal
 */
interface IDecorationRenderOptions extends IThemeDecorationRenderOptions {
    isWholeLine?: boolean;
    rangeBehavior?: TrackedRangeStickiness;
    overviewRulerLane?: OverviewRulerLane;
    light?: IThemeDecorationRenderOptions;
    dark?: IThemeDecorationRenderOptions;
}

interface IDiffComputationResult {
    quitEarly: boolean;
    identical: boolean;
    changes: ILineChange[];
}
/**
 * A change
 */
interface IChange {
    readonly originalStartLineNumber: number;
    readonly originalEndLineNumber: number;
    readonly modifiedStartLineNumber: number;
    readonly modifiedEndLineNumber: number;
}
/**
 * A character level change.
 */
interface ICharChange extends IChange {
    readonly originalStartColumn: number;
    readonly originalEndColumn: number;
    readonly modifiedStartColumn: number;
    readonly modifiedEndColumn: number;
}
/**
 * A line change
 */
interface ILineChange extends IChange {
    readonly charChanges: ICharChange[] | undefined;
}

/**
 * A rich code editor.
 */
type ICodeEditor = monaco.editor.ICodeEditor
/**
 * Information about a line in the diff editor
 */
interface IDiffLineInformation {
    readonly equivalentLineNumber: number;
}
/**
 * A rich diff editor.
 */
interface IDiffEditor extends IEditor {
    /**
     * Returns whether the diff editor is ignoring trim whitespace or not.
     * @internal
     */
    readonly ignoreTrimWhitespace: boolean;
    /**
     * Returns whether the diff editor is rendering side by side or inline.
     * @internal
     */
    readonly renderSideBySide: boolean;
    /**
     * Timeout in milliseconds after which diff computation is cancelled.
     * @internal
     */
    readonly maxComputationTime: number;
    /**
     * @see {@link ICodeEditor.getContainerDomNode}
     */
    getContainerDomNode(): HTMLElement;
    /**
     * An event emitted when the diff information computed by this diff editor has been updated.
     * @event
     */
    readonly onDidUpdateDiff: Event$1<void>;
    /**
     * An event emitted when the diff model is changed (i.e. the diff editor shows new content).
     * @event
     */
    readonly onDidChangeModel: Event$1<void>;
    /**
     * Saves current view state of the editor in a serializable object.
     */
    saveViewState(): IDiffEditorViewState | null;
    /**
     * Restores the view state of the editor from a serializable object generated by `saveViewState`.
     */
    restoreViewState(state: IDiffEditorViewState | null): void;
    /**
     * Type the getModel() of IEditor.
     */
    getModel(): IDiffEditorModel | null;
    /**
     * Sets the current model attached to this editor.
     * If the previous model was created by the editor via the value key in the options
     * literal object, it will be destroyed. Otherwise, if the previous model was set
     * via setModel, or the model key in the options literal object, the previous model
     * will not be destroyed.
     * It is safe to call setModel(null) to simply detach the current model from the editor.
     */
    setModel(model: IDiffEditorModel | null): void;
    /**
     * Get the `original` editor.
     */
    getOriginalEditor(): ICodeEditor;
    /**
     * Get the `modified` editor.
     */
    getModifiedEditor(): ICodeEditor;
    /**
     * Get the computed diff information.
     */
    getLineChanges(): ILineChange[] | null;
    /**
     * Get the computed diff information.
     * @internal
     */
    getDiffComputationResult(): IDiffComputationResult | null;
    /**
     * Get information based on computed diff about a line number from the original model.
     * If the diff computation is not finished or the model is missing, will return null.
     */
    getDiffLineInformationForOriginal(lineNumber: number): IDiffLineInformation | null;
    /**
     * Get information based on computed diff about a line number from the modified model.
     * If the diff computation is not finished or the model is missing, will return null.
     */
    getDiffLineInformationForModified(lineNumber: number): IDiffLineInformation | null;
    /**
     * Update the editor's options after the editor has been created.
     */
    updateOptions(newOptions: IDiffEditorOptions): void;
}

declare const ICodeEditorService: ServiceIdentifier<ICodeEditorService>;
interface ICodeEditorService {
    readonly _serviceBrand: undefined;
    readonly onWillCreateCodeEditor: Event$1<void>;
    readonly onCodeEditorAdd: Event$1<ICodeEditor>;
    readonly onCodeEditorRemove: Event$1<ICodeEditor>;
    readonly onWillCreateDiffEditor: Event$1<void>;
    readonly onDiffEditorAdd: Event$1<IDiffEditor>;
    readonly onDiffEditorRemove: Event$1<IDiffEditor>;
    readonly onDidChangeTransientModelProperty: Event$1<ITextModel>;
    readonly onDecorationTypeRegistered: Event$1<string>;
    willCreateCodeEditor(): void;
    addCodeEditor(editor: ICodeEditor): void;
    removeCodeEditor(editor: ICodeEditor): void;
    listCodeEditors(): readonly ICodeEditor[];
    willCreateDiffEditor(): void;
    addDiffEditor(editor: IDiffEditor): void;
    removeDiffEditor(editor: IDiffEditor): void;
    listDiffEditors(): readonly IDiffEditor[];
    /**
     * Returns the current focused code editor (if the focus is in the editor or in an editor widget) or null.
     */
    getFocusedCodeEditor(): ICodeEditor | null;
    registerDecorationType(description: string, key: string, options: IDecorationRenderOptions, parentTypeKey?: string, editor?: ICodeEditor): void;
    listDecorationTypes(): string[];
    removeDecorationType(key: string): void;
    resolveDecorationOptions(typeKey: string, writable: boolean): IModelDecorationOptions;
    resolveDecorationCSSRules(decorationTypeKey: string): CSSRuleList | null;
    setModelProperty(resource: URI, key: string, value: any): void;
    getModelProperty(resource: URI, key: string): any;
    setTransientModelProperty(model: ITextModel, key: string, value: any): void;
    getTransientModelProperty(model: ITextModel, key: string): any;
    getTransientModelProperties(model: ITextModel): [string, any][] | undefined;
    getActiveCodeEditor(): ICodeEditor | null;
    openCodeEditor(input: ITextResourceEditorInput, source: ICodeEditor | null, sideBySide?: boolean): Promise<ICodeEditor | null>;
    registerCodeEditorOpenHandler(handler: ICodeEditorOpenHandler): IDisposable;
}
interface ICodeEditorOpenHandler {
    (input: ITextResourceEditorInput, source: ICodeEditor | null, sideBySide?: boolean): Promise<ICodeEditor | null>;
}

interface IDimension {
    readonly width: number;
    readonly height: number;
}
declare class Dimension implements IDimension {
    readonly width: number;
    readonly height: number;
    static readonly None: Dimension;
    constructor(width: number, height: number);
    with(width?: number, height?: number): Dimension;
    static is(obj: unknown): obj is IDimension;
    static lift(obj: IDimension): Dimension;
    static equals(a: Dimension | undefined, b: Dimension | undefined): boolean;
}
interface IDomPosition {
    readonly left: number;
    readonly top: number;
}

interface ILayoutOffsetInfo {
    /**
     * Generic top offset
     */
    readonly top: number;
    /**
     * Quick pick specific top offset.
     */
    readonly quickPickTop: number;
}
declare const ILayoutService: ServiceIdentifier<ILayoutService>;
interface ILayoutService {
    readonly _serviceBrand: undefined;
    /**
     * The dimensions of the container.
     */
    readonly dimension: IDimension;
    /**
     * Does the application have a single container?
     */
    readonly hasContainer: boolean;
    /**
     * Container of the application.
     *
     * **NOTE**: In the standalone editor case, multiple editors can be created on a page.
     * Therefore, in the standalone editor case, there are multiple containers, not just
     * a single one. If you ship code that needs a "container" for the standalone editor,
     * please use `ICodeEditorService` to get the current focused code editor and use its
     * container if necessary. You can also instantiate `EditorScopedLayoutService`
     * which implements `ILayoutService` but is not a part of the service collection because
     * it is code editor instance specific.
     *
     */
    readonly container: HTMLElement;
    /**
     * An offset to use for positioning elements inside the container.
     */
    readonly offset: ILayoutOffsetInfo;
    /**
     * An event that is emitted when the container is layed out. The
     * event carries the dimensions of the container as part of it.
     */
    readonly onDidLayout: Event$1<IDimension>;
    /**
     * Focus the primary component of the container.
     */
    focus(): void;
}

interface IPropertyData {
    classification: 'SystemMetaData' | 'CallstackOrException' | 'CustomerContent' | 'PublicNonPersonalData' | 'EndUserPseudonymizedInformation';
    purpose: 'PerformanceAndHealth' | 'FeatureInsight' | 'BusinessInsight';
    comment: string;
    expiration?: string;
    endpoint?: string;
    isMeasurement?: boolean;
}
interface IGDPRProperty {
    owner: string;
    comment: string;
    expiration?: string;
    readonly [name: string]: IPropertyData | undefined | IGDPRProperty | string;
}
type IGDPRPropertyWithoutMetadata = Omit<IGDPRProperty, 'owner' | 'comment' | 'expiration'>;
type OmitMetadata<T> = Omit<T, 'owner' | 'comment' | 'expiration'>;
type ClassifiedEvent<T extends IGDPRPropertyWithoutMetadata> = {
    [k in keyof T]: any;
};
type StrictPropertyChecker<TEvent, TClassification, TError> = keyof TEvent extends keyof OmitMetadata<TClassification> ? keyof OmitMetadata<TClassification> extends keyof TEvent ? TEvent : TError : TError;
type StrictPropertyCheckError = {
    error: 'Type of classified event does not match event properties';
};
type StrictPropertyCheck<T extends IGDPRProperty, E> = StrictPropertyChecker<E, ClassifiedEvent<OmitMetadata<T>>, StrictPropertyCheckError>;

interface ITelemetryInfo {
    sessionId: string;
    machineId: string;
    firstSessionDate: string;
    msftInternal?: boolean;
}
interface ITelemetryData {
    from?: string;
    target?: string;
    [key: string]: any;
}
declare const ITelemetryService: ServiceIdentifier<ITelemetryService>;
interface ITelemetryService {
    /**
     * Whether error telemetry will get sent. If false, `publicLogError` will no-op.
     */
    readonly sendErrorTelemetry: boolean;
    readonly _serviceBrand: undefined;
    /**
     * @deprecated Use publicLog2 and the typescript GDPR annotation where possible
     */
    publicLog(eventName: string, data?: ITelemetryData): Promise<void>;
    /**
     * Sends a telemetry event that has been privacy approved.
     * Do not call this unless you have been given approval.
     */
    publicLog2<E extends ClassifiedEvent<OmitMetadata<T>> = never, T extends IGDPRProperty = never>(eventName: string, data?: StrictPropertyCheck<T, E>): Promise<void>;
    /**
     * @deprecated Use publicLogError2 and the typescript GDPR annotation where possible
     */
    publicLogError(errorEventName: string, data?: ITelemetryData): Promise<void>;
    publicLogError2<E extends ClassifiedEvent<OmitMetadata<T>> = never, T extends IGDPRProperty = never>(eventName: string, data?: StrictPropertyCheck<T, E>): Promise<void>;
    getTelemetryInfo(): Promise<ITelemetryInfo>;
    setExperimentProperty(name: string, value: string): void;
    readonly telemetryLevel: TelemetryLevel;
}
interface ITelemetryEndpoint {
    id: string;
    aiKey: string;
    sendErrorTelemetry: boolean;
}
declare const enum TelemetryLevel {
    NONE = 0,
    CRASH = 1,
    ERROR = 2,
    USAGE = 3
}

interface IBuiltInExtension {
    readonly name: string;
    readonly version: string;
    readonly repo: string;
    readonly metadata: any;
}
type ConfigurationSyncStore = {
    url: string;
    insidersUrl: string;
    stableUrl: string;
    canSwitch: boolean;
    authenticationProviders: IStringDictionary<{
        scopes: string[];
    }>;
};
type ExtensionUntrustedWorkspaceSupport = {
    readonly default?: boolean | 'limited';
    readonly override?: boolean | 'limited';
};
type ExtensionVirtualWorkspaceSupport = {
    readonly default?: boolean;
    readonly override?: boolean;
};
interface IProductConfiguration {
    readonly version: string;
    readonly date?: string;
    readonly quality?: string;
    readonly commit?: string;
    readonly nameShort: string;
    readonly nameLong: string;
    readonly win32AppUserModelId?: string;
    readonly win32MutexName?: string;
    readonly win32RegValueName?: string;
    readonly applicationName: string;
    readonly embedderIdentifier?: string;
    readonly urlProtocol: string;
    readonly dataFolderName: string;
    readonly builtInExtensions?: IBuiltInExtension[];
    readonly downloadUrl?: string;
    readonly updateUrl?: string;
    readonly webUrl?: string;
    readonly webEndpointUrlTemplate?: string;
    readonly webviewContentExternalBaseUrlTemplate?: string;
    readonly target?: string;
    readonly settingsSearchBuildId?: number;
    readonly settingsSearchUrl?: string;
    readonly tasConfig?: {
        endpoint: string;
        telemetryEventName: string;
        featuresTelemetryPropertyName: string;
        assignmentContextTelemetryPropertyName: string;
    };
    readonly experimentsUrl?: string;
    readonly extensionsGallery?: {
        readonly serviceUrl: string;
        readonly servicePPEUrl?: string;
        readonly searchUrl?: string;
        readonly itemUrl: string;
        readonly publisherUrl: string;
        readonly resourceUrlTemplate: string;
        readonly controlUrl: string;
        readonly nlsBaseUrl: string;
    };
    readonly extensionTips?: {
        [id: string]: string;
    };
    readonly extensionImportantTips?: IStringDictionary<ImportantExtensionTip>;
    readonly configBasedExtensionTips?: {
        [id: string]: IConfigBasedExtensionTip;
    };
    readonly exeBasedExtensionTips?: {
        [id: string]: IExeBasedExtensionTip;
    };
    readonly remoteExtensionTips?: {
        [remoteName: string]: IRemoteExtensionTip;
    };
    readonly virtualWorkspaceExtensionTips?: {
        [virtualWorkspaceName: string]: IVirtualWorkspaceExtensionTip;
    };
    readonly extensionKeywords?: {
        [extension: string]: readonly string[];
    };
    readonly keymapExtensionTips?: readonly string[];
    readonly webExtensionTips?: readonly string[];
    readonly languageExtensionTips?: readonly string[];
    readonly trustedExtensionUrlPublicKeys?: {
        [id: string]: string[];
    };
    readonly trustedExtensionAuthAccess?: readonly string[];
    readonly commandPaletteSuggestedCommandIds?: string[];
    readonly crashReporter?: {
        readonly companyName: string;
        readonly productName: string;
    };
    readonly removeTelemetryMachineId?: boolean;
    readonly enabledTelemetryLevels?: {
        error: boolean;
        usage: boolean;
    };
    readonly enableTelemetry?: boolean;
    readonly openToWelcomeMainPage?: boolean;
    readonly aiConfig?: {
        readonly ariaKey: string;
    };
    readonly sendASmile?: {
        readonly reportIssueUrl: string;
        readonly requestFeatureUrl: string;
    };
    readonly documentationUrl?: string;
    readonly releaseNotesUrl?: string;
    readonly keyboardShortcutsUrlMac?: string;
    readonly keyboardShortcutsUrlLinux?: string;
    readonly keyboardShortcutsUrlWin?: string;
    readonly introductoryVideosUrl?: string;
    readonly tipsAndTricksUrl?: string;
    readonly newsletterSignupUrl?: string;
    readonly twitterUrl?: string;
    readonly requestFeatureUrl?: string;
    readonly reportIssueUrl?: string;
    readonly reportMarketplaceIssueUrl?: string;
    readonly licenseUrl?: string;
    readonly privacyStatementUrl?: string;
    readonly showTelemetryOptOut?: boolean;
    readonly serverGreeting?: string[];
    readonly serverLicense?: string[];
    readonly serverLicensePrompt?: string;
    readonly serverApplicationName: string;
    readonly serverDataFolderName?: string;
    readonly tunnelApplicationName?: string;
    readonly tunnelApplicationConfig?: ITunnelApplicationConfig;
    readonly npsSurveyUrl?: string;
    readonly cesSurveyUrl?: string;
    readonly surveys?: readonly ISurveyData[];
    readonly checksums?: {
        [path: string]: string;
    };
    readonly checksumFailMoreInfoUrl?: string;
    readonly appCenter?: IAppCenterConfiguration;
    readonly portable?: string;
    readonly extensionKind?: {
        readonly [extensionId: string]: ('ui' | 'workspace' | 'web')[];
    };
    readonly extensionPointExtensionKind?: {
        readonly [extensionPointId: string]: ('ui' | 'workspace' | 'web')[];
    };
    readonly extensionSyncedKeys?: {
        readonly [extensionId: string]: string[];
    };
    readonly extensionEnabledApiProposals?: {
        readonly [extensionId: string]: string[];
    };
    readonly extensionUntrustedWorkspaceSupport?: {
        readonly [extensionId: string]: ExtensionUntrustedWorkspaceSupport;
    };
    readonly extensionVirtualWorkspacesSupport?: {
        readonly [extensionId: string]: ExtensionVirtualWorkspaceSupport;
    };
    readonly msftInternalDomains?: string[];
    readonly linkProtectionTrustedDomains?: readonly string[];
    readonly 'configurationSync.store'?: ConfigurationSyncStore;
    readonly 'editSessions.store'?: Omit<ConfigurationSyncStore, 'insidersUrl' | 'stableUrl'>;
    readonly darwinUniversalAssetId?: string;
}
interface ITunnelApplicationConfig {
    authenticationProviders: IStringDictionary<{
        scopes: string[];
    }>;
    editorWebUrl: string;
    extension: IRemoteExtensionTip;
}
type ImportantExtensionTip = {
    name: string;
    languages?: string[];
    pattern?: string;
    isExtensionPack?: boolean;
    whenNotInstalled?: string[];
};
interface IAppCenterConfiguration {
    readonly 'win32-ia32': string;
    readonly 'win32-x64': string;
    readonly 'linux-x64': string;
    readonly 'darwin': string;
}
interface IConfigBasedExtensionTip {
    configPath: string;
    configName: string;
    configScheme?: string;
    recommendations: IStringDictionary<{
        name: string;
        remotes?: string[];
        important?: boolean;
        isExtensionPack?: boolean;
        whenNotInstalled?: string[];
    }>;
}
interface IExeBasedExtensionTip {
    friendlyName: string;
    windowsPath?: string;
    important?: boolean;
    recommendations: IStringDictionary<{
        name: string;
        important?: boolean;
        isExtensionPack?: boolean;
        whenNotInstalled?: string[];
    }>;
}
interface IRemoteExtensionTip {
    friendlyName: string;
    extensionId: string;
    supportedPlatforms?: PlatformName[];
}
interface IVirtualWorkspaceExtensionTip {
    friendlyName: string;
    extensionId: string;
    supportedPlatforms?: PlatformName[];
}
interface ISurveyData {
    surveyId: string;
    surveyUrl: string;
    languageId: string;
    editCount: number;
    userProbability: number;
}

declare const IProductService: ServiceIdentifier<IProductService>;
interface IProductService extends Readonly<IProductConfiguration> {
    readonly _serviceBrand: undefined;
}

interface IBaseDialogOptions {
    readonly type?: Severity$1 | DialogType;
    readonly title?: string;
    readonly message: string;
    readonly detail?: string;
    readonly checkbox?: ICheckbox;
    /**
     * Allows to enforce use of custom dialog even in native environments.
     */
    readonly custom?: boolean | ICustomDialogOptions;
}
interface IConfirmation extends IBaseDialogOptions {
    /**
     * If not provided, defaults to `Yes`.
     */
    readonly primaryButton?: string;
    /**
     * If not provided, defaults to `Cancel`.
     */
    readonly cancelButton?: string;
}
interface IConfirmationResult extends ICheckboxResult {
    /**
     * Will be true if the dialog was confirmed with the primary button pressed.
     */
    readonly confirmed: boolean;
}
interface IInput extends IConfirmation {
    readonly inputs: IInputElement[];
    /**
     * If not provided, defaults to `Ok`.
     */
    readonly primaryButton?: string;
}
interface IInputElement {
    readonly type?: 'text' | 'password';
    readonly value?: string;
    readonly placeholder?: string;
}
interface IInputResult extends IConfirmationResult {
    /**
     * Values for the input fields as provided by the user or `undefined` if none.
     */
    readonly values?: string[];
}
interface IPromptBaseButton<T> {
    /**
     * @returns the result of the prompt button will be returned
     * as result from the `prompt()` call.
     */
    run(checkbox: ICheckboxResult): T | Promise<T>;
}
interface IPromptButton<T> extends IPromptBaseButton<T> {
    readonly label: string;
}
interface IPromptCancelButton<T> extends IPromptBaseButton<T> {
    /**
     * The cancel button to show in the prompt. Defaults to
     * `Cancel` if not provided.
     */
    readonly label?: string;
}
interface IPrompt<T> extends IBaseDialogOptions {
    /**
     * The buttons to show in the prompt. Defaults to `OK`
     * if no buttons or cancel button is provided.
     */
    readonly buttons?: IPromptButton<T>[];
    /**
     * The cancel button to show in the prompt. Defaults to
     * `Cancel` if set to `true`.
     */
    readonly cancelButton?: IPromptCancelButton<T> | true | string;
}
interface IPromptWithCustomCancel<T> extends IPrompt<T> {
    readonly cancelButton: IPromptCancelButton<T>;
}
interface IPromptWithDefaultCancel<T> extends IPrompt<T> {
    readonly cancelButton: true | string;
}
interface IPromptResult<T> extends ICheckboxResult {
    /**
     * The result of the `IPromptButton`` that was pressed or `undefined` if none.
     */
    readonly result?: T;
}
interface IPromptResultWithCancel<T> extends IPromptResult<T> {
    readonly result: T;
}
type DialogType = 'none' | 'info' | 'error' | 'question' | 'warning';
interface ICheckbox {
    readonly label: string;
    readonly checked?: boolean;
}
interface ICheckboxResult {
    /**
     * This will only be defined if the confirmation was created
     * with the checkbox option defined.
     */
    readonly checkboxChecked?: boolean;
}
interface ICustomDialogOptions {
    readonly buttonDetails?: string[];
    readonly markdownDetails?: ICustomDialogMarkdown[];
    readonly classes?: string[];
    readonly icon?: ThemeIcon;
    readonly disableCloseAction?: boolean;
}
interface ICustomDialogMarkdown {
    readonly markdown: IMarkdownString;
    readonly classes?: string[];
}
declare const IDialogService: ServiceIdentifier<IDialogService>;
/**
 * A service to bring up modal dialogs.
 *
 * Note: use the `INotificationService.prompt()` method for a non-modal way to ask
 * the user for input.
 */
interface IDialogService {
    readonly _serviceBrand: undefined;
    /**
     * An event that fires when a dialog is about to show.
     */
    onWillShowDialog: Event$1<void>;
    /**
     * An event that fires when a dialog did show (closed).
     */
    onDidShowDialog: Event$1<void>;
    /**
     * Ask the user for confirmation with a modal dialog.
     */
    confirm(confirmation: IConfirmation): Promise<IConfirmationResult>;
    /**
     * Prompt the user with a modal dialog. Provides a bit
     * more control over the dialog compared to the simpler
     * `confirm` method. Specifically, allows to show more
     * than 2 buttons and makes it easier to just show a
     * message to the user.
     *
     * @returns a promise that resolves to the `T` result
     * from the provided `IPromptButton<T>` or `undefined`.
     */
    prompt<T>(prompt: IPromptWithCustomCancel<T>): Promise<IPromptResultWithCancel<T>>;
    prompt<T>(prompt: IPromptWithDefaultCancel<T>): Promise<IPromptResult<T>>;
    prompt<T>(prompt: IPrompt<T>): Promise<IPromptResult<T>>;
    /**
     * Present a modal dialog to the user asking for input.
     */
    input(input: IInput): Promise<IInputResult>;
    /**
     * Show a modal info dialog.
     */
    info(message: string, detail?: string): Promise<void>;
    /**
     * Show a modal warning dialog.
     */
    warn(message: string, detail?: string): Promise<void>;
    /**
     * Show a modal error dialog.
     */
    error(message: string, detail?: string): Promise<void>;
    /**
     * Present the about dialog to the user.
     */
    about(): Promise<void>;
}
declare const enum ConfirmResult {
    SAVE = 0,
    DONT_SAVE = 1,
    CANCEL = 2
}

interface LanguageFilter {
    readonly language?: string;
    readonly scheme?: string;
    readonly pattern?: string | IRelativePattern;
    readonly notebookType?: string;
    /**
     * This provider is implemented in the UI thread.
     */
    readonly hasAccessToAllModels?: boolean;
    readonly exclusive?: boolean;
}
type LanguageSelector = string | LanguageFilter | ReadonlyArray<string | LanguageFilter>;

interface NotebookInfo {
    readonly uri: URI;
    readonly type: string;
}
interface NotebookInfoResolver {
    (uri: URI): NotebookInfo | undefined;
}
declare class LanguageFeatureRegistry<T> {
    private readonly _notebookInfoResolver?;
    private _clock;
    private readonly _entries;
    private readonly _onDidChange;
    readonly onDidChange: Event$1<number>;
    constructor(_notebookInfoResolver?: NotebookInfoResolver | undefined);
    register(selector: LanguageSelector, provider: T): IDisposable;
    has(model: ITextModel): boolean;
    all(model: ITextModel): T[];
    ordered(model: ITextModel): T[];
    orderedGroups(model: ITextModel): T[][];
    private _orderedForEach;
    private _lastCandidate;
    private _updateScores;
    private static _compareByScoreAndTime;
}

declare const IModelService: ServiceIdentifier<IModelService>;
interface IModelService {
    readonly _serviceBrand: undefined;
    createModel(value: string | ITextBufferFactory, languageSelection: ILanguageSelection | null, resource?: URI, isForSimpleWidget?: boolean): ITextModel;
    updateModel(model: ITextModel, value: string | ITextBufferFactory): void;
    setMode(model: ITextModel, languageSelection: ILanguageSelection, source?: string): void;
    destroyModel(resource: URI): void;
    getModels(): ITextModel[];
    getCreationOptions(language: string, resource: URI, isForSimpleWidget: boolean): ITextModelCreationOptions;
    getModel(resource: URI): ITextModel | null;
    onModelAdded: Event$1<ITextModel>;
    onModelRemoved: Event$1<ITextModel>;
    onModelLanguageChanged: Event$1<{
        model: ITextModel;
        oldLanguageId: string;
    }>;
}

declare const ILanguageFeaturesService: ServiceIdentifier<ILanguageFeaturesService>;
interface ILanguageFeaturesService {
    readonly _serviceBrand: undefined;
    readonly referenceProvider: LanguageFeatureRegistry<ReferenceProvider>;
    readonly definitionProvider: LanguageFeatureRegistry<DefinitionProvider>;
    readonly typeDefinitionProvider: LanguageFeatureRegistry<TypeDefinitionProvider>;
    readonly declarationProvider: LanguageFeatureRegistry<DeclarationProvider>;
    readonly implementationProvider: LanguageFeatureRegistry<ImplementationProvider>;
    readonly codeActionProvider: LanguageFeatureRegistry<CodeActionProvider>;
    readonly documentPasteEditProvider: LanguageFeatureRegistry<DocumentPasteEditProvider>;
    readonly renameProvider: LanguageFeatureRegistry<RenameProvider>;
    readonly documentFormattingEditProvider: LanguageFeatureRegistry<DocumentFormattingEditProvider>;
    readonly documentRangeFormattingEditProvider: LanguageFeatureRegistry<DocumentRangeFormattingEditProvider>;
    readonly onTypeFormattingEditProvider: LanguageFeatureRegistry<OnTypeFormattingEditProvider>;
    readonly documentSymbolProvider: LanguageFeatureRegistry<DocumentSymbolProvider>;
    readonly inlayHintsProvider: LanguageFeatureRegistry<InlayHintsProvider>;
    readonly colorProvider: LanguageFeatureRegistry<DocumentColorProvider>;
    readonly codeLensProvider: LanguageFeatureRegistry<CodeLensProvider>;
    readonly signatureHelpProvider: LanguageFeatureRegistry<SignatureHelpProvider>;
    readonly hoverProvider: LanguageFeatureRegistry<HoverProvider>;
    readonly documentHighlightProvider: LanguageFeatureRegistry<DocumentHighlightProvider>;
    readonly documentRangeSemanticTokensProvider: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>;
    readonly documentSemanticTokensProvider: LanguageFeatureRegistry<DocumentSemanticTokensProvider>;
    readonly selectionRangeProvider: LanguageFeatureRegistry<SelectionRangeProvider>;
    readonly foldingRangeProvider: LanguageFeatureRegistry<FoldingRangeProvider>;
    readonly linkProvider: LanguageFeatureRegistry<LinkProvider>;
    readonly inlineCompletionsProvider: LanguageFeatureRegistry<InlineCompletionsProvider>;
    readonly completionProvider: LanguageFeatureRegistry<CompletionItemProvider>;
    readonly linkedEditingRangeProvider: LanguageFeatureRegistry<LinkedEditingRangeProvider>;
    readonly inlineValuesProvider: LanguageFeatureRegistry<InlineValuesProvider>;
    readonly evaluatableExpressionProvider: LanguageFeatureRegistry<EvaluatableExpressionProvider>;
    readonly documentOnDropEditProvider: LanguageFeatureRegistry<DocumentOnDropEditProvider>;
    setNotebookTypeResolver(resolver: NotebookInfoResolver | undefined): void;
}

interface ICommandEvent {
    commandId: string;
    args: any[];
}
declare const ICommandService: ServiceIdentifier<ICommandService>;
interface ICommandService {
    readonly _serviceBrand: undefined;
    onWillExecuteCommand: Event$1<ICommandEvent>;
    onDidExecuteCommand: Event$1<ICommandEvent>;
    executeCommand<T = any>(commandId: string, ...args: any[]): Promise<T | undefined>;
}

declare class ResolvedKeybindingItem {
    _resolvedKeybindingItemBrand: void;
    readonly resolvedKeybinding: ResolvedKeybinding | undefined;
    readonly chords: string[];
    readonly bubble: boolean;
    readonly command: string | null;
    readonly commandArgs: any;
    readonly when: ContextKeyExpression | undefined;
    readonly isDefault: boolean;
    readonly extensionId: string | null;
    readonly isBuiltinExtension: boolean;
    constructor(resolvedKeybinding: ResolvedKeybinding | undefined, command: string | null, commandArgs: any, when: ContextKeyExpression | undefined, isDefault: boolean, extensionId: string | null, isBuiltinExtension: boolean);
}

interface IResolveResult {
    /** Whether the resolved keybinding is entering a multi chord */
    enterMultiChord: boolean;
    /** Whether the resolved keybinding is leaving (and executing) a multi chord keybinding */
    leaveMultiChord: boolean;
    commandId: string | null;
    commandArgs: any;
    bubble: boolean;
}

interface IKeyboardEvent {
    readonly _standardKeyboardEventBrand: true;
    readonly ctrlKey: boolean;
    readonly shiftKey: boolean;
    readonly altKey: boolean;
    readonly metaKey: boolean;
    readonly altGraphKey: boolean;
    readonly keyCode: KeyCode;
    readonly code: string;
}
interface KeybindingsSchemaContribution {
    readonly onDidChange?: Event$1<void>;
    getSchemaAdditions(): IJSONSchema[];
}
declare const IKeybindingService: ServiceIdentifier<IKeybindingService>;
interface IKeybindingService {
    readonly _serviceBrand: undefined;
    readonly inChordMode: boolean;
    onDidUpdateKeybindings: Event$1<void>;
    /**
     * Returns none, one or many (depending on keyboard layout)!
     */
    resolveKeybinding(keybinding: Keybinding): ResolvedKeybinding[];
    resolveKeyboardEvent(keyboardEvent: IKeyboardEvent): ResolvedKeybinding;
    resolveUserBinding(userBinding: string): ResolvedKeybinding[];
    /**
     * Resolve and dispatch `keyboardEvent` and invoke the command.
     */
    dispatchEvent(e: IKeyboardEvent, target: IContextKeyServiceTarget): boolean;
    /**
     * Resolve and dispatch `keyboardEvent`, but do not invoke the command or change inner state.
     */
    softDispatch(keyboardEvent: IKeyboardEvent, target: IContextKeyServiceTarget): IResolveResult | null;
    dispatchByUserSettingsLabel(userSettingsLabel: string, target: IContextKeyServiceTarget): void;
    /**
     * Look up keybindings for a command.
     * Use `lookupKeybinding` if you are interested in the preferred keybinding.
     */
    lookupKeybindings(commandId: string): ResolvedKeybinding[];
    /**
     * Look up the preferred (last defined) keybinding for a command.
     * @returns The preferred keybinding or null if the command is not bound.
     */
    lookupKeybinding(commandId: string, context?: IContextKeyService): ResolvedKeybinding | undefined;
    getDefaultKeybindingsContent(): string;
    getDefaultKeybindings(): readonly ResolvedKeybindingItem[];
    getKeybindings(): readonly ResolvedKeybindingItem[];
    customKeybindingsCount(): number;
    /**
     * Will the given key event produce a character that's rendered on screen, e.g. in a
     * text box. *Note* that the results of this function can be incorrect.
     */
    mightProducePrintableCharacter(event: IKeyboardEvent): boolean;
    registerSchemaContribution(contribution: KeybindingsSchemaContribution): void;
    toggleLogging(): boolean;
    _dumpDebugInfo(): string;
    _dumpDebugInfoJSON(): string;
}

type IEditorOverrideServices = monaco.editor.IEditorOverrideServices
/**
 * We don't want to eagerly instantiate services because embedders get a one time chance
 * to override services when they create the first editor.
 */
declare module StandaloneServices {
    function get<T>(serviceId: ServiceIdentifier<T>): T;
    function initialize(overrides: IEditorOverrideServices): IInstantiationService;
}

declare class ResourceEdit {
    readonly metadata?: WorkspaceEditMetadata | undefined;
    protected constructor(metadata?: WorkspaceEditMetadata | undefined);
    static convert(edit: WorkspaceEdit): ResourceEdit[];
}
interface IBulkEditOptions {
    editor?: ICodeEditor;
    progress?: IProgress<IProgressStep>;
    token?: CancellationToken;
    showPreview?: boolean;
    label?: string;
    code?: string;
    quotableLabel?: string;
    undoRedoSource?: UndoRedoSource;
    undoRedoGroupId?: number;
    confirmBeforeUndo?: boolean;
    respectAutoSaveConfig?: boolean;
}
interface IBulkEditResult {
    ariaSummary: string;
    isApplied: boolean;
}
type IBulkEditPreviewHandler = (edits: ResourceEdit[], options?: IBulkEditOptions) => Promise<ResourceEdit[]>;
declare const IBulkEditService: ServiceIdentifier<IBulkEditService>;
interface IBulkEditService {
    readonly _serviceBrand: undefined;
    hasPreviewHandler(): boolean;
    setPreviewHandler(handler: IBulkEditPreviewHandler): IDisposable;
    apply(edit: ResourceEdit[] | WorkspaceEdit, options?: IBulkEditOptions): Promise<IBulkEditResult>;
}

interface UnicodeHighlighterOptions {
    nonBasicASCII: boolean;
    ambiguousCharacters: boolean;
    invisibleCharacters: boolean;
    includeComments: boolean;
    includeStrings: boolean;
    allowedCodePoints: number[];
    allowedLocales: string[];
}

type DiffAlgorithmName = 'smart' | 'experimental';
declare const IEditorWorkerService: ServiceIdentifier<IEditorWorkerService>;
interface IEditorWorkerService {
    readonly _serviceBrand: undefined;
    canComputeUnicodeHighlights(uri: URI): boolean;
    computedUnicodeHighlights(uri: URI, options: UnicodeHighlighterOptions, range?: IRange): Promise<IUnicodeHighlightsResult>;
    /** Implementation in {@link EditorSimpleWorker.computeDiff} */
    computeDiff(original: URI, modified: URI, options: IDocumentDiffProviderOptions, algorithm: DiffAlgorithmName): Promise<IDocumentDiff | null>;
    canComputeDirtyDiff(original: URI, modified: URI): boolean;
    computeDirtyDiff(original: URI, modified: URI, ignoreTrimWhitespace: boolean): Promise<IChange[] | null>;
    computeMoreMinimalEdits(resource: URI, edits: TextEdit[] | null | undefined): Promise<TextEdit[] | undefined>;
    canComputeWordRanges(resource: URI): boolean;
    computeWordRanges(resource: URI, range: IRange): Promise<{
        [word: string]: IRange[];
    } | null>;
    canNavigateValueSet(resource: URI): boolean;
    navigateValueSet(resource: URI, range: IRange, up: boolean): Promise<IInplaceReplaceSupportResult | null>;
}
interface IUnicodeHighlightsResult {
    ranges: IRange[];
    hasMore: boolean;
    nonBasicAsciiCharacterCount: number;
    invisibleCharacterCount: number;
    ambiguousCharacterCount: number;
}

declare const IClipboardService: ServiceIdentifier<IClipboardService>;
interface IClipboardService {
    readonly _serviceBrand: undefined;
    /**
     * Writes text to the system clipboard.
     */
    writeText(text: string, type?: string): Promise<void>;
    /**
     * Reads the content of the clipboard in plain text
     */
    readText(type?: string): Promise<string>;
    /**
     * Reads text from the system find pasteboard.
     */
    readFindText(): Promise<string>;
    /**
     * Writes text to the system find pasteboard.
     */
    writeFindText(text: string): Promise<void>;
    /**
     * Writes resources to the system clipboard.
     */
    writeResources(resources: URI[]): Promise<void>;
    /**
     * Reads resources from the system clipboard.
     */
    readResources(): Promise<URI[]>;
    /**
     * Find out if resources are copied to the clipboard.
     */
    hasResources(): Promise<boolean>;
}

type OpenInternalOptions = {
    /**
     * Signals that the intent is to open an editor to the side
     * of the currently active editor.
     */
    readonly openToSide?: boolean;
    /**
     * Extra editor options to apply in case an editor is used to open.
     */
    readonly editorOptions?: IEditorOptions;
    /**
     * Signals that the editor to open was triggered through a user
     * action, such as keyboard or mouse usage.
     */
    readonly fromUserGesture?: boolean;
    /**
     * Allow command links to be handled.
     *
     * If this is an array, then only the commands included in the array can be run.
     */
    readonly allowCommands?: boolean | readonly string[];
};
type OpenExternalOptions = {
    readonly openExternal?: boolean;
    readonly allowTunneling?: boolean;
    readonly allowContributedOpeners?: boolean | string;
    readonly fromWorkspace?: boolean;
};
type OpenOptions = OpenInternalOptions & OpenExternalOptions;
type ResolveExternalUriOptions = {
    readonly allowTunneling?: boolean;
};
interface IResolvedExternalUri extends IDisposable {
    resolved: URI;
}
interface IOpener {
    open(resource: URI | string, options?: OpenInternalOptions | OpenExternalOptions): Promise<boolean>;
}
interface IExternalOpener {
    openExternal(href: string, ctx: {
        sourceUri: URI;
        preferredOpenerId?: string;
    }, token: CancellationToken): Promise<boolean>;
    dispose?(): void;
}
interface IValidator {
    shouldOpen(resource: URI | string, openOptions?: OpenOptions): Promise<boolean>;
}
interface IExternalUriResolver {
    resolveExternalUri(resource: URI, options?: OpenOptions): Promise<{
        resolved: URI;
        dispose(): void;
    } | undefined>;
}
declare const IOpenerService: ServiceIdentifier<IOpenerService>;
interface IOpenerService {
    readonly _serviceBrand: undefined;
    /**
     * Register a participant that can handle the open() call.
     */
    registerOpener(opener: IOpener): IDisposable;
    /**
     * Register a participant that can validate if the URI resource be opened.
     * Validators are run before openers.
     */
    registerValidator(validator: IValidator): IDisposable;
    /**
     * Register a participant that can resolve an external URI resource to be opened.
     */
    registerExternalUriResolver(resolver: IExternalUriResolver): IDisposable;
    /**
     * Sets the handler for opening externally. If not provided,
     * a default handler will be used.
     */
    setDefaultExternalOpener(opener: IExternalOpener): void;
    /**
     * Registers a new opener external resources openers.
     */
    registerExternalOpener(opener: IExternalOpener): IDisposable;
    /**
     * Opens a resource, like a webaddress, a document uri, or executes command.
     *
     * @param resource A resource
     * @return A promise that resolves when the opening is done.
     */
    open(resource: URI | string, options?: OpenInternalOptions | OpenExternalOptions): Promise<boolean>;
    /**
     * Resolve a resource to its external form.
     * @throws whenever resolvers couldn't resolve this resource externally.
     */
    resolveExternalUri(resource: URI, options?: ResolveExternalUriOptions): Promise<IResolvedExternalUri>;
}

/**
 * Provider specific options for this particular showing of the
 * quick access.
 */
interface IQuickAccessProviderRunOptions {
    from?: string;
}
interface IQuickAccessOptions {
    /**
     * Allows to enable quick navigate support in quick input.
     */
    quickNavigateConfiguration?: IQuickNavigateConfiguration;
    /**
     * Allows to configure a different item activation strategy.
     * By default the first item in the list will get activated.
     */
    itemActivation?: ItemActivation;
    /**
     * Whether to take the input value as is and not restore it
     * from any existing value if quick access is visible.
     */
    preserveValue?: boolean;
    /**
     * Provider specific options for this particular showing of the
     * quick access.
     */
    providerOptions?: IQuickAccessProviderRunOptions;
}
interface IQuickAccessController {
    /**
     * Open the quick access picker with the optional value prefilled.
     */
    show(value?: string, options?: IQuickAccessOptions): void;
    /**
     * Same as `show()` but instead of executing the selected pick item,
     * it will be returned. May return `undefined` in case no item was
     * picked by the user.
     */
    pick(value?: string, options?: IQuickAccessOptions): Promise<IQuickPickItem[] | undefined>;
}

interface IMatch {
    start: number;
    end: number;
}

interface IQuickPickItemHighlights {
    label?: IMatch[];
    description?: IMatch[];
    detail?: IMatch[];
}
interface IQuickPickItem {
    type?: 'item';
    id?: string;
    label: string;
    meta?: string;
    ariaLabel?: string;
    description?: string;
    detail?: string;
    tooltip?: string | IMarkdownString;
    /**
     * Allows to show a keybinding next to the item to indicate
     * how the item can be triggered outside of the picker using
     * keyboard shortcut.
     */
    keybinding?: ResolvedKeybinding;
    iconClasses?: readonly string[];
    italic?: boolean;
    strikethrough?: boolean;
    highlights?: IQuickPickItemHighlights;
    buttons?: readonly IQuickInputButton[];
    picked?: boolean;
    alwaysShow?: boolean;
}
interface IQuickPickSeparator {
    type: 'separator';
    id?: string;
    label?: string;
    ariaLabel?: string;
    buttons?: readonly IQuickInputButton[];
    tooltip?: string | IMarkdownString;
}
interface IKeyMods {
    readonly ctrlCmd: boolean;
    readonly alt: boolean;
}
interface IQuickNavigateConfiguration {
    keybindings: readonly ResolvedKeybinding[];
}
interface IPickOptions<T extends IQuickPickItem> {
    /**
     * an optional string to show as the title of the quick input
     */
    title?: string;
    /**
     * an optional string to show as placeholder in the input box to guide the user what she picks on
     */
    placeHolder?: string;
    /**
     * an optional flag to include the description when filtering the picks
     */
    matchOnDescription?: boolean;
    /**
     * an optional flag to include the detail when filtering the picks
     */
    matchOnDetail?: boolean;
    /**
     * an optional flag to filter the picks based on label. Defaults to true.
     */
    matchOnLabel?: boolean;
    /**
     * an option flag to control whether focus is always automatically brought to a list item. Defaults to true.
     */
    autoFocusOnList?: boolean;
    /**
     * an optional flag to not close the picker on focus lost
     */
    ignoreFocusLost?: boolean;
    /**
     * an optional flag to make this picker multi-select
     */
    canPickMany?: boolean;
    /**
     * enables quick navigate in the picker to open an element without typing
     */
    quickNavigate?: IQuickNavigateConfiguration;
    /**
     * Hides the input box from the picker UI. This is typically used
     * in combination with quick-navigation where no search UI should
     * be presented.
     */
    hideInput?: boolean;
    /**
     * a context key to set when this picker is active
     */
    contextKey?: string;
    /**
     * an optional property for the item to focus initially.
     */
    activeItem?: Promise<T> | T;
    onKeyMods?: (keyMods: IKeyMods) => void;
    onDidFocus?: (entry: T) => void;
    onDidTriggerItemButton?: (context: IQuickPickItemButtonContext<T>) => void;
    onDidTriggerSeparatorButton?: (context: IQuickPickSeparatorButtonEvent) => void;
}
interface IInputOptions {
    /**
     * an optional string to show as the title of the quick input
     */
    title?: string;
    /**
     * the value to prefill in the input box
     */
    value?: string;
    /**
     * the selection of value, default to the whole prefilled value
     */
    valueSelection?: readonly [number, number];
    /**
     * the text to display underneath the input box
     */
    prompt?: string;
    /**
     * an optional string to show as placeholder in the input box to guide the user what to type
     */
    placeHolder?: string;
    /**
     * Controls if a password input is shown. Password input hides the typed text.
     */
    password?: boolean;
    /**
     * an optional flag to not close the input on focus lost
     */
    ignoreFocusLost?: boolean;
    /**
     * an optional function that is used to validate user input.
     */
    validateInput?: (input: string) => Promise<string | null | undefined | {
        content: string;
        severity: Severity$1;
    }>;
}
declare enum QuickInputHideReason {
    /**
     * Focus moved away from the quick input.
     */
    Blur = 1,
    /**
     * An explicit user gesture, e.g. pressing Escape key.
     */
    Gesture = 2,
    /**
     * Anything else.
     */
    Other = 3
}
interface IQuickInputHideEvent {
    reason: QuickInputHideReason;
}
interface IQuickInput extends IDisposable {
    readonly onDidHide: Event$1<IQuickInputHideEvent>;
    readonly onDispose: Event$1<void>;
    title: string | undefined;
    description: string | undefined;
    step: number | undefined;
    totalSteps: number | undefined;
    enabled: boolean;
    contextKey: string | undefined;
    busy: boolean;
    ignoreFocusOut: boolean;
    show(): void;
    hide(): void;
}
interface IQuickPickWillAcceptEvent {
    /**
     * Allows to disable the default accept handling
     * of the picker. If `veto` is called, the picker
     * will not trigger the `onDidAccept` event.
     */
    veto(): void;
}
interface IQuickPickDidAcceptEvent {
    /**
     * Signals if the picker item is to be accepted
     * in the background while keeping the picker open.
     */
    inBackground: boolean;
}
declare enum ItemActivation {
    NONE = 0,
    FIRST = 1,
    SECOND = 2,
    LAST = 3
}
interface IQuickPick<T extends IQuickPickItem> extends IQuickInput {
    value: string;
    /**
     * A method that allows to massage the value used
     * for filtering, e.g, to remove certain parts.
     */
    filterValue: (value: string) => string;
    ariaLabel: string | undefined;
    placeholder: string | undefined;
    readonly onDidChangeValue: Event$1<string>;
    readonly onWillAccept: Event$1<IQuickPickWillAcceptEvent>;
    readonly onDidAccept: Event$1<IQuickPickDidAcceptEvent>;
    /**
     * If enabled, will fire the `onDidAccept` event when
     * pressing the arrow-right key with the idea of accepting
     * the selected item without closing the picker.
     */
    canAcceptInBackground: boolean;
    ok: boolean | 'default';
    readonly onDidCustom: Event$1<void>;
    customButton: boolean;
    customLabel: string | undefined;
    customHover: string | undefined;
    buttons: ReadonlyArray<IQuickInputButton>;
    readonly onDidTriggerButton: Event$1<IQuickInputButton>;
    readonly onDidTriggerItemButton: Event$1<IQuickPickItemButtonEvent<T>>;
    readonly onDidTriggerSeparatorButton: Event$1<IQuickPickSeparatorButtonEvent>;
    items: ReadonlyArray<T | IQuickPickSeparator>;
    scrollTop: number;
    canSelectMany: boolean;
    matchOnDescription: boolean;
    matchOnDetail: boolean;
    matchOnLabel: boolean;
    /**
     * The mode to filter label with. Fuzzy will use fuzzy searching and
     * contiguous will make filter entries that do not contain the exact string
     * (including whitespace). This defaults to `'fuzzy'`.
     */
    matchOnLabelMode: 'fuzzy' | 'contiguous';
    sortByLabel: boolean;
    autoFocusOnList: boolean;
    keepScrollPosition: boolean;
    quickNavigate: IQuickNavigateConfiguration | undefined;
    activeItems: ReadonlyArray<T>;
    readonly onDidChangeActive: Event$1<T[]>;
    /**
     * Allows to control which entry should be activated by default.
     */
    itemActivation: ItemActivation;
    selectedItems: ReadonlyArray<T>;
    readonly onDidChangeSelection: Event$1<T[]>;
    readonly keyMods: IKeyMods;
    valueSelection: Readonly<[number, number]> | undefined;
    validationMessage: string | undefined;
    inputHasFocus(): boolean;
    focusOnInput(): void;
    /**
     * Hides the input box from the picker UI. This is typically used
     * in combination with quick-navigation where no search UI should
     * be presented.
     */
    hideInput: boolean;
    hideCheckAll: boolean;
    /**
     * A set of `Toggle` objects to add to the input box.
     */
    toggles: IQuickInputToggle[] | undefined;
}
interface IQuickInputToggle {
    onChange: Event$1<boolean>;
}
interface IInputBox extends IQuickInput {
    /**
     * Value shown in the input box.
     */
    value: string;
    /**
     * Provide start and end values to be selected in the input box.
     */
    valueSelection: Readonly<[number, number]> | undefined;
    /**
     * Value shown as example for input.
     */
    placeholder: string | undefined;
    /**
     * Determines if the input value should be hidden while typing.
     */
    password: boolean;
    /**
     * Event called when the input value changes.
     */
    readonly onDidChangeValue: Event$1<string>;
    /**
     * Event called when the user submits the input.
     */
    readonly onDidAccept: Event$1<void>;
    /**
     * Buttons to show in addition to user input submission.
     */
    buttons: ReadonlyArray<IQuickInputButton>;
    /**
     * Event called when a button is selected.
     */
    readonly onDidTriggerButton: Event$1<IQuickInputButton>;
    /**
     * Text show below the input box.
     */
    prompt: string | undefined;
    /**
     * An optional validation message indicating a problem with the current input value.
     * Returning undefined clears the validation message.
     */
    validationMessage: string | undefined;
    /**
     * Severity of the input validation message.
     */
    severity: Severity$1;
}
interface IQuickInputButton {
    /** iconPath or iconClass required */
    iconPath?: {
        dark: URI;
        light?: URI;
    };
    /** iconPath or iconClass required */
    iconClass?: string;
    tooltip?: string;
    /**
     * Whether to always show the button. By default buttons
     * are only visible when hovering over them with the mouse
     */
    alwaysVisible?: boolean;
}
interface IQuickPickItemButtonEvent<T extends IQuickPickItem> {
    button: IQuickInputButton;
    item: T;
}
interface IQuickPickSeparatorButtonEvent {
    button: IQuickInputButton;
    separator: IQuickPickSeparator;
}
interface IQuickPickItemButtonContext<T extends IQuickPickItem> extends IQuickPickItemButtonEvent<T> {
    removeItem(): void;
}
type QuickPickInput<T = IQuickPickItem> = T | IQuickPickSeparator;
type Omit$1<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
declare const IQuickInputService: ServiceIdentifier<IQuickInputService>;
interface IQuickInputService {
    readonly _serviceBrand: undefined;
    /**
     * Provides access to the back button in quick input.
     */
    readonly backButton: IQuickInputButton;
    /**
     * Provides access to the quick access providers.
     */
    readonly quickAccess: IQuickAccessController;
    /**
     * Allows to register on the event that quick input is showing.
     */
    readonly onShow: Event$1<void>;
    /**
     * Allows to register on the event that quick input is hiding.
     */
    readonly onHide: Event$1<void>;
    /**
     * Opens the quick input box for selecting items and returns a promise
     * with the user selected item(s) if any.
     */
    pick<T extends IQuickPickItem>(picks: Promise<QuickPickInput<T>[]> | QuickPickInput<T>[], options?: IPickOptions<T> & {
        canPickMany: true;
    }, token?: CancellationToken): Promise<T[] | undefined>;
    pick<T extends IQuickPickItem>(picks: Promise<QuickPickInput<T>[]> | QuickPickInput<T>[], options?: IPickOptions<T> & {
        canPickMany: false;
    }, token?: CancellationToken): Promise<T | undefined>;
    pick<T extends IQuickPickItem>(picks: Promise<QuickPickInput<T>[]> | QuickPickInput<T>[], options?: Omit$1<IPickOptions<T>, 'canPickMany'>, token?: CancellationToken): Promise<T | undefined>;
    /**
     * Opens the quick input box for text input and returns a promise with the user typed value if any.
     */
    input(options?: IInputOptions, token?: CancellationToken): Promise<string | undefined>;
    /**
     * Provides raw access to the quick pick controller.
     */
    createQuickPick<T extends IQuickPickItem>(): IQuickPick<T>;
    /**
     * Provides raw access to the quick input controller.
     */
    createInputBox(): IInputBox;
    /**
     * Moves focus into quick input.
     */
    focus(): void;
    /**
     * Toggle the checked state of the selected item.
     */
    toggle(): void;
    /**
     * Navigate inside the opened quick input list.
     */
    navigate(next: boolean, quickNavigate?: IQuickNavigateConfiguration): void;
    /**
     * Navigate back in a multi-step quick input.
     */
    back(): Promise<void>;
    /**
     * Accept the selected item.
     *
     * @param keyMods allows to override the state of key
     * modifiers that should be present when invoking.
     */
    accept(keyMods?: IKeyMods): Promise<void>;
    /**
     * Cancels quick input and closes it.
     */
    cancel(): Promise<void>;
}

interface IEditorCloseHandler {
    /**
     * If `true`, will call into the `confirm` method to ask for confirmation
     * before closing the editor.
     */
    showConfirm(): boolean;
    /**
     * Allows an editor to control what should happen when the editor
     * (or a list of editor of the same kind) is being closed.
     *
     * By default a file specific dialog will open if the editor is
     * dirty and not in the process of saving.
     *
     * If the editor is not dealing with files or another condition
     * should be used besides dirty state, this method should be
     * implemented to show a different dialog.
     *
     * @param editors All editors of the same kind that are being closed. Should be used
     * to show a combined dialog.
     */
    confirm(editors: ReadonlyArray<IEditorIdentifier>): Promise<ConfirmResult>;
}
/**
 * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.
 * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.
 */
declare abstract class EditorInput extends AbstractEditorInput {
    protected readonly _onDidChangeDirty: Emitter<void>;
    protected readonly _onDidChangeLabel: Emitter<void>;
    protected readonly _onDidChangeCapabilities: Emitter<void>;
    private readonly _onWillDispose;
    /**
     * Triggered when this input changes its dirty state.
     */
    readonly onDidChangeDirty: Event$1<void>;
    /**
     * Triggered when this input changes its label
     */
    readonly onDidChangeLabel: Event$1<void>;
    /**
     * Triggered when this input changes its capabilities.
     */
    readonly onDidChangeCapabilities: Event$1<void>;
    /**
     * Triggered when this input is about to be disposed.
     */
    readonly onWillDispose: Event$1<void>;
    private disposed;
    /**
     * Optional: subclasses can override to implement
     * custom confirmation on close behavior.
     */
    readonly closeHandler?: IEditorCloseHandler;
    /**
     * Unique type identifier for this input. Every editor input of the
     * same class should share the same type identifier. The type identifier
     * is used for example for serialising/deserialising editor inputs
     * via the serialisers of the `EditorInputFactoryRegistry`.
     */
    abstract get typeId(): string;
    /**
     * Returns the optional associated resource of this input.
     *
     * This resource should be unique for all editors of the same
     * kind and input and is often used to identify the editor input among
     * others.
     *
     * **Note:** DO NOT use this property for anything but identity
     * checks. DO NOT use this property to present as label to the user.
     * Please refer to `EditorResourceAccessor` documentation in that case.
     */
    abstract get resource(): URI | undefined;
    /**
     * Identifies the type of editor this input represents
     * This ID is registered with the {@link EditorResolverService} to allow
     * for resolving an untyped input to a typed one
     */
    get editorId(): string | undefined;
    /**
     * The capabilities of the input.
     */
    get capabilities(): EditorInputCapabilities;
    /**
     * Figure out if the input has the provided capability.
     */
    hasCapability(capability: EditorInputCapabilities): boolean;
    /**
     * Returns the display name of this input.
     */
    getName(): string;
    /**
     * Returns the display description of this input.
     */
    getDescription(verbosity?: Verbosity): string | undefined;
    /**
     * Returns the display title of this input.
     */
    getTitle(verbosity?: Verbosity): string;
    /**
     * Returns the extra classes to apply to the label of this input.
     */
    getLabelExtraClasses(): string[];
    /**
     * Returns the aria label to be read out by a screen reader.
     */
    getAriaLabel(): string;
    /**
     * Returns a descriptor suitable for telemetry events.
     *
     * Subclasses should extend if they can contribute.
     */
    getTelemetryDescriptor(): {
        [key: string]: unknown;
    };
    /**
     * Returns if this input is dirty or not.
     */
    isDirty(): boolean;
    /**
     * Returns if this input is currently being saved or soon to be
     * saved. Based on this assumption the editor may for example
     * decide to not signal the dirty state to the user assuming that
     * the save is scheduled to happen anyway.
     */
    isSaving(): boolean;
    /**
     * Returns a type of `IEditorModel` that represents the resolved input.
     * Subclasses should override to provide a meaningful model or return
     * `null` if the editor does not require a model.
     *
     * The `options` parameter are passed down from the editor when the
     * input is resolved as part of it.
     */
    resolve(options?: IEditorOptions): Promise<IEditorModel$1 | null>;
    /**
     * Saves the editor. The provided groupId helps implementors
     * to e.g. preserve view state of the editor and re-open it
     * in the correct group after saving.
     *
     * @returns the resulting editor input (typically the same) of
     * this operation or `undefined` to indicate that the operation
     * failed or was canceled.
     */
    save(group: GroupIdentifier, options?: ISaveOptions): Promise<EditorInput | IUntypedEditorInput | undefined>;
    /**
     * Saves the editor to a different location. The provided `group`
     * helps implementors to e.g. preserve view state of the editor
     * and re-open it in the correct group after saving.
     *
     * @returns the resulting editor input (typically a different one)
     * of this operation or `undefined` to indicate that the operation
     * failed or was canceled.
     */
    saveAs(group: GroupIdentifier, options?: ISaveOptions): Promise<EditorInput | IUntypedEditorInput | undefined>;
    /**
     * Reverts this input from the provided group.
     */
    revert(group: GroupIdentifier, options?: IRevertOptions): Promise<void>;
    /**
     * Called to determine how to handle a resource that is renamed that matches
     * the editors resource (or is a child of).
     *
     * Implementors are free to not implement this method to signal no intent
     * to participate. If an editor is returned though, it will replace the
     * current one with that editor and optional options.
     */
    rename(group: GroupIdentifier, target: URI): Promise<IMoveResult | undefined>;
    /**
     * Returns a copy of the current editor input. Used when we can't just reuse the input
     */
    copy(): EditorInput;
    /**
     * Returns if the other object matches this input.
     */
    matches(otherInput: EditorInput | IUntypedEditorInput): boolean;
    /**
     * If a editor was registered onto multiple editor panes, this method
     * will be asked to return the preferred one to use.
     *
     * @param editorPanes a list of editor pane descriptors that are candidates
     * for the editor to open in.
     */
    prefersEditorPane<T extends IEditorDescriptor<IEditorPane>>(editorPanes: T[]): T | undefined;
    /**
     * Returns a representation of this typed editor input as untyped
     * resource editor input that e.g. can be used to serialize the
     * editor input into a form that it can be restored.
     *
     * May return `undefined` if an untyped representation is not supported.
     *
     * @param options additional configuration for the expected return type.
     * When `preserveViewState` is provided, implementations should try to
     * preserve as much view state as possible from the typed input based on
     * the group the editor is opened.
     */
    toUntyped(options?: {
        preserveViewState: GroupIdentifier;
    }): IUntypedEditorInput | undefined;
    /**
     * Returns if this editor is disposed.
     */
    isDisposed(): boolean;
    dispose(): void;
}

declare const enum WorkingCopyCapabilities {
    /**
     * Signals no specific capability for the working copy.
     */
    None = 0,
    /**
     * Signals that the working copy requires
     * additional input when saving, e.g. an
     * associated path to save to.
     */
    Untitled = 2
}
/**
 * Data to be associated with working copy backups. Use
 * `IWorkingCopyBackupService.resolve(workingCopy)` to
 * retrieve the backup when loading the working copy.
 */
interface IWorkingCopyBackup {
    /**
     * Any serializable metadata to be associated with the backup.
     */
    meta?: IWorkingCopyBackupMeta;
    /**
     * The actual snapshot of the contents of the working copy at
     * the time the backup was made.
     */
    content?: VSBufferReadable | VSBufferReadableStream;
}
/**
 * Working copy backup metadata that can be associated
 * with the backup.
 *
 * Some properties may be reserved as outlined here and
 * cannot be used.
 */
interface IWorkingCopyBackupMeta {
    /**
     * Any property needs to be serializable through JSON.
     */
    [key: string]: unknown;
    /**
     * `typeId` is a reserved property that cannot be used
     * as backup metadata.
     */
    typeId?: never;
}
/**
 * Every working copy has in common that it is identified by
 * a resource `URI` and a `typeId`. There can only be one
 * working copy registered with the same `URI` and `typeId`.
 */
interface IWorkingCopyIdentifier {
    /**
     * The type identifier of the working copy for grouping
     * working copies of the same domain together.
     *
     * There can only be one working copy for a given resource
     * and type identifier.
     */
    readonly typeId: string;
    /**
     * The resource of the working copy must be unique for
     * working copies of the same `typeId`.
     */
    readonly resource: URI;
}
interface IWorkingCopySaveEvent {
    /**
     * The reason why the working copy was saved.
     */
    readonly reason?: SaveReason;
    /**
     * The source of the working copy save request.
     */
    readonly source?: SaveSource;
}
/**
 * A working copy is an abstract concept to unify handling of
 * data that can be worked on (e.g. edited) in an editor.
 *
 *
 * A working copy resource may be the backing store of the data
 * (e.g. a file on disk), but that is not a requirement. If
 * your working copy is file based, consider to use the
 * `IFileWorkingCopy` instead that simplifies a lot of things
 * when working with file based working copies.
 */
interface IWorkingCopy extends IWorkingCopyIdentifier {
    /**
     * Human readable name of the working copy.
     */
    readonly name: string;
    /**
     * The capabilities of the working copy.
     */
    readonly capabilities: WorkingCopyCapabilities;
    /**
     * Used by the workbench to signal if the working copy
     * is dirty or not. Typically a working copy is dirty
     * once changed until saved or reverted.
     */
    readonly onDidChangeDirty: Event$1<void>;
    /**
     * Used by the workbench e.g. to trigger auto-save
     * (unless this working copy is untitled) and backups.
     */
    readonly onDidChangeContent: Event$1<void>;
    /**
     * Used by the workbench e.g. to track local history
     * (unless this working copy is untitled).
     */
    readonly onDidSave: Event$1<IWorkingCopySaveEvent>;
    isDirty(): boolean;
    /**
     * The workbench may call this method often after it receives
     * the `onDidChangeContent` event for the working copy. The motivation
     * is to allow to quit VSCode with dirty working copies present.
     *
     * Providers of working copies should use `IWorkingCopyBackupService.resolve(workingCopy)`
     * to retrieve the backup metadata associated when loading the working copy.
     *
     * @param token support for cancellation
     */
    backup(token: CancellationToken): Promise<IWorkingCopyBackup>;
    /**
     * Asks the working copy to save. If the working copy was dirty, it is
     * expected to be non-dirty after this operation has finished.
     *
     * @returns `true` if the operation was successful and `false` otherwise.
     */
    save(options?: ISaveOptions): Promise<boolean>;
    /**
     * Asks the working copy to revert. If the working copy was dirty, it is
     * expected to be non-dirty after this operation has finished.
     */
    revert(options?: IRevertOptions): Promise<void>;
}

interface IGroupModelChangeEvent {
    /**
     * The kind of change that occurred in the group model.
     */
    readonly kind: GroupModelChangeKind;
    /**
     * Only applies when editors change providing
     * access to the editor the event is about.
     */
    readonly editor?: EditorInput;
    /**
     * Only applies when editors change providing
     * access to the index of the editor the event
     * is about.
     */
    readonly editorIndex?: number;
}

/**
 * Open an editor in the currently active group.
 */
declare const ACTIVE_GROUP = -1;
type ACTIVE_GROUP_TYPE = typeof ACTIVE_GROUP;
/**
 * Open an editor to the side of the active group.
 */
declare const SIDE_GROUP = -2;
type SIDE_GROUP_TYPE = typeof SIDE_GROUP;
interface ISaveEditorsOptions extends ISaveOptions {
    /**
     * If true, will ask for a location of the editor to save to.
     */
    readonly saveAs?: boolean;
}
interface IUntypedEditorReplacement {
    /**
     * The editor to replace.
     */
    readonly editor: EditorInput;
    /**
     * The replacement for the editor.
     */
    readonly replacement: IUntypedEditorInput;
    /**
     * Skips asking the user for confirmation and doesn't
     * save the document. Only use this if you really need to!
    */
    forceReplaceDirty?: boolean;
}
interface IBaseSaveRevertAllEditorOptions {
    /**
     * Whether to include untitled editors as well.
     */
    readonly includeUntitled?: boolean;
    /**
     * Whether to exclude sticky editors.
     */
    readonly excludeSticky?: boolean;
}
interface ISaveAllEditorsOptions extends ISaveEditorsOptions, IBaseSaveRevertAllEditorOptions {
}
interface IRevertAllEditorsOptions extends IRevertOptions, IBaseSaveRevertAllEditorOptions {
}
interface IOpenEditorsOptions {
    /**
     * Whether to validate trust when opening editors
     * that are potentially not inside the workspace.
     */
    readonly validateTrust?: boolean;
}
interface IEditorsChangeEvent {
    /**
     * The group which had the editor change
     */
    groupId: GroupIdentifier;
    event: IGroupModelChangeEvent;
}
declare const IEditorService: ServiceIdentifier<IEditorService>;
interface IEditorService {
    readonly _serviceBrand: undefined;
    /**
     * Emitted when the currently active editor changes.
     *
     * @see {@link IEditorService.activeEditorPane}
     */
    readonly onDidActiveEditorChange: Event$1<void>;
    /**
     * Emitted when any of the current visible editors changes.
     *
     * @see {@link IEditorService.visibleEditorPanes}
     */
    readonly onDidVisibleEditorsChange: Event$1<void>;
    /**
     * An aggregated event for any change to any editor across
     * all groups.
     */
    readonly onDidEditorsChange: Event$1<IEditorsChangeEvent>;
    /**
     * Emitted when an editor is closed.
     */
    readonly onDidCloseEditor: Event$1<IEditorCloseEvent>;
    /**
     * The currently active editor pane or `undefined` if none. The editor pane is
     * the workbench container for editors of any kind.
     *
     * @see {@link IEditorService.activeEditor} for access to the active editor input
     */
    readonly activeEditorPane: IVisibleEditorPane | undefined;
    /**
     * The currently active editor or `undefined` if none. An editor is active when it is
     * located in the currently active editor group. It will be `undefined` if the active
     * editor group has no editors open.
     */
    readonly activeEditor: EditorInput | undefined;
    /**
     * The currently active text editor control or `undefined` if there is currently no active
     * editor or the active editor widget is neither a text nor a diff editor.
     *
     * @see {@link IEditorService.activeEditor}
     */
    readonly activeTextEditorControl: IEditor | IDiffEditor$1 | undefined;
    /**
     * The currently active text editor language id or `undefined` if there is currently no active
     * editor or the active editor control is neither a text nor a diff editor. If the active
     * editor is a diff editor, the modified side's language id will be taken.
     */
    readonly activeTextEditorLanguageId: string | undefined;
    /**
     * All editor panes that are currently visible across all editor groups.
     *
     * @see {@link IEditorService.visibleEditors} for access to the visible editor inputs
     */
    readonly visibleEditorPanes: readonly IVisibleEditorPane[];
    /**
     * All editors that are currently visible. An editor is visible when it is opened in an
     * editor group and active in that group. Multiple editor groups can be opened at the same time.
     */
    readonly visibleEditors: readonly EditorInput[];
    /**
     * All text editor widgets that are currently visible across all editor groups. A text editor
     * widget is either a text or a diff editor.
     */
    readonly visibleTextEditorControls: readonly (IEditor | IDiffEditor$1)[];
    /**
     * All editors that are opened across all editor groups in sequential order
     * of appearance.
     *
     * This includes active as well as inactive editors in each editor group.
     */
    readonly editors: readonly EditorInput[];
    /**
     * The total number of editors that are opened either inactive or active.
     */
    readonly count: number;
    /**
     * All editors that are opened across all editor groups with their group
     * identifier.
     *
     * @param order the order of the editors to use
     * @param options whether to exclude sticky editors or not
     */
    getEditors(order: EditorsOrder, options?: {
        excludeSticky?: boolean;
    }): readonly IEditorIdentifier[];
    /**
     * Open an editor in an editor group.
     *
     * @param editor the editor to open
     * @param options the options to use for the editor
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP` to open the editor in a new editor group to the side
     * of the currently active group.
     *
     * @returns the editor that opened or `undefined` if the operation failed or the editor was not
     * opened to be active.
     */
    openEditor(editor: IResourceEditorInput, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<IEditorPane | undefined>;
    openEditor(editor: ITextResourceEditorInput | IUntitledTextResourceEditorInput, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<IEditorPane | undefined>;
    openEditor(editor: IResourceDiffEditorInput, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<ITextDiffEditorPane | undefined>;
    openEditor(editor: IUntypedEditorInput, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<IEditorPane | undefined>;
    /**
     * @deprecated using this method is a sign that your editor has not adopted the editor
     * resolver yet. Please use `IEditorResolverService.registerEditor` to make your editor
     * known to the workbench and then use untyped editor inputs for opening:
     *
     * ```ts
     * editorService.openEditor({ resource });
     * ```
     *
     * If you already have an `EditorInput` in hand and must use it for opening, use `group.openEditor`
     * instead, via `IEditorGroupService`.
     */
    openEditor(editor: EditorInput, options?: IEditorOptions, group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE): Promise<IEditorPane | undefined>;
    /**
     * Open editors in an editor group.
     *
     * @param editors the editors to open with associated options
     * @param group the target group. If unspecified, the editor will open in the currently
     * active group. Use `SIDE_GROUP` to open the editor in a new editor group to the side
     * of the currently active group.
     *
     * @returns the editors that opened. The array can be empty or have less elements for editors
     * that failed to open or were instructed to open as inactive.
     */
    openEditors(editors: IUntypedEditorInput[], group?: IEditorGroup | GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE, options?: IOpenEditorsOptions): Promise<readonly IEditorPane[]>;
    /**
     * Replaces editors in an editor group with the provided replacement.
     *
     * @param replacements the editors to replace
     * @param group the editor group
     *
     * @returns a promise that is resolved when the replaced active
     * editor (if any) has finished loading.
     */
    replaceEditors(replacements: IUntypedEditorReplacement[], group: IEditorGroup | GroupIdentifier): Promise<void>;
    /**
     * Find out if the provided editor is opened in any editor group.
     *
     * Note: An editor can be opened but not actively visible.
     *
     * Note: This method will return `true` if a side by side editor
     * is opened where the `primary` editor matches too.
     */
    isOpened(editor: IResourceEditorInputIdentifier): boolean;
    /**
     * Find out if the provided editor is visible in any editor group.
     */
    isVisible(editor: EditorInput): boolean;
    /**
     * Close an editor in a specific editor group.
     */
    closeEditor(editor: IEditorIdentifier, options?: ICloseEditorOptions): Promise<void>;
    /**
     * Close multiple editors in specific editor groups.
     */
    closeEditors(editors: readonly IEditorIdentifier[], options?: ICloseEditorOptions): Promise<void>;
    /**
     * This method will return an entry for each editor that reports
     * a `resource` that matches the provided one in the group or
     * across all groups.
     *
     * It is possible that multiple editors are returned in case the
     * same resource is opened in different editors. To find the specific
     * editor, use the `IResourceEditorInputIdentifier` as input.
     */
    findEditors(resource: URI, options?: IFindEditorOptions): readonly IEditorIdentifier[];
    findEditors(editor: IResourceEditorInputIdentifier, options?: IFindEditorOptions): readonly IEditorIdentifier[];
    /**
     * Save the provided list of editors.
     *
     * @returns `true` if all editors saved and `false` otherwise.
     */
    save(editors: IEditorIdentifier | IEditorIdentifier[], options?: ISaveEditorsOptions): Promise<boolean>;
    /**
     * Save all editors.
     *
     * @returns `true` if all editors saved and `false` otherwise.
     */
    saveAll(options?: ISaveAllEditorsOptions): Promise<boolean>;
    /**
     * Reverts the provided list of editors.
     *
     * @returns `true` if all editors reverted and `false` otherwise.
     */
    revert(editors: IEditorIdentifier | IEditorIdentifier[], options?: IRevertOptions): Promise<boolean>;
    /**
     * Reverts all editors.
     *
     * @returns `true` if all editors reverted and `false` otherwise.
     */
    revertAll(options?: IRevertAllEditorsOptions): Promise<boolean>;
}

interface IUntitledTextEditorModel extends ITextEditorModel, ILanguageSupport, IEncodingSupport, IWorkingCopy {
    /**
     * Emits an event when the encoding of this untitled model changes.
     */
    readonly onDidChangeEncoding: Event$1<void>;
    /**
     * Emits an event when the name of this untitled model changes.
     */
    readonly onDidChangeName: Event$1<void>;
    /**
     * Emits an event when this untitled model is reverted.
     */
    readonly onDidRevert: Event$1<void>;
    /**
     * Whether this untitled text model has an associated file path.
     */
    readonly hasAssociatedFilePath: boolean;
    /**
     * Whether this model has an explicit language or not.
     */
    readonly hasLanguageSetExplicitly: boolean;
    /**
     * Sets the encoding to use for this untitled model.
     */
    setEncoding(encoding: string): Promise<void>;
    /**
     * Resolves the untitled model.
     */
    resolve(): Promise<void>;
}

interface INewUntitledTextEditorOptions {
    /**
     * Initial value of the untitled editor. An untitled editor with initial
     * value is dirty right from the beginning.
     */
    initialValue?: string;
    /**
     * Preferred language id to use when saving the untitled editor.
     */
    languageId?: string;
    /**
     * Preferred encoding to use when saving the untitled editor.
     */
    encoding?: string;
}
interface IExistingUntitledTextEditorOptions extends INewUntitledTextEditorOptions {
    /**
     * A resource to identify the untitled editor to create or return
     * if already existing.
     *
     * Note: the resource will not be used unless the scheme is `untitled`.
     */
    untitledResource?: URI;
}
interface INewUntitledTextEditorWithAssociatedResourceOptions extends INewUntitledTextEditorOptions {
    /**
     * Resource components to associate with the untitled editor. When saving
     * the untitled editor, the associated components will be used and the user
     * is not being asked to provide a file path.
     *
     * Note: currently it is not possible to specify the `scheme` to use. The
     * untitled editor will saved to the default local or remote resource.
     */
    associatedResource?: {
        authority: string;
        path: string;
        query: string;
        fragment: string;
    };
}
interface IUntitledTextEditorModelManager {
    /**
     * Events for when untitled text editors change (e.g. getting dirty, saved or reverted).
     */
    readonly onDidChangeDirty: Event$1<IUntitledTextEditorModel>;
    /**
     * Events for when untitled text editor encodings change.
     */
    readonly onDidChangeEncoding: Event$1<IUntitledTextEditorModel>;
    /**
     * Events for when untitled text editor labels change.
     */
    readonly onDidChangeLabel: Event$1<IUntitledTextEditorModel>;
    /**
     * Events for when untitled text editors are about to be disposed.
     */
    readonly onWillDispose: Event$1<IUntitledTextEditorModel>;
    /**
     * Creates a new untitled editor model with the provided options. If the `untitledResource`
     * property is provided and the untitled editor exists, it will return that existing
     * instance instead of creating a new one.
     */
    create(options?: INewUntitledTextEditorOptions): IUntitledTextEditorModel;
    create(options?: INewUntitledTextEditorWithAssociatedResourceOptions): IUntitledTextEditorModel;
    create(options?: IExistingUntitledTextEditorOptions): IUntitledTextEditorModel;
    /**
     * Returns an existing untitled editor model if already created before.
     */
    get(resource: URI): IUntitledTextEditorModel | undefined;
    /**
     * Returns the value of the untitled editor, undefined if none exists
     * @param resource The URI of the untitled file
     * @returns The content, or undefined
     */
    getValue(resource: URI): string | undefined;
    /**
     * Resolves an untitled editor model from the provided options. If the `untitledResource`
     * property is provided and the untitled editor exists, it will return that existing
     * instance instead of creating a new one.
     */
    resolve(options?: INewUntitledTextEditorOptions): Promise<IUntitledTextEditorModel>;
    resolve(options?: INewUntitledTextEditorWithAssociatedResourceOptions): Promise<IUntitledTextEditorModel>;
    resolve(options?: IExistingUntitledTextEditorOptions): Promise<IUntitledTextEditorModel>;
}

/**
 * A resource based `IWorkingCopy` is backed by a `URI` from a
 * known file system provider.
 */
interface IResourceWorkingCopy extends IWorkingCopy, IDisposable {
    /**
     * An event for when the orphaned state of the resource working copy changes.
     */
    readonly onDidChangeOrphaned: Event$1<void>;
    /**
     * Whether the resource working copy is orphaned or not.
     */
    isOrphaned(): boolean;
    /**
     * An event for when the file working copy has been disposed.
     */
    readonly onWillDispose: Event$1<void>;
    /**
     * Whether the file working copy has been disposed or not.
     */
    isDisposed(): boolean;
}

/**
 * A generic file working copy model to be reused by untitled
 * and stored file working copies.
 */
interface IFileWorkingCopyModel extends IDisposable {
    /**
     * This event signals ANY changes to the contents, for example:
     * - through the user typing into the editor
     * - from API usage (e.g. bulk edits)
     * - when `IFileWorkingCopyModel#update` is invoked with contents
     *   that are different from the current contents
     *
     * The file working copy will listen to these changes and may mark
     * the working copy as dirty whenever this event fires.
     *
     * Note: ONLY report changes to the model but not the underlying
     * file. The file working copy is tracking changes to the file
     * automatically.
     */
    readonly onDidChangeContent: Event$1<unknown>;
    /**
     * An event emitted right before disposing the model.
     */
    readonly onWillDispose: Event$1<void>;
    /**
     * Snapshots the model's current content for writing. This must include
     * any changes that were made to the model that are in memory.
     *
     * @param token support for cancellation
     */
    snapshot(token: CancellationToken): Promise<VSBufferReadableStream>;
    /**
     * Updates the model with the provided contents. The implementation should
     * behave in a similar fashion as `IFileWorkingCopyModelFactory#createModel`
     * except that here the model already exists and just needs to update to
     * the provided contents.
     *
     * Note: it is expected that the model fires a `onDidChangeContent` event
     * as part of the update.
     *
     * @param contents the contents to use for the model
     * @param token support for cancellation
     */
    update(contents: VSBufferReadableStream, token: CancellationToken): Promise<void>;
}
interface IFileWorkingCopy<M extends IFileWorkingCopyModel> extends IWorkingCopy, IDisposable {
    /**
     * An event for when the file working copy has been reverted.
     */
    readonly onDidRevert: Event$1<void>;
    /**
     * An event for when the file working copy has been disposed.
     */
    readonly onWillDispose: Event$1<void>;
    /**
     * Provides access to the underlying model of this file
     * based working copy. As long as the file working copy
     * has not been resolved, the model is `undefined`.
     */
    readonly model: M | undefined;
    /**
     * Resolves the file working copy and thus makes the `model`
     * available.
     */
    resolve(): Promise<void>;
    /**
     * Whether we have a resolved model or not.
     */
    isResolved(): this is IResolvedFileWorkingCopy<M>;
}
interface IResolvedFileWorkingCopy<M extends IFileWorkingCopyModel> extends IFileWorkingCopy<M> {
    /**
     * A resolved file working copy has a resolved model.
     */
    readonly model: M;
}

/**
 * The underlying model of a stored file working copy provides some
 * methods for the stored file working copy to function. The model is
 * typically only available after the working copy has been
 * resolved via it's `resolve()` method.
 */
interface IStoredFileWorkingCopyModel extends IFileWorkingCopyModel {
    readonly onDidChangeContent: Event$1<IStoredFileWorkingCopyModelContentChangedEvent>;
    /**
     * A version ID of the model. If a `onDidChangeContent` is fired
     * from the model and the last known saved `versionId` matches
     * with the `model.versionId`, the stored file working copy will
     * discard any dirty state.
     *
     * A use case is the following:
     * - a stored file working copy gets edited and thus dirty
     * - the user triggers undo to revert the changes
     * - at this point the `versionId` should match the one we had saved
     *
     * This requires the model to be aware of undo/redo operations.
     */
    readonly versionId: unknown;
    /**
     * Close the current undo-redo element. This offers a way
     * to create an undo/redo stop point.
     *
     * This method may for example be called right before the
     * save is triggered so that the user can always undo back
     * to the state before saving.
     */
    pushStackElement(): void;
}
interface IStoredFileWorkingCopyModelContentChangedEvent {
    /**
     * Flag that indicates that this event was generated while undoing.
     */
    readonly isUndoing: boolean;
    /**
     * Flag that indicates that this event was generated while redoing.
     */
    readonly isRedoing: boolean;
}
/**
 * A stored file based `IWorkingCopy` is backed by a `URI` from a
 * known file system provider. Given this assumption, a lot
 * of functionality can be built on top, such as saving in
 * a secure way to prevent data loss.
 */
interface IStoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel> extends IResourceWorkingCopy, IFileWorkingCopy<M> {
    /**
     * An event for when a stored file working copy was resolved.
     */
    readonly onDidResolve: Event$1<void>;
    /**
     * An event for when a stored file working copy was saved successfully.
     */
    readonly onDidSave: Event$1<IStoredFileWorkingCopySaveEvent>;
    /**
     * An event indicating that a stored file working copy save operation failed.
     */
    readonly onDidSaveError: Event$1<void>;
    /**
     * An event for when the readonly state of the stored file working copy changes.
     */
    readonly onDidChangeReadonly: Event$1<void>;
    /**
     * Resolves a stored file working copy.
     */
    resolve(options?: IStoredFileWorkingCopyResolveOptions): Promise<void>;
    /**
     * Explicitly sets the working copy to be dirty.
     */
    markDirty(): void;
    /**
     * Whether the stored file working copy is in the provided `state`
     * or not.
     *
     * @param state the `FileWorkingCopyState` to check on.
     */
    hasState(state: StoredFileWorkingCopyState): boolean;
    /**
     * Allows to join a state change away from the provided `state`.
     *
     * @param state currently only `FileWorkingCopyState.PENDING_SAVE`
     * can be awaited on to resolve.
     */
    joinState(state: StoredFileWorkingCopyState.PENDING_SAVE): Promise<void>;
    /**
     * Whether we have a resolved model or not.
     */
    isResolved(): this is IResolvedStoredFileWorkingCopy<M>;
    /**
     * Whether the stored file working copy is readonly or not.
     */
    isReadonly(): boolean;
}
interface IResolvedStoredFileWorkingCopy<M extends IStoredFileWorkingCopyModel> extends IStoredFileWorkingCopy<M> {
    /**
     * A resolved stored file working copy has a resolved model.
     */
    readonly model: M;
}
/**
 * States the stored file working copy can be in.
 */
declare const enum StoredFileWorkingCopyState {
    /**
     * A stored file working copy is saved.
     */
    SAVED = 0,
    /**
     * A stored file working copy is dirty.
     */
    DIRTY = 1,
    /**
     * A stored file working copy is currently being saved but
     * this operation has not completed yet.
     */
    PENDING_SAVE = 2,
    /**
     * A stored file working copy is in conflict mode when changes
     * cannot be saved because the underlying file has changed.
     * Stored file working copies in conflict mode are always dirty.
     */
    CONFLICT = 3,
    /**
     * A stored file working copy is in orphan state when the underlying
     * file has been deleted.
     */
    ORPHAN = 4,
    /**
     * Any error that happens during a save that is not causing
     * the `StoredFileWorkingCopyState.CONFLICT` state.
     * Stored file working copies in error mode are always dirty.
     */
    ERROR = 5
}
interface IStoredFileWorkingCopyResolveOptions {
    /**
     * The contents to use for the stored file working copy if known. If not
     * provided, the contents will be retrieved from the underlying
     * resource or backup if present.
     *
     * If contents are provided, the stored file working copy will be marked
     * as dirty right from the beginning.
     */
    readonly contents?: VSBufferReadableStream;
    /**
     * Go to disk bypassing any cache of the stored file working copy if any.
     */
    readonly forceReadFromFile?: boolean;
}
interface IStoredFileWorkingCopySaveEvent extends IWorkingCopySaveEvent {
    /**
     * The resolved stat from the save operation.
     */
    readonly stat: IFileStatWithMetadata;
}

interface SourceTargetPair {
    /**
     * The source resource that is defined for move operations.
     */
    readonly source?: URI;
    /**
     * The target resource the event is about.
     */
    readonly target: URI;
}
interface IFileOperationUndoRedoInfo {
    /**
     * Id of the undo group that the file operation belongs to.
     */
    undoRedoGroupId?: number;
    /**
     * Flag indicates if the operation is an undo.
     */
    isUndoing?: boolean;
}
interface WorkingCopyFileEvent extends IWaitUntil {
    /**
     * An identifier to correlate the operation through the
     * different event types (before, after, error).
     */
    readonly correlationId: number;
    /**
     * The file operation that is taking place.
     */
    readonly operation: FileOperation;
    /**
     * The array of source/target pair of files involved in given operation.
     */
    readonly files: readonly SourceTargetPair[];
}
interface IWorkingCopyFileOperationParticipant {
    /**
     * Participate in a file operation of working copies. Allows to
     * change the working copies before they are being saved to disk.
     */
    participate(files: SourceTargetPair[], operation: FileOperation, undoInfo: IFileOperationUndoRedoInfo | undefined, timeout: number, token: CancellationToken): Promise<void>;
}
interface IStoredFileWorkingCopySaveParticipant {
    /**
     * Participate in a save operation of file stored working copies.
     * Allows to make changes before content is being saved to disk.
     */
    participate(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: {
        reason: SaveReason;
    }, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;
}
interface ICreateOperation {
    resource: URI;
    overwrite?: boolean;
}
interface ICreateFileOperation extends ICreateOperation {
    contents?: VSBuffer | VSBufferReadable | VSBufferReadableStream;
}
interface IDeleteOperation {
    resource: URI;
    useTrash?: boolean;
    recursive?: boolean;
}
interface IMoveOperation {
    file: Required<SourceTargetPair>;
    overwrite?: boolean;
}
interface ICopyOperation extends IMoveOperation {
}
/**
 * Returns the working copies for a given resource.
 */
type WorkingCopyProvider = (resourceOrFolder: URI) => IWorkingCopy[];
declare const IWorkingCopyFileService: ServiceIdentifier<IWorkingCopyFileService>;
/**
 * A service that allows to perform file operations with working copy support.
 * Any operation that would leave a stale dirty working copy behind will make
 * sure to revert the working copy first.
 *
 * On top of that events are provided to participate in each state of the
 * operation to perform additional work.
 */
interface IWorkingCopyFileService {
    readonly _serviceBrand: undefined;
    /**
     * An event that is fired when a certain working copy IO operation is about to run.
     *
     * Participants can join this event with a long running operation to keep some state
     * before the operation is started, but working copies should not be changed at this
     * point in time. For that purpose, use the `IWorkingCopyFileOperationParticipant` API.
     */
    readonly onWillRunWorkingCopyFileOperation: Event$1<WorkingCopyFileEvent>;
    /**
     * An event that is fired after a working copy IO operation has failed.
     *
     * Participants can join this event with a long running operation to clean up as needed.
     */
    readonly onDidFailWorkingCopyFileOperation: Event$1<WorkingCopyFileEvent>;
    /**
     * An event that is fired after a working copy IO operation has been performed.
     *
     * Participants can join this event with a long running operation to make changes
     * after the operation has finished.
     */
    readonly onDidRunWorkingCopyFileOperation: Event$1<WorkingCopyFileEvent>;
    /**
     * Adds a participant for file operations on working copies.
     */
    addFileOperationParticipant(participant: IWorkingCopyFileOperationParticipant): IDisposable;
    /**
     * Whether save participants are present for stored file working copies.
     */
    get hasSaveParticipants(): boolean;
    /**
     * Adds a participant for save operations on stored file working copies.
     */
    addSaveParticipant(participant: IStoredFileWorkingCopySaveParticipant): IDisposable;
    /**
     * Runs all available save participants for stored file working copies.
     */
    runSaveParticipants(workingCopy: IStoredFileWorkingCopy<IStoredFileWorkingCopyModel>, context: {
        reason: SaveReason;
    }, token: CancellationToken): Promise<void>;
    /**
     * Will create a resource with the provided optional contents, optionally overwriting any target.
     *
     * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and
     * `onDidRunWorkingCopyFileOperation` events to participate.
     */
    create(operations: ICreateFileOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;
    /**
     * Will create a folder and any parent folder that needs to be created.
     *
     * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and
     * `onDidRunWorkingCopyFileOperation` events to participate.
     *
     * Note: events will only be emitted for the provided resource, but not any
     * parent folders that are being created as part of the operation.
     */
    createFolder(operations: ICreateOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;
    /**
     * Will move working copies matching the provided resources and corresponding children
     * to the target resources using the associated file service for those resources.
     *
     * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and
     * `onDidRunWorkingCopyFileOperation` events to participate.
     */
    move(operations: IMoveOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;
    /**
     * Will copy working copies matching the provided resources and corresponding children
     * to the target resources using the associated file service for those resources.
     *
     * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and
     * `onDidRunWorkingCopyFileOperation` events to participate.
     */
    copy(operations: ICopyOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;
    /**
     * Will delete working copies matching the provided resources and children
     * using the associated file service for those resources.
     *
     * Working copy owners can listen to the `onWillRunWorkingCopyFileOperation` and
     * `onDidRunWorkingCopyFileOperation` events to participate.
     */
    delete(operations: IDeleteOperation[], token: CancellationToken, undoInfo?: IFileOperationUndoRedoInfo): Promise<void>;
    /**
     * Register a new provider for working copies based on a resource.
     *
     * @return a disposable that unregisters the provider.
     */
    registerWorkingCopyProvider(provider: WorkingCopyProvider): IDisposable;
    /**
     * Will return all working copies that are dirty matching the provided resource.
     * If the resource is a folder and the scheme supports file operations, a working
     * copy that is dirty and is a child of that folder will also be returned.
     */
    getDirty(resource: URI): readonly IWorkingCopy[];
}

declare const ITextFileService: ServiceIdentifier<ITextFileService>;
interface ITextFileService extends IDisposable {
    readonly _serviceBrand: undefined;
    /**
     * Access to the manager of text file editor models providing further
     * methods to work with them.
     */
    readonly files: ITextFileEditorModelManager;
    /**
     * Access to the manager of untitled text editor models providing further
     * methods to work with them.
     */
    readonly untitled: IUntitledTextEditorModelManager;
    /**
     * Helper to determine encoding for resources.
     */
    readonly encoding: IResourceEncodings;
    /**
     * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.
     *
     * @param resource the resource to check for being dirty
     */
    isDirty(resource: URI): boolean;
    /**
     * Saves the resource.
     *
     * @param resource the resource to save
     * @param options optional save options
     * @return Path of the saved resource or undefined if canceled.
     */
    save(resource: URI, options?: ITextFileSaveOptions): Promise<URI | undefined>;
    /**
     * Saves the provided resource asking the user for a file name or using the provided one.
     *
     * @param resource the resource to save as.
     * @param targetResource the optional target to save to.
     * @param options optional save options
     * @return Path of the saved resource or undefined if canceled.
     */
    saveAs(resource: URI, targetResource?: URI, options?: ITextFileSaveAsOptions): Promise<URI | undefined>;
    /**
     * Reverts the provided resource.
     *
     * @param resource the resource of the file to revert.
     * @param force to force revert even when the file is not dirty
     */
    revert(resource: URI, options?: IRevertOptions): Promise<void>;
    /**
     * Read the contents of a file identified by the resource.
     */
    read(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileContent>;
    /**
     * Read the contents of a file identified by the resource as stream.
     */
    readStream(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileStreamContent>;
    /**
     * Update a file with given contents.
     */
    write(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;
    /**
     * Create files. If the file exists it will be overwritten with the contents if
     * the options enable to overwrite.
     */
    create(operations: {
        resource: URI;
        value?: string | ITextSnapshot;
        options?: {
            overwrite?: boolean;
        };
    }[], undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;
    /**
     * Returns the readable that uses the appropriate encoding. This method should
     * be used whenever a `string` or `ITextSnapshot` is being persisted to the
     * file system.
     */
    getEncodedReadable(resource: URI, value: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable>;
    getEncodedReadable(resource: URI, value: string, options?: IWriteTextFileOptions): Promise<VSBuffer>;
    getEncodedReadable(resource: URI, value?: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable | undefined>;
    getEncodedReadable(resource: URI, value?: string, options?: IWriteTextFileOptions): Promise<VSBuffer | undefined>;
    getEncodedReadable(resource: URI, value?: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;
    /**
     * Returns a stream of strings that uses the appropriate encoding. This method should
     * be used whenever a `VSBufferReadableStream` is being loaded from the file system.
     *
     * Will throw an error if `acceptTextOnly: true` for resources that seem to be binary.
     */
    getDecodedStream(resource: URI, value: VSBufferReadableStream, options?: IReadTextFileEncodingOptions): Promise<ReadableStream<string>>;
}
interface IReadTextFileEncodingOptions {
    /**
     * The optional encoding parameter allows to specify the desired encoding when resolving
     * the contents of the file.
     */
    readonly encoding?: string;
    /**
     * The optional guessEncoding parameter allows to guess encoding from content of the file.
     */
    readonly autoGuessEncoding?: boolean;
    /**
     * The optional acceptTextOnly parameter allows to fail this request early if the file
     * contents are not textual.
     */
    readonly acceptTextOnly?: boolean;
}
interface IReadTextFileOptions extends IReadTextFileEncodingOptions, IReadFileStreamOptions {
}
interface IWriteTextFileOptions extends IWriteFileOptions {
    /**
     * The encoding to use when updating a file.
     */
    readonly encoding?: string;
    /**
     * Whether to write to the file as elevated (admin) user. When setting this option a prompt will
     * ask the user to authenticate as super user.
     */
    readonly writeElevated?: boolean;
}
interface IResourceEncodings {
    getPreferredReadEncoding(resource: URI): Promise<IResourceEncoding>;
    getPreferredWriteEncoding(resource: URI, preferredEncoding?: string): Promise<IResourceEncoding>;
}
interface IResourceEncoding {
    readonly encoding: string;
    readonly hasBOM: boolean;
}
/**
 * The save error handler can be installed on the text file editor model to install code that executes when save errors occur.
 */
interface ISaveErrorHandler {
    /**
     * Called whenever a save fails.
     */
    onSaveError(error: Error, model: ITextFileEditorModel): void;
}
/**
 * States the text file editor model can be in.
 */
declare const enum TextFileEditorModelState {
    /**
     * A model is saved.
     */
    SAVED = 0,
    /**
     * A model is dirty.
     */
    DIRTY = 1,
    /**
     * A model is currently being saved but this operation has not completed yet.
     */
    PENDING_SAVE = 2,
    /**
     * A model is in conflict mode when changes cannot be saved because the
     * underlying file has changed. Models in conflict mode are always dirty.
     */
    CONFLICT = 3,
    /**
     * A model is in orphan state when the underlying file has been deleted.
     */
    ORPHAN = 4,
    /**
     * Any error that happens during a save that is not causing the CONFLICT state.
     * Models in error mode are always dirty.
     */
    ERROR = 5
}
declare const enum TextFileResolveReason {
    EDITOR = 1,
    REFERENCE = 2,
    OTHER = 3
}
interface IBaseTextFileContent extends IBaseFileStatWithMetadata {
    /**
     * The encoding of the content if known.
     */
    readonly encoding: string;
}
interface ITextFileContent extends IBaseTextFileContent {
    /**
     * The content of a text file.
     */
    readonly value: string;
}
interface ITextFileStreamContent extends IBaseTextFileContent {
    /**
     * The line grouped content of a text file.
     */
    readonly value: ITextBufferFactory;
}
interface ITextFileEditorModelResolveOrCreateOptions extends ITextFileResolveOptions {
    /**
     * The language id to use for the model text content.
     */
    readonly languageId?: string;
    /**
     * The encoding to use when resolving the model text content.
     */
    readonly encoding?: string;
    /**
     * If the model was already resolved before, allows to trigger
     * a reload of it to fetch the latest contents.
     */
    readonly reload?: {
        /**
         * Controls whether the reload happens in the background
         * or whether `resolve` will await the reload to happen.
         */
        readonly async: boolean;
    };
}
interface ITextFileSaveEvent extends ITextFileEditorModelSaveEvent {
    /**
     * The model that was saved.
     */
    readonly model: ITextFileEditorModel;
}
interface ITextFileResolveEvent {
    /**
     * The model that was resolved.
     */
    readonly model: ITextFileEditorModel;
    /**
     * The reason why the model was resolved.
     */
    readonly reason: TextFileResolveReason;
}
interface ITextFileSaveParticipant {
    /**
     * Participate in a save of a model. Allows to change the model
     * before it is being saved to disk.
     */
    participate(model: ITextFileEditorModel, context: {
        reason: SaveReason;
    }, progress: IProgress<IProgressStep>, token: CancellationToken): Promise<void>;
}
interface ITextFileEditorModelManager {
    readonly onDidCreate: Event$1<ITextFileEditorModel>;
    readonly onDidResolve: Event$1<ITextFileResolveEvent>;
    readonly onDidChangeDirty: Event$1<ITextFileEditorModel>;
    readonly onDidChangeReadonly: Event$1<ITextFileEditorModel>;
    readonly onDidRemove: Event$1<URI>;
    readonly onDidChangeOrphaned: Event$1<ITextFileEditorModel>;
    readonly onDidChangeEncoding: Event$1<ITextFileEditorModel>;
    readonly onDidSaveError: Event$1<ITextFileEditorModel>;
    readonly onDidSave: Event$1<ITextFileSaveEvent>;
    readonly onDidRevert: Event$1<ITextFileEditorModel>;
    /**
     * Access to all text file editor models in memory.
     */
    readonly models: ITextFileEditorModel[];
    /**
     * Allows to configure the error handler that is called on save errors.
     */
    saveErrorHandler: ISaveErrorHandler;
    /**
     * Returns the text file editor model for the provided resource
     * or undefined if none.
     */
    get(resource: URI): ITextFileEditorModel | undefined;
    /**
     * Allows to resolve a text file model from disk.
     */
    resolve(resource: URI, options?: ITextFileEditorModelResolveOrCreateOptions): Promise<ITextFileEditorModel>;
    /**
     * Adds a participant for saving text file models.
     */
    addSaveParticipant(participant: ITextFileSaveParticipant): IDisposable;
    /**
     * Runs the registered save participants on the provided model.
     */
    runSaveParticipants(model: ITextFileEditorModel, context: {
        reason: SaveReason;
    }, token: CancellationToken): Promise<void>;
    /**
     * Waits for the model to be ready to be disposed. There may be conditions
     * under which the model cannot be disposed, e.g. when it is dirty. Once the
     * promise is settled, it is safe to dispose the model.
     */
    canDispose(model: ITextFileEditorModel): true | Promise<true>;
}
interface ITextFileSaveOptions extends ISaveOptions {
    /**
     * Save the file with an attempt to unlock it.
     */
    readonly writeUnlock?: boolean;
    /**
     * Save the file with elevated privileges.
     *
     * Note: This may not be supported in all environments.
     */
    readonly writeElevated?: boolean;
    /**
     * Allows to write to a file even if it has been modified on disk.
     */
    readonly ignoreModifiedSince?: boolean;
    /**
     * If set, will bubble up the error to the caller instead of handling it.
     */
    readonly ignoreErrorHandler?: boolean;
}
interface ITextFileSaveAsOptions extends ITextFileSaveOptions {
    /**
     * Optional URI to use as suggested file path to save as.
     */
    readonly suggestedTarget?: URI;
}
interface ITextFileResolveOptions {
    /**
     * The contents to use for the model if known. If not
     * provided, the contents will be retrieved from the
     * underlying resource or backup if present.
     */
    readonly contents?: ITextBufferFactory;
    /**
     * Go to file bypassing any cache of the model if any.
     */
    readonly forceReadFromFile?: boolean;
    /**
     * Allow to resolve a model even if we think it is a binary file.
     */
    readonly allowBinary?: boolean;
    /**
     * Context why the model is being resolved.
     */
    readonly reason?: TextFileResolveReason;
    /**
     * If provided, the size of the file will be checked against the limits
     * and an error will be thrown if any limit is exceeded.
     */
    readonly limits?: IFileReadLimits;
}
declare const enum EncodingMode {
    /**
     * Instructs the encoding support to encode the object with the provided encoding
     */
    Encode = 0,
    /**
     * Instructs the encoding support to decode the object with the provided encoding
     */
    Decode = 1
}
interface IEncodingSupport {
    /**
     * Gets the encoding of the object if known.
     */
    getEncoding(): string | undefined;
    /**
     * Sets the encoding for the object for saving.
     */
    setEncoding(encoding: string, mode: EncodingMode): Promise<void>;
}
interface ILanguageSupport {
    /**
     * Sets the language id of the object.
     */
    setLanguageId(languageId: string, source?: string): void;
}
interface ITextFileEditorModelSaveEvent extends IWorkingCopySaveEvent {
    /**
     * The resolved stat from the save operation.
     */
    readonly stat: IFileStatWithMetadata;
}
interface ITextFileEditorModel extends ITextEditorModel, IEncodingSupport, ILanguageSupport, IWorkingCopy {
    readonly onDidSave: Event$1<ITextFileEditorModelSaveEvent>;
    readonly onDidSaveError: Event$1<void>;
    readonly onDidChangeOrphaned: Event$1<void>;
    readonly onDidChangeReadonly: Event$1<void>;
    readonly onDidChangeEncoding: Event$1<void>;
    hasState(state: TextFileEditorModelState): boolean;
    joinState(state: TextFileEditorModelState.PENDING_SAVE): Promise<void>;
    updatePreferredEncoding(encoding: string | undefined): void;
    save(options?: ITextFileSaveOptions): Promise<boolean>;
    revert(options?: IRevertOptions): Promise<void>;
    resolve(options?: ITextFileResolveOptions): Promise<void>;
    isDirty(): this is IResolvedTextFileEditorModel;
    getLanguageId(): string | undefined;
    isResolved(): this is IResolvedTextFileEditorModel;
}
interface IResolvedTextFileEditorModel extends ITextFileEditorModel {
    readonly textEditorModel: ITextModel;
    createSnapshot(): ITextSnapshot;
}

interface IComposite {
    /**
     * An event when the composite gained focus.
     */
    readonly onDidFocus: Event$1<void>;
    /**
     * An event when the composite lost focus.
     */
    readonly onDidBlur: Event$1<void>;
    /**
     * Returns true if the composite has focus.
     */
    hasFocus(): boolean;
    /**
     * Returns the unique identifier of this composite.
     */
    getId(): string;
    /**
     * Returns the name of this composite to show in the title area.
     */
    getTitle(): string | undefined;
    /**
     * Returns the underlying control of this composite.
     */
    getControl(): ICompositeControl | undefined;
    /**
     * Asks the underlying control to focus.
     */
    focus(): void;
}
/**
 * Marker interface for the composite control
 */
interface ICompositeControl {
}

interface IBaseOpenWindowsOptions {
    /**
     * Whether to reuse the window or open a new one.
     */
    readonly forceReuseWindow?: boolean;
    /**
     * The remote authority to use when windows are opened with either
     * - no workspace (empty window)
     * - a workspace that is neither `file://` nor `vscode-remote://`
     * Use 'null' for a local window.
     * If not set, defaults to the remote authority of the current window.
     */
    readonly remoteAuthority?: string | null;
}
interface IOpenWindowOptions extends IBaseOpenWindowsOptions {
    readonly forceNewWindow?: boolean;
    readonly preferNewWindow?: boolean;
    readonly noRecentEntry?: boolean;
    readonly addMode?: boolean;
    readonly diffMode?: boolean;
    readonly mergeMode?: boolean;
    readonly gotoLineMode?: boolean;
    readonly waitMarkerFileURI?: URI;
    readonly forceProfile?: string;
    readonly forceTempProfile?: boolean;
}
interface IOpenEmptyWindowOptions extends IBaseOpenWindowsOptions {
}
type IWindowOpenable = IWorkspaceToOpen | IFolderToOpen | IFileToOpen;
interface IBaseWindowOpenable {
    label?: string;
}
interface IWorkspaceToOpen extends IBaseWindowOpenable {
    readonly workspaceUri: URI;
}
interface IFolderToOpen extends IBaseWindowOpenable {
    readonly folderUri: URI;
}
interface IFileToOpen extends IBaseWindowOpenable {
    readonly fileUri: URI;
}
interface IPath$1<T = IEditorOptions> extends IPathData<T> {
    /**
     * The file path to open within the instance
     */
    fileUri?: URI;
}
interface IPathData<T = IEditorOptions> {
    /**
     * The file path to open within the instance
     */
    readonly fileUri?: UriComponents;
    /**
     * Optional editor options to apply in the file
     */
    readonly options?: T;
    /**
     * A hint that the file exists. if true, the
     * file exists, if false it does not. with
     * `undefined` the state is unknown.
     */
    readonly exists?: boolean;
    /**
     * A hint about the file type of this path.
     * with `undefined` the type is unknown.
     */
    readonly type?: FileType;
    /**
     * Specifies if the file should be only be opened
     * if it exists.
     */
    readonly openOnlyIfExists?: boolean;
}

interface IEditorDescriptor<T extends IEditorPane> {
    /**
     * The unique type identifier of the editor. All instances
     * of the same `IEditorPane` should have the same type
     * identifier.
     */
    readonly typeId: string;
    /**
     * The display name of the editor.
     */
    readonly name: string;
    /**
     * Instantiates the editor pane using the provided services.
     */
    instantiate(instantiationService: IInstantiationService): T;
    /**
     * Whether the descriptor is for the provided editor pane.
     */
    describes(editorPane: T): boolean;
}
/**
 * The editor pane is the container for workbench editors.
 */
interface IEditorPane extends IComposite {
    /**
     * An event to notify when the `IEditorControl` in this
     * editor pane changes.
     *
     * This can be used for editor panes that are a compound
     * of multiple editor controls to signal that the active
     * editor control has changed when the user clicks around.
     */
    readonly onDidChangeControl: Event$1<void>;
    /**
     * An optional event to notify when the selection inside the editor
     * pane changed in case the editor has a selection concept.
     *
     * For example, in a text editor pane, the selection changes whenever
     * the cursor is set to a new location.
     */
    readonly onDidChangeSelection?: Event$1<IEditorPaneSelectionChangeEvent>;
    /**
     * The assigned input of this editor.
     */
    readonly input: EditorInput | undefined;
    /**
     * The assigned options of the editor.
     */
    readonly options: IEditorOptions | undefined;
    /**
     * The assigned group this editor is showing in.
     */
    readonly group: IEditorGroup | undefined;
    /**
     * The minimum width of this editor.
     */
    readonly minimumWidth: number;
    /**
     * The maximum width of this editor.
     */
    readonly maximumWidth: number;
    /**
     * The minimum height of this editor.
     */
    readonly minimumHeight: number;
    /**
     * The maximum height of this editor.
     */
    readonly maximumHeight: number;
    /**
     * An event to notify whenever minimum/maximum width/height changes.
     */
    readonly onDidChangeSizeConstraints: Event$1<{
        width: number;
        height: number;
    } | undefined>;
    /**
     * The context key service for this editor. Should be overridden by
     * editors that have their own ScopedContextKeyService
     */
    readonly scopedContextKeyService: IContextKeyService | undefined;
    /**
     * Returns the underlying control of this editor. Callers need to cast
     * the control to a specific instance as needed, e.g. by using the
     * `isCodeEditor` helper method to access the text code editor.
     *
     * Use the `onDidChangeControl` event to track whenever the control
     * changes.
     */
    getControl(): IEditorControl | undefined;
    /**
     * Returns the current view state of the editor if any.
     *
     * This method is optional to override for the editor pane
     * and should only be overridden when the pane can deal with
     * `IEditorOptions.viewState` to be applied when opening.
     */
    getViewState(): object | undefined;
    /**
     * An optional method to return the current selection in
     * the editor pane in case the editor pane has a selection
     * concept.
     *
     * Clients of this method will typically react to the
     * `onDidChangeSelection` event to receive the current
     * selection as needed.
     */
    getSelection?(): IEditorPaneSelection | undefined;
    /**
     * Finds out if this editor is visible or not.
     */
    isVisible(): boolean;
}
interface IEditorPaneSelectionChangeEvent {
    /**
     * More details for how the selection was made.
     */
    reason: EditorPaneSelectionChangeReason;
}
declare const enum EditorPaneSelectionChangeReason {
    /**
     * The selection was changed as a result of a programmatic
     * method invocation.
     *
     * For a text editor pane, this for example can be a selection
     * being restored from previous view state automatically.
     */
    PROGRAMMATIC = 1,
    /**
     * The selection was changed by the user.
     *
     * This typically means the user changed the selection
     * with mouse or keyboard.
     */
    USER = 2,
    /**
     * The selection was changed as a result of editing in
     * the editor pane.
     *
     * For a text editor pane, this for example can be typing
     * in the text of the editor pane.
     */
    EDIT = 3,
    /**
     * The selection was changed as a result of a navigation
     * action.
     *
     * For a text editor pane, this for example can be a result
     * of selecting an entry from a text outline view.
     */
    NAVIGATION = 4,
    /**
     * The selection was changed as a result of a jump action
     * from within the editor pane.
     *
     * For a text editor pane, this for example can be a result
     * of invoking "Go to definition" from a symbol.
     */
    JUMP = 5
}
interface IEditorPaneSelection {
    /**
     * Asks to compare this selection to another selection.
     */
    compare(otherSelection: IEditorPaneSelection): EditorPaneSelectionCompareResult;
    /**
     * Asks to massage the provided `options` in a way
     * that the selection can be restored when the editor
     * is opened again.
     *
     * For a text editor this means to apply the selected
     * line and column as text editor options.
     */
    restore(options: IEditorOptions): IEditorOptions;
    /**
     * Only used for logging to print more info about the selection.
     */
    log?(): string;
}
declare const enum EditorPaneSelectionCompareResult {
    /**
     * The selections are identical.
     */
    IDENTICAL = 1,
    /**
     * The selections are similar.
     *
     * For a text editor this can mean that the one
     * selection is in close proximity to the other
     * selection.
     *
     * Upstream clients may decide in this case to
     * not treat the selection different from the
     * previous one because it is not distinct enough.
     */
    SIMILAR = 2,
    /**
     * The selections are entirely different.
     */
    DIFFERENT = 3
}
/**
 * Overrides `IEditorPane` where `input` and `group` are known to be set.
 */
interface IVisibleEditorPane extends IEditorPane {
    readonly input: EditorInput;
    readonly group: IEditorGroup;
}
/**
 * The text editor pane is the container for workbench text diff editors.
 */
interface ITextDiffEditorPane extends IEditorPane {
    /**
     * Returns the underlying text diff editor widget of this editor.
     */
    getControl(): IDiffEditor$1 | undefined;
}
/**
 * Marker interface for the control inside an editor pane. Callers
 * have to cast the control to work with it, e.g. via methods
 * such as `isCodeEditor(control)`.
 */
interface IEditorControl extends ICompositeControl {
}
interface IUntitledTextResourceEditorInput extends IBaseTextResourceEditorInput {
    /**
     * Optional resource for the untitled editor. Depending on the value, the editor:
     * - should get a unique name if `undefined` (for example `Untitled-1`)
     * - should use the resource directly if the scheme is `untitled:`
     * - should change the scheme to `untitled:` otherwise and assume an associated path
     *
     * Untitled editors with associated path behave slightly different from other untitled
     * editors:
     * - they are dirty right when opening
     * - they will not ask for a file path when saving but use the associated path
     */
    readonly resource: URI | undefined;
}
/**
 * A resource side by side editor input shows 2 editors side by side but
 * without highlighting any differences.
 *
 * Note: both sides will be resolved as editor individually. As such, it is
 * possible to show 2 different editors side by side.
 *
 * @see {@link IResourceDiffEditorInput} for a variant that compares 2 editors.
 */
interface IResourceSideBySideEditorInput extends IBaseUntypedEditorInput {
    /**
     * The right hand side editor to open inside a side-by-side editor.
     */
    readonly primary: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
    /**
     * The left hand side editor to open inside a side-by-side editor.
     */
    readonly secondary: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
}
/**
 * A resource diff editor input compares 2 editors side by side
 * highlighting the differences.
 *
 * Note: both sides must be resolvable to the same editor, or
 * a text based presentation will be used as fallback.
 */
interface IResourceDiffEditorInput extends IBaseUntypedEditorInput {
    /**
     * The left hand side editor to open inside a diff editor.
     */
    readonly original: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
    /**
     * The right hand side editor to open inside a diff editor.
     */
    readonly modified: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
}
type IResourceMergeEditorInputSide = (IResourceEditorInput | ITextResourceEditorInput) & {
    detail?: string;
};
/**
 * A resource merge editor input compares multiple editors
 * highlighting the differences for merging.
 *
 * Note: all sides must be resolvable to the same editor, or
 * a text based presentation will be used as fallback.
 */
interface IResourceMergeEditorInput extends IBaseUntypedEditorInput {
    /**
     * The one changed version of the file.
     */
    readonly input1: IResourceMergeEditorInputSide;
    /**
     * The second changed version of the file.
     */
    readonly input2: IResourceMergeEditorInputSide;
    /**
     * The base common ancestor of the file to merge.
     */
    readonly base: IResourceEditorInput | ITextResourceEditorInput;
    /**
     * The resulting output of the merge.
     */
    readonly result: IResourceEditorInput | ITextResourceEditorInput;
}
declare const enum Verbosity {
    SHORT = 0,
    MEDIUM = 1,
    LONG = 2
}
declare const enum SaveReason {
    /**
     * Explicit user gesture.
     */
    EXPLICIT = 1,
    /**
     * Auto save after a timeout.
     */
    AUTO = 2,
    /**
     * Auto save after editor focus change.
     */
    FOCUS_CHANGE = 3,
    /**
     * Auto save after window change.
     */
    WINDOW_CHANGE = 4
}
type SaveSource = string;
interface ISaveOptions {
    /**
     * An indicator how the save operation was triggered.
     */
    reason?: SaveReason;
    /**
     * An indicator about the source of the save operation.
     *
     * Must use `SaveSourceRegistry.registerSource()` to obtain.
     */
    readonly source?: SaveSource;
    /**
     * Forces to save the contents of the working copy
     * again even if the working copy is not dirty.
     */
    readonly force?: boolean;
    /**
     * Instructs the save operation to skip any save participants.
     */
    readonly skipSaveParticipants?: boolean;
    /**
     * A hint as to which file systems should be available for saving.
     */
    readonly availableFileSystems?: string[];
}
interface IRevertOptions {
    /**
     * Forces to load the contents of the working copy
     * again even if the working copy is not dirty.
     */
    readonly force?: boolean;
    /**
     * A soft revert will clear dirty state of a working copy
     * but will not attempt to load it from its persisted state.
     *
     * This option may be used in scenarios where an editor is
     * closed and where we do not require to load the contents.
     */
    readonly soft?: boolean;
}
interface IMoveResult {
    editor: EditorInput | IUntypedEditorInput;
    options?: IEditorOptions;
}
declare const enum EditorInputCapabilities {
    /**
     * Signals no specific capability for the input.
     */
    None = 0,
    /**
     * Signals that the input is readonly.
     */
    Readonly = 2,
    /**
     * Signals that the input is untitled.
     */
    Untitled = 4,
    /**
     * Signals that the input can only be shown in one group
     * and not be split into multiple groups.
     */
    Singleton = 8,
    /**
     * Signals that the input requires workspace trust.
     */
    RequiresTrust = 16,
    /**
     * Signals that the editor can split into 2 in the same
     * editor group.
     */
    CanSplitInGroup = 32,
    /**
     * Signals that the editor wants it's description to be
     * visible when presented to the user. By default, a UI
     * component may decide to hide the description portion
     * for brevity.
     */
    ForceDescription = 64,
    /**
     * Signals that the editor supports dropping into the
     * editor by holding shift.
     */
    CanDropIntoEditor = 128,
    /**
     * Signals that the editor is composed of multiple editors
     * within.
     */
    MultipleEditors = 256
}
type IUntypedEditorInput = IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput | IResourceDiffEditorInput | IResourceSideBySideEditorInput | IResourceMergeEditorInput;
declare abstract class AbstractEditorInput extends Disposable {
}
interface EditorInputWithOptions {
    editor: EditorInput;
    options?: IEditorOptions;
}
interface IEditorIdentifier {
    groupId: GroupIdentifier;
    editor: EditorInput;
}
/**
 * More information around why an editor was closed in the model.
 */
declare enum EditorCloseContext {
    /**
     * No specific context for closing (e.g. explicit user gesture).
     */
    UNKNOWN = 0,
    /**
     * The editor closed because it was replaced with another editor.
     * This can either happen via explicit replace call or when an
     * editor is in preview mode and another editor opens.
     */
    REPLACE = 1,
    /**
     * The editor closed as a result of moving it to another group.
     */
    MOVE = 2,
    /**
     * The editor closed because another editor turned into preview
     * and this used to be the preview editor before.
     */
    UNPIN = 3
}
interface IEditorCloseEvent extends IEditorIdentifier {
    /**
     * More information around why the editor was closed.
     */
    readonly context: EditorCloseContext;
    /**
     * The index of the editor before closing.
     */
    readonly index: number;
    /**
     * Whether the editor was sticky or not.
     */
    readonly sticky: boolean;
}
interface IActiveEditorChangeEvent {
    /**
     * The new active editor or `undefined` if the group is empty.
     */
    editor: EditorInput | undefined;
}
interface IEditorWillMoveEvent extends IEditorIdentifier {
    /**
     * The target group of the move operation.
     */
    readonly target: GroupIdentifier;
}
interface IEditorWillOpenEvent extends IEditorIdentifier {
}
type GroupIdentifier = number;
declare const enum GroupModelChangeKind {
    GROUP_ACTIVE = 0,
    GROUP_INDEX = 1,
    GROUP_LOCKED = 2,
    EDITOR_OPEN = 3,
    EDITOR_CLOSE = 4,
    EDITOR_MOVE = 5,
    EDITOR_ACTIVE = 6,
    EDITOR_LABEL = 7,
    EDITOR_CAPABILITIES = 8,
    EDITOR_PIN = 9,
    EDITOR_STICKY = 10,
    EDITOR_DIRTY = 11,
    EDITOR_WILL_DISPOSE = 12
}
interface IEditorPartConfiguration {
    showTabs?: boolean;
    wrapTabs?: boolean;
    scrollToSwitchTabs?: boolean;
    highlightModifiedTabs?: boolean;
    tabCloseButton?: 'left' | 'right' | 'off';
    tabSizing?: 'fit' | 'shrink';
    pinnedTabSizing?: 'normal' | 'compact' | 'shrink';
    titleScrollbarSizing?: 'default' | 'large';
    focusRecentEditorAfterClose?: boolean;
    showIcons?: boolean;
    enablePreview?: boolean;
    enablePreviewFromQuickOpen?: boolean;
    enablePreviewFromCodeNavigation?: boolean;
    closeOnFileDelete?: boolean;
    openPositioning?: 'left' | 'right' | 'first' | 'last';
    openSideBySideDirection?: 'right' | 'down';
    closeEmptyGroups?: boolean;
    autoLockGroups?: Set<string>;
    revealIfOpen?: boolean;
    mouseBackForwardToNavigate?: boolean;
    labelFormat?: 'default' | 'short' | 'medium' | 'long';
    restoreViewState?: boolean;
    splitInGroupLayout?: 'vertical' | 'horizontal';
    splitSizing?: 'split' | 'distribute';
    splitOnDragAndDrop?: boolean;
    centeredLayoutFixedWidth?: boolean;
    limit?: {
        enabled?: boolean;
        excludeDirty?: boolean;
        value?: number;
        perEditorGroup?: boolean;
    };
    decorations?: {
        badges?: boolean;
        colors?: boolean;
    };
}
interface IEditorPartOptions extends IEditorPartConfiguration {
    hasIcons?: boolean;
}
interface IEditorPartOptionsChangeEvent {
    oldPartOptions: IEditorPartOptions;
    newPartOptions: IEditorPartOptions;
}
declare enum SideBySideEditor {
    PRIMARY = 1,
    SECONDARY = 2,
    BOTH = 3,
    ANY = 4
}
interface IFindEditorOptions {
    /**
     * Whether to consider any or both side by side editor as matching.
     * By default, side by side editors will not be considered
     * as matching, even if the editor is opened in one of the sides.
     */
    supportSideBySide?: SideBySideEditor.PRIMARY | SideBySideEditor.SECONDARY | SideBySideEditor.ANY;
}
interface IMatchEditorOptions {
    /**
     * Whether to consider a side by side editor as matching.
     * By default, side by side editors will not be considered
     * as matching, even if the editor is opened in one of the sides.
     */
    supportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;
    /**
     * Only consider an editor to match when the
     * `candidate === editor` but not when
     * `candidate.matches(editor)`.
     */
    strictEquals?: boolean;
}
declare const enum CloseDirection {
    LEFT = 0,
    RIGHT = 1
}
declare const enum EditorsOrder {
    /**
     * Editors sorted by most recent activity (most recent active first)
     */
    MOST_RECENTLY_ACTIVE = 0,
    /**
     * Editors sorted by sequential order
     */
    SEQUENTIAL = 1
}

declare const enum GroupDirection {
    UP = 0,
    DOWN = 1,
    LEFT = 2,
    RIGHT = 3
}
declare const enum GroupOrientation {
    HORIZONTAL = 0,
    VERTICAL = 1
}
declare const enum GroupLocation {
    FIRST = 0,
    LAST = 1,
    NEXT = 2,
    PREVIOUS = 3
}
interface IFindGroupScope {
    direction?: GroupDirection;
    location?: GroupLocation;
}
declare const enum GroupsArrangement {
    /**
     * Make the current active group consume the maximum
     * amount of space possible.
     */
    MAXIMIZE = 0,
    /**
     * Size all groups evenly.
     */
    EVEN = 1,
    /**
     * Will behave like MINIMIZE_OTHERS if the active
     * group is not already maximized and EVEN otherwise
     */
    TOGGLE = 2
}
interface GroupLayoutArgument {
    /**
     * Only applies when there are multiple groups
     * arranged next to each other in a row or column.
     * If provided, their sum must be 1 to be applied
     * per row or column.
     */
    size?: number;
    /**
     * Editor groups  will be laid out orthogonal to the
     * parent orientation.
     */
    groups?: GroupLayoutArgument[];
}
interface EditorGroupLayout {
    /**
     * The initial orientation of the editor groups at the root.
     */
    orientation: GroupOrientation;
    /**
     * The editor groups at the root of the layout.
     */
    groups: GroupLayoutArgument[];
}
interface IAddGroupOptions {
    activate?: boolean;
}
declare const enum MergeGroupMode {
    COPY_EDITORS = 0,
    MOVE_EDITORS = 1
}
interface IMergeGroupOptions {
    mode?: MergeGroupMode;
    index?: number;
}
interface ICloseEditorOptions {
    preserveFocus?: boolean;
}
type ICloseEditorsFilter = {
    except?: EditorInput;
    direction?: CloseDirection;
    savedOnly?: boolean;
    excludeSticky?: boolean;
};
interface ICloseAllEditorsOptions {
    excludeSticky?: boolean;
}
interface IEditorReplacement {
    editor: EditorInput;
    replacement: EditorInput;
    options?: IEditorOptions;
    /**
     * Skips asking the user for confirmation and doesn't
     * save the document. Only use this if you really need to!
     */
    forceReplaceDirty?: boolean;
}
declare const enum GroupsOrder {
    /**
     * Groups sorted by creation order (oldest one first)
     */
    CREATION_TIME = 0,
    /**
     * Groups sorted by most recent activity (most recent active first)
     */
    MOST_RECENTLY_ACTIVE = 1,
    /**
     * Groups sorted by grid widget order
     */
    GRID_APPEARANCE = 2
}
interface IEditorSideGroup {
    /**
     * Open an editor in this group.
     *
     * @returns a promise that resolves around an IEditor instance unless
     * the call failed, or the editor was not opened as active editor.
     */
    openEditor(editor: EditorInput, options?: IEditorOptions): Promise<IEditorPane | undefined>;
}
declare const IEditorGroupsService: ServiceIdentifier<IEditorGroupsService>;
interface IEditorGroupsService {
    readonly _serviceBrand: undefined;
    /**
     * An event for when the active editor group changes. The active editor
     * group is the default location for new editors to open.
     */
    readonly onDidChangeActiveGroup: Event$1<IEditorGroup>;
    /**
     * An event for when a new group was added.
     */
    readonly onDidAddGroup: Event$1<IEditorGroup>;
    /**
     * An event for when a group was removed.
     */
    readonly onDidRemoveGroup: Event$1<IEditorGroup>;
    /**
     * An event for when a group was moved.
     */
    readonly onDidMoveGroup: Event$1<IEditorGroup>;
    /**
     * An event for when a group gets activated.
     */
    readonly onDidActivateGroup: Event$1<IEditorGroup>;
    /**
     * An event for when the group container is layed out.
     */
    readonly onDidLayout: Event$1<IDimension$1>;
    /**
     * An event for when the group container is scrolled.
     */
    readonly onDidScroll: Event$1<void>;
    /**
     * An event for when the index of a group changes.
     */
    readonly onDidChangeGroupIndex: Event$1<IEditorGroup>;
    /**
     * An event for when the locked state of a group changes.
     */
    readonly onDidChangeGroupLocked: Event$1<IEditorGroup>;
    /**
     * The size of the editor groups area.
     */
    readonly contentDimension: IDimension$1;
    /**
     * An active group is the default location for new editors to open.
     */
    readonly activeGroup: IEditorGroup;
    /**
     * A side group allows a subset of methods on a group that is either
     * created to the side or picked if already there.
     */
    readonly sideGroup: IEditorSideGroup;
    /**
     * All groups that are currently visible in the editor area in the
     * order of their creation (oldest first).
     */
    readonly groups: readonly IEditorGroup[];
    /**
     * The number of editor groups that are currently opened.
     */
    readonly count: number;
    /**
     * The current layout orientation of the root group.
     */
    readonly orientation: GroupOrientation;
    /**
     * A property that indicates when groups have been created
     * and are ready to be used.
     */
    readonly isReady: boolean;
    /**
     * A promise that resolves when groups have been created
     * and are ready to be used.
     *
     * Await this promise to safely work on the editor groups model
     * (for example, install editor group listeners).
     *
     * Use the `whenRestored` property to await visible editors
     * having fully resolved.
     */
    readonly whenReady: Promise<void>;
    /**
     * A promise that resolves when groups have been restored.
     *
     * For groups with active editor, the promise will resolve
     * when the visible editor has finished to resolve.
     *
     * Use the `whenReady` property to not await editors to
     * resolve.
     */
    readonly whenRestored: Promise<void>;
    /**
     * Find out if the editor group service has UI state to restore
     * from a previous session.
     */
    readonly hasRestorableState: boolean;
    /**
     * Get all groups that are currently visible in the editor area.
     *
     * @param order the order of the editors to use
     */
    getGroups(order: GroupsOrder): readonly IEditorGroup[];
    /**
     * Allows to convert a group identifier to a group.
     */
    getGroup(identifier: GroupIdentifier): IEditorGroup | undefined;
    /**
     * Set a group as active. An active group is the default location for new editors to open.
     */
    activateGroup(group: IEditorGroup | GroupIdentifier): IEditorGroup;
    /**
     * Returns the size of a group.
     */
    getSize(group: IEditorGroup | GroupIdentifier): {
        width: number;
        height: number;
    };
    /**
     * Sets the size of a group.
     */
    setSize(group: IEditorGroup | GroupIdentifier, size: {
        width: number;
        height: number;
    }): void;
    /**
     * Arrange all groups according to the provided arrangement.
     */
    arrangeGroups(arrangement: GroupsArrangement): void;
    /**
     * Applies the provided layout by either moving existing groups or creating new groups.
     */
    applyLayout(layout: EditorGroupLayout): void;
    /**
     * Enable or disable centered editor layout.
     */
    centerLayout(active: boolean): void;
    /**
     * Find out if the editor layout is currently centered.
     */
    isLayoutCentered(): boolean;
    /**
     * Sets the orientation of the root group to be either vertical or horizontal.
     */
    setGroupOrientation(orientation: GroupOrientation): void;
    /**
     * Find a groupd in a specific scope:
     * * `GroupLocation.FIRST`: the first group
     * * `GroupLocation.LAST`: the last group
     * * `GroupLocation.NEXT`: the next group from either the active one or `source`
     * * `GroupLocation.PREVIOUS`: the previous group from either the active one or `source`
     * * `GroupDirection.UP`: the next group above the active one or `source`
     * * `GroupDirection.DOWN`: the next group below the active one or `source`
     * * `GroupDirection.LEFT`: the next group to the left of the active one or `source`
     * * `GroupDirection.RIGHT`: the next group to the right of the active one or `source`
     *
     * @param scope the scope of the group to search in
     * @param source optional source to search from
     * @param wrap optionally wrap around if reaching the edge of groups
     */
    findGroup(scope: IFindGroupScope, source?: IEditorGroup | GroupIdentifier, wrap?: boolean): IEditorGroup | undefined;
    /**
     * Add a new group to the editor area. A new group is added by splitting a provided one in
     * one of the four directions.
     *
     * @param location the group from which to split to add a new group
     * @param direction the direction of where to split to
     * @param options configure the newly group with options
     */
    addGroup(location: IEditorGroup | GroupIdentifier, direction: GroupDirection, options?: IAddGroupOptions): IEditorGroup;
    /**
     * Remove a group from the editor area.
     */
    removeGroup(group: IEditorGroup | GroupIdentifier): void;
    /**
     * Move a group to a new group in the editor area.
     *
     * @param group the group to move
     * @param location the group from which to split to add the moved group
     * @param direction the direction of where to split to
     */
    moveGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;
    /**
     * Merge the editors of a group into a target group. By default, all editors will
     * move and the source group will close. This behaviour can be configured via the
     * `IMergeGroupOptions` options.
     *
     * @param group the group to merge
     * @param target the target group to merge into
     * @param options controls how the merge should be performed. by default all editors
     * will be moved over to the target and the source group will close. Configure to
     * `MOVE_EDITORS_KEEP_GROUP` to prevent the source group from closing. Set to
     * `COPY_EDITORS` to copy the editors into the target instead of moding them.
     */
    mergeGroup(group: IEditorGroup | GroupIdentifier, target: IEditorGroup | GroupIdentifier, options?: IMergeGroupOptions): IEditorGroup;
    /**
     * Merge all editor groups into the active one.
     */
    mergeAllGroups(): IEditorGroup;
    /**
     * Copy a group to a new group in the editor area.
     *
     * @param group the group to copy
     * @param location the group from which to split to add the copied group
     * @param direction the direction of where to split to
     */
    copyGroup(group: IEditorGroup | GroupIdentifier, location: IEditorGroup | GroupIdentifier, direction: GroupDirection): IEditorGroup;
    /**
     * Access the options of the editor part.
     */
    readonly partOptions: IEditorPartOptions;
    /**
     * An event that notifies when editor part options change.
     */
    readonly onDidChangeEditorPartOptions: Event$1<IEditorPartOptionsChangeEvent>;
    /**
     * Enforce editor part options temporarily.
     */
    enforcePartOptions(options: IEditorPartOptions): IDisposable;
}
interface IEditorGroup {
    /**
     * An event which fires whenever the underlying group model changes.
     */
    readonly onDidModelChange: Event$1<IGroupModelChangeEvent>;
    /**
     * An event that is fired when the group gets disposed.
     */
    readonly onWillDispose: Event$1<void>;
    /**
     * An event that is fired when the active editor in the group changed.
     */
    readonly onDidActiveEditorChange: Event$1<IActiveEditorChangeEvent>;
    /**
     * An event that is fired when an editor is about to close.
     */
    readonly onWillCloseEditor: Event$1<IEditorCloseEvent>;
    /**
     * An event that is fired when an editor is closed.
     */
    readonly onDidCloseEditor: Event$1<IEditorCloseEvent>;
    /**
     * An event that is fired when an editor is about to move to
     * a different group.
     */
    readonly onWillMoveEditor: Event$1<IEditorWillMoveEvent>;
    /**
     * An event that is fired when an editor is about to be opened
     * in the group.
     */
    readonly onWillOpenEditor: Event$1<IEditorWillOpenEvent>;
    /**
     * A unique identifier of this group that remains identical even if the
     * group is moved to different locations.
     */
    readonly id: GroupIdentifier;
    /**
     * A number that indicates the position of this group in the visual
     * order of groups from left to right and top to bottom. The lowest
     * index will likely be top-left while the largest index in most
     * cases should be bottom-right, but that depends on the grid.
     */
    readonly index: number;
    /**
     * A human readable label for the group. This label can change depending
     * on the layout of all editor groups. Clients should listen on the
     * `onDidGroupModelChange` event to react to that.
     */
    readonly label: string;
    /**
     * A human readable label for the group to be used by screen readers.
     */
    readonly ariaLabel: string;
    /**
     * The active editor pane is the currently visible editor pane of the group.
     */
    readonly activeEditorPane: IVisibleEditorPane | undefined;
    /**
     * The active editor is the currently visible editor of the group
     * within the current active editor pane.
     */
    readonly activeEditor: EditorInput | null;
    /**
     * The editor in the group that is in preview mode if any. There can
     * only ever be one editor in preview mode.
     */
    readonly previewEditor: EditorInput | null;
    /**
     * The number of opened editors in this group.
     */
    readonly count: number;
    /**
     * Whether the group has editors or not.
     */
    readonly isEmpty: boolean;
    /**
     * Whether this editor group is locked or not. Locked editor groups
     * will only be considered for editors to open in when the group is
     * explicitly provided for the editor.
     *
     * Note: editor group locking only applies when more than one group
     * is opened.
     */
    readonly isLocked: boolean;
    /**
     * The number of sticky editors in this group.
     */
    readonly stickyCount: number;
    /**
     * All opened editors in the group in sequential order of their appearance.
     */
    readonly editors: readonly EditorInput[];
    /**
     * The scoped context key service for this group.
     */
    readonly scopedContextKeyService: IContextKeyService;
    /**
     * Get all editors that are currently opened in the group.
     *
     * @param order the order of the editors to use
     * @param options options to select only specific editors as instructed
     */
    getEditors(order: EditorsOrder, options?: {
        excludeSticky?: boolean;
    }): readonly EditorInput[];
    /**
     * Finds all editors for the given resource that are currently
     * opened in the group. This method will return an entry for
     * each editor that reports a `resource` that matches the
     * provided one.
     *
     * @param resource the resource of the editor to find
     * @param options whether to support side by side editors or not
     */
    findEditors(resource: URI, options?: IFindEditorOptions): readonly EditorInput[];
    /**
     * Returns the editor at a specific index of the group.
     */
    getEditorByIndex(index: number): EditorInput | undefined;
    /**
     * Returns the index of the editor in the group or -1 if not opened.
     */
    getIndexOfEditor(editor: EditorInput): number;
    /**
     * Whether the editor is the first in the group.
     */
    isFirst(editor: EditorInput): boolean;
    /**
     * Whether the editor is the last in the group.
     */
    isLast(editor: EditorInput): boolean;
    /**
     * Open an editor in this group.
     *
     * @returns a promise that resolves around an IEditor instance unless
     * the call failed, or the editor was not opened as active editor.
     */
    openEditor(editor: EditorInput, options?: IEditorOptions): Promise<IEditorPane | undefined>;
    /**
     * Opens editors in this group.
     *
     * @returns a promise that resolves around an IEditor instance unless
     * the call failed, or the editor was not opened as active editor. Since
     * a group can only ever have one active editor, even if many editors are
     * opened, the result will only be one editor.
     */
    openEditors(editors: EditorInputWithOptions[]): Promise<IEditorPane | undefined>;
    /**
     * Find out if the provided editor is pinned in the group.
     */
    isPinned(editorOrIndex: EditorInput | number): boolean;
    /**
     * Find out if the provided editor or index of editor is sticky in the group.
     */
    isSticky(editorOrIndex: EditorInput | number): boolean;
    /**
     * Find out if the provided editor is active in the group.
     */
    isActive(editor: EditorInput | IUntypedEditorInput): boolean;
    /**
     * Find out if a certain editor is included in the group.
     *
     * @param candidate the editor to find
     * @param options fine tune how to match editors
     */
    contains(candidate: EditorInput | IUntypedEditorInput, options?: IMatchEditorOptions): boolean;
    /**
     * Move an editor from this group either within this group or to another group.
     */
    moveEditor(editor: EditorInput, target: IEditorGroup, options?: IEditorOptions): void;
    /**
     * Move editors from this group either within this group or to another group.
     */
    moveEditors(editors: EditorInputWithOptions[], target: IEditorGroup): void;
    /**
     * Copy an editor from this group to another group.
     *
     * Note: It is currently not supported to show the same editor more than once in the same group.
     */
    copyEditor(editor: EditorInput, target: IEditorGroup, options?: IEditorOptions): void;
    /**
     * Copy editors from this group to another group.
     *
     * Note: It is currently not supported to show the same editor more than once in the same group.
     */
    copyEditors(editors: EditorInputWithOptions[], target: IEditorGroup): void;
    /**
     * Close an editor from the group. This may trigger a confirmation dialog if
     * the editor is dirty and thus returns a promise as value.
     *
     * @param editor the editor to close, or the currently active editor
     * if unspecified.
     *
     * @returns a promise when the editor is closed or not. If `true`, the editor
     * is closed and if `false` there was a veto closing the editor, e.g. when it
     * is dirty.
     */
    closeEditor(editor?: EditorInput, options?: ICloseEditorOptions): Promise<boolean>;
    /**
     * Closes specific editors in this group. This may trigger a confirmation dialog if
     * there are dirty editors and thus returns a promise as value.
     *
     * @returns a promise whether the editors were closed or not. If `true`, the editors
     * were closed and if `false` there was a veto closing the editors, e.g. when one
     * is dirty.
     */
    closeEditors(editors: EditorInput[] | ICloseEditorsFilter, options?: ICloseEditorOptions): Promise<boolean>;
    /**
     * Closes all editors from the group. This may trigger a confirmation dialog if
     * there are dirty editors and thus returns a promise as value.
     *
     * @returns a promise when all editors are closed.
     */
    closeAllEditors(options?: ICloseAllEditorsOptions): Promise<boolean>;
    /**
     * Replaces editors in this group with the provided replacement.
     *
     * @param editors the editors to replace
     *
     * @returns a promise that is resolved when the replaced active
     * editor (if any) has finished loading.
     */
    replaceEditors(editors: IEditorReplacement[]): Promise<void>;
    /**
     * Set an editor to be pinned. A pinned editor is not replaced
     * when another editor opens at the same location.
     *
     * @param editor the editor to pin, or the currently active editor
     * if unspecified.
     */
    pinEditor(editor?: EditorInput): void;
    /**
     * Set an editor to be sticky. A sticky editor is showing in the beginning
     * of the tab stripe and will not be impacted by close operations.
     *
     * @param editor the editor to make sticky, or the currently active editor
     * if unspecified.
     */
    stickEditor(editor?: EditorInput): void;
    /**
     * Set an editor to be non-sticky and thus moves back to a location after
     * sticky editors and can be closed normally.
     *
     * @param editor the editor to make unsticky, or the currently active editor
     * if unspecified.
     */
    unstickEditor(editor?: EditorInput): void;
    /**
     * Whether this editor group should be locked or not.
     *
     * See {@linkcode IEditorGroup.isLocked `isLocked`}
     */
    lock(locked: boolean): void;
    /**
     * Move keyboard focus into the group.
     */
    focus(): void;
}

declare const IWorkbenchEnvironmentService: ServiceIdentifier<IWorkbenchEnvironmentService>;
/**
 * A workbench specific environment service that is only present in workbench
 * layer.
 */
interface IWorkbenchEnvironmentService extends IEnvironmentService {
    readonly logFile: URI;
    readonly windowLogsPath: URI;
    readonly extHostLogsPath: URI;
    readonly extHostTelemetryLogFile: URI;
    readonly extensionEnabledProposedApi?: string[];
    readonly remoteAuthority?: string;
    readonly skipReleaseNotes: boolean;
    readonly skipWelcome: boolean;
    readonly disableWorkspaceTrust: boolean;
    readonly webviewExternalEndpoint: string;
    readonly debugRenderer: boolean;
    readonly logExtensionHostCommunication?: boolean;
    readonly enableSmokeTestDriver?: boolean;
    readonly profDurationMarkers?: string[];
    readonly filesToOpenOrCreate?: IPath$1[] | undefined;
    readonly filesToDiff?: IPath$1[] | undefined;
    readonly filesToMerge?: IPath$1[] | undefined;
}

declare const IHostService: ServiceIdentifier<IHostService>;
/**
 * A set of methods supported in both web and native environments.
 *
 * @see {@link INativeHostService} for methods that are specific to native
 * environments.
 */
interface IHostService {
    readonly _serviceBrand: undefined;
    /**
     * Emitted when the window focus changes.
     */
    readonly onDidChangeFocus: Event$1<boolean>;
    /**
     * Find out if the window has focus or not.
     */
    readonly hasFocus: boolean;
    /**
     * Find out if the window had the last focus.
     */
    hadLastFocus(): Promise<boolean>;
    /**
     * Attempt to bring the window to the foreground and focus it.
     *
     * @param options Pass `force: true` if you want to make the window take
     * focus even if the application does not have focus currently. This option
     * should only be used if it is necessary to steal focus from the current
     * focused application which may not be VSCode. It may not be supported
     * in all environments.
     */
    focus(options?: {
        force: boolean;
    }): Promise<void>;
    /**
     * Opens an empty window. The optional parameter allows to define if
     * a new window should open or the existing one change to an empty.
     */
    openWindow(options?: IOpenEmptyWindowOptions): Promise<void>;
    /**
     * Opens the provided array of openables in a window with the provided options.
     */
    openWindow(toOpen: IWindowOpenable[], options?: IOpenWindowOptions): Promise<void>;
    /**
     * Switch between fullscreen and normal window.
     */
    toggleFullScreen(): Promise<void>;
    /**
     * Restart the entire application.
     */
    restart(): Promise<void>;
    /**
     * Reload the currently active window.
     */
    reload(options?: {
        disableExtensions?: boolean;
    }): Promise<void>;
    /**
     * Attempt to close the active window.
     */
    close(): Promise<void>;
}

interface ILanguageStatus {
    readonly id: string;
    readonly name: string;
    readonly selector: LanguageSelector;
    readonly severity: Severity$1;
    readonly label: string;
    readonly detail: string;
    readonly busy: boolean;
    readonly source: string;
    readonly command: Command | undefined;
    readonly accessibilityInfo: IAccessibilityInformation | undefined;
}
declare const ILanguageStatusService: ServiceIdentifier<ILanguageStatusService>;
interface ILanguageStatusService {
    _serviceBrand: undefined;
    onDidChange: Event$1<void>;
    addStatus(status: ILanguageStatus): IDisposable;
    getLanguageStatus(model: ITextModel): ILanguageStatus[];
}

type MementoObject = {
    [key: string]: any;
};

declare class Component extends Themable {
    private readonly id;
    private readonly memento;
    constructor(id: string, themeService: IThemeService, storageService: IStorageService);
    getId(): string;
    protected getMemento(scope: StorageScope, target: StorageTarget): MementoObject;
    protected saveState(): void;
}

interface IAnchor {
    x: number;
    y: number;
    width?: number;
    height?: number;
}
declare const enum AnchorAlignment {
    LEFT = 0,
    RIGHT = 1
}
declare const enum AnchorPosition {
    BELOW = 0,
    ABOVE = 1
}
declare const enum AnchorAxisAlignment {
    VERTICAL = 0,
    HORIZONTAL = 1
}
interface IDelegate {
    getAnchor(): HTMLElement | IAnchor;
    render(container: HTMLElement): IDisposable | null;
    focus?(): void;
    layout?(): void;
    anchorAlignment?: AnchorAlignment;
    anchorPosition?: AnchorPosition;
    anchorAxisAlignment?: AnchorAxisAlignment;
    canRelayout?: boolean;
    onDOMEvent?(e: Event, activeElement: HTMLElement): void;
    onHide?(data?: unknown): void;
}
interface IContextViewProvider {
    showContextView(delegate: IDelegate, container?: HTMLElement): void;
    hideContextView(): void;
    layout(): void;
}

declare abstract class Widget extends Disposable {
    protected onclick(domNode: HTMLElement, listener: (e: IMouseEvent) => void): void;
    protected onmousedown(domNode: HTMLElement, listener: (e: IMouseEvent) => void): void;
    protected onmouseover(domNode: HTMLElement, listener: (e: IMouseEvent) => void): void;
    protected onmouseleave(domNode: HTMLElement, listener: (e: IMouseEvent) => void): void;
    protected onkeydown(domNode: HTMLElement, listener: (e: IKeyboardEvent$1) => void): void;
    protected onkeyup(domNode: HTMLElement, listener: (e: IKeyboardEvent$1) => void): void;
    protected oninput(domNode: HTMLElement, listener: (e: Event) => void): void;
    protected onblur(domNode: HTMLElement, listener: (e: Event) => void): void;
    protected onfocus(domNode: HTMLElement, listener: (e: Event) => void): void;
    protected onchange(domNode: HTMLElement, listener: (e: Event) => void): void;
    protected ignoreGesture(domNode: HTMLElement): IDisposable;
}

declare const enum HoverPosition {
    LEFT = 0,
    RIGHT = 1,
    BELOW = 2,
    ABOVE = 3
}

/**
 * Copied from src\vs\workbench\services\hover\browser\hover.ts
 * @deprecated Use IHoverService
 */
interface IHoverAction {
    label: string;
    commandId: string;
    iconClass?: string;
    run(target: HTMLElement): void;
}
interface IUpdatableHoverOptions {
    actions?: IHoverAction[];
    linkHandler?(url: string): void;
}

interface IHoverDelegateTarget extends IDisposable {
    readonly targetElements: readonly HTMLElement[];
    x?: number;
}
interface IHoverDelegateOptions extends IUpdatableHoverOptions {
    /**
     * The content to display in the primary section of the hover. The type of text determines the
     * default `hideOnHover` behavior.
     */
    content: IMarkdownString | string | HTMLElement;
    /**
     * The target for the hover. This determines the position of the hover and it will only be
     * hidden when the mouse leaves both the hover and the target. A HTMLElement can be used for
     * simple cases and a IHoverDelegateTarget for more complex cases where multiple elements and/or a
     * dispose method is required.
     */
    target: IHoverDelegateTarget | HTMLElement;
    /**
     * Position of the hover. The default is to show above the target. This option will be ignored
     * if there is not enough room to layout the hover in the specified position, unless the
     * forcePosition option is set.
     */
    hoverPosition?: HoverPosition;
    /**
     * Whether to show the hover pointer
     */
    showPointer?: boolean;
    /**
     * Whether to skip the fade in animation, this should be used when hovering from one hover to
     * another in the same group so it looks like the hover is moving from one element to the other.
     */
    skipFadeInAnimation?: boolean;
    /**
     * The container to pass to {@link IContextViewProvider.showContextView} which renders the hover
     * in. This is particularly useful for more natural tab focusing behavior, where the hover is
     * created as the next tab index after the element being hovered and/or to workaround the
     * element's container hiding on `focusout`.
     */
    container?: HTMLElement;
}
interface IHoverDelegate {
    showHover(options: IHoverDelegateOptions, focus?: boolean): IHoverWidget | undefined;
    onDidHideHover?: () => void;
    delay: number;
    placement?: 'mouse' | 'element';
}
interface IHoverWidget extends IDisposable {
    readonly isDisposed: boolean;
}

interface IToggleStyles {
    readonly inputActiveOptionBorder: string | undefined;
    readonly inputActiveOptionForeground: string | undefined;
    readonly inputActiveOptionBackground: string | undefined;
}

interface IBaseActionViewItemOptions {
    draggable?: boolean;
    isMenu?: boolean;
    useEventAsContext?: boolean;
    hoverDelegate?: IHoverDelegate;
}
interface IActionViewItemOptions extends IBaseActionViewItemOptions {
    icon?: boolean;
    label?: boolean;
    keybinding?: string | null;
    toggleStyles?: IToggleStyles;
}

interface IActionViewItem extends IDisposable {
    action: IAction;
    actionRunner: IActionRunner;
    setActionContext(context: unknown): void;
    render(element: HTMLElement): void;
    isEnabled(): boolean;
    focus(fromRight?: boolean): void;
    blur(): void;
}
interface IActionViewItemProvider {
    (action: IAction, options: IActionViewItemOptions): IActionViewItem | undefined;
}

interface IKeybindings {
    primary?: number;
    secondary?: number[];
    win?: {
        primary: number;
        secondary?: number[];
    };
    linux?: {
        primary: number;
        secondary?: number[];
    };
    mac?: {
        primary: number;
        secondary?: number[];
    };
}

interface ISubmenuItem {
    title: string | ICommandActionTitle;
    submenu: MenuId;
    icon?: Icon;
    when?: ContextKeyExpression;
    group?: 'navigation' | string;
    order?: number;
    isSelection?: boolean;
    rememberDefaultAction?: boolean;
}
declare class MenuId {
    private static readonly _instances;
    static readonly CommandPalette: MenuId;
    static readonly DebugBreakpointsContext: MenuId;
    static readonly DebugCallStackContext: MenuId;
    static readonly DebugConsoleContext: MenuId;
    static readonly DebugVariablesContext: MenuId;
    static readonly DebugWatchContext: MenuId;
    static readonly DebugToolBar: MenuId;
    static readonly DebugToolBarStop: MenuId;
    static readonly EditorContext: MenuId;
    static readonly SimpleEditorContext: MenuId;
    static readonly EditorContent: MenuId;
    static readonly EditorContextCopy: MenuId;
    static readonly EditorContextPeek: MenuId;
    static readonly EditorContextShare: MenuId;
    static readonly EditorTitle: MenuId;
    static readonly EditorTitleRun: MenuId;
    static readonly EditorTitleContext: MenuId;
    static readonly EmptyEditorGroup: MenuId;
    static readonly EmptyEditorGroupContext: MenuId;
    static readonly ExplorerContext: MenuId;
    static readonly ExtensionContext: MenuId;
    static readonly GlobalActivity: MenuId;
    static readonly CommandCenter: MenuId;
    static readonly LayoutControlMenuSubmenu: MenuId;
    static readonly LayoutControlMenu: MenuId;
    static readonly MenubarMainMenu: MenuId;
    static readonly MenubarAppearanceMenu: MenuId;
    static readonly MenubarDebugMenu: MenuId;
    static readonly MenubarEditMenu: MenuId;
    static readonly MenubarCopy: MenuId;
    static readonly MenubarFileMenu: MenuId;
    static readonly MenubarGoMenu: MenuId;
    static readonly MenubarHelpMenu: MenuId;
    static readonly MenubarLayoutMenu: MenuId;
    static readonly MenubarNewBreakpointMenu: MenuId;
    static readonly PanelAlignmentMenu: MenuId;
    static readonly PanelPositionMenu: MenuId;
    static readonly MenubarPreferencesMenu: MenuId;
    static readonly MenubarRecentMenu: MenuId;
    static readonly MenubarSelectionMenu: MenuId;
    static readonly MenubarShare: MenuId;
    static readonly MenubarSwitchEditorMenu: MenuId;
    static readonly MenubarSwitchGroupMenu: MenuId;
    static readonly MenubarTerminalMenu: MenuId;
    static readonly MenubarViewMenu: MenuId;
    static readonly MenubarHomeMenu: MenuId;
    static readonly OpenEditorsContext: MenuId;
    static readonly ProblemsPanelContext: MenuId;
    static readonly SCMChangeContext: MenuId;
    static readonly SCMResourceContext: MenuId;
    static readonly SCMResourceFolderContext: MenuId;
    static readonly SCMResourceGroupContext: MenuId;
    static readonly SCMSourceControl: MenuId;
    static readonly SCMTitle: MenuId;
    static readonly SearchContext: MenuId;
    static readonly SearchActionMenu: MenuId;
    static readonly StatusBarWindowIndicatorMenu: MenuId;
    static readonly StatusBarRemoteIndicatorMenu: MenuId;
    static readonly StickyScrollContext: MenuId;
    static readonly TestItem: MenuId;
    static readonly TestItemGutter: MenuId;
    static readonly TestPeekElement: MenuId;
    static readonly TestPeekTitle: MenuId;
    static readonly TouchBarContext: MenuId;
    static readonly TitleBarContext: MenuId;
    static readonly TitleBarTitleContext: MenuId;
    static readonly TunnelContext: MenuId;
    static readonly TunnelPrivacy: MenuId;
    static readonly TunnelProtocol: MenuId;
    static readonly TunnelPortInline: MenuId;
    static readonly TunnelTitle: MenuId;
    static readonly TunnelLocalAddressInline: MenuId;
    static readonly TunnelOriginInline: MenuId;
    static readonly ViewItemContext: MenuId;
    static readonly ViewContainerTitle: MenuId;
    static readonly ViewContainerTitleContext: MenuId;
    static readonly ViewTitle: MenuId;
    static readonly ViewTitleContext: MenuId;
    static readonly CommentEditorActions: MenuId;
    static readonly CommentThreadTitle: MenuId;
    static readonly CommentThreadActions: MenuId;
    static readonly CommentThreadAdditionalActions: MenuId;
    static readonly CommentThreadTitleContext: MenuId;
    static readonly CommentThreadCommentContext: MenuId;
    static readonly CommentTitle: MenuId;
    static readonly CommentActions: MenuId;
    static readonly InteractiveToolbar: MenuId;
    static readonly InteractiveCellTitle: MenuId;
    static readonly InteractiveCellDelete: MenuId;
    static readonly InteractiveCellExecute: MenuId;
    static readonly InteractiveInputExecute: MenuId;
    static readonly NotebookToolbar: MenuId;
    static readonly NotebookCellTitle: MenuId;
    static readonly NotebookCellDelete: MenuId;
    static readonly NotebookCellInsert: MenuId;
    static readonly NotebookCellBetween: MenuId;
    static readonly NotebookCellListTop: MenuId;
    static readonly NotebookCellExecute: MenuId;
    static readonly NotebookCellExecutePrimary: MenuId;
    static readonly NotebookDiffCellInputTitle: MenuId;
    static readonly NotebookDiffCellMetadataTitle: MenuId;
    static readonly NotebookDiffCellOutputsTitle: MenuId;
    static readonly NotebookOutputToolbar: MenuId;
    static readonly NotebookEditorLayoutConfigure: MenuId;
    static readonly NotebookKernelSource: MenuId;
    static readonly BulkEditTitle: MenuId;
    static readonly BulkEditContext: MenuId;
    static readonly TimelineItemContext: MenuId;
    static readonly TimelineTitle: MenuId;
    static readonly TimelineTitleContext: MenuId;
    static readonly TimelineFilterSubMenu: MenuId;
    static readonly AccountsContext: MenuId;
    static readonly PanelTitle: MenuId;
    static readonly AuxiliaryBarTitle: MenuId;
    static readonly TerminalInstanceContext: MenuId;
    static readonly TerminalEditorInstanceContext: MenuId;
    static readonly TerminalNewDropdownContext: MenuId;
    static readonly TerminalTabContext: MenuId;
    static readonly TerminalTabEmptyAreaContext: MenuId;
    static readonly TerminalInlineTabContext: MenuId;
    static readonly WebviewContext: MenuId;
    static readonly InlineCompletionsActions: MenuId;
    static readonly NewFile: MenuId;
    static readonly MergeInput1Toolbar: MenuId;
    static readonly MergeInput2Toolbar: MenuId;
    static readonly MergeBaseToolbar: MenuId;
    static readonly MergeInputResultToolbar: MenuId;
    static readonly InlineSuggestionToolbar: MenuId;
    /**
     * Create or reuse a `MenuId` with the given identifier
     */
    static for(identifier: string): MenuId;
    readonly id: string;
    /**
     * Create a new `MenuId` with the unique identifier. Will throw if a menu
     * with the identifier already exists, use `MenuId.for(ident)` or a unique
     * identifier
     */
    constructor(identifier: string);
}
interface IMenuActionOptions {
    arg?: any;
    shouldForwardArgs?: boolean;
    renderShortTitle?: boolean;
}
interface IMenuChangeEvent {
    readonly menu: IMenu;
    readonly isStructuralChange: boolean;
    readonly isToggleChange: boolean;
    readonly isEnablementChange: boolean;
}
interface IMenu extends IDisposable {
    readonly onDidChange: Event$1<IMenuChangeEvent>;
    getActions(options?: IMenuActionOptions): [string, Array<MenuItemAction | SubmenuItemAction>][];
}
interface IMenuCreateOptions {
    emitEventsForSubmenuChanges?: boolean;
    eventDebounceDelay?: number;
}
declare const IMenuService: ServiceIdentifier<IMenuService>;
interface IMenuService {
    readonly _serviceBrand: undefined;
    /**
     * Create a new menu for the given menu identifier. A menu sends events when it's entries
     * have changed (placement, enablement, checked-state). By default it does not send events for
     * submenu entries. That is more expensive and must be explicitly enabled with the
     * `emitEventsForSubmenuChanges` flag.
     */
    createMenu(id: MenuId, contextKeyService: IContextKeyService, options?: IMenuCreateOptions): IMenu;
    /**
     * Reset **all** menu item hidden states.
     */
    resetHiddenStates(): void;
    /**
     * Reset the menu's hidden states.
     */
    resetHiddenStates(menuIds: readonly MenuId[] | undefined): void;
}
declare class SubmenuItemAction extends SubmenuAction {
    readonly item: ISubmenuItem;
    readonly hideActions: IMenuItemHide | undefined;
    constructor(item: ISubmenuItem, hideActions: IMenuItemHide | undefined, actions: IAction[]);
}
interface IMenuItemHide {
    readonly isHidden: boolean;
    readonly hide: IAction;
    readonly toggle: IAction;
}
declare class MenuItemAction implements IAction {
    readonly hideActions: IMenuItemHide | undefined;
    private _commandService;
    static label(action: ICommandAction, options?: IMenuActionOptions): string;
    readonly item: ICommandAction;
    readonly alt: MenuItemAction | undefined;
    private readonly _options;
    readonly id: string;
    readonly label: string;
    readonly tooltip: string;
    readonly class: string | undefined;
    readonly enabled: boolean;
    readonly checked?: boolean;
    constructor(item: ICommandAction, alt: ICommandAction | undefined, options: IMenuActionOptions | undefined, hideActions: IMenuItemHide | undefined, contextKeyService: IContextKeyService, _commandService: ICommandService);
    run(...args: any[]): Promise<void>;
}

/**
 * A vertical sash layout provider provides position and height for a sash.
 */
interface IVerticalSashLayoutProvider {
    getVerticalSashLeft(sash: Sash): number;
    getVerticalSashTop?(sash: Sash): number;
    getVerticalSashHeight?(sash: Sash): number;
}
/**
 * A vertical sash layout provider provides position and width for a sash.
 */
interface IHorizontalSashLayoutProvider {
    getHorizontalSashTop(sash: Sash): number;
    getHorizontalSashLeft?(sash: Sash): number;
    getHorizontalSashWidth?(sash: Sash): number;
}
interface ISashEvent {
    readonly startX: number;
    readonly currentX: number;
    readonly startY: number;
    readonly currentY: number;
    readonly altKey: boolean;
}
declare enum OrthogonalEdge {
    North = "north",
    South = "south",
    East = "east",
    West = "west"
}
interface IBoundarySashes {
    readonly top?: Sash;
    readonly right?: Sash;
    readonly bottom?: Sash;
    readonly left?: Sash;
}
interface ISashOptions {
    /**
     * Whether a sash is horizontal or vertical.
     */
    readonly orientation: Orientation;
    /**
     * The width or height of a vertical or horizontal sash, respectively.
     */
    readonly size?: number;
    /**
     * A reference to another sash, perpendicular to this one, which
     * aligns at the start of this one. A corner sash will be created
     * automatically at that location.
     *
     * The start of a horizontal sash is its left-most position.
     * The start of a vertical sash is its top-most position.
     */
    readonly orthogonalStartSash?: Sash;
    /**
     * A reference to another sash, perpendicular to this one, which
     * aligns at the end of this one. A corner sash will be created
     * automatically at that location.
     *
     * The end of a horizontal sash is its right-most position.
     * The end of a vertical sash is its bottom-most position.
     */
    readonly orthogonalEndSash?: Sash;
    /**
     * Provides a hint as to what mouse cursor to use whenever the user
     * hovers over a corner sash provided by this and an orthogonal sash.
     */
    readonly orthogonalEdge?: OrthogonalEdge;
}
interface IVerticalSashOptions extends ISashOptions {
    readonly orientation: Orientation.VERTICAL;
}
interface IHorizontalSashOptions extends ISashOptions {
    readonly orientation: Orientation.HORIZONTAL;
}
declare const enum Orientation {
    VERTICAL = 0,
    HORIZONTAL = 1
}
declare const enum SashState {
    /**
     * Disable any UI interaction.
     */
    Disabled = 0,
    /**
     * Allow dragging down or to the right, depending on the sash orientation.
     *
     * Some OSs allow customizing the mouse cursor differently whenever
     * some resizable component can't be any smaller, but can be larger.
     */
    AtMinimum = 1,
    /**
     * Allow dragging up or to the left, depending on the sash orientation.
     *
     * Some OSs allow customizing the mouse cursor differently whenever
     * some resizable component can't be any larger, but can be smaller.
     */
    AtMaximum = 2,
    /**
     * Enable dragging.
     */
    Enabled = 3
}
/**
 * The {@link Sash} is the UI component which allows the user to resize other
 * components. It's usually an invisible horizontal or vertical line which, when
 * hovered, becomes highlighted and can be dragged along the perpendicular dimension
 * to its direction.
 *
 * Features:
 * - Touch event handling
 * - Corner sash support
 * - Hover with different mouse cursor support
 * - Configurable hover size
 * - Linked sash support, for 2x2 corner sashes
 */
declare class Sash extends Disposable {
    private el;
    private layoutProvider;
    private orientation;
    private size;
    private hoverDelay;
    private hoverDelayer;
    private _state;
    private readonly onDidEnablementChange;
    private readonly _onDidStart;
    private readonly _onDidChange;
    private readonly _onDidReset;
    private readonly _onDidEnd;
    private readonly orthogonalStartSashDisposables;
    private _orthogonalStartSash;
    private readonly orthogonalStartDragHandleDisposables;
    private _orthogonalStartDragHandle;
    private readonly orthogonalEndSashDisposables;
    private _orthogonalEndSash;
    private readonly orthogonalEndDragHandleDisposables;
    private _orthogonalEndDragHandle;
    get state(): SashState;
    get orthogonalStartSash(): Sash | undefined;
    get orthogonalEndSash(): Sash | undefined;
    /**
     * The state of a sash defines whether it can be interacted with by the user
     * as well as what mouse cursor to use, when hovered.
     */
    set state(state: SashState);
    /**
     * An event which fires whenever the user starts dragging this sash.
     */
    readonly onDidStart: Event$1<ISashEvent>;
    /**
     * An event which fires whenever the user moves the mouse while
     * dragging this sash.
     */
    readonly onDidChange: Event$1<ISashEvent>;
    /**
     * An event which fires whenever the user double clicks this sash.
     */
    readonly onDidReset: Event$1<void>;
    /**
     * An event which fires whenever the user stops dragging this sash.
     */
    readonly onDidEnd: Event$1<void>;
    /**
     * A linked sash will be forwarded the same user interactions and events
     * so it moves exactly the same way as this sash.
     *
     * Useful in 2x2 grids. Not meant for widespread usage.
     */
    linkedSash: Sash | undefined;
    /**
     * A reference to another sash, perpendicular to this one, which
     * aligns at the start of this one. A corner sash will be created
     * automatically at that location.
     *
     * The start of a horizontal sash is its left-most position.
     * The start of a vertical sash is its top-most position.
     */
    set orthogonalStartSash(sash: Sash | undefined);
    /**
     * A reference to another sash, perpendicular to this one, which
     * aligns at the end of this one. A corner sash will be created
     * automatically at that location.
     *
     * The end of a horizontal sash is its right-most position.
     * The end of a vertical sash is its bottom-most position.
     */
    set orthogonalEndSash(sash: Sash | undefined);
    /**
     * Create a new vertical sash.
     *
     * @param container A DOM node to append the sash to.
     * @param verticalLayoutProvider A vertical layout provider.
     * @param options The options.
     */
    constructor(container: HTMLElement, verticalLayoutProvider: IVerticalSashLayoutProvider, options: IVerticalSashOptions);
    /**
     * Create a new horizontal sash.
     *
     * @param container A DOM node to append the sash to.
     * @param horizontalLayoutProvider A horizontal layout provider.
     * @param options The options.
     */
    constructor(container: HTMLElement, horizontalLayoutProvider: IHorizontalSashLayoutProvider, options: IHorizontalSashOptions);
    private onPointerStart;
    private onPointerDoublePress;
    private static onMouseEnter;
    private static onMouseLeave;
    /**
     * Forcefully stop any user interactions with this sash.
     * Useful when hiding a parent component, while the user is still
     * interacting with the sash.
     */
    clearSashHoverState(): void;
    /**
     * Layout the sash. The sash will size and position itself
     * based on its provided {@link ISashLayoutProvider layout provider}.
     */
    layout(): void;
    private getOrthogonalSash;
    dispose(): void;
}

/**
 * Composites are layed out in the sidebar and panel part of the workbench. At a time only one composite
 * can be open in the sidebar, and only one composite can be open in the panel.
 *
 * Each composite has a minimized representation that is good enough to provide some
 * information about the state of the composite data.
 *
 * The workbench will keep a composite alive after it has been created and show/hide it based on
 * user interaction. The lifecycle of a composite goes in the order create(), setVisible(true|false),
 * layout(), focus(), dispose(). During use of the workbench, a composite will often receive a setVisible,
 * layout and focus call, but only one create and dispose call.
 */
declare abstract class Composite extends Component implements IComposite {
    private readonly _onTitleAreaUpdate;
    readonly onTitleAreaUpdate: Event$1<void>;
    private _onDidFocus;
    get onDidFocus(): Event$1<void>;
    protected fireOnDidFocus(): void;
    private _onDidBlur;
    get onDidBlur(): Event$1<void>;
    private _hasFocus;
    hasFocus(): boolean;
    private registerFocusTrackEvents;
    protected actionRunner: IActionRunner | undefined;
    private _telemetryService;
    protected get telemetryService(): ITelemetryService;
    private visible;
    private parent;
    constructor(id: string, telemetryService: ITelemetryService, themeService: IThemeService, storageService: IStorageService);
    getTitle(): string | undefined;
    /**
     * Note: Clients should not call this method, the workbench calls this
     * method. Calling it otherwise may result in unexpected behavior.
     *
     * Called to create this composite on the provided parent. This method is only
     * called once during the lifetime of the workbench.
     * Note that DOM-dependent calculations should be performed from the setVisible()
     * call. Only then the composite will be part of the DOM.
     */
    create(parent: HTMLElement): void;
    /**
     * Returns the container this composite is being build in.
     */
    getContainer(): HTMLElement | undefined;
    /**
     * Note: Clients should not call this method, the workbench calls this
     * method. Calling it otherwise may result in unexpected behavior.
     *
     * Called to indicate that the composite has become visible or hidden. This method
     * is called more than once during workbench lifecycle depending on the user interaction.
     * The composite will be on-DOM if visible is set to true and off-DOM otherwise.
     *
     * Typically this operation should be fast though because setVisible might be called many times during a session.
     * If there is a long running operation it is fine to have it running in the background asyncly and return before.
     */
    setVisible(visible: boolean): void;
    /**
     * Called when this composite should receive keyboard focus.
     */
    focus(): void;
    /**
     * Layout the contents of this composite using the provided dimensions.
     */
    abstract layout(dimension: Dimension, position?: IDomPosition): void;
    /**
     * Set boundary sashes for this composite. These are used to create
     * draggable corner areas with inner sashes.
     */
    abstract setBoundarySashes(sashes: IBoundarySashes): void;
    /**
     * Update the styles of the contents of this composite.
     */
    updateStyles(): void;
    /**
     *
     * @returns the action runner for this composite
     */
    getMenuIds(): readonly MenuId[];
    /**
     * Returns an array of actions to show in the action bar of the composite.
     */
    getActions(): readonly IAction[];
    /**
     * Returns an array of actions to show in the action bar of the composite
     * in a less prominent way then action from getActions.
     */
    getSecondaryActions(): readonly IAction[];
    /**
     * Returns an array of actions to show in the context menu of the composite
     */
    getContextMenuActions(): readonly IAction[];
    /**
     * For any of the actions returned by this composite, provide an IActionViewItem in
     * cases where the implementor of the composite wants to override the presentation
     * of an action. Returns undefined to indicate that the action is not rendered through
     * an action item.
     */
    getActionViewItem(action: IAction): IActionViewItem | undefined;
    /**
     * Provide a context to be passed to the toolbar.
     */
    getActionsContext(): unknown;
    /**
     * Returns the instance of IActionRunner to use with this composite for the
     * composite tool bar.
     */
    getActionRunner(): IActionRunner;
    /**
     * Method for composite implementors to indicate to the composite container that the title or the actions
     * of the composite have changed. Calling this method will cause the container to ask for title (getTitle())
     * and actions (getActions(), getSecondaryActions()) if the composite is visible or the next time the composite
     * gets visible.
     */
    protected updateTitleArea(): void;
    /**
     * Returns true if this composite is currently visible and false otherwise.
     */
    isVisible(): boolean;
    /**
     * Returns the underlying composite control or `undefined` if it is not accessible.
     */
    getControl(): ICompositeControl | undefined;
}
/**
 * A composite descriptor is a lightweight descriptor of a composite in the workbench.
 */
declare abstract class CompositeDescriptor<T extends Composite> {
    private readonly ctor;
    readonly id: string;
    readonly name: string;
    readonly cssClass?: string | undefined;
    readonly order?: number | undefined;
    readonly requestedIndex?: number | undefined;
    constructor(ctor: IConstructorSignature<T>, id: string, name: string, cssClass?: string | undefined, order?: number | undefined, requestedIndex?: number | undefined);
    instantiate(instantiationService: IInstantiationService): T;
}

interface IContextMenuEvent {
    readonly shiftKey?: boolean;
    readonly ctrlKey?: boolean;
    readonly altKey?: boolean;
    readonly metaKey?: boolean;
}
interface IContextMenuDelegate {
    getAnchor(): HTMLElement | {
        x: number;
        y: number;
        width?: number;
        height?: number;
    };
    getActions(): readonly IAction[];
    getCheckedActionsRepresentation?(action: IAction): 'radio' | 'checkbox';
    getActionViewItem?(action: IAction, options: IActionViewItemOptions): IActionViewItem | undefined;
    getActionsContext?(event?: IContextMenuEvent): unknown;
    getKeyBinding?(action: IAction): ResolvedKeybinding | undefined;
    getMenuClassName?(): string;
    onHide?(didCancel: boolean): void;
    actionRunner?: IActionRunner;
    skipTelemetry?: boolean;
    autoSelectFirstItem?: boolean;
    anchorAlignment?: AnchorAlignment;
    anchorAxisAlignment?: AnchorAxisAlignment;
    domForShadowRoot?: HTMLElement;
}

declare const IContextViewService: ServiceIdentifier<IContextViewService>;
interface IContextViewService extends IContextViewProvider {
    readonly _serviceBrand: undefined;
    showContextView(delegate: IContextViewDelegate, container?: HTMLElement, shadowRoot?: boolean): IDisposable;
    hideContextView(data?: any): void;
    getContextViewElement(): HTMLElement;
    layout(): void;
    anchorAlignment?: AnchorAlignment;
}
interface IContextViewDelegate {
    canRelayout?: boolean;
    getAnchor(): HTMLElement | {
        x: number;
        y: number;
        width?: number;
        height?: number;
    };
    render(container: HTMLElement): IDisposable;
    onDOMEvent?(e: any, activeElement: HTMLElement): void;
    onHide?(data?: any): void;
    focus?(): void;
    anchorAlignment?: AnchorAlignment;
    anchorAxisAlignment?: AnchorAxisAlignment;
}
declare const IContextMenuService: ServiceIdentifier<IContextMenuService>;
interface IContextMenuService {
    readonly _serviceBrand: undefined;
    readonly onDidShowContextMenu: Event$1<void>;
    readonly onDidHideContextMenu: Event$1<void>;
    showContextMenu(delegate: IContextMenuDelegate | IContextMenuMenuDelegate): void;
}
type IContextMenuMenuDelegate = {
    /**
     * The MenuId that should be used to populate the context menu.
     */
    menuId?: MenuId;
    /**
     * Optional options how menu actions are invoked
     */
    menuActionOptions?: IMenuActionOptions;
    /**
     * Optional context key service which drives the given menu
     */
    contextKeyService?: IContextKeyService;
    /**
     * Optional getter for extra actions. They will be prepended to the menu actions.
     */
    getActions?(): IAction[];
} & Omit<IContextMenuDelegate, 'getActions'>;

declare const enum LayoutPriority {
    Normal = 0,
    Low = 1,
    High = 2
}
/**
 * The interface to implement for views within a {@link SplitView}.
 *
 * An optional {@link TLayoutContext layout context type} may be used in order to
 * pass along layout contextual data from the {@link SplitView.layout} method down
 * to each view's {@link IView.layout} calls.
 */
interface IView$3<TLayoutContext = undefined> {
    /**
     * The DOM element for this view.
     */
    readonly element: HTMLElement;
    /**
     * A minimum size for this view.
     *
     * @remarks If none, set it to `0`.
     */
    readonly minimumSize: number;
    /**
     * A maximum size for this view.
     *
     * @remarks If none, set it to `Number.POSITIVE_INFINITY`.
     */
    readonly maximumSize: number;
    /**
     * The priority of the view when the {@link SplitView.resize layout} algorithm
     * runs. Views with higher priority will be resized first.
     *
     * @remarks Only used when `proportionalLayout` is false.
     */
    readonly priority?: LayoutPriority;
    /**
     * If the {@link SplitView} supports {@link ISplitViewOptions.proportionalLayout proportional layout},
     * this property allows for finer control over the proportional layout algorithm, per view.
     *
     * @defaultValue `true`
     */
    readonly proportionalLayout?: boolean;
    /**
     * Whether the view will snap whenever the user reaches its minimum size or
     * attempts to grow it beyond the minimum size.
     *
     * @defaultValue `false`
     */
    readonly snap?: boolean;
    /**
     * View instances are supposed to fire the {@link IView.onDidChange} event whenever
     * any of the constraint properties have changed:
     *
     * - {@link IView.minimumSize}
     * - {@link IView.maximumSize}
     * - {@link IView.priority}
     * - {@link IView.snap}
     *
     * The SplitView will relayout whenever that happens. The event can optionally emit
     * the view's preferred size for that relayout.
     */
    readonly onDidChange: Event$1<number | undefined>;
    /**
     * This will be called by the {@link SplitView} during layout. A view meant to
     * pass along the layout information down to its descendants.
     *
     * @param size The size of this view, in pixels.
     * @param offset The offset of this view, relative to the start of the {@link SplitView}.
     * @param context The optional {@link IView layout context} passed to {@link SplitView.layout}.
     */
    layout(size: number, offset: number, context: TLayoutContext | undefined): void;
    /**
     * This will be called by the {@link SplitView} whenever this view is made
     * visible or hidden.
     *
     * @param visible Whether the view becomes visible.
     */
    setVisible?(visible: boolean): void;
}

interface IPaneOptions {
    minimumBodySize?: number;
    maximumBodySize?: number;
    expanded?: boolean;
    orientation?: Orientation;
    title: string;
    titleDescription?: string;
}
interface IPaneStyles {
    readonly dropBackground: string | undefined;
    readonly headerForeground: string | undefined;
    readonly headerBackground: string | undefined;
    readonly headerBorder: string | undefined;
    readonly leftBorder: string | undefined;
}
/**
 * A Pane is a structured SplitView view.
 *
 * WARNING: You must call `render()` after you construct it.
 * It can't be done automatically at the end of the ctor
 * because of the order of property initialization in TypeScript.
 * Subclasses wouldn't be able to set own properties
 * before the `render()` call, thus forbidding their use.
 */
declare abstract class Pane extends Disposable implements IView$3 {
    private static readonly HEADER_SIZE;
    readonly element: HTMLElement;
    private header;
    private body;
    protected _expanded: boolean;
    protected _orientation: Orientation;
    private expandedSize;
    private _headerVisible;
    private _bodyRendered;
    private _minimumBodySize;
    private _maximumBodySize;
    private _ariaHeaderLabel;
    private styles;
    private animationTimer;
    private readonly _onDidChange;
    readonly onDidChange: Event$1<number | undefined>;
    private readonly _onDidChangeExpansionState;
    readonly onDidChangeExpansionState: Event$1<boolean>;
    get ariaHeaderLabel(): string;
    set ariaHeaderLabel(newLabel: string);
    get draggableElement(): HTMLElement;
    get dropTargetElement(): HTMLElement;
    get dropBackground(): string | undefined;
    get minimumBodySize(): number;
    set minimumBodySize(size: number);
    get maximumBodySize(): number;
    set maximumBodySize(size: number);
    private get headerSize();
    get minimumSize(): number;
    get maximumSize(): number;
    orthogonalSize: number;
    constructor(options: IPaneOptions);
    isExpanded(): boolean;
    setExpanded(expanded: boolean): boolean;
    get headerVisible(): boolean;
    set headerVisible(visible: boolean);
    get orientation(): Orientation;
    set orientation(orientation: Orientation);
    render(): void;
    layout(size: number): void;
    style(styles: IPaneStyles): void;
    protected updateHeader(): void;
    protected abstract renderHeader(container: HTMLElement): void;
    protected abstract renderBody(container: HTMLElement): void;
    protected abstract layoutBody(height: number, width: number): void;
}
interface IPaneDndController {
    canDrag(pane: Pane): boolean;
    canDrop(pane: Pane, overPane: Pane): boolean;
}
interface IPaneViewOptions {
    dnd?: IPaneDndController;
    orientation?: Orientation;
}

declare class CompositeMenuActions extends Disposable {
    readonly menuId: MenuId;
    private readonly contextMenuId;
    private readonly options;
    private readonly contextKeyService;
    private readonly menuService;
    private readonly menuActions;
    private _onDidChange;
    readonly onDidChange: Event$1<void>;
    constructor(menuId: MenuId, contextMenuId: MenuId | undefined, options: IMenuActionOptions | undefined, contextKeyService: IContextKeyService, menuService: IMenuService);
    getPrimaryActions(): IAction[];
    getSecondaryActions(): IAction[];
    getContextMenuActions(): IAction[];
}

interface IPaneComposite extends IComposite {
    /**
     * Returns the minimal width needed to avoid any content horizontal truncation
     */
    getOptimalWidth(): number | undefined;
    openView<T extends IView$2>(id: string, focus?: boolean): T | undefined;
    getViewPaneContainer(): IViewPaneContainer | undefined;
    saveState(): void;
}

declare const enum ViewContainerLocation {
    Sidebar = 0,
    Panel = 1,
    AuxiliaryBar = 2
}
type OpenCommandActionDescriptor = {
    readonly id: string;
    readonly title?: ILocalizedString | string;
    readonly mnemonicTitle?: string;
    readonly order?: number;
    readonly keybindings?: IKeybindings & {
        when?: ContextKeyExpression;
    };
};
/**
 * View Container Contexts
 */
interface IViewContainerDescriptor {
    /**
     * The id of the view container
     */
    readonly id: string;
    /**
     * The title of the view container
     */
    readonly title: ILocalizedString | string;
    /**
     * Icon representation of the View container
     */
    readonly icon?: ThemeIcon | URI;
    /**
     * Order of the view container.
     */
    readonly order?: number;
    /**
     * IViewPaneContainer Ctor to instantiate
     */
    readonly ctorDescriptor: SyncDescriptor<IViewPaneContainer>;
    /**
     * Descriptor for open view container command
     * If not provided, view container info (id, title) is used.
     *
     * Note: To prevent registering open command, use `doNotRegisterOpenCommand` flag while registering the view container
     */
    readonly openCommandActionDescriptor?: OpenCommandActionDescriptor;
    /**
     * Storage id to use to store the view container state.
     * If not provided, it will be derived.
     */
    readonly storageId?: string;
    /**
     * If enabled, view container is not shown if it has no active views.
     */
    readonly hideIfEmpty?: boolean;
    /**
     * Id of the extension that contributed the view container
     */
    readonly extensionId?: ExtensionIdentifier;
    readonly alwaysUseContainerInfo?: boolean;
    readonly viewOrderDelegate?: ViewOrderDelegate;
    readonly rejectAddedViews?: boolean;
    requestedIndex?: number;
}
interface ViewOrderDelegate {
    getOrder(group?: string): number | undefined;
}
interface ViewContainer extends IViewContainerDescriptor {
}
interface IViewDescriptor {
    readonly type?: string;
    readonly id: string;
    readonly name: string;
    readonly ctorDescriptor: SyncDescriptor<IView$2>;
    readonly when?: ContextKeyExpression;
    readonly order?: number;
    readonly weight?: number;
    readonly collapsed?: boolean;
    readonly canToggleVisibility?: boolean;
    readonly canMoveView?: boolean;
    readonly containerIcon?: ThemeIcon | URI;
    readonly containerTitle?: string;
    readonly hideByDefault?: boolean;
    readonly workspace?: boolean;
    readonly focusCommand?: {
        id: string;
        keybindings?: IKeybindings;
    };
    readonly group?: string;
    readonly remoteAuthority?: string | string[];
    readonly virtualWorkspace?: string;
    readonly openCommandActionDescriptor?: OpenCommandActionDescriptor;
}
interface IViewDescriptorRef {
    viewDescriptor: IViewDescriptor;
    index: number;
}
interface IAddedViewDescriptorRef extends IViewDescriptorRef {
    collapsed: boolean;
    size?: number;
}
interface IViewContainerModel {
    readonly viewContainer: ViewContainer;
    readonly title: string;
    readonly icon: ThemeIcon | URI | undefined;
    readonly keybindingId: string | undefined;
    readonly onDidChangeContainerInfo: Event$1<{
        title?: boolean;
        icon?: boolean;
        keybindingId?: boolean;
        badgeEnablement?: boolean;
    }>;
    readonly allViewDescriptors: ReadonlyArray<IViewDescriptor>;
    readonly onDidChangeAllViewDescriptors: Event$1<{
        added: ReadonlyArray<IViewDescriptor>;
        removed: ReadonlyArray<IViewDescriptor>;
    }>;
    readonly activeViewDescriptors: ReadonlyArray<IViewDescriptor>;
    readonly onDidChangeActiveViewDescriptors: Event$1<{
        added: ReadonlyArray<IViewDescriptor>;
        removed: ReadonlyArray<IViewDescriptor>;
    }>;
    readonly visibleViewDescriptors: ReadonlyArray<IViewDescriptor>;
    readonly onDidAddVisibleViewDescriptors: Event$1<IAddedViewDescriptorRef[]>;
    readonly onDidRemoveVisibleViewDescriptors: Event$1<IViewDescriptorRef[]>;
    readonly onDidMoveVisibleViewDescriptors: Event$1<{
        from: IViewDescriptorRef;
        to: IViewDescriptorRef;
    }>;
    isVisible(id: string): boolean;
    setVisible(id: string, visible: boolean): void;
    isCollapsed(id: string): boolean;
    setCollapsed(id: string, collapsed: boolean): void;
    getSize(id: string): number | undefined;
    setSizes(newSizes: readonly {
        id: string;
        size: number;
    }[]): void;
    move(from: string, to: string): void;
}
interface IView$2 {
    readonly id: string;
    focus(): void;
    isVisible(): boolean;
    isBodyVisible(): boolean;
    setExpanded(expanded: boolean): boolean;
    getProgressIndicator(): IProgressIndicator | undefined;
}
declare enum ViewVisibilityState {
    Default = 0,
    Expand = 1
}
declare const IViewDescriptorService: ServiceIdentifier<IViewDescriptorService>;
interface IViewDescriptorService {
    readonly _serviceBrand: undefined;
    readonly viewContainers: ReadonlyArray<ViewContainer>;
    readonly onDidChangeViewContainers: Event$1<{
        added: ReadonlyArray<{
            container: ViewContainer;
            location: ViewContainerLocation;
        }>;
        removed: ReadonlyArray<{
            container: ViewContainer;
            location: ViewContainerLocation;
        }>;
    }>;
    getDefaultViewContainer(location: ViewContainerLocation): ViewContainer | undefined;
    getViewContainerById(id: string): ViewContainer | null;
    isViewContainerRemovedPermanently(id: string): boolean;
    getDefaultViewContainerLocation(viewContainer: ViewContainer): ViewContainerLocation | null;
    getViewContainerLocation(viewContainer: ViewContainer): ViewContainerLocation | null;
    getViewContainersByLocation(location: ViewContainerLocation): ViewContainer[];
    getViewContainerModel(viewContainer: ViewContainer): IViewContainerModel;
    readonly onDidChangeContainerLocation: Event$1<{
        viewContainer: ViewContainer;
        from: ViewContainerLocation;
        to: ViewContainerLocation;
    }>;
    moveViewContainerToLocation(viewContainer: ViewContainer, location: ViewContainerLocation, requestedIndex?: number): void;
    getViewContainerBadgeEnablementState(id: string): boolean;
    setViewContainerBadgeEnablementState(id: string, badgesEnabled: boolean): void;
    getViewDescriptorById(id: string): IViewDescriptor | null;
    getViewContainerByViewId(id: string): ViewContainer | null;
    getDefaultContainerById(id: string): ViewContainer | null;
    getViewLocationById(id: string): ViewContainerLocation | null;
    readonly onDidChangeContainer: Event$1<{
        views: IViewDescriptor[];
        from: ViewContainer;
        to: ViewContainer;
    }>;
    moveViewsToContainer(views: IViewDescriptor[], viewContainer: ViewContainer, visibilityState?: ViewVisibilityState): void;
    readonly onDidChangeLocation: Event$1<{
        views: IViewDescriptor[];
        from: ViewContainerLocation;
        to: ViewContainerLocation;
    }>;
    moveViewToLocation(view: IViewDescriptor, location: ViewContainerLocation): void;
    reset(): void;
}
interface IViewPaneContainer {
    onDidAddViews: Event$1<IView$2[]>;
    onDidRemoveViews: Event$1<IView$2[]>;
    onDidChangeViewVisibility: Event$1<IView$2>;
    readonly views: IView$2[];
    setVisible(visible: boolean): void;
    isVisible(): boolean;
    focus(): void;
    getActionsContext(): unknown;
    getView(viewId: string): IView$2 | undefined;
    toggleViewVisibility(viewId: string): void;
}

interface IKeybindingProvider {
    (action: IAction): ResolvedKeybinding | undefined;
}
interface IAnchorAlignmentProvider {
    (): AnchorAlignment;
}
interface IDropdownMenuActionViewItemOptions extends IBaseActionViewItemOptions {
    readonly actionViewItemProvider?: IActionViewItemProvider;
    readonly keybindingProvider?: IKeybindingProvider;
    readonly actionRunner?: IActionRunner;
    readonly classNames?: string[] | string;
    readonly anchorAlignmentProvider?: IAnchorAlignmentProvider;
    readonly menuAsChild?: boolean;
}

interface IFilterWidgetOptions {
    readonly text?: string;
    readonly placeholder?: string;
    readonly ariaLabel?: string;
    readonly history?: string[];
    readonly focusContextKey?: string;
}
declare class FilterWidget extends Widget {
    private readonly options;
    private readonly instantiationService;
    private readonly contextViewService;
    private readonly keybindingService;
    readonly element: HTMLElement;
    private readonly delayedFilterUpdate;
    private readonly filterInputBox;
    private readonly filterBadge;
    private readonly toolbar;
    private readonly focusContextKey;
    private readonly _onDidChangeFilterText;
    readonly onDidChangeFilterText: Event$1<string>;
    private moreFiltersActionViewItem;
    private isMoreFiltersChecked;
    constructor(options: IFilterWidgetOptions, instantiationService: IInstantiationService, contextViewService: IContextViewService, contextKeyService: IContextKeyService, keybindingService: IKeybindingService);
    focus(): void;
    blur(): void;
    updateBadge(message: string | undefined): void;
    setFilterText(filterText: string): void;
    getFilterText(): string;
    getHistory(): string[];
    layout(width: number): void;
    checkMoreFilters(checked: boolean): void;
    private createInput;
    private createBadge;
    private createToolBar;
    private onDidInputChange;
    private adjustInputBox;
    private handleKeyboardEvent;
    private onInputKeyDown;
}

interface IViewPaneOptions extends IPaneOptions {
    id: string;
    showActionsAlways?: boolean;
    titleMenuId?: MenuId;
    donotForwardArgs?: boolean;
}
declare abstract class ViewPane extends Pane implements IView$2 {
    protected keybindingService: IKeybindingService;
    protected contextMenuService: IContextMenuService;
    protected readonly configurationService: IConfigurationService;
    protected contextKeyService: IContextKeyService;
    protected viewDescriptorService: IViewDescriptorService;
    protected instantiationService: IInstantiationService;
    protected openerService: IOpenerService;
    protected themeService: IThemeService;
    protected telemetryService: ITelemetryService;
    private static readonly AlwaysShowActionsConfig;
    private _onDidFocus;
    readonly onDidFocus: Event$1<void>;
    private _onDidBlur;
    readonly onDidBlur: Event$1<void>;
    private _onDidChangeBodyVisibility;
    readonly onDidChangeBodyVisibility: Event$1<boolean>;
    protected _onDidChangeTitleArea: Emitter<void>;
    readonly onDidChangeTitleArea: Event$1<void>;
    protected _onDidChangeViewWelcomeState: Emitter<void>;
    readonly onDidChangeViewWelcomeState: Event$1<void>;
    private _isVisible;
    readonly id: string;
    private _title;
    get title(): string;
    private _titleDescription;
    get titleDescription(): string | undefined;
    readonly menuActions: CompositeMenuActions;
    private progressBar;
    private progressIndicator;
    private toolbar?;
    private readonly showActionsAlways;
    private headerContainer?;
    private titleContainer?;
    private titleDescriptionContainer?;
    private iconContainer?;
    protected twistiesContainer?: HTMLElement;
    private bodyContainer;
    private viewWelcomeContainer;
    private viewWelcomeDisposable;
    private viewWelcomeController;
    protected readonly scopedContextKeyService: IContextKeyService;
    constructor(options: IViewPaneOptions, keybindingService: IKeybindingService, contextMenuService: IContextMenuService, configurationService: IConfigurationService, contextKeyService: IContextKeyService, viewDescriptorService: IViewDescriptorService, instantiationService: IInstantiationService, openerService: IOpenerService, themeService: IThemeService, telemetryService: ITelemetryService);
    get headerVisible(): boolean;
    set headerVisible(visible: boolean);
    setVisible(visible: boolean): void;
    isVisible(): boolean;
    isBodyVisible(): boolean;
    setExpanded(expanded: boolean): boolean;
    render(): void;
    protected renderHeader(container: HTMLElement): void;
    protected getTwistyIcon(expanded: boolean): ThemeIcon;
    style(styles: IPaneStyles): void;
    private getIcon;
    protected renderHeaderTitle(container: HTMLElement, title: string): void;
    protected updateTitle(title: string): void;
    private setTitleDescription;
    protected updateTitleDescription(description?: string | undefined): void;
    private calculateTitle;
    private scrollableElement;
    protected renderBody(container: HTMLElement): void;
    protected layoutBody(height: number, width: number): void;
    onDidScrollRoot(): void;
    getProgressIndicator(): IProgressIndicator;
    protected getProgressLocation(): string;
    protected getBackgroundColor(): string;
    focus(): void;
    private setActions;
    private updateActionsVisibility;
    protected updateActions(): void;
    getActionViewItem(action: IAction, options?: IDropdownMenuActionViewItemOptions): IActionViewItem | undefined;
    getActionsContext(): unknown;
    getActionRunner(): IActionRunner | undefined;
    getOptimalWidth(): number;
    saveState(): void;
    private updateViewWelcome;
    shouldShowWelcome(): boolean;
    getFilterWidget(): FilterWidget | undefined;
    shouldShowFilterInHeader(): boolean;
}

declare class ExtensionMessageCollector {
    private readonly _messageHandler;
    private readonly _extension;
    private readonly _extensionPointId;
    constructor(messageHandler: (msg: IMessage) => void, extension: IExtensionDescription, extensionPointId: string);
    private _msg;
    error(message: string): void;
    warn(message: string): void;
    info(message: string): void;
}
interface IExtensionPointUser<T> {
    description: IExtensionDescription;
    value: T;
    collector: ExtensionMessageCollector;
}
type IExtensionPointHandler<T> = (extensions: readonly IExtensionPointUser<T>[], delta: ExtensionPointUserDelta<T>) => void;
interface IExtensionPoint<T> {
    readonly name: string;
    setHandler(handler: IExtensionPointHandler<T>): void;
    readonly defaultExtensionKind: ExtensionKind[] | undefined;
}
declare class ExtensionPointUserDelta<T> {
    readonly added: readonly IExtensionPointUser<T>[];
    readonly removed: readonly IExtensionPointUser<T>[];
    private static _toSet;
    static compute<T>(previous: readonly IExtensionPointUser<T>[] | null, current: readonly IExtensionPointUser<T>[]): ExtensionPointUserDelta<T>;
    constructor(added: readonly IExtensionPointUser<T>[], removed: readonly IExtensionPointUser<T>[]);
}

interface IMessage {
    type: Severity$1;
    message: string;
    extensionId: ExtensionIdentifier;
    extensionPointId: string;
}
declare class LocalProcessRunningLocation {
    readonly affinity: number;
    readonly kind = ExtensionHostKind.LocalProcess;
    constructor(affinity: number);
    equals(other: ExtensionRunningLocation): boolean;
    asString(): string;
}
declare class LocalWebWorkerRunningLocation {
    readonly affinity: number;
    readonly kind = ExtensionHostKind.LocalWebWorker;
    constructor(affinity: number);
    equals(other: ExtensionRunningLocation): boolean;
    asString(): string;
}
declare class RemoteRunningLocation {
    readonly kind = ExtensionHostKind.Remote;
    readonly affinity = 0;
    equals(other: ExtensionRunningLocation): boolean;
    asString(): string;
}
type ExtensionRunningLocation = LocalProcessRunningLocation | LocalWebWorkerRunningLocation | RemoteRunningLocation;
interface IExtensionsStatus {
    messages: IMessage[];
    activationTimes: ActivationTimes | undefined;
    runtimeErrors: Error[];
    runningLocation: ExtensionRunningLocation | null;
}
declare const enum ExtensionHostKind {
    LocalProcess = 1,
    LocalWebWorker = 2,
    Remote = 3
}
interface ExtensionActivationReason {
    readonly startup: boolean;
    readonly extensionId: ExtensionIdentifier;
    readonly activationEvent: string;
}
declare class ActivationTimes {
    readonly codeLoadingTime: number;
    readonly activateCallTime: number;
    readonly activateResolvedTime: number;
    readonly activationReason: ExtensionActivationReason;
    constructor(codeLoadingTime: number, activateCallTime: number, activateResolvedTime: number, activationReason: ExtensionActivationReason);
}
declare class ExtensionPointContribution<T> {
    readonly description: IExtensionDescription;
    readonly value: T;
    constructor(description: IExtensionDescription, value: T);
}
interface IWillActivateEvent {
    readonly event: string;
    readonly activation: Promise<void>;
}
interface IResponsiveStateChangeEvent {
    extensionHostId: string;
    extensionHostKind: ExtensionHostKind;
    isResponsive: boolean;
}
declare const enum ActivationKind {
    Normal = 0,
    Immediate = 1
}
declare const IExtensionService: ServiceIdentifier<IExtensionService>;
interface IExtensionService {
    readonly _serviceBrand: undefined;
    /**
     * An event emitted when extensions are registered after their extension points got handled.
     *
     * This event will also fire on startup to signal the installed extensions.
     *
     * @returns the extensions that got registered
     */
    onDidRegisterExtensions: Event$1<void>;
    /**
     * @event
     * Fired when extensions status changes.
     * The event contains the ids of the extensions that have changed.
     */
    onDidChangeExtensionsStatus: Event$1<ExtensionIdentifier[]>;
    /**
     * Fired when the available extensions change (i.e. when extensions are added or removed).
     */
    onDidChangeExtensions: Event$1<{
        readonly added: readonly IExtensionDescription[];
        readonly removed: readonly IExtensionDescription[];
    }>;
    /**
     * All registered extensions.
     * - List will be empty initially during workbench startup and will be filled with extensions as they are registered
     * - Listen to `onDidChangeExtensions` event for any changes to the extensions list. It will change as extensions get registered or de-reigstered.
     * - Listen to `onDidRegisterExtensions` event or wait for `whenInstalledExtensionsRegistered` promise to get the initial list of registered extensions.
     */
    readonly extensions: readonly IExtensionDescription[];
    /**
     * An event that is fired when activation happens.
     */
    onWillActivateByEvent: Event$1<IWillActivateEvent>;
    /**
     * An event that is fired when an extension host changes its
     * responsive-state.
     */
    onDidChangeResponsiveChange: Event$1<IResponsiveStateChangeEvent>;
    /**
     * Send an activation event and activate interested extensions.
     *
     * This will wait for the normal startup of the extension host(s).
     *
     * In extraordinary circumstances, if the activation event needs to activate
     * one or more extensions before the normal startup is finished, then you can use
     * `ActivationKind.Immediate`. Please do not use this flag unless really necessary
     * and you understand all consequences.
     */
    activateByEvent(activationEvent: string, activationKind?: ActivationKind): Promise<void>;
    /**
     * Determine if `activateByEvent(activationEvent)` has resolved already.
     *
     * i.e. the activation event is finished and all interested extensions are already active.
     */
    activationEventIsDone(activationEvent: string): boolean;
    /**
     * An promise that resolves when the installed extensions are registered after
     * their extension points got handled.
     */
    whenInstalledExtensionsRegistered(): Promise<boolean>;
    /**
     * Return a specific extension
     * @param id An extension id
     */
    getExtension(id: string): Promise<IExtensionDescription | undefined>;
    /**
     * Returns `true` if the given extension can be added. Otherwise `false`.
     * @param extension An extension
     */
    canAddExtension(extension: IExtensionDescription): boolean;
    /**
     * Returns `true` if the given extension can be removed. Otherwise `false`.
     * @param extension An extension
     */
    canRemoveExtension(extension: IExtensionDescription): boolean;
    /**
     * Read all contributions to an extension point.
     */
    readExtensionPointContributions<T extends IExtensionContributions[keyof IExtensionContributions]>(extPoint: IExtensionPoint<T>): Promise<ExtensionPointContribution<T>[]>;
    /**
     * Get information about extensions status.
     */
    getExtensionsStatus(): {
        [id: string]: IExtensionsStatus;
    };
    /**
     * Return the inspect port or `0` for a certain extension host.
     * `0` means inspection is not possible.
     */
    getInspectPort(extensionHostId: string, tryEnableInspector: boolean): Promise<number>;
    /**
     * Return the inspect ports (if inspection is possible) for extension hosts of kind `extensionHostKind`.
     */
    getInspectPorts(extensionHostKind: ExtensionHostKind, tryEnableInspector: boolean): Promise<number[]>;
    /**
     * Stops the extension hosts.
     */
    stopExtensionHosts(): void;
    /**
     * Restarts the extension host.
     */
    restartExtensionHost(): Promise<void>;
    /**
     * Starts the extension hosts.
     */
    startExtensionHosts(): Promise<void>;
    /**
     * Modify the environment of the remote extension host
     * @param env New properties for the remote extension host
     */
    setRemoteEnvironment(env: {
        [key: string]: string | null;
    }): Promise<void>;
}

interface IViewSize {
    readonly width: number;
    readonly height: number;
}
/**
 * The interface to implement for views within a {@link GridView}.
 */
interface IView$1 {
    /**
     * The DOM element for this view.
     */
    readonly element: HTMLElement;
    /**
     * A minimum width for this view.
     *
     * @remarks If none, set it to `0`.
     */
    readonly minimumWidth: number;
    /**
     * A minimum width for this view.
     *
     * @remarks If none, set it to `Number.POSITIVE_INFINITY`.
     */
    readonly maximumWidth: number;
    /**
     * A minimum height for this view.
     *
     * @remarks If none, set it to `0`.
     */
    readonly minimumHeight: number;
    /**
     * A minimum height for this view.
     *
     * @remarks If none, set it to `Number.POSITIVE_INFINITY`.
     */
    readonly maximumHeight: number;
    /**
     * The priority of the view when the {@link GridView} layout algorithm
     * runs. Views with higher priority will be resized first.
     *
     * @remarks Only used when `proportionalLayout` is false.
     */
    readonly priority?: LayoutPriority;
    /**
     * If the {@link GridView} supports proportional layout,
     * this property allows for finer control over the proportional layout algorithm, per view.
     *
     * @defaultValue `true`
     */
    readonly proportionalLayout?: boolean;
    /**
     * Whether the view will snap whenever the user reaches its minimum size or
     * attempts to grow it beyond the minimum size.
     *
     * @defaultValue `false`
     */
    readonly snap?: boolean;
    /**
     * View instances are supposed to fire this event whenever any of the constraint
     * properties have changed:
     *
     * - {@link IView.minimumWidth}
     * - {@link IView.maximumWidth}
     * - {@link IView.minimumHeight}
     * - {@link IView.maximumHeight}
     * - {@link IView.priority}
     * - {@link IView.snap}
     *
     * The {@link GridView} will relayout whenever that happens. The event can
     * optionally emit the view's preferred size for that relayout.
     */
    readonly onDidChange: Event$1<IViewSize | undefined>;
    /**
     * This will be called by the {@link GridView} during layout. A view meant to
     * pass along the layout information down to its descendants.
     */
    layout(width: number, height: number, top: number, left: number): void;
    /**
     * This will be called by the {@link GridView} whenever this view is made
     * visible or hidden.
     *
     * @param visible Whether the view becomes visible.
     */
    setVisible?(visible: boolean): void;
    /**
     * This will be called by the {@link GridView} whenever this view is on
     * an edge of the grid and the grid's
     * {@link GridView.boundarySashes boundary sashes} change.
     */
    setBoundarySashes?(sashes: IBoundarySashes): void;
}

declare const enum Direction {
    Up = 0,
    Down = 1,
    Left = 2,
    Right = 3
}
/**
 * The interface to implement for views within a {@link Grid}.
 */
interface IView extends IView$1 {
    /**
     * The preferred width for when the user double clicks a sash
     * adjacent to this view.
     */
    readonly preferredWidth?: number;
    /**
     * The preferred height for when the user double clicks a sash
     * adjacent to this view.
     */
    readonly preferredHeight?: number;
}
interface ISerializableView extends IView {
    toJSON(): object;
}

interface IPartOptions {
    readonly hasTitle?: boolean;
    readonly borderWidth?: () => number;
}
interface ILayoutContentResult {
    readonly titleSize: IDimension;
    readonly contentSize: IDimension;
}
/**
 * Parts are layed out in the workbench and have their own layout that
 * arranges an optional title and mandatory content area to show content.
 */
declare abstract class Part extends Component implements ISerializableView {
    private options;
    protected readonly layoutService: IWorkbenchLayoutService;
    private _dimension;
    get dimension(): Dimension | undefined;
    protected _onDidVisibilityChange: Emitter<boolean>;
    readonly onDidVisibilityChange: Event$1<boolean>;
    private parent;
    private titleArea;
    private contentArea;
    private partLayout;
    constructor(id: string, options: IPartOptions, themeService: IThemeService, storageService: IStorageService, layoutService: IWorkbenchLayoutService);
    protected onThemeChange(theme: IColorTheme): void;
    updateStyles(): void;
    /**
     * Note: Clients should not call this method, the workbench calls this
     * method. Calling it otherwise may result in unexpected behavior.
     *
     * Called to create title and content area of the part.
     */
    create(parent: HTMLElement, options?: object): void;
    /**
     * Returns the overall part container.
     */
    getContainer(): HTMLElement | undefined;
    /**
     * Subclasses override to provide a title area implementation.
     */
    protected createTitleArea(parent: HTMLElement, options?: object): HTMLElement | undefined;
    /**
     * Returns the title area container.
     */
    protected getTitleArea(): HTMLElement | undefined;
    /**
     * Subclasses override to provide a content area implementation.
     */
    protected createContentArea(parent: HTMLElement, options?: object): HTMLElement | undefined;
    /**
     * Returns the content area container.
     */
    protected getContentArea(): HTMLElement | undefined;
    /**
     * Layout title and content area in the given dimension.
     */
    protected layoutContents(width: number, height: number): ILayoutContentResult;
    protected _onDidChange: Emitter<IViewSize | undefined>;
    get onDidChange(): Event$1<IViewSize | undefined>;
    element: HTMLElement;
    abstract minimumWidth: number;
    abstract maximumWidth: number;
    abstract minimumHeight: number;
    abstract maximumHeight: number;
    layout(width: number, height: number, _top: number, _left: number): void;
    setVisible(visible: boolean): void;
    abstract toJSON(): object;
}

declare const enum Parts {
    TITLEBAR_PART = "workbench.parts.titlebar",
    BANNER_PART = "workbench.parts.banner",
    ACTIVITYBAR_PART = "workbench.parts.activitybar",
    SIDEBAR_PART = "workbench.parts.sidebar",
    PANEL_PART = "workbench.parts.panel",
    AUXILIARYBAR_PART = "workbench.parts.auxiliarybar",
    EDITOR_PART = "workbench.parts.editor",
    STATUSBAR_PART = "workbench.parts.statusbar"
}
declare const enum Position {
    LEFT = 0,
    RIGHT = 1,
    BOTTOM = 2
}
type PanelAlignment = 'left' | 'center' | 'right' | 'justify';
declare const IWorkbenchLayoutService: ServiceIdentifier<IWorkbenchLayoutService>;
interface IWorkbenchLayoutService extends ILayoutService {
    readonly _serviceBrand: undefined;
    /**
     * Emits when the zen mode is enabled or disabled.
     */
    readonly onDidChangeZenMode: Event$1<boolean>;
    /**
     * Emits when fullscreen is enabled or disabled.
     */
    readonly onDidChangeFullscreen: Event$1<boolean>;
    /**
     * Emits when the window is maximized or unmaximized.
     */
    readonly onDidChangeWindowMaximized: Event$1<boolean>;
    /**
     * Emits when centered layout is enabled or disabled.
     */
    readonly onDidChangeCenteredLayout: Event$1<boolean>;
    readonly onDidChangePanelPosition: Event$1<string>;
    /**
     * Emit when panel alignment changes.
     */
    readonly onDidChangePanelAlignment: Event$1<PanelAlignment>;
    /**
     * Emit when part visibility changes
     */
    readonly onDidChangePartVisibility: Event$1<void>;
    /**
     * Emit when notifications (toasts or center) visibility changes.
     */
    readonly onDidChangeNotificationsVisibility: Event$1<boolean>;
    /**
     * True if a default layout with default editors was applied at startup
     */
    readonly openedDefaultEditors: boolean;
    /**
     * Run a layout of the workbench.
     */
    layout(): void;
    /**
     * Asks the part service if all parts have been fully restored. For editor part
     * this means that the contents of visible editors have loaded.
     */
    isRestored(): boolean;
    /**
     * A promise for to await the `isRestored()` condition to be `true`.
     */
    readonly whenRestored: Promise<void>;
    /**
     * Returns whether the given part has the keyboard focus or not.
     */
    hasFocus(part: Parts): boolean;
    /**
     * Focuses the part. If the part is not visible this is a noop.
     */
    focusPart(part: Parts): void;
    /**
     * Returns the parts HTML element, if there is one.
     */
    getContainer(part: Parts): HTMLElement | undefined;
    /**
     * Returns if the part is visible.
     */
    isVisible(part: Parts): boolean;
    /**
     * Returns if the part is visible.
     */
    getDimension(part: Parts): Dimension | undefined;
    /**
     * Set part hidden or not
     */
    setPartHidden(hidden: boolean, part: Exclude<Parts, Parts.STATUSBAR_PART | Parts.TITLEBAR_PART>): void;
    /**
     * Maximizes the panel height if the panel is not already maximized.
     * Shrinks the panel to the default starting size if the panel is maximized.
     */
    toggleMaximizedPanel(): void;
    /**
     * Returns true if the window has a border.
     */
    hasWindowBorder(): boolean;
    /**
     * Returns the window border width.
     */
    getWindowBorderWidth(): number;
    /**
     * Returns the window border radius if any.
     */
    getWindowBorderRadius(): string | undefined;
    /**
     * Returns true if the panel is maximized.
     */
    isPanelMaximized(): boolean;
    /**
     * Gets the current side bar position. Note that the sidebar can be hidden too.
     */
    getSideBarPosition(): Position;
    /**
     * Toggles the menu bar visibility.
     */
    toggleMenuBar(): void;
    getPanelPosition(): Position;
    /**
     * Sets the panel position.
     */
    setPanelPosition(position: Position): void;
    /**
     * Gets the panel alignement.
     */
    getPanelAlignment(): PanelAlignment;
    /**
     * Sets the panel alignment.
     */
    setPanelAlignment(alignment: PanelAlignment): void;
    /**
     * Gets the maximum possible size for editor.
     */
    getMaximumEditorDimensions(): Dimension;
    /**
     * Toggles the workbench in and out of zen mode - parts get hidden and window goes fullscreen.
     */
    toggleZenMode(): void;
    /**
     * Returns whether the centered editor layout is active.
     */
    isEditorLayoutCentered(): boolean;
    /**
     * Sets the workbench in and out of centered editor layout.
     */
    centerEditorLayout(active: boolean): void;
    /**
     * Resizes currently focused part on main access
     */
    resizePart(part: Parts, sizeChangeWidth: number, sizeChangeHeight: number): void;
    /**
     * Register a part to participate in the layout.
     */
    registerPart(part: Part): void;
    /**
     * Returns whether the window is maximized.
     */
    isWindowMaximized(): boolean;
    /**
     * Updates the maximized state of the window.
     */
    updateWindowMaximizedState(maximized: boolean): void;
    /**
     * Returns the next visible view part in a given direction
     */
    getVisibleNeighborPart(part: Parts, direction: Direction): Parts | undefined;
}

interface IViewletViewOptions extends IViewPaneOptions {
    readonly fromExtensionId?: ExtensionIdentifier;
}

interface IViewPaneContainerOptions extends IPaneViewOptions {
    mergeViewWithContainerWhenSingleView: boolean;
}
declare class ViewPaneContainer extends Component implements IViewPaneContainer {
    private options;
    protected instantiationService: IInstantiationService;
    protected configurationService: IConfigurationService;
    protected layoutService: IWorkbenchLayoutService;
    protected contextMenuService: IContextMenuService;
    protected telemetryService: ITelemetryService;
    protected extensionService: IExtensionService;
    protected storageService: IStorageService;
    protected contextService: IWorkspaceContextService;
    protected viewDescriptorService: IViewDescriptorService;
    readonly viewContainer: ViewContainer;
    private lastFocusedPane;
    private lastMergedCollapsedPane;
    private paneItems;
    private paneview?;
    private visible;
    private areExtensionsReady;
    private didLayout;
    private dimension;
    private _boundarySashes;
    private readonly visibleViewsCountFromCache;
    private readonly visibleViewsStorageId;
    protected readonly viewContainerModel: IViewContainerModel;
    private viewDisposables;
    private readonly _onTitleAreaUpdate;
    readonly onTitleAreaUpdate: Event$1<void>;
    private readonly _onDidChangeVisibility;
    readonly onDidChangeVisibility: Event$1<boolean>;
    private readonly _onDidAddViews;
    readonly onDidAddViews: Event$1<IView$2[]>;
    private readonly _onDidRemoveViews;
    readonly onDidRemoveViews: Event$1<IView$2[]>;
    private readonly _onDidChangeViewVisibility;
    readonly onDidChangeViewVisibility: Event$1<IView$2>;
    private readonly _onDidFocusView;
    readonly onDidFocusView: Event$1<IView$2>;
    private readonly _onDidBlurView;
    readonly onDidBlurView: Event$1<IView$2>;
    get onDidSashChange(): Event$1<number>;
    get panes(): ViewPane[];
    get views(): IView$2[];
    get length(): number;
    private _menuActions?;
    get menuActions(): CompositeMenuActions | undefined;
    constructor(id: string, options: IViewPaneContainerOptions, instantiationService: IInstantiationService, configurationService: IConfigurationService, layoutService: IWorkbenchLayoutService, contextMenuService: IContextMenuService, telemetryService: ITelemetryService, extensionService: IExtensionService, themeService: IThemeService, storageService: IStorageService, contextService: IWorkspaceContextService, viewDescriptorService: IViewDescriptorService);
    create(parent: HTMLElement): void;
    getTitle(): string;
    private showContextMenu;
    getActionsContext(): unknown;
    getActionViewItem(action: IAction): IActionViewItem | undefined;
    focus(): void;
    private get orientation();
    layout(dimension: Dimension): void;
    setBoundarySashes(sashes: IBoundarySashes): void;
    getOptimalWidth(): number;
    addPanes(panes: {
        pane: ViewPane;
        size: number;
        index?: number;
    }[]): void;
    setVisible(visible: boolean): void;
    isVisible(): boolean;
    protected updateTitleArea(): void;
    protected createView(viewDescriptor: IViewDescriptor, options: IViewletViewOptions): ViewPane;
    getView(id: string): ViewPane | undefined;
    private saveViewSizes;
    private restoreViewSizes;
    private computeInitialSizes;
    protected saveState(): void;
    private onContextMenu;
    openView(id: string, focus?: boolean): IView$2 | undefined;
    protected onDidAddViewDescriptors(added: IAddedViewDescriptorRef[]): ViewPane[];
    private onDidRemoveViewDescriptors;
    toggleViewVisibility(viewId: string): void;
    private addPane;
    removePanes(panes: ViewPane[]): void;
    private removePane;
    movePane(from: ViewPane, to: ViewPane): void;
    resizePane(pane: ViewPane, size: number): void;
    getPaneSize(pane: ViewPane): number;
    private updateViewHeaders;
    isViewMergedWithContainer(): boolean;
    private onDidScrollPane;
    private onDidSashReset;
    dispose(): void;
}

declare abstract class PaneComposite extends Composite implements IPaneComposite {
    protected storageService: IStorageService;
    protected instantiationService: IInstantiationService;
    protected contextMenuService: IContextMenuService;
    protected extensionService: IExtensionService;
    protected contextService: IWorkspaceContextService;
    private viewPaneContainer?;
    constructor(id: string, telemetryService: ITelemetryService, storageService: IStorageService, instantiationService: IInstantiationService, themeService: IThemeService, contextMenuService: IContextMenuService, extensionService: IExtensionService, contextService: IWorkspaceContextService);
    create(parent: HTMLElement): void;
    setVisible(visible: boolean): void;
    layout(dimension: Dimension): void;
    setBoundarySashes(sashes: IBoundarySashes): void;
    getOptimalWidth(): number;
    openView<T extends IView$2>(id: string, focus?: boolean): T | undefined;
    getViewPaneContainer(): ViewPaneContainer | undefined;
    getActionsContext(): unknown;
    getContextMenuActions(): readonly IAction[];
    getMenuIds(): MenuId[];
    getActions(): readonly IAction[];
    getSecondaryActions(): readonly IAction[];
    getActionViewItem(action: IAction): IActionViewItem | undefined;
    getTitle(): string;
    saveState(): void;
    focus(): void;
    protected abstract createViewPaneContainer(parent: HTMLElement): ViewPaneContainer;
}
/**
 * A Pane Composite descriptor is a lightweight descriptor of a Pane Composite in the workbench.
 */
declare class PaneCompositeDescriptor extends CompositeDescriptor<PaneComposite> {
    readonly iconUrl?: URI | undefined;
    static create<Services extends BrandedService[]>(ctor: {
        new (...services: Services): PaneComposite;
    }, id: string, name: string, cssClass?: string, order?: number, requestedIndex?: number, iconUrl?: URI): PaneCompositeDescriptor;
    private constructor();
}

interface IBadge {
    getDescription(): string;
}

declare const IPaneCompositePartService: ServiceIdentifier<IPaneCompositePartService>;
interface IPaneCompositePartService {
    readonly _serviceBrand: undefined;
    readonly onDidPaneCompositeOpen: Event$1<{
        composite: IPaneComposite;
        viewContainerLocation: ViewContainerLocation;
    }>;
    readonly onDidPaneCompositeClose: Event$1<{
        composite: IPaneComposite;
        viewContainerLocation: ViewContainerLocation;
    }>;
    /**
     * Opens a viewlet with the given identifier and pass keyboard focus to it if specified.
     */
    openPaneComposite(id: string | undefined, viewContainerLocation: ViewContainerLocation, focus?: boolean): Promise<IPaneComposite | undefined>;
    /**
     * Returns the current active viewlet if any.
     */
    getActivePaneComposite(viewContainerLocation: ViewContainerLocation): IPaneComposite | undefined;
    /**
     * Returns the viewlet by id.
     */
    getPaneComposite(id: string, viewContainerLocation: ViewContainerLocation): PaneCompositeDescriptor | undefined;
    /**
     * Returns all enabled viewlets
     */
    getPaneComposites(viewContainerLocation: ViewContainerLocation): PaneCompositeDescriptor[];
    /**
     * Returns id of pinned view containers following the visual order.
     */
    getPinnedPaneCompositeIds(viewContainerLocation: ViewContainerLocation): string[];
    /**
     * Returns id of visible view containers following the visual order.
     */
    getVisiblePaneCompositeIds(viewContainerLocation: ViewContainerLocation): string[];
    /**
     * Returns the progress indicator for the side bar.
     */
    getProgressIndicator(id: string, viewContainerLocation: ViewContainerLocation): IProgressIndicator | undefined;
    /**
     * Hide the active viewlet.
     */
    hideActivePaneComposite(viewContainerLocation: ViewContainerLocation): void;
    /**
     * Return the last active viewlet id.
     */
    getLastActivePaneCompositeId(viewContainerLocation: ViewContainerLocation): string;
    /**
     * Show an activity in a viewlet.
     */
    showActivity(id: string, viewContainerLocation: ViewContainerLocation, badge: IBadge, clazz?: string, priority?: number): IDisposable;
}

interface ParsedPath {
    root: string;
    dir: string;
    base: string;
    ext: string;
    name: string;
}
interface IPath {
    normalize(path: string): string;
    isAbsolute(path: string): boolean;
    join(...paths: string[]): string;
    resolve(...pathSegments: string[]): string;
    relative(from: string, to: string): string;
    dirname(path: string): string;
    basename(path: string, ext?: string): string;
    extname(path: string): string;
    format(pathObject: ParsedPath): string;
    parse(path: string): ParsedPath;
    toNamespacedPath(path: string): string;
    sep: '\\' | '/';
    delimiter: string;
    win32: IPath | null;
    posix: IPath | null;
}

declare const IPathService: ServiceIdentifier<IPathService>;
/**
 * Provides access to path related properties that will match the
 * environment. If the environment is connected to a remote, the
 * path properties will match that of the remotes operating system.
 */
interface IPathService {
    readonly _serviceBrand: undefined;
    /**
     * The correct path library to use for the target environment. If
     * the environment is connected to a remote, this will be the
     * path library of the remote file system. Otherwise it will be
     * the local file system's path library depending on the OS.
     */
    readonly path: Promise<IPath>;
    /**
     * Determines the best default URI scheme for the current workspace.
     * It uses information about whether we're running remote, in browser,
     * or native combined with information about the current workspace to
     * find the best default scheme.
     */
    readonly defaultUriScheme: string;
    /**
     * Converts the given path to a file URI to use for the target
     * environment. If the environment is connected to a remote, it
     * will use the path separators according to the remote file
     * system. Otherwise it will use the local file system's path
     * separators.
     */
    fileURI(path: string): Promise<URI>;
    /**
     * Resolves the user-home directory for the target environment.
     * If the envrionment is connected to a remote, this will be the
     * remote's user home directory, otherwise the local one unless
     * `preferLocal` is set to `true`.
     */
    userHome(options: {
        preferLocal: true;
    }): URI;
    userHome(options?: {
        preferLocal: boolean;
    }): Promise<URI>;
    /**
     * Figures out if the provided resource has a valid file name
     * for the operating system the file is saved to.
     *
     * Note: this currently only supports `file` and `vscode-file`
     * protocols where we know the limits of the file systems behind
     * these OS. Other remotes are not supported and this method
     * will always return `true` for them.
     */
    hasValidBasename(resource: URI, basename?: string): Promise<boolean>;
    hasValidBasename(resource: URI, os: OperatingSystem, basename?: string): boolean;
    /**
     * @deprecated use `userHome` instead.
     */
    readonly resolvedUserHome: URI | undefined;
}

declare const IExtensionResourceLoaderService: ServiceIdentifier<IExtensionResourceLoaderService>;
/**
 * A service useful for reading resources from within extensions.
 */
interface IExtensionResourceLoaderService {
    readonly _serviceBrand: undefined;
    /**
     * Read a certain resource within an extension.
     */
    readExtensionResource(uri: URI): Promise<string>;
    /**
     * Returns whether the gallery provides extension resources.
     */
    readonly supportsExtensionGalleryResources: boolean;
    /**
     * Computes the URL of a extension gallery resource. Returns `undefined` if gallery does not provide extension resources.
     */
    getExtensionGalleryResourceURL(galleryExtension: {
        publisher: string;
        name: string;
        version: string;
    }, path?: string): URI | undefined;
}

declare class Snippet {
    readonly isFileTemplate: boolean;
    readonly scopes: string[];
    readonly name: string;
    readonly prefix: string;
    readonly description: string;
    readonly body: string;
    readonly source: string;
    readonly snippetSource: SnippetSource;
    readonly snippetIdentifier: string;
    readonly extensionId?: ExtensionIdentifier | undefined;
    private readonly _bodyInsights;
    readonly prefixLow: string;
    constructor(isFileTemplate: boolean, scopes: string[], name: string, prefix: string, description: string, body: string, source: string, snippetSource: SnippetSource, snippetIdentifier: string, extensionId?: ExtensionIdentifier | undefined);
    get codeSnippet(): string;
    get isBogous(): boolean;
    get isTrivial(): boolean;
    get needsClipboard(): boolean;
    get usesSelection(): boolean;
}
declare const enum SnippetSource {
    User = 1,
    Workspace = 2,
    Extension = 3
}
declare class SnippetFile {
    readonly source: SnippetSource;
    readonly location: URI;
    defaultScopes: string[] | undefined;
    private readonly _extension;
    private readonly _fileService;
    private readonly _extensionResourceLoaderService;
    readonly data: Snippet[];
    readonly isGlobalSnippets: boolean;
    readonly isUserSnippets: boolean;
    private _loadPromise?;
    constructor(source: SnippetSource, location: URI, defaultScopes: string[] | undefined, _extension: IExtensionDescription | undefined, _fileService: IFileService, _extensionResourceLoaderService: IExtensionResourceLoaderService);
    select(selector: string, bucket: Snippet[]): void;
    private _filepathSelect;
    private _scopeSelect;
    private _load;
    load(): Promise<this>;
    reset(): void;
    private _parseSnippet;
}

interface ISnippetGetOptions {
    includeDisabledSnippets?: boolean;
    includeNoPrefixSnippets?: boolean;
    noRecencySort?: boolean;
    fileTemplateSnippets?: boolean;
}
declare const ISnippetsService: ServiceIdentifier<ISnippetsService>;
interface ISnippetsService {
    readonly _serviceBrand: undefined;
    getSnippetFiles(): Promise<Iterable<SnippetFile>>;
    isEnabled(snippet: Snippet): boolean;
    updateEnablement(snippet: Snippet, enabled: boolean): void;
    updateUsageTimestamp(snippet: Snippet): void;
    getSnippets(languageId: string | undefined, opt?: ISnippetGetOptions): Promise<Snippet[]>;
    getSnippetsSync(languageId: string, opt?: ISnippetGetOptions): Snippet[];
}

declare const IAudioCueService: ServiceIdentifier<IAudioCueService>;
interface IAudioCueService {
    readonly _serviceBrand: undefined;
    playAudioCue(cue: AudioCue, allowManyInParallel?: boolean): Promise<void>;
    playAudioCues(cues: AudioCue[]): Promise<void>;
    isEnabled(cue: AudioCue): boolean;
    onEnabledChanged(cue: AudioCue): Event$1<void>;
    playSound(cue: Sound, allowManyInParallel?: boolean): Promise<void>;
}
/**
 * Corresponds to the audio files in ./media.
*/
declare class Sound {
    readonly fileName: string;
    private static register;
    static readonly error: Sound;
    static readonly warning: Sound;
    static readonly foldedArea: Sound;
    static readonly break: Sound;
    static readonly quickFixes: Sound;
    static readonly taskCompleted: Sound;
    static readonly taskFailed: Sound;
    static readonly terminalBell: Sound;
    static readonly diffLineInserted: Sound;
    static readonly diffLineDeleted: Sound;
    static readonly diffLineModified: Sound;
    private constructor();
}
declare class AudioCue {
    readonly sound: Sound;
    readonly name: string;
    readonly settingsKey: string;
    private static _audioCues;
    private static register;
    static get allAudioCues(): AudioCue[];
    static readonly error: AudioCue;
    static readonly warning: AudioCue;
    static readonly foldedArea: AudioCue;
    static readonly break: AudioCue;
    static readonly inlineSuggestion: AudioCue;
    static readonly terminalQuickFix: AudioCue;
    static readonly onDebugBreak: AudioCue;
    static readonly noInlayHints: AudioCue;
    static readonly taskCompleted: AudioCue;
    static readonly taskFailed: AudioCue;
    static readonly terminalCommandFailed: AudioCue;
    static readonly terminalBell: AudioCue;
    static readonly notebookCellCompleted: AudioCue;
    static readonly notebookCellFailed: AudioCue;
    static readonly diffLineInserted: AudioCue;
    static readonly diffLineDeleted: AudioCue;
    static readonly diffLineModified: AudioCue;
    private constructor();
}

declare class DebugCompoundRoot {
    private stopped;
    private stopEmitter;
    onDidSessionStop: Event$1<void>;
    sessionStopped(): void;
}

/**
 * Debug URI format
 *
 * a debug URI represents a Source object and the debug session where the Source comes from.
 *
 *       debug:arbitrary_path?session=123e4567-e89b-12d3-a456-426655440000&ref=1016
 *       \___/ \____________/ \__________________________________________/ \______/
 *         |          |                             |                          |
 *      scheme   source.path                    session id            source.reference
 *
 *
 */
declare class Source {
    readonly uri: URI;
    available: boolean;
    raw: DebugProtocol.Source;
    constructor(raw_: DebugProtocol.Source | undefined, sessionId: string, uriIdentityService: IUriIdentityService, logService: ILogService);
    get name(): string;
    get origin(): string | undefined;
    get presentationHint(): "normal" | "emphasize" | "deemphasize" | undefined;
    get reference(): number | undefined;
    get inMemory(): boolean;
    openInEditor(editorService: IEditorService, selection: IRange, preserveFocus?: boolean, sideBySide?: boolean, pinned?: boolean): Promise<IEditorPane | undefined>;
    static getEncodedDebugData(modelUri: URI): {
        name: string;
        path: string;
        sessionId?: string;
        sourceReference?: number;
    };
}

interface ITaskIdentifier {
    type: string;
    [name: string]: any;
}

interface IRawModelUpdate {
    sessionId: string;
    threads: DebugProtocol.Thread[];
    stoppedDetails?: IRawStoppedDetails;
}
interface IRawStoppedDetails {
    reason?: string;
    description?: string;
    threadId?: number;
    text?: string;
    totalFrames?: number;
    allThreadsStopped?: boolean;
    framesErrorMessage?: string;
    hitBreakpointIds?: number[];
}
interface ITreeElement {
    getId(): string;
}
interface IReplElement extends ITreeElement {
    toString(includeSource?: boolean): string;
    readonly sourceData?: IReplElementSource;
}
interface IReplElementSource {
    readonly source: Source;
    readonly lineNumber: number;
    readonly column: number;
}
interface IExpressionContainer extends ITreeElement {
    readonly hasChildren: boolean;
    evaluateLazy(): Promise<void>;
    getChildren(): Promise<IExpression[]>;
    readonly reference?: number;
    readonly memoryReference?: string;
    readonly value: string;
    readonly type?: string;
    valueChanged?: boolean;
    readonly presentationHint?: DebugProtocol.VariablePresentationHint | undefined;
}
interface IExpression extends IExpressionContainer {
    name: string;
}
interface IDebugger {
    readonly type: string;
    createDebugAdapter(session: IDebugSession): Promise<IDebugAdapter>;
    runInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;
    startDebugging(args: IConfig, parentSessionId: string): Promise<boolean>;
    getCustomTelemetryEndpoint(): ITelemetryEndpoint | undefined;
    getInitialConfigurationContent(initialConfigs?: IConfig[]): Promise<string>;
}
interface IDebuggerMetadata {
    label: string;
    type: string;
    strings?: {
        [key in DebuggerString]: string;
    };
    interestedInLanguage(languageId: string): boolean;
}
declare const enum State {
    Inactive = 0,
    Initializing = 1,
    Stopped = 2,
    Running = 3
}
interface AdapterEndEvent {
    error?: Error;
    sessionLengthInSeconds: number;
    emittedStopped: boolean;
}
interface LoadedSourceEvent {
    reason: 'new' | 'changed' | 'removed';
    source: Source;
}
type IDebugSessionReplMode = 'separate' | 'mergeWithParent';
interface IDebugSessionOptions {
    noDebug?: boolean;
    parentSession?: IDebugSession;
    lifecycleManagedByParent?: boolean;
    repl?: IDebugSessionReplMode;
    compoundRoot?: DebugCompoundRoot;
    compact?: boolean;
    startedByUser?: boolean;
    saveBeforeRestart?: boolean;
    suppressDebugToolbar?: boolean;
    suppressDebugStatusbar?: boolean;
    suppressDebugView?: boolean;
}
interface IDataBreakpointInfoResponse {
    dataId: string | null;
    description: string;
    canPersist?: boolean;
    accessTypes?: DebugProtocol.DataBreakpointAccessType[];
}
interface IMemoryInvalidationEvent {
    fromOffset: number;
    toOffset: number;
}
declare const enum MemoryRangeType {
    Valid = 0,
    Unreadable = 1,
    Error = 2
}
interface IMemoryRange {
    type: MemoryRangeType;
    offset: number;
    length: number;
}
interface IValidMemoryRange extends IMemoryRange {
    type: MemoryRangeType.Valid;
    offset: number;
    length: number;
    data: VSBuffer;
}
interface IUnreadableMemoryRange extends IMemoryRange {
    type: MemoryRangeType.Unreadable;
}
interface IErrorMemoryRange extends IMemoryRange {
    type: MemoryRangeType.Error;
    error: string;
}
/**
 * Union type of memory that can be returned from read(). Since a read request
 * could encompass multiple previously-read ranges, multiple of these types
 * are possible to return.
 */
type MemoryRange = IValidMemoryRange | IUnreadableMemoryRange | IErrorMemoryRange;
/**
 * An IMemoryRegion corresponds to a contiguous range of memory referred to
 * by a DAP `memoryReference`.
 */
interface IMemoryRegion extends IDisposable {
    /**
     * Event that fires when memory changes. Can be a result of memory events or
     * `write` requests.
     */
    readonly onDidInvalidate: Event$1<IMemoryInvalidationEvent>;
    /**
     * Whether writes are supported on this memory region.
     */
    readonly writable: boolean;
    /**
     * Requests memory ranges from the debug adapter. It returns a list of memory
     * ranges that overlap (but may exceed!) the given offset. Use the `offset`
     * and `length` of each range for display.
     */
    read(fromOffset: number, toOffset: number): Promise<MemoryRange[]>;
    /**
     * Writes memory to the debug adapter at the given offset.
     */
    write(offset: number, data: VSBuffer): Promise<number>;
}
/** Data that can be inserted in {@link IDebugSession.appendToRepl} */
interface INewReplElementData {
    /**
     * Output string to display
     */
    output: string;
    /**
     * Expression data to display. Will result in the item being expandable in
     * the REPL. Its value will be used if {@link output} is not provided.
     */
    expression?: IExpression;
    /**
     * Output severity.
     */
    sev: Severity$1;
    /**
     * Originating location.
     */
    source?: IReplElementSource;
}
interface IDebugSession extends ITreeElement {
    readonly configuration: IConfig;
    readonly unresolvedConfiguration: IConfig | undefined;
    readonly state: State;
    readonly root: IWorkspaceFolder | undefined;
    readonly parentSession: IDebugSession | undefined;
    readonly subId: string | undefined;
    readonly compact: boolean;
    readonly compoundRoot: DebugCompoundRoot | undefined;
    readonly saveBeforeRestart: boolean;
    readonly name: string;
    readonly autoExpandLazyVariables: boolean;
    readonly suppressDebugToolbar: boolean;
    readonly suppressDebugStatusbar: boolean;
    readonly suppressDebugView: boolean;
    readonly lifecycleManagedByParent: boolean;
    setSubId(subId: string | undefined): void;
    getMemory(memoryReference: string): IMemoryRegion;
    setName(name: string): void;
    readonly onDidChangeName: Event$1<string>;
    getLabel(): string;
    getSourceForUri(modelUri: URI): Source | undefined;
    getSource(raw?: DebugProtocol.Source): Source;
    setConfiguration(configuration: {
        resolved: IConfig;
        unresolved: IConfig | undefined;
    }): void;
    rawUpdate(data: IRawModelUpdate): void;
    getThread(threadId: number): IThread | undefined;
    getAllThreads(): IThread[];
    clearThreads(removeThreads: boolean, reference?: number): void;
    getStoppedDetails(): IRawStoppedDetails | undefined;
    getReplElements(): IReplElement[];
    hasSeparateRepl(): boolean;
    removeReplExpressions(): void;
    addReplExpression(stackFrame: IStackFrame | undefined, name: string): Promise<void>;
    appendToRepl(data: INewReplElementData): void;
    readonly onDidEndAdapter: Event$1<AdapterEndEvent | undefined>;
    readonly onDidChangeState: Event$1<void>;
    readonly onDidChangeReplElements: Event$1<void>;
    readonly capabilities: DebugProtocol.Capabilities;
    readonly onDidLoadedSource: Event$1<LoadedSourceEvent>;
    readonly onDidCustomEvent: Event$1<DebugProtocol.Event>;
    readonly onDidProgressStart: Event$1<DebugProtocol.ProgressStartEvent>;
    readonly onDidProgressUpdate: Event$1<DebugProtocol.ProgressUpdateEvent>;
    readonly onDidProgressEnd: Event$1<DebugProtocol.ProgressEndEvent>;
    readonly onDidInvalidateMemory: Event$1<DebugProtocol.MemoryEvent>;
    initialize(dbgr: IDebugger): Promise<void>;
    launchOrAttach(config: IConfig): Promise<void>;
    restart(): Promise<void>;
    terminate(restart?: boolean): Promise<void>;
    disconnect(restart?: boolean, suspend?: boolean): Promise<void>;
    sendBreakpoints(modelUri: URI, bpts: IBreakpoint[], sourceModified: boolean): Promise<void>;
    sendFunctionBreakpoints(fbps: IFunctionBreakpoint[]): Promise<void>;
    dataBreakpointInfo(name: string, variablesReference?: number): Promise<IDataBreakpointInfoResponse | undefined>;
    sendDataBreakpoints(dbps: IDataBreakpoint[]): Promise<void>;
    sendInstructionBreakpoints(dbps: IInstructionBreakpoint[]): Promise<void>;
    sendExceptionBreakpoints(exbpts: IExceptionBreakpoint[]): Promise<void>;
    breakpointsLocations(uri: URI, lineNumber: number): Promise<IPosition[]>;
    getDebugProtocolBreakpoint(breakpointId: string): DebugProtocol.Breakpoint | undefined;
    stackTrace(threadId: number, startFrame: number, levels: number, token: CancellationToken): Promise<DebugProtocol.StackTraceResponse | undefined>;
    exceptionInfo(threadId: number): Promise<IExceptionInfo | undefined>;
    scopes(frameId: number, threadId: number): Promise<DebugProtocol.ScopesResponse | undefined>;
    variables(variablesReference: number, threadId: number | undefined, filter: 'indexed' | 'named' | undefined, start: number | undefined, count: number | undefined): Promise<DebugProtocol.VariablesResponse | undefined>;
    evaluate(expression: string, frameId?: number, context?: string): Promise<DebugProtocol.EvaluateResponse | undefined>;
    customRequest(request: string, args: any): Promise<DebugProtocol.Response | undefined>;
    cancel(progressId: string): Promise<DebugProtocol.CancelResponse | undefined>;
    disassemble(memoryReference: string, offset: number, instructionOffset: number, instructionCount: number): Promise<DebugProtocol.DisassembledInstruction[] | undefined>;
    readMemory(memoryReference: string, offset: number, count: number): Promise<DebugProtocol.ReadMemoryResponse | undefined>;
    writeMemory(memoryReference: string, offset: number, data: string, allowPartial?: boolean): Promise<DebugProtocol.WriteMemoryResponse | undefined>;
    restartFrame(frameId: number, threadId: number): Promise<void>;
    next(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepIn(threadId: number, targetId?: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepInTargets(frameId: number): Promise<DebugProtocol.StepInTarget[] | undefined>;
    stepOut(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    stepBack(threadId: number, granularity?: DebugProtocol.SteppingGranularity): Promise<void>;
    continue(threadId: number): Promise<void>;
    reverseContinue(threadId: number): Promise<void>;
    pause(threadId: number): Promise<void>;
    terminateThreads(threadIds: number[]): Promise<void>;
    completions(frameId: number | undefined, threadId: number, text: string, position: Position$1, overwriteBefore: number, token: CancellationToken): Promise<DebugProtocol.CompletionsResponse | undefined>;
    setVariable(variablesReference: number | undefined, name: string, value: string): Promise<DebugProtocol.SetVariableResponse | undefined>;
    setExpression(frameId: number, expression: string, value: string): Promise<DebugProtocol.SetExpressionResponse | undefined>;
    loadSource(resource: URI): Promise<DebugProtocol.SourceResponse | undefined>;
    getLoadedSources(): Promise<Source[]>;
    gotoTargets(source: DebugProtocol.Source, line: number, column?: number): Promise<DebugProtocol.GotoTargetsResponse | undefined>;
    goto(threadId: number, targetId: number): Promise<DebugProtocol.GotoResponse | undefined>;
}
interface IThread extends ITreeElement {
    /**
     * Process the thread belongs to
     */
    readonly session: IDebugSession;
    /**
     * Id of the thread generated by the debug adapter backend.
     */
    readonly threadId: number;
    /**
     * Name of the thread.
     */
    readonly name: string;
    /**
     * Information about the current thread stop event. Undefined if thread is not stopped.
     */
    readonly stoppedDetails: IRawStoppedDetails | undefined;
    /**
     * Information about the exception if an 'exception' stopped event raised and DA supports the 'exceptionInfo' request, otherwise undefined.
     */
    readonly exceptionInfo: Promise<IExceptionInfo | undefined>;
    readonly stateLabel: string;
    /**
     * Gets the callstack if it has already been received from the debug
     * adapter.
     */
    getCallStack(): ReadonlyArray<IStackFrame>;
    /**
     * Gets the top stack frame that is not hidden if the callstack has already been received from the debug adapter
     */
    getTopStackFrame(): IStackFrame | undefined;
    /**
     * Invalidates the callstack cache
     */
    clearCallStack(): void;
    /**
     * Indicates whether this thread is stopped. The callstack for stopped
     * threads can be retrieved from the debug adapter.
     */
    readonly stopped: boolean;
    next(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;
    stepIn(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;
    stepOut(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;
    stepBack(granularity?: DebugProtocol.SteppingGranularity): Promise<any>;
    continue(): Promise<any>;
    pause(): Promise<any>;
    terminate(): Promise<any>;
    reverseContinue(): Promise<any>;
}
interface IScope extends IExpressionContainer {
    readonly name: string;
    readonly expensive: boolean;
    readonly range?: IRange;
    readonly hasChildren: boolean;
}
interface IStackFrame extends ITreeElement {
    readonly thread: IThread;
    readonly name: string;
    readonly presentationHint: string | undefined;
    readonly frameId: number;
    readonly range: IRange;
    readonly source: Source;
    readonly canRestart: boolean;
    readonly instructionPointerReference?: string;
    getScopes(): Promise<IScope[]>;
    getMostSpecificScopes(range: IRange): Promise<ReadonlyArray<IScope>>;
    forgetScopes(): void;
    restart(): Promise<any>;
    toString(): string;
    openInEditor(editorService: IEditorService, preserveFocus?: boolean, sideBySide?: boolean, pinned?: boolean): Promise<IEditorPane | undefined>;
    equals(other: IStackFrame): boolean;
}
interface IEnablement extends ITreeElement {
    readonly enabled: boolean;
}
interface IBreakpointData {
    readonly id?: string;
    readonly lineNumber: number;
    readonly column?: number;
    readonly enabled?: boolean;
    readonly condition?: string;
    readonly logMessage?: string;
    readonly hitCondition?: string;
}
interface IBreakpointUpdateData {
    readonly condition?: string;
    readonly hitCondition?: string;
    readonly logMessage?: string;
    readonly lineNumber?: number;
    readonly column?: number;
}
interface IBaseBreakpoint extends IEnablement {
    readonly condition?: string;
    readonly hitCondition?: string;
    readonly logMessage?: string;
    readonly verified: boolean;
    readonly supported: boolean;
    readonly message?: string;
    readonly sessionsThatVerified: string[];
    getIdFromAdapter(sessionId: string): number | undefined;
}
interface IBreakpoint extends IBaseBreakpoint {
    readonly uri: URI;
    readonly lineNumber: number;
    readonly endLineNumber?: number;
    readonly column?: number;
    readonly endColumn?: number;
    readonly adapterData: any;
    readonly sessionAgnosticData: {
        lineNumber: number;
        column: number | undefined;
    };
}
interface IFunctionBreakpoint extends IBaseBreakpoint {
    readonly name: string;
}
interface IExceptionBreakpoint extends IBaseBreakpoint {
    readonly filter: string;
    readonly label: string;
    readonly description: string | undefined;
}
interface IDataBreakpoint extends IBaseBreakpoint {
    readonly description: string;
    readonly dataId: string;
    readonly canPersist: boolean;
    readonly accessType: DebugProtocol.DataBreakpointAccessType;
}
interface IInstructionBreakpoint extends IBaseBreakpoint {
    readonly instructionReference: string;
    readonly offset?: number;
}
interface IExceptionInfo {
    readonly id?: string;
    readonly description?: string;
    readonly breakMode: string | null;
    readonly details?: DebugProtocol.ExceptionDetails;
}
interface IViewModel extends ITreeElement {
    /**
     * Returns the focused debug session or undefined if no session is stopped.
     */
    readonly focusedSession: IDebugSession | undefined;
    /**
     * Returns the focused thread or undefined if no thread is stopped.
     */
    readonly focusedThread: IThread | undefined;
    /**
     * Returns the focused stack frame or undefined if there are no stack frames.
     */
    readonly focusedStackFrame: IStackFrame | undefined;
    getSelectedExpression(): {
        expression: IExpression;
        settingWatch: boolean;
    } | undefined;
    setSelectedExpression(expression: IExpression | undefined, settingWatch: boolean): void;
    updateViews(): void;
    isMultiSessionView(): boolean;
    onDidFocusSession: Event$1<IDebugSession | undefined>;
    onDidFocusStackFrame: Event$1<{
        stackFrame: IStackFrame | undefined;
        explicit: boolean;
    }>;
    onDidSelectExpression: Event$1<{
        expression: IExpression;
        settingWatch: boolean;
    } | undefined>;
    onDidEvaluateLazyExpression: Event$1<IExpressionContainer>;
    onWillUpdateViews: Event$1<void>;
    evaluateLazyExpression(expression: IExpressionContainer): void;
}
interface IEvaluate {
    evaluate(session: IDebugSession, stackFrame: IStackFrame, context: string): Promise<void>;
}
interface IDebugModel extends ITreeElement {
    getSession(sessionId: string | undefined, includeInactive?: boolean): IDebugSession | undefined;
    getSessions(includeInactive?: boolean): IDebugSession[];
    getBreakpoints(filter?: {
        uri?: URI;
        lineNumber?: number;
        column?: number;
        enabledOnly?: boolean;
    }): ReadonlyArray<IBreakpoint>;
    areBreakpointsActivated(): boolean;
    getFunctionBreakpoints(): ReadonlyArray<IFunctionBreakpoint>;
    getDataBreakpoints(): ReadonlyArray<IDataBreakpoint>;
    /**
     * Returns list of all exception breakpoints.
     */
    getExceptionBreakpoints(): ReadonlyArray<IExceptionBreakpoint>;
    /**
     * Returns list of exception breakpoints for the given session
     * @param sessionId Session id. If falsy, returns the breakpoints from the last set fallback session.
     */
    getExceptionBreakpointsForSession(sessionId?: string): ReadonlyArray<IExceptionBreakpoint>;
    getInstructionBreakpoints(): ReadonlyArray<IInstructionBreakpoint>;
    getWatchExpressions(): ReadonlyArray<IExpression & IEvaluate>;
    onDidChangeBreakpoints: Event$1<IBreakpointsChangeEvent | undefined>;
    onDidChangeCallStack: Event$1<void>;
    onDidChangeWatchExpressions: Event$1<IExpression | undefined>;
    fetchCallstack(thread: IThread, levels?: number): Promise<void>;
}
/**
 * An event describing a change to the set of [breakpoints](#debug.Breakpoint).
 */
interface IBreakpointsChangeEvent {
    added?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;
    removed?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;
    changed?: Array<IBreakpoint | IFunctionBreakpoint | IDataBreakpoint | IInstructionBreakpoint>;
    sessionOnly: boolean;
}
interface IEnvConfig {
    internalConsoleOptions?: 'neverOpen' | 'openOnSessionStart' | 'openOnFirstSessionStart';
    preRestartTask?: string | ITaskIdentifier;
    postRestartTask?: string | ITaskIdentifier;
    preLaunchTask?: string | ITaskIdentifier;
    postDebugTask?: string | ITaskIdentifier;
    debugServer?: number;
    noDebug?: boolean;
    suppressMultipleSessionWarning?: boolean;
}
interface IConfigPresentation {
    hidden?: boolean;
    group?: string;
    order?: number;
}
interface IConfig extends IEnvConfig {
    type: string;
    request: string;
    name: string;
    presentation?: IConfigPresentation;
    windows?: IEnvConfig;
    osx?: IEnvConfig;
    linux?: IEnvConfig;
    __configurationTarget?: ConfigurationTarget;
    __sessionId?: string;
    __restart?: any;
    __autoAttach?: boolean;
    port?: number;
}
interface ICompound {
    name: string;
    stopAll?: boolean;
    preLaunchTask?: string | ITaskIdentifier;
    configurations: (string | {
        name: string;
        folder: string;
    })[];
    presentation?: IConfigPresentation;
}
interface IDebugAdapter extends IDisposable {
    readonly onError: Event$1<Error>;
    readonly onExit: Event$1<number | null>;
    onRequest(callback: (request: DebugProtocol.Request) => void): void;
    onEvent(callback: (event: DebugProtocol.Event) => void): void;
    startSession(): Promise<void>;
    sendMessage(message: DebugProtocol.ProtocolMessage): void;
    sendResponse(response: DebugProtocol.Response): void;
    sendRequest(command: string, args: any, clb: (result: DebugProtocol.Response) => void, timeout?: number): number;
    stopSession(): Promise<void>;
}
interface IDebugAdapterFactory extends ITerminalLauncher {
    createDebugAdapter(session: IDebugSession): IDebugAdapter;
    substituteVariables(folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;
}
interface IDebugAdapterExecutableOptions {
    cwd?: string;
    env?: {
        [key: string]: string;
    };
}
interface IDebugAdapterExecutable {
    readonly type: 'executable';
    readonly command: string;
    readonly args: string[];
    readonly options?: IDebugAdapterExecutableOptions;
}
interface IDebugAdapterServer {
    readonly type: 'server';
    readonly port: number;
    readonly host?: string;
}
interface IDebugAdapterNamedPipeServer {
    readonly type: 'pipeServer';
    readonly path: string;
}
interface IDebugAdapterInlineImpl extends IDisposable {
    readonly onDidSendMessage: Event$1<DebugProtocol.Message>;
    handleMessage(message: DebugProtocol.Message): void;
}
interface IDebugAdapterImpl {
    readonly type: 'implementation';
    readonly implementation: IDebugAdapterInlineImpl;
}
type IAdapterDescriptor = IDebugAdapterExecutable | IDebugAdapterServer | IDebugAdapterNamedPipeServer | IDebugAdapterImpl;
declare enum DebugConfigurationProviderTriggerKind {
    /**
     *	`DebugConfigurationProvider.provideDebugConfigurations` is called to provide the initial debug configurations for a newly created launch.json.
     */
    Initial = 1,
    /**
     * `DebugConfigurationProvider.provideDebugConfigurations` is called to provide dynamically generated debug configurations when the user asks for them through the UI (e.g. via the "Select and Start Debugging" command).
     */
    Dynamic = 2
}
interface IDebugConfigurationProvider {
    readonly type: string;
    readonly triggerKind: DebugConfigurationProviderTriggerKind;
    resolveDebugConfiguration?(folderUri: URI | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;
    resolveDebugConfigurationWithSubstitutedVariables?(folderUri: URI | undefined, debugConfiguration: IConfig, token: CancellationToken): Promise<IConfig | null | undefined>;
    provideDebugConfigurations?(folderUri: URI | undefined, token: CancellationToken): Promise<IConfig[]>;
}
interface IDebugAdapterDescriptorFactory {
    readonly type: string;
    createDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor>;
}
interface ITerminalLauncher {
    runInTerminal(args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;
}
interface IConfigurationManager {
    /**
     * Returns an object containing the selected launch configuration and the selected configuration name. Both these fields can be null (no folder workspace).
     */
    readonly selectedConfiguration: {
        launch: ILaunch | undefined;
        getConfig: () => Promise<IConfig | undefined>;
        name: string | undefined;
        type: string | undefined;
    };
    selectConfiguration(launch: ILaunch | undefined, name?: string, config?: IConfig, dynamicConfigOptions?: {
        type?: string;
    }): Promise<void>;
    getLaunches(): ReadonlyArray<ILaunch>;
    getLaunch(workspaceUri: URI | undefined): ILaunch | undefined;
    getAllConfigurations(): {
        launch: ILaunch;
        name: string;
        presentation?: IConfigPresentation;
    }[];
    removeRecentDynamicConfigurations(name: string, type: string): void;
    getRecentDynamicConfigurations(): {
        name: string;
        type: string;
    }[];
    /**
     * Allows to register on change of selected debug configuration.
     */
    onDidSelectConfiguration: Event$1<void>;
    hasDebugConfigurationProvider(debugType: string): boolean;
    getDynamicProviders(): Promise<{
        label: string;
        type: string;
        pick: () => Promise<{
            launch: ILaunch;
            config: IConfig;
        } | undefined>;
    }[]>;
    registerDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): IDisposable;
    unregisterDebugConfigurationProvider(debugConfigurationProvider: IDebugConfigurationProvider): void;
    resolveConfigurationByProviders(folderUri: URI | undefined, type: string | undefined, debugConfiguration: any, token: CancellationToken): Promise<any>;
}
declare enum DebuggerString {
    UnverifiedBreakpoints = "unverifiedBreakpoints"
}
interface IAdapterManager {
    onDidRegisterDebugger: Event$1<void>;
    hasEnabledDebuggers(): boolean;
    getDebugAdapterDescriptor(session: IDebugSession): Promise<IAdapterDescriptor | undefined>;
    getDebuggerLabel(type: string): string | undefined;
    someDebuggerInterestedInLanguage(language: string): boolean;
    getDebugger(type: string): IDebuggerMetadata | undefined;
    activateDebuggers(activationEvent: string, debugType?: string): Promise<void>;
    registerDebugAdapterFactory(debugTypes: string[], debugAdapterFactory: IDebugAdapterFactory): IDisposable;
    createDebugAdapter(session: IDebugSession): IDebugAdapter | undefined;
    registerDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): IDisposable;
    unregisterDebugAdapterDescriptorFactory(debugAdapterDescriptorFactory: IDebugAdapterDescriptorFactory): void;
    substituteVariables(debugType: string, folder: IWorkspaceFolder | undefined, config: IConfig): Promise<IConfig>;
    runInTerminal(debugType: string, args: DebugProtocol.RunInTerminalRequestArguments, sessionId: string): Promise<number | undefined>;
    getEnabledDebugger(type: string): (IDebugger & IDebuggerMetadata) | undefined;
    guessDebugger(gettingConfigurations: boolean): Promise<(IDebugger & IDebuggerMetadata) | undefined>;
    get onDidDebuggersExtPointRead(): Event$1<void>;
}
interface ILaunch {
    /**
     * Resource pointing to the launch.json this object is wrapping.
     */
    readonly uri: URI;
    /**
     * Name of the launch.
     */
    readonly name: string;
    /**
     * Workspace of the launch. Can be undefined.
     */
    readonly workspace: IWorkspaceFolder | undefined;
    /**
     * Should this launch be shown in the debug dropdown.
     */
    readonly hidden: boolean;
    /**
     * Returns a configuration with the specified name.
     * Returns undefined if there is no configuration with the specified name.
     */
    getConfiguration(name: string): IConfig | undefined;
    /**
     * Returns a compound with the specified name.
     * Returns undefined if there is no compound with the specified name.
     */
    getCompound(name: string): ICompound | undefined;
    /**
     * Returns the names of all configurations and compounds.
     * Ignores configurations which are invalid.
     */
    getConfigurationNames(ignoreCompoundsAndPresentation?: boolean): string[];
    /**
     * Opens the launch.json file. Creates if it does not exist.
     */
    openConfigFile(options: {
        preserveFocus: boolean;
        type?: string;
        suppressInitialConfigs?: boolean;
    }, token?: CancellationToken): Promise<{
        editor: IEditorPane | null;
        created: boolean;
    }>;
}
declare const IDebugService: ServiceIdentifier<IDebugService>;
interface IDebugService {
    readonly _serviceBrand: undefined;
    /**
     * Gets the current debug state.
     */
    readonly state: State;
    readonly initializingOptions?: IDebugSessionOptions | undefined;
    /**
     * Allows to register on debug state changes.
     */
    onDidChangeState: Event$1<State>;
    /**
     * Allows to register on new session events.
     */
    onDidNewSession: Event$1<IDebugSession>;
    /**
     * Allows to register on sessions about to be created (not yet fully initialised)
     */
    onWillNewSession: Event$1<IDebugSession>;
    /**
     * Allows to register on end session events.
     */
    onDidEndSession: Event$1<IDebugSession>;
    /**
     * Gets the configuration manager.
     */
    getConfigurationManager(): IConfigurationManager;
    /**
     * Gets the adapter manager.
     */
    getAdapterManager(): IAdapterManager;
    /**
     * Sets the focused stack frame and evaluates all expressions against the newly focused stack frame,
     */
    focusStackFrame(focusedStackFrame: IStackFrame | undefined, thread?: IThread, session?: IDebugSession, options?: {
        explicit?: boolean;
        preserveFocus?: boolean;
        sideBySide?: boolean;
        pinned?: boolean;
    }): Promise<void>;
    /**
     * Returns true if breakpoints can be set for a given editor model. Depends on mode.
     */
    canSetBreakpointsIn(model: ITextModel): boolean;
    /**
     * Adds new breakpoints to the model for the file specified with the uri. Notifies debug adapter of breakpoint changes.
     */
    addBreakpoints(uri: URI, rawBreakpoints: IBreakpointData[], ariaAnnounce?: boolean): Promise<IBreakpoint[]>;
    /**
     * Updates the breakpoints.
     */
    updateBreakpoints(uri: URI, data: Map<string, IBreakpointUpdateData>, sendOnResourceSaved: boolean): Promise<void>;
    /**
     * Enables or disables all breakpoints. If breakpoint is passed only enables or disables the passed breakpoint.
     * Notifies debug adapter of breakpoint changes.
     */
    enableOrDisableBreakpoints(enable: boolean, breakpoint?: IEnablement): Promise<void>;
    /**
     * Sets the global activated property for all breakpoints.
     * Notifies debug adapter of breakpoint changes.
     */
    setBreakpointsActivated(activated: boolean): Promise<void>;
    /**
     * Removes all breakpoints. If id is passed only removes the breakpoint associated with that id.
     * Notifies debug adapter of breakpoint changes.
     */
    removeBreakpoints(id?: string): Promise<any>;
    /**
     * Adds a new function breakpoint for the given name.
     */
    addFunctionBreakpoint(name?: string, id?: string): void;
    /**
     * Updates an already existing function breakpoint.
     * Notifies debug adapter of breakpoint changes.
     */
    updateFunctionBreakpoint(id: string, update: {
        name?: string;
        hitCondition?: string;
        condition?: string;
    }): Promise<void>;
    /**
     * Removes all function breakpoints. If id is passed only removes the function breakpoint with the passed id.
     * Notifies debug adapter of breakpoint changes.
     */
    removeFunctionBreakpoints(id?: string): Promise<void>;
    /**
     * Adds a new data breakpoint.
     */
    addDataBreakpoint(label: string, dataId: string, canPersist: boolean, accessTypes: DebugProtocol.DataBreakpointAccessType[] | undefined, accessType: DebugProtocol.DataBreakpointAccessType): Promise<void>;
    /**
     * Removes all data breakpoints. If id is passed only removes the data breakpoint with the passed id.
     * Notifies debug adapter of breakpoint changes.
     */
    removeDataBreakpoints(id?: string): Promise<void>;
    /**
     * Adds a new instruction breakpoint.
     */
    addInstructionBreakpoint(address: string, offset: number, condition?: string, hitCondition?: string): Promise<void>;
    /**
     * Removes all instruction breakpoints. If address is passed only removes the instruction breakpoint with the passed address.
     * The address should be the address string supplied by the debugger from the "Disassemble" request.
     * Notifies debug adapter of breakpoint changes.
     */
    removeInstructionBreakpoints(address?: string): Promise<void>;
    setExceptionBreakpointCondition(breakpoint: IExceptionBreakpoint, condition: string | undefined): Promise<void>;
    setExceptionBreakpointsForSession(session: IDebugSession, data: DebugProtocol.ExceptionBreakpointsFilter[]): void;
    /**
     * Sends all breakpoints to the passed session.
     * If session is not passed, sends all breakpoints to each session.
     */
    sendAllBreakpoints(session?: IDebugSession): Promise<any>;
    /**
     * Adds a new watch expression and evaluates it against the debug adapter.
     */
    addWatchExpression(name?: string): void;
    /**
     * Renames a watch expression and evaluates it against the debug adapter.
     */
    renameWatchExpression(id: string, newName: string): void;
    /**
     * Moves a watch expression to a new possition. Used for reordering watch expressions.
     */
    moveWatchExpression(id: string, position: number): void;
    /**
     * Removes all watch expressions. If id is passed only removes the watch expression with the passed id.
     */
    removeWatchExpressions(id?: string): void;
    /**
     * Starts debugging. If the configOrName is not passed uses the selected configuration in the debug dropdown.
     * Also saves all files, manages if compounds are present in the configuration
     * and resolveds configurations via DebugConfigurationProviders.
     *
     * Returns true if the start debugging was successful. For compound launches, all configurations have to start successfully for it to return success.
     * On errors the startDebugging will throw an error, however some error and cancelations are handled and in that case will simply return false.
     */
    startDebugging(launch: ILaunch | undefined, configOrName?: IConfig | string, options?: IDebugSessionOptions, saveBeforeStart?: boolean): Promise<boolean>;
    /**
     * Restarts a session or creates a new one if there is no active session.
     */
    restartSession(session: IDebugSession, restartData?: any): Promise<any>;
    /**
     * Stops the session. If no session is specified then all sessions are stopped.
     */
    stopSession(session: IDebugSession | undefined, disconnect?: boolean, suspend?: boolean): Promise<any>;
    /**
     * Makes unavailable all sources with the passed uri. Source will appear as grayed out in callstack view.
     */
    sourceIsNotAvailable(uri: URI): void;
    /**
     * Gets the current debug model.
     */
    getModel(): IDebugModel;
    /**
     * Gets the current view model.
     */
    getViewModel(): IViewModel;
    /**
     * Resumes execution and pauses until the given position is reached.
     */
    runTo(uri: URI, lineNumber: number, column?: number): Promise<void>;
}

interface Window {
    createOutputChannel?(name: string, options: string | {
        log: true;
    } | undefined): vscode.LogOutputChannel;
    withProgress?: IProgressService['withProgress'];
}
interface Workspace {
    rootPath?: string;
    workspaceFolders?: typeof vscode.workspace.workspaceFolders;
    updateWorkspaceFolders?: typeof vscode.workspace.updateWorkspaceFolders;
    onDidChangeWorkspaceFolders?: typeof vscode.workspace.onDidChangeWorkspaceFolders;
    onWillSaveTextDocument?: vscode.Event<vscode.TextDocumentWillSaveEvent>;
    onDidSaveTextDocument?: vscode.Event<vscode.TextDocument>;
    createFileSystemWatcher?: typeof vscode.workspace.createFileSystemWatcher;
}
interface Services {
    extension?: IExtensionDescription;
    workspace?: Workspace;
    window?: Window;
}
declare namespace Services {
    type Provider = () => Services;
    const get: Provider;
    function install(_services: Services): vscode.Disposable;
}

export { ContextKeyExprType, IAudioCueService, IBulkEditService, IClipboardService, ICodeEditorService, IColorTheme, ICommandService, IConfigurationChangeEvent, IConfigurationService, IDebugService, IDialogService, IEditorGroupsService, IEditorService, IEditorWorkerService, IFileService, IHostService, IInstantiationService, ILanguageConfigurationService, ILanguageFeaturesService, ILanguageService, ILanguageStatusService, IMarkerService, IModelService, INotificationService, IOpenerService, IPaneCompositePartService, IPathService, IProductService, IQuickInputService, ISnippetsService, IStorageService, ITelemetryService, ITextFileService, ITextModelContentProvider, ITextModelService, IThemeService, IUriIdentityService, IWorkbenchEnvironmentService, IWorkingCopyFileService, IWorkspaceContextService, NotificationsFilter, Services, Severity$1 as Severity, StandaloneServices, StorageScope, StorageTarget, Window, Workspace };
