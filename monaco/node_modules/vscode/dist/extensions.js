import { c as consoleExtensionMessageHandler } from './polyfill.js';
import { bM as api$1, bN as create, bO as create$1, bP as create$2, bQ as create$5, bR as create$3, bS as create$4, bT as create$6, bU as IExtHostExtensionService } from './api2.js';
import { E as ExtensionsRegistry, a as ExtensionMessageCollector } from './extensionsRegistry.js';
import { t as toExtensionDescription, g as getExtensionId } from './missing-services.js';
import { r as registerExtensionFile } from './files.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
function createApi(extension) {
    const workspace = create$4(() => extension);
    return {
        ...api$1,
        extensions: create(() => extension),
        debug: create$1(() => extension),
        env: create$2(() => extension),
        commands: create$5(() => extension),
        window: create$3(() => extension, workspace),
        workspace: create$4(() => extension),
        languages: create$6(() => extension)
    };
}
const hasOwnProperty = Object.hasOwnProperty;
function handleExtensionPoint(extensionPoint, availableExtensions, messageHandler) {
    const users = [];
    for (const desc of availableExtensions) {
        if ((desc.contributes != null) && hasOwnProperty.call(desc.contributes, extensionPoint.name)) {
            users.push({
                description: desc,
                value: desc.contributes[extensionPoint.name],
                collector: new ExtensionMessageCollector(messageHandler, desc, extensionPoint.name)
            });
        }
    }
    extensionPoint.acceptUsers(users);
}
function deltaExtensions(toAdd, toRemove) {
    void StandaloneServices.get(IExtHostExtensionService).getExtensionRegistry().then(extensionRegistry => {
        const affectedExtensions = [].concat(toAdd).concat(toRemove);
        const affectedExtensionPoints = Object.create(null);
        for (const extensionDescription of affectedExtensions) {
            for (const extPointName in extensionDescription.contributes) {
                if (hasOwnProperty.call(extensionDescription.contributes, extPointName)) {
                    affectedExtensionPoints[extPointName] = true;
                }
            }
        }
        extensionRegistry.deltaExtensions(toAdd, ( toRemove.map(ext => ext.identifier)));
        const availableExtensions = extensionRegistry.getAllExtensionDescriptions();
        const extensionPoints = ExtensionsRegistry.getExtensionPoints();
        for (const extensionPoint of extensionPoints) {
            if (affectedExtensionPoints[extensionPoint.name] ?? false) {
                handleExtensionPoint(extensionPoint, availableExtensions, consoleExtensionMessageHandler);
            }
        }
    });
}
function registerExtension(manifest) {
    const uuid = generateUuid();
    const location = ( URI.from({ scheme: 'extension', path: `/${uuid}` }));
    const extension = {
        manifest,
        type: 1 ,
        isBuiltin: false,
        identifier: {
            id: getExtensionId(manifest.publisher, manifest.name),
            uuid
        },
        location,
        targetPlatform: "web" ,
        isValid: true,
        validations: []
    };
    const extensionDescription = toExtensionDescription(extension);
    deltaExtensions([extensionDescription], []);
    return {
        api: createApi(extensionDescription),
        registerFile: (path, getContent) => {
            return registerExtensionFile(location, path, getContent);
        },
        dispose() {
            deltaExtensions([], [extensionDescription]);
        }
    };
}
export { createApi, registerExtension };
