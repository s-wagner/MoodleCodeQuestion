import * as vscode from 'vscode';
import * as monaco from 'monaco-editor';

/**
 * An object that performs a cleanup operation when `.dispose()` is called.
 *
 * Some examples of how disposables are used:
 *
 * - An event listener that removes itself when `.dispose()` is called.
 * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.
 * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.
 */
interface IDisposable {
    dispose(): void;
}
/**
 * Manages a collection of disposable values.
 *
 * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an
 * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a
 * store that has already been disposed of.
 */
declare class DisposableStore implements IDisposable {
    static DISABLE_DISPOSED_WARNING: boolean;
    private readonly _toDispose;
    private _isDisposed;
    constructor();
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose(): void;
    /**
     * @return `true` if this object has been disposed of.
     */
    get isDisposed(): boolean;
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear(): void;
    /**
     * Add a new {@link IDisposable disposable} to the collection.
     */
    add<T extends IDisposable>(o: T): T;
}

interface IObservable<T, TChange = void> {
    readonly TChange: TChange;
    /**
     * Reads the current value.
     *
     * Must not be called from {@link IObserver.handleChange}.
     */
    get(): T;
    /**
     * Adds an observer.
     */
    addObserver(observer: IObserver): void;
    removeObserver(observer: IObserver): void;
    /**
     * Subscribes the reader to this observable and returns the current value of this observable.
     */
    read(reader: IReader): T;
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    readonly debugName: string;
}
interface IReader {
    /**
     * Reports an observable that was read.
     *
     * Is called by {@link IObservable.read}.
     */
    subscribeTo<T>(observable: IObservable<T, any>): void;
}
interface IObserver {
    /**
     * Indicates that an update operation is about to begin.
     *
     * During an update, invariants might not hold for subscribed observables and
     * change events might be delayed.
     * However, all changes must be reported before all update operations are over.
     */
    beginUpdate<T>(observable: IObservable<T>): void;
    /**
     * Is called by a subscribed observable immediately after it notices a change.
     *
     * When {@link IObservable.get} returns and no change has been reported,
     * there has been no change for that observable.
     *
     * Implementations must not call into other observables!
     * The change should be processed when {@link IObserver.endUpdate} is called.
     */
    handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
    /**
     * Indicates that an update operation has completed.
     */
    endUpdate<T>(observable: IObservable<T>): void;
}

/**
 * Can be passed into the Delayed to defer using a microtask
 * */
declare const MicrotaskDelay: unique symbol;

/**
 * An event with zero or one parameters that can be subscribed to. The event is a function itself.
 */
type Event<T> = vscode.Event<T>
declare namespace Event {
    const None: Event<any>;
    /**
     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared
     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a
     * result of merging events and to try prevent race conditions that could arise when using related deferred and
     * non-deferred events.
     *
     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work
     * (eg. latency of keypress to text rendered).
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function defer(event: Event<unknown>, disposable?: DisposableStore): Event<void>;
    /**
     * Given an event, returns another event which only fires once.
     *
     * @param event The event source for the new event.
     */
    function once<T>(event: Event<T>): Event<T>;
    /**
     * Maps an event of one type into an event of another type using a mapping function, similar to how
     * `Array.prototype.map` works.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param map The mapping function.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;
    function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;
    function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;
    /**
     * Given an event, returns the same event but typed as `Event<void>`.
     */
    function signal<T>(event: Event<T>): Event<void>;
    /**
     * Given a collection of events, returns a single event which emits
     * whenever any of the provided events emit.
     */
    function any<T>(...events: Event<T>[]): Event<T>;
    function any(...events: Event<any>[]): Event<void>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O>;
    /**
     * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an
     * array event object of all events that fired.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The original event to debounce.
     * @param merge A function that reduces all events into a single event.
     * @param delay The number of milliseconds to debounce.
     * @param leading Whether to fire a leading event without debouncing.
     * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not
     * specified, some events could go missing. Use this if it's important that all events are processed, even if the
     * listener gets disposed before the debounced event fires.
     * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.
     * @param disposable A disposable store to register the debounce emitter to.
     */
    function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;
    function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;
    /**
     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function accumulate<T>(event: Event<T>, delay?: number, disposable?: DisposableStore): Event<T[]>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function latch<T>(event: Event<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event<T>;
    /**
     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @example
     * ```
     * const event = new EventEmitter<number | undefined>().event;
     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);
     * ```
     *
     * @param event The event source for the new event.
     * @param isT A function that determines what event is of the first type.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>];
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function buffer<T>(event: Event<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event<T>;
    interface IChainableEvent<T> extends IDisposable {
        event: Event<T>;
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        latch(): IChainableEvent<T>;
        debounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;
        debounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
    }
    function chain<T>(event: Event<T>): IChainableEvent<T>;
    interface NodeEventEmitter {
        on(event: string | symbol, listener: Function): unknown;
        removeListener(event: string | symbol, listener: Function): unknown;
    }
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event<T>;
    interface DOMEventEmitter {
        addEventListener(event: string | symbol, listener: Function): void;
        removeEventListener(event: string | symbol, listener: Function): void;
    }
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event<T>;
    function toPromise<T>(event: Event<T>): Promise<T>;
    function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => any): IDisposable;
    function runAndSubscribeWithStore<T>(event: Event<T>, handler: (e: T | undefined, disposableStore: DisposableStore) => any): IDisposable;
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event<T>;
}

/**
 * An interface for a JavaScript object that
 * acts a dictionary. The keys are strings.
 */
type IStringDictionary<V> = Record<string, V>;

type JSONSchemaType = 'string' | 'number' | 'integer' | 'boolean' | 'null' | 'array' | 'object';
interface IJSONSchema {
    id?: string;
    $id?: string;
    $schema?: string;
    type?: JSONSchemaType | JSONSchemaType[];
    title?: string;
    default?: any;
    definitions?: IJSONSchemaMap;
    description?: string;
    properties?: IJSONSchemaMap;
    patternProperties?: IJSONSchemaMap;
    additionalProperties?: boolean | IJSONSchema;
    minProperties?: number;
    maxProperties?: number;
    dependencies?: IJSONSchemaMap | {
        [prop: string]: string[];
    };
    items?: IJSONSchema | IJSONSchema[];
    minItems?: number;
    maxItems?: number;
    uniqueItems?: boolean;
    additionalItems?: boolean | IJSONSchema;
    pattern?: string;
    minLength?: number;
    maxLength?: number;
    minimum?: number;
    maximum?: number;
    exclusiveMinimum?: boolean | number;
    exclusiveMaximum?: boolean | number;
    multipleOf?: number;
    required?: string[];
    $ref?: string;
    anyOf?: IJSONSchema[];
    allOf?: IJSONSchema[];
    oneOf?: IJSONSchema[];
    not?: IJSONSchema;
    enum?: any[];
    format?: string;
    const?: any;
    contains?: IJSONSchema;
    propertyNames?: IJSONSchema;
    examples?: any[];
    $comment?: string;
    if?: IJSONSchema;
    then?: IJSONSchema;
    else?: IJSONSchema;
    unevaluatedProperties?: boolean | IJSONSchema;
    unevaluatedItems?: boolean | IJSONSchema;
    minContains?: number;
    maxContains?: number;
    deprecated?: boolean;
    dependentRequired?: {
        [prop: string]: string[];
    };
    dependentSchemas?: IJSONSchemaMap;
    $defs?: {
        [name: string]: IJSONSchema;
    };
    $anchor?: string;
    $recursiveRef?: string;
    $recursiveAnchor?: string;
    $vocabulary?: any;
    prefixItems?: IJSONSchema[];
    $dynamicRef?: string;
    $dynamicAnchor?: string;
    defaultSnippets?: IJSONSchemaSnippet[];
    errorMessage?: string;
    patternErrorMessage?: string;
    deprecationMessage?: string;
    markdownDeprecationMessage?: string;
    enumDescriptions?: string[];
    markdownEnumDescriptions?: string[];
    markdownDescription?: string;
    doNotSuggest?: boolean;
    suggestSortText?: string;
    allowComments?: boolean;
    allowTrailingCommas?: boolean;
}
interface IJSONSchemaMap {
    [name: string]: IJSONSchema;
}
interface IJSONSchemaSnippet {
    label?: string;
    description?: string;
    body?: any;
    bodyText?: string;
}

type PolicyName = string;

declare enum EditPresentationTypes {
    Multiline = "multilineText",
    Singleline = "singlelineText"
}
interface IConfigurationDelta {
    removedDefaults?: IConfigurationDefaults[];
    removedConfigurations?: IConfigurationNode[];
    addedDefaults?: IConfigurationDefaults[];
    addedConfigurations?: IConfigurationNode[];
}
interface IConfigurationRegistry {
    /**
     * Register a configuration to the registry.
     */
    registerConfiguration(configuration: IConfigurationNode): void;
    /**
     * Register multiple configurations to the registry.
     */
    registerConfigurations(configurations: IConfigurationNode[], validate?: boolean): void;
    /**
     * Deregister multiple configurations from the registry.
     */
    deregisterConfigurations(configurations: IConfigurationNode[]): void;
    /**
     * update the configuration registry by
     * 	- registering the configurations to add
     * 	- dereigstering the configurations to remove
     */
    updateConfigurations(configurations: {
        add: IConfigurationNode[];
        remove: IConfigurationNode[];
    }): void;
    /**
     * Register multiple default configurations to the registry.
     */
    registerDefaultConfigurations(defaultConfigurations: IConfigurationDefaults[]): void;
    /**
     * Deregister multiple default configurations from the registry.
     */
    deregisterDefaultConfigurations(defaultConfigurations: IConfigurationDefaults[]): void;
    /**
     * Bulk update of the configuration registry (default and configurations, remove and add)
     * @param delta
     */
    deltaConfiguration(delta: IConfigurationDelta): void;
    /**
     * Return the registered configuration defaults overrides
     */
    getConfigurationDefaultsOverrides(): Map<string, IConfigurationDefaultOverride>;
    /**
     * Signal that the schema of a configuration setting has changes. It is currently only supported to change enumeration values.
     * Property or default value changes are not allowed.
     */
    notifyConfigurationSchemaUpdated(...configurations: IConfigurationNode[]): void;
    /**
     * Event that fires whenever a configuration has been
     * registered.
     */
    readonly onDidSchemaChange: Event<void>;
    /**
     * Event that fires whenever a configuration has been
     * registered.
     */
    readonly onDidUpdateConfiguration: Event<{
        properties: ReadonlySet<string>;
        defaultsOverrides?: boolean;
    }>;
    /**
     * Returns all configuration nodes contributed to this registry.
     */
    getConfigurations(): IConfigurationNode[];
    /**
     * Returns all configurations settings of all configuration nodes contributed to this registry.
     */
    getConfigurationProperties(): IStringDictionary<IRegisteredConfigurationPropertySchema>;
    /**
     * Return all configurations by policy name
     */
    getPolicyConfigurations(): Map<PolicyName, string>;
    /**
     * Returns all excluded configurations settings of all configuration nodes contributed to this registry.
     */
    getExcludedConfigurationProperties(): IStringDictionary<IRegisteredConfigurationPropertySchema>;
    /**
     * Register the identifiers for editor configurations
     */
    registerOverrideIdentifiers(identifiers: string[]): void;
}
declare const enum ConfigurationScope {
    /**
     * Application specific configuration, which can be configured only in local user settings.
     */
    APPLICATION = 1,
    /**
     * Machine specific configuration, which can be configured only in local and remote user settings.
     */
    MACHINE = 2,
    /**
     * Window specific configuration, which can be configured in the user or workspace settings.
     */
    WINDOW = 3,
    /**
     * Resource specific configuration, which can be configured in the user, workspace or folder settings.
     */
    RESOURCE = 4,
    /**
     * Resource specific configuration that can be configured in language specific settings
     */
    LANGUAGE_OVERRIDABLE = 5,
    /**
     * Machine specific configuration that can also be configured in workspace or folder settings.
     */
    MACHINE_OVERRIDABLE = 6
}
interface IPolicy {
    /**
     * The policy name.
     */
    readonly name: PolicyName;
    /**
     * The Code version in which this policy was introduced.
     */
    readonly minimumVersion: `${number}.${number}`;
}
interface IConfigurationPropertySchema extends IJSONSchema {
    scope?: ConfigurationScope;
    /**
     * When restricted, value of this configuration will be read only from trusted sources.
     * For eg., If the workspace is not trusted, then the value of this configuration is not read from workspace settings file.
     */
    restricted?: boolean;
    /**
     * When `false` this property is excluded from the registry. Default is to include.
     */
    included?: boolean;
    /**
     * List of tags associated to the property.
     *  - A tag can be used for filtering
     *  - Use `experimental` tag for marking the setting as experimental. **Note:** Defaults of experimental settings can be changed by the running experiments.
     */
    tags?: string[];
    /**
     * When enabled this setting is ignored during sync and user can override this.
     */
    ignoreSync?: boolean;
    /**
     * When enabled this setting is ignored during sync and user cannot override this.
     */
    disallowSyncIgnore?: boolean;
    /**
     * Labels for enumeration items
     */
    enumItemLabels?: string[];
    /**
     * When specified, controls the presentation format of string settings.
     * Otherwise, the presentation format defaults to `singleline`.
     */
    editPresentation?: EditPresentationTypes;
    /**
     * When specified, gives an order number for the setting
     * within the settings editor. Otherwise, the setting is placed at the end.
     */
    order?: number;
    /**
     * When specified, this setting's value can always be overwritten by
     * a system-wide policy.
     */
    policy?: IPolicy;
}
interface IExtensionInfo {
    id: string;
    displayName?: string;
}
interface IConfigurationNode {
    id?: string;
    order?: number;
    type?: string | string[];
    title?: string;
    description?: string;
    properties?: IStringDictionary<IConfigurationPropertySchema>;
    allOf?: IConfigurationNode[];
    scope?: ConfigurationScope;
    extensionInfo?: IExtensionInfo;
    restrictedProperties?: string[];
}
interface IConfigurationDefaults {
    overrides: IStringDictionary<any>;
    source?: IExtensionInfo | string;
}
type IRegisteredConfigurationPropertySchema = IConfigurationPropertySchema & {
    defaultDefaultValue?: any;
    source?: IExtensionInfo;
    defaultValueSource?: IExtensionInfo | string;
};
type IConfigurationDefaultOverride = {
    readonly value: any;
    readonly source?: IExtensionInfo | string;
    readonly valuesSources?: Map<string, IExtensionInfo | string>;
};

type IEditorOverrideServices = monaco.editor.IEditorOverrideServices

interface IThemeScopedColorCustomizations {
    [colorId: string]: string;
}
interface IColorCustomizations {
    [colorIdOrThemeScope: string]: IThemeScopedColorCustomizations | string;
}

declare function updateUserConfiguration(configurationJson: string): Promise<void>;
declare function getUserConfiguration(): Promise<string>;
declare function onUserConfigurationChange(callback: () => void): vscode.Disposable;
declare const configurationRegistry: IConfigurationRegistry;
declare function getServiceOverride(): IEditorOverrideServices;

export { ConfigurationScope, IColorCustomizations, IConfigurationDefaults, IConfigurationNode, IThemeScopedColorCustomizations, configurationRegistry, getServiceOverride as default, getUserConfiguration, onUserConfigurationChange, updateUserConfiguration };
