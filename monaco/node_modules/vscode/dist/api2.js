import { P as Position$2, R as Range$2, w as withUndefinedAsNull, m as mapArrayOrNot, d as delta$1, r as readonly, a as disposed, s as setUnexpectedErrorHandler, i as isUntitledWorkspace, S as Selection$3, N as NotImplementedError, t as toWorkspaceFolder, f as flatten, e as encodeBase64 } from './polyfill.js';
import { I as IWorkingCopyService, u as unsupported$1, e as extensionTelemetryLogChannelId, i as isLogLevel, a as getRemoteName, c as cleanRemoteAuthority, b as cleanData, D as Disposable$2, P as Position$3, R as Range$3, L as Location$1, N as NotebookRange$2, T as TelemetryTrustedValue$1, r as resultIsMatch, s as supportsTelemetry, d as TELEMETRY_SETTING_ID, f as TELEMETRY_OLD_SETTING_ID, F as FileSystemError$1, h as format2, j as FileDecoration$1, k as checkProposedApiEnabled, E as ExtensionRuntime, l as ILoggerService, m as EndOfLine$2, n as IURITransformerService, S as Selection$2, o as TextEditorRevealType$2, p as extensionIdentifiersArrayToSet, q as isProposedApiEnabled, v as RemoteAuthorityResolverErrorCode, w as RemoteAuthorityResolverError, x as getRemoteAuthorityPrefix, y as SourceBreakpoint$1, z as DebugConsoleMode$1, A as setBreakpointId, B as FunctionBreakpoint$1, C as DebugAdapterExecutable$1, G as DebugAdapterServer$1, H as DebugAdapterNamedPipeServer$1, J as DebugAdapterInlineImplementation$1, K as count, M as ProgressLocation$2, O as ExtensionKind$1, Q as Breakpoint$1, U as CallHierarchyIncomingCall$1, V as CallHierarchyItem$2, W as CallHierarchyOutgoingCall$1, X as CodeAction$1, Y as CodeActionKind$1, Z as CodeActionTriggerKind$2, _ as CodeLens$1, $ as Color$2, a0 as ColorInformation$1, a1 as ColorPresentation$2, a2 as CommentMode$1, a3 as CommentThreadCollapsibleState$1, a4 as CompletionItem$1, a5 as CompletionItemKind$2, a6 as CompletionItemTag$2, a7 as CompletionList$1, a8 as CompletionTriggerKind$2, a9 as ConfigurationTarget$1, aa as CustomExecution$1, ab as DecorationRangeBehavior$2, ac as Diagnostic$2, ad as DiagnosticRelatedInformation$2, ae as DiagnosticSeverity$2, af as DiagnosticTag$2, ag as DocumentHighlight$2, ah as DocumentHighlightKind$1, ai as DocumentLink$2, aj as DocumentSymbol$2, ak as EnvironmentVariableMutatorType$1, al as EvaluatableExpression$2, am as InlineValueText$1, an as InlineValueVariableLookup$1, ao as InlineValueEvaluatableExpression$1, ap as ExtensionMode$1, aq as FileChangeType$1, ar as FoldingRange$2, as as FoldingRangeKind$3, at as Hover$2, au as MarkdownString$2, av as ParameterInformation$2, aw as ProcessExecution$1, ax as QuickInputButtons$1, ay as RelativePattern$1, az as SelectionRange$2, aA as SemanticTokens$1, aB as SemanticTokensBuilder$1, aC as SemanticTokensEdit$1, aD as SemanticTokensEdits$1, aE as SemanticTokensLegend$1, aF as ShellExecution$1, aG as ShellQuoting$1, aH as SignatureHelp$2, aI as SignatureHelpTriggerKind$1, aJ as SignatureInformation$2, aK as SnippetString$1, aL as SymbolInformation$1, aM as SymbolKind$2, aN as SymbolTag$2, aO as TextDocumentSaveReason$1, aP as TextEdit$2, aQ as TextEditorLineNumbersStyle$2, aR as TextEditorSelectionChangeKind$1, aS as TextDocumentChangeReason$1, aT as ThemeColor$1, aU as ThemeIcon$1, aV as TreeItem$1, aW as TreeItemCollapsibleState$1, aX as TypeHierarchyItem$2, aY as ViewColumn$2, aZ as WorkspaceEdit$2, a_ as InlayHint$1, a$ as InlayHintLabelPart$1, b0 as InlayHintKind$2, b1 as LinkedEditingRanges$1, b2 as TestRunRequest$1, b3 as TestMessage$1, b4 as TestTag$1, b5 as TestRunProfileKind$1, b6 as LanguageStatusSeverity$1, b7 as QuickPickItemKind$1, b8 as TextDiffTabInput, b9 as CustomEditorTabInput, ba as NotebookEditorTabInput, bb as NotebookDiffEditorTabInput, bc as WebviewEditorTabInput, bd as TerminalEditorTabInput, be as InputBoxValidationSeverity$1, bf as InlineSuggestionList, bg as InlineCompletionTriggerKind$1, bh as InlineSuggestion, bi as DocumentDropEdit$1, bj as SnippetTextEdit$1, bk as MissingExtensionDependency, bl as TextTabInput$1, bm as DataBreakpoint, bn as InteractiveWindowInput, bo as TextMergeTabInput, bp as IExtensionService, bq as ISearchService, br as IWorkspaceTrustRequestService, bs as IRequestService, bt as IEditSessionIdentityService, bu as IWorkspaceEditingService, bv as ITimerService, bw as IExtensionsWorkbenchService, bx as IWorkbenchExtensionEnablementService, by as URITransformerService, bz as StandardTokenType, bA as areSameExtensions, bB as pathIncludedInQuery, bC as getExcludes, bD as InlineValueContext$1, bE as NotebookCellData$2, bF as DataTransfer$2, bG as NotebookCellOutput$2, bH as CellKind, bI as NotebookCellKind$2, bJ as DataTransferItem$2, bK as NotebookCellOutputItem$2 } from './missing-services.js';
import { _ as __decorate, E as Emitter$1, a as __param, b as __classPrivateFieldSet, c as __classPrivateFieldGet, F as FileSystemProviderErrorCode, I as IEditorService, d as IEditorGroupsService, e as IProductService, m as mark, g as getMarks, S as Services, D as DebugConfigurationProviderTriggerKind$1, f as FileType$1, h as FilePermission$1, i as SIDE_GROUP, A as ACTIVE_GROUP, p as preferredSideBySideGroupDirection, j as IUriIdentityService, k as IPaneCompositePartService, l as ITextFileService, n as IFileService, o as IWorkbenchEnvironmentService, q as IWorkingCopyFileService, r as IPathService, s as ILanguageStatusService, t as IHostService, u as IDebugService, v as FileOperationError, w as refineServiceDecorator, x as toFileSystemProviderErrorCode } from './services2.js';
import { C as CancellationTokenSource$1 } from './cancellation.js';
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { marked } from 'monaco-editor/esm/vs/base/common/marked/marked.js';
import { parseHrefAndDimensions, isMarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { isNonEmptyArray, asArray, groupBy as groupBy$1, equals, coalesce, isFalsyOrEmpty } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { assertType, validateConstraint, assertIsDefined, withNullAsUndefined, isString, isNumber, isObject, isDefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { revive, parse as parse$1 } from 'monaco-editor/esm/vs/base/common/marshalling.js';
import { mixin, cloneAndChange, equals as equals$1, deepClone, deepFreeze } from 'monaco-editor/esm/vs/base/common/objects.js';
import { MarkerSeverity, IMarkerService } from 'monaco-editor/esm/vs/platform/markers/common/markers.js';
import { VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { once } from 'monaco-editor/esm/vs/base/common/functional.js';
import { Mimes } from 'monaco-editor/esm/vs/base/common/mime.js';
import { createStringDataTransferItem, VSDataTransfer, UriList } from 'monaco-editor/esm/vs/base/common/dataTransfer.js';
import { createDecorator as createDecorator$1, IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Disposable as Disposable$1, toDisposable, dispose, RefCountedDisposable, MutableDisposable, DisposableStore, combinedDisposable, SafeDisposable, DisposableMap } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { LogLevel as LogLevel$1, ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { CommandsRegistry, ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { Schemas, FileAccess } from 'monaco-editor/esm/vs/base/common/network.js';
import { ExtUri, basename, dirname, basenameOrAuthority, relativePath, extUriBiasedIgnorePathCase, joinPath, originalFSPath, extUri, isAbsolutePath, isEqual } from 'monaco-editor/esm/vs/base/common/resources.js';
import { Event, DebounceEmitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { ResourceMap as ResourceMap$1 } from 'monaco-editor/esm/vs/base/common/map.js';
import { MirrorTextModel } from 'monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js';
import { ok } from 'monaco-editor/esm/vs/base/common/assert.js';
import { isFalsyOrWhitespace, compare, regExpLeadsToEndlessLoop, splitLines, regExpFlags, rtrim, containsUppercaseCharacter, escapeRegExpCharacters, commonPrefixLength } from 'monaco-editor/esm/vs/base/common/strings.js';
import { getWordAtText, ensureValidWordDefinition } from 'monaco-editor/esm/vs/editor/common/core/wordHelper.js';
import { onUnexpectedExternalError, canceled, transformErrorForSerialization, onUnexpectedError, illegalArgument, CancellationError as CancellationError$1, isCancellationError, ErrorNoTelemetry } from 'monaco-editor/esm/vs/base/common/errors.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import Severity$1 from 'monaco-editor/esm/vs/base/common/severity.js';
import { ThemeIcon as ThemeIcon$2 } from 'monaco-editor/esm/vs/base/common/themables.js';
import { LinkedList } from 'monaco-editor/esm/vs/base/common/linkedList.js';
import { B as Barrier, a as asPromise, r as raceCancellationError } from './async.js';
import { Severity, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { Workspace, WorkspaceFolder, IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { TernarySearchTree } from 'monaco-editor/esm/vs/base/common/ternarySearchTree.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { Action, toAction } from 'monaco-editor/esm/vs/base/common/actions.js';
import { IDialogService } from 'monaco-editor/esm/vs/platform/dialogs/common/dialogs.js';
import { Progress, IProgressService } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { EditOperation } from 'monaco-editor/esm/vs/editor/common/core/editOperation.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { IEditorWorkerService } from 'monaco-editor/esm/vs/editor/common/services/editorWorker.js';
import { IdGenerator } from 'monaco-editor/esm/vs/base/common/idGenerator.js';
import { Lazy } from 'monaco-editor/esm/vs/base/common/lazy.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
import { t as toLocalResource } from './resources.js';
import { OverviewRulerLane as OverviewRulerLane$1, shouldSynchronizeModel } from 'monaco-editor/esm/vs/editor/common/model.js';
import { SnippetParser } from 'monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetParser.js';
import { SnippetController2 } from 'monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetController2.js';
import { EditorState } from 'monaco-editor/esm/vs/editor/contrib/editorState/browser/editorState.js';
import { TextEditorCursorStyle as TextEditorCursorStyle$2 } from 'monaco-editor/esm/vs/editor/common/config/editorOptions.js';
import { getCodeEditor, isCodeEditor, isDiffEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { IBulkEditService, ResourceTextEdit, ResourceFileEdit, ResourceEdit } from 'monaco-editor/esm/vs/editor/browser/services/bulkEditService.js';
import { RunOnceScheduler, timeout, IntervalTimer, DeferredPromise, disposableTimeout } from 'monaco-editor/esm/vs/base/common/async.js';
import { matchesScheme, IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { encodeSemanticTokensDto } from 'monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js';
import { InlineCompletionTriggerKind as InlineCompletionTriggerKind$2 } from 'monaco-editor/esm/vs/editor/common/languages.js';
import { LanguageFeatureRegistry } from 'monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js';
import { LANGUAGE_DEFAULT, setTimeout0, isNative, isLittleEndian } from 'monaco-editor/esm/vs/base/common/platform.js';
import { ILanguageConfigurationService } from 'monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js';
import { ILanguageFeaturesService } from 'monaco-editor/esm/vs/editor/common/services/languageFeatures.js';
import { Configuration, ConfigurationChangeEvent } from 'monaco-editor/esm/vs/platform/configuration/common/configurationModels.js';
import { OVERRIDE_PROPERTY_REGEX, Extensions } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { g as getScopes } from './configurationRegistry.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { ExtensionIdentifier } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
import { dirname as dirname$1, normalize, posix, relative } from 'monaco-editor/esm/vs/base/common/path.js';
import { u as untildify } from './labels.js';
import { isMultilineRegexSource } from 'monaco-editor/esm/vs/editor/common/model/textModelSearch.js';
import { j as join, A as AbstractVariableResolverService, c as convertToVSCPaths, a as convertToDAPaths, i as isDebuggerMainContribution, b as isSessionAttach, d as isAbsolute } from './variableResolver.js';
import { GLOBSTAR, splitGlobAware } from 'monaco-editor/esm/vs/base/common/glob.js';
import { ServiceCollection } from 'monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js';
import { cwd, env as env$1 } from 'monaco-editor/esm/vs/base/common/process.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { IWorkspaceTrustManagementService } from 'monaco-editor/esm/vs/platform/workspace/common/workspaceTrust.js';
import { StateMachine, LinkComputer } from 'monaco-editor/esm/vs/editor/common/languages/linkComputer.js';
import { registerSingleton } from 'monaco-editor/esm/vs/platform/instantiation/common/extensions.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { score } from 'monaco-editor/esm/vs/editor/common/languageSelector.js';
import { IndentAction as IndentAction$1 } from 'monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js';
class EventProfiling {
    constructor(name) {
        this.listenerCount = 0;
        this.invocationCount = 0;
        this.elapsedOverall = 0;
        this.durations = [];
        this.name = `${name}_${EventProfiling._idPool++}`;
        EventProfiling.all.add(this);
    }
    start(listenerCount) {
        this._stopWatch = ( (new StopWatch(true)));
        this.listenerCount = listenerCount;
    }
    stop() {
        if (this._stopWatch) {
            const elapsed = this._stopWatch.elapsed();
            this.durations.push(elapsed);
            this.elapsedOverall += elapsed;
            this.invocationCount += 1;
            this._stopWatch = undefined;
        }
    }
}
EventProfiling.all = ( (new Set()));
EventProfiling._idPool = 0;
let _globalLeakWarningThreshold = -1;
class LeakageMonitor {
    constructor(threshold, name = ( (Math.random().toString(18))).slice(2, 5)) {
        this.threshold = threshold;
        this.name = name;
        this._warnCountdown = 0;
    }
    dispose() {
        this._stacks?.clear();
    }
    check(stack, listenerCount) {
        const threshold = this.threshold;
        if (threshold <= 0 || listenerCount < threshold) {
            return undefined;
        }
        if (!this._stacks) {
            this._stacks = ( (new Map()));
        }
        const count = (this._stacks.get(stack.value) || 0);
        this._stacks.set(stack.value, count + 1);
        this._warnCountdown -= 1;
        if (this._warnCountdown <= 0) {
            this._warnCountdown = threshold * 0.5;
            let topStack;
            let topCount = 0;
            for (const [stack, count] of this._stacks) {
                if (!topStack || topCount < count) {
                    topStack = stack;
                    topCount = count;
                }
            }
            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
            console.warn(topStack);
        }
        return () => {
            const count = (this._stacks.get(stack.value) || 0);
            this._stacks.set(stack.value, count - 1);
        };
    }
}
class Stacktrace {
    static create() {
        return (
             (new Stacktrace(( (new Error())).stack ?? ''))
        );
    }
    constructor(value) {
        this.value = value;
    }
    print() {
        console.warn(this.value.split('\n').slice(2).join('\n'));
    }
}
class Listener {
    constructor(callback, callbackThis, stack) {
        this.callback = callback;
        this.callbackThis = callbackThis;
        this.stack = stack;
        this.subscription = ( (new SafeDisposable()));
    }
    invoke(e) {
        this.callback.call(this.callbackThis, e);
    }
}
class Emitter {
    constructor(options) {
        this._disposed = false;
        this._options = options;
        this._leakageMon = this._options?.leakWarningThreshold ? ( (new LeakageMonitor(this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold))) : undefined;
        this._perfMon = this._options?._profName ? ( (new EventProfiling(this._options._profName))) : undefined;
        this._deliveryQueue = this._options?.deliveryQueue;
    }
    dispose() {
        if (!this._disposed) {
            this._disposed = true;
            if (this._listeners) {
                this._listeners.clear();
            }
            this._deliveryQueue?.clear(this);
            this._options?.onDidRemoveLastListener?.();
            this._leakageMon?.dispose();
        }
    }
    get event() {
        if (!this._event) {
            this._event = (callback, thisArgs, disposables) => {
                if (!this._listeners) {
                    this._listeners = ( (new LinkedList()));
                }
                if (this._leakageMon && this._listeners.size > this._leakageMon.threshold * 3) {
                    console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);
                    return Disposable$1.None;
                }
                const firstListener = this._listeners.isEmpty();
                if (firstListener && this._options?.onWillAddFirstListener) {
                    this._options.onWillAddFirstListener(this);
                }
                let removeMonitor;
                let stack;
                if (this._leakageMon && this._listeners.size >= Math.ceil(this._leakageMon.threshold * 0.2)) {
                    stack = Stacktrace.create();
                    removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);
                }
                const listener = ( (new Listener(callback, thisArgs, stack)));
                const removeListener = this._listeners.push(listener);
                if (firstListener && this._options?.onDidAddFirstListener) {
                    this._options.onDidAddFirstListener(this);
                }
                if (this._options?.onDidAddListener) {
                    this._options.onDidAddListener(this, callback, thisArgs);
                }
                const result = listener.subscription.set(() => {
                    removeMonitor?.();
                    if (!this._disposed) {
                        this._options?.onWillRemoveListener?.(this);
                        removeListener();
                        if (this._options && this._options.onDidRemoveLastListener) {
                            const hasListeners = (this._listeners && !this._listeners.isEmpty());
                            if (!hasListeners) {
                                this._options.onDidRemoveLastListener(this);
                            }
                        }
                    }
                });
                if (disposables instanceof DisposableStore) {
                    disposables.add(result);
                }
                else if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    fire(event) {
        if (this._listeners) {
            if (!this._deliveryQueue) {
                this._deliveryQueue = ( (new PrivateEventDeliveryQueue()));
            }
            for (const listener of this._listeners) {
                this._deliveryQueue.push(this, listener, event);
            }
            this._perfMon?.start(this._deliveryQueue.size);
            this._deliveryQueue.deliver();
            this._perfMon?.stop();
        }
    }
    hasListeners() {
        if (!this._listeners) {
            return false;
        }
        return !this._listeners.isEmpty();
    }
}
class EventDeliveryQueue {
    constructor() {
        this._queue = ( (new LinkedList()));
    }
    get size() {
        return this._queue.size;
    }
    push(emitter, listener, event) {
        this._queue.push(( (new EventDeliveryQueueElement(emitter, listener, event))));
    }
    clear(emitter) {
        const newQueue = ( (new LinkedList()));
        for (const element of this._queue) {
            if (element.emitter !== emitter) {
                newQueue.push(element);
            }
        }
        this._queue = newQueue;
    }
    deliver() {
        while (this._queue.size > 0) {
            const element = this._queue.shift();
            try {
                element.listener.invoke(element.event);
            }
            catch (e) {
                onUnexpectedError(e);
            }
        }
    }
}
class PrivateEventDeliveryQueue extends EventDeliveryQueue {
    clear(emitter) {
        this._queue.clear();
    }
}
class EventDeliveryQueueElement {
    constructor(emitter, listener, event) {
        this.emitter = emitter;
        this.listener = listener;
        this.event = event;
    }
}
class AsyncEmitter extends Emitter {
    async fireAsync(data, token, promiseJoin) {
        if (!this._listeners) {
            return;
        }
        if (!this._asyncDeliveryQueue) {
            this._asyncDeliveryQueue = ( (new LinkedList()));
        }
        for (const listener of this._listeners) {
            this._asyncDeliveryQueue.push([listener, data]);
        }
        while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {
            const [listener, data] = this._asyncDeliveryQueue.shift();
            const thenables = [];
            const event = {
                ...data,
                token,
                waitUntil: (p) => {
                    if (Object.isFrozen(thenables)) {
                        throw new Error('waitUntil can NOT be called asynchronous');
                    }
                    if (promiseJoin) {
                        p = promiseJoin(p, listener.callback);
                    }
                    thenables.push(p);
                }
            };
            try {
                listener.invoke(event);
            }
            catch (e) {
                onUnexpectedError(e);
                continue;
            }
            await Promise.allSettled(thenables).then(values => {
                for (const value of values) {
                    if (value.status === 'rejected') {
                        onUnexpectedError(value.reason);
                    }
                }
            });
        }
    }
}
const FoldingRangeKind$2 = monaco.languages.FoldingRangeKind;
var _a$1, _b;
class ResourceMapEntry {
    constructor(uri, value) {
        this.uri = uri;
        this.value = value;
    }
}
class ResourceMap {
    constructor(mapOrKeyFn, toKey) {
        this[_a$1] = 'ResourceMap';
        if (mapOrKeyFn instanceof ResourceMap) {
            this.map = ( (new Map(mapOrKeyFn.map)));
            this.toKey = toKey ?? ResourceMap.defaultToKey;
        }
        else {
            this.map = ( (new Map()));
            this.toKey = mapOrKeyFn ?? ResourceMap.defaultToKey;
        }
    }
    set(resource, value) {
        this.map.set(this.toKey(resource), ( (new ResourceMapEntry(resource, value))));
        return this;
    }
    get(resource) {
        return this.map.get(this.toKey(resource))?.value;
    }
    has(resource) {
        return this.map.has(this.toKey(resource));
    }
    get size() {
        return this.map.size;
    }
    clear() {
        this.map.clear();
    }
    delete(resource) {
        return this.map.delete(this.toKey(resource));
    }
    forEach(clb, thisArg) {
        if (typeof thisArg !== 'undefined') {
            clb = clb.bind(thisArg);
        }
        for (const [_, entry] of this.map) {
            clb(entry.value, entry.uri, this);
        }
    }
    *values() {
        for (const entry of ( (this.map.values()))) {
            yield entry.value;
        }
    }
    *keys() {
        for (const entry of ( (this.map.values()))) {
            yield entry.uri;
        }
    }
    *entries() {
        for (const entry of ( (this.map.values()))) {
            yield [entry.uri, entry.value];
        }
    }
    *[(_a$1 = Symbol.toStringTag, Symbol.iterator)]() {
        for (const [, entry] of this.map) {
            yield [entry.uri, entry.value];
        }
    }
}
ResourceMap.defaultToKey = (resource) => ( (resource.toString()));
class ResourceSet {
    constructor(entriesOrKey, toKey) {
        this[_b] = 'ResourceSet';
        if (!entriesOrKey || typeof entriesOrKey === 'function') {
            this._map = ( (new ResourceMap(entriesOrKey)));
        }
        else {
            this._map = ( (new ResourceMap(toKey)));
            entriesOrKey.forEach(this.add, this);
        }
    }
    get size() {
        return this._map.size;
    }
    add(value) {
        this._map.set(value, value);
        return this;
    }
    clear() {
        this._map.clear();
    }
    delete(value) {
        return this._map.delete(value);
    }
    forEach(callbackfn, thisArg) {
        this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));
    }
    has(value) {
        return this._map.has(value);
    }
    entries() {
        return this._map.entries();
    }
    keys() {
        return (
             (this._map.keys())
        );
    }
    values() {
        return (
             (this._map.keys())
        );
    }
    [(_b = Symbol.toStringTag, Symbol.iterator)]() {
        return (
             (this.keys())
        );
    }
}
function groupBy(data, groupFn) {
    const result = Object.create(null);
    for (const element of data) {
        const key = groupFn(element);
        let target = result[key];
        if (!target) {
            target = result[key] = [];
        }
        target.push(element);
    }
    return result;
}
function diffSets(before, after) {
    const removed = [];
    const added = [];
    for (const element of before) {
        if (!after.has(element)) {
            removed.push(element);
        }
    }
    for (const element of after) {
        if (!before.has(element)) {
            added.push(element);
        }
    }
    return { removed, added };
}
function diffMaps(before, after) {
    const removed = [];
    const added = [];
    for (const [index, value] of before) {
        if (!after.has(index)) {
            removed.push(value);
        }
    }
    for (const [index, value] of after) {
        if (!before.has(index)) {
            added.push(value);
        }
    }
    return { removed, added };
}
class Counter {
    constructor() {
        this._next = 0;
    }
    getNext() {
        return this._next++;
    }
}
function createDecorator(mapFn) {
    return (target, key, descriptor) => {
        let fnKey = null;
        let fn = null;
        if (typeof descriptor.value === 'function') {
            fnKey = 'value';
            fn = descriptor.value;
        }
        else if (typeof descriptor.get === 'function') {
            fnKey = 'get';
            fn = descriptor.get;
        }
        if (!fn) {
            throw new Error('not supported');
        }
        descriptor[fnKey] = mapFn(fn, key);
    };
}
function throttle(delay, reducer, initialValueProvider) {
    return (
         (createDecorator((fn, key) => {
            const timerKey = `$throttle$timer$${key}`;
            const resultKey = `$throttle$result$${key}`;
            const lastRunKey = `$throttle$lastRun$${key}`;
            const pendingKey = `$throttle$pending$${key}`;
            return function (...args) {
                if (!this[resultKey]) {
                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
                }
                if (this[lastRunKey] === null || this[lastRunKey] === undefined) {
                    this[lastRunKey] = -Number.MAX_VALUE;
                }
                if (reducer) {
                    this[resultKey] = reducer(this[resultKey], ...args);
                }
                if (this[pendingKey]) {
                    return;
                }
                const nextTime = this[lastRunKey] + delay;
                if (nextTime <= Date.now()) {
                    this[lastRunKey] = Date.now();
                    fn.apply(this, [this[resultKey]]);
                    this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
                }
                else {
                    this[pendingKey] = true;
                    this[timerKey] = setTimeout(() => {
                        this[pendingKey] = false;
                        this[lastRunKey] = Date.now();
                        fn.apply(this, [this[resultKey]]);
                        this[resultKey] = initialValueProvider ? initialValueProvider() : undefined;
                    }, nextTime - Date.now());
                }
            };
        }))
    );
}
var TextEditorCursorStyle$1;
( ((function(TextEditorCursorStyle) {
    TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
    TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
    TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
    TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
    TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle$1 || (TextEditorCursorStyle$1 = {}))));
function cursorStyleToString(cursorStyle) {
    switch (cursorStyle) {
        case TextEditorCursorStyle$1.Line: return 'line';
        case TextEditorCursorStyle$1.Block: return 'block';
        case TextEditorCursorStyle$1.Underline: return 'underline';
        case TextEditorCursorStyle$1.LineThin: return 'line-thin';
        case TextEditorCursorStyle$1.BlockOutline: return 'block-outline';
        case TextEditorCursorStyle$1.UnderlineThin: return 'underline-thin';
    }
}
var UIKind$1;
( ((function(UIKind) {
    UIKind[UIKind["Desktop"] = 1] = "Desktop";
    UIKind[UIKind["Web"] = 2] = "Web";
})(UIKind$1 || (UIKind$1 = {}))));
var Selection$1;
( ((function(Selection) {
    function to(selection) {
        const { selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn } = selection;
        const start = new Position$3(selectionStartLineNumber - 1, selectionStartColumn - 1);
        const end = new Position$3(positionLineNumber - 1, positionColumn - 1);
        return new Selection$2(start, end);
    }
    Selection.to = to;
    function from(selection) {
        const { anchor, active } = selection;
        return {
            selectionStartLineNumber: anchor.line + 1,
            selectionStartColumn: anchor.character + 1,
            positionLineNumber: active.line + 1,
            positionColumn: active.character + 1
        };
    }
    Selection.from = from;
})(Selection$1 || (Selection$1 = {}))));
var Range$1;
( ((function(Range) {
    function from(range) {
        if (!range) {
            return undefined;
        }
        const { start, end } = range;
        return {
            startLineNumber: start.line + 1,
            startColumn: start.character + 1,
            endLineNumber: end.line + 1,
            endColumn: end.character + 1
        };
    }
    Range.from = from;
    function to(range) {
        if (!range) {
            return undefined;
        }
        const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
        return new Range$3(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
    }
    Range.to = to;
})(Range$1 || (Range$1 = {}))));
var TokenType;
( ((function(TokenType) {
    function to(type) {
        switch (type) {
            case 1 : return StandardTokenType.Comment;
            case 0 : return StandardTokenType.Other;
            case 3 : return StandardTokenType.RegEx;
            case 2 : return StandardTokenType.String;
        }
    }
    TokenType.to = to;
})(TokenType || (TokenType = {}))));
var Position$1;
( ((function(Position) {
    function to(position) {
        return new Position$3(position.lineNumber - 1, position.column - 1);
    }
    Position.to = to;
    function from(position) {
        return { lineNumber: position.line + 1, column: position.character + 1 };
    }
    Position.from = from;
})(Position$1 || (Position$1 = {}))));
var DocumentSelector;
( ((function(DocumentSelector) {
    function from(value, uriTransformer) {
        return coalesce(( (asArray(value).map(sel => _doTransformDocumentSelector(sel, uriTransformer)))));
    }
    DocumentSelector.from = from;
    function _doTransformDocumentSelector(selector, uriTransformer) {
        if (typeof selector === 'string') {
            return {
                $serialized: true,
                language: selector
            };
        }
        if (selector) {
            return {
                $serialized: true,
                language: selector.language,
                scheme: _transformScheme(selector.scheme, uriTransformer),
                pattern: GlobPattern.from(selector.pattern) ?? undefined,
                exclusive: selector.exclusive,
                notebookType: selector.notebookType
            };
        }
        return undefined;
    }
    function _transformScheme(scheme, uriTransformer) {
        if (uriTransformer && typeof scheme === 'string') {
            return uriTransformer.transformOutgoingScheme(scheme);
        }
        return scheme;
    }
})(DocumentSelector || (DocumentSelector = {}))));
var DiagnosticTag$1;
( ((function(DiagnosticTag) {
    function from(value) {
        switch (value) {
            case DiagnosticTag$2.Unnecessary:
                return 1 ;
            case DiagnosticTag$2.Deprecated:
                return 2 ;
        }
        return undefined;
    }
    DiagnosticTag.from = from;
    function to(value) {
        switch (value) {
            case 1 :
                return DiagnosticTag$2.Unnecessary;
            case 2 :
                return DiagnosticTag$2.Deprecated;
            default:
                return undefined;
        }
    }
    DiagnosticTag.to = to;
})(DiagnosticTag$1 || (DiagnosticTag$1 = {}))));
var Diagnostic$1;
( ((function(Diagnostic) {
    function from(value) {
        let code;
        if (value.code) {
            if (isString(value.code) || isNumber(value.code)) {
                code = String(value.code);
            }
            else {
                code = {
                    value: String(value.code.value),
                    target: value.code.target,
                };
            }
        }
        return {
            ...Range$1.from(value.range),
            message: value.message,
            source: value.source,
            code,
            severity: DiagnosticSeverity$1.from(value.severity),
            relatedInformation: value.relatedInformation && ( (value.relatedInformation.map(DiagnosticRelatedInformation$1.from))),
            tags: Array.isArray(value.tags) ? coalesce(( (value.tags.map(DiagnosticTag$1.from)))) : undefined,
        };
    }
    Diagnostic.from = from;
    function to(value) {
        const res = new Diagnostic$2(Range$1.to(value), value.message, DiagnosticSeverity$1.to(value.severity));
        res.source = value.source;
        res.code = isString(value.code) ? value.code : value.code?.value;
        res.relatedInformation = value.relatedInformation && ( (value.relatedInformation.map(DiagnosticRelatedInformation$1.to)));
        res.tags = value.tags && coalesce(( (value.tags.map(DiagnosticTag$1.to))));
        return res;
    }
    Diagnostic.to = to;
})(Diagnostic$1 || (Diagnostic$1 = {}))));
var DiagnosticRelatedInformation$1;
( ((function(DiagnosticRelatedInformation) {
    function from(value) {
        return {
            ...Range$1.from(value.location.range),
            message: value.message,
            resource: value.location.uri
        };
    }
    DiagnosticRelatedInformation.from = from;
    function to(value) {
        return new DiagnosticRelatedInformation$2(new Location$1(value.resource, Range$1.to(value)), value.message);
    }
    DiagnosticRelatedInformation.to = to;
})(DiagnosticRelatedInformation$1 || (DiagnosticRelatedInformation$1 = {}))));
var DiagnosticSeverity$1;
( ((function(DiagnosticSeverity) {
    function from(value) {
        switch (value) {
            case DiagnosticSeverity$2.Error:
                return MarkerSeverity.Error;
            case DiagnosticSeverity$2.Warning:
                return MarkerSeverity.Warning;
            case DiagnosticSeverity$2.Information:
                return MarkerSeverity.Info;
            case DiagnosticSeverity$2.Hint:
                return MarkerSeverity.Hint;
        }
        return MarkerSeverity.Error;
    }
    DiagnosticSeverity.from = from;
    function to(value) {
        switch (value) {
            case MarkerSeverity.Info:
                return DiagnosticSeverity$2.Information;
            case MarkerSeverity.Warning:
                return DiagnosticSeverity$2.Warning;
            case MarkerSeverity.Error:
                return DiagnosticSeverity$2.Error;
            case MarkerSeverity.Hint:
                return DiagnosticSeverity$2.Hint;
            default:
                return DiagnosticSeverity$2.Error;
        }
    }
    DiagnosticSeverity.to = to;
})(DiagnosticSeverity$1 || (DiagnosticSeverity$1 = {}))));
var ViewColumn$1;
( ((function(ViewColumn) {
    function from(column) {
        if (typeof column === 'number' && column >= ViewColumn$2.One) {
            return column - 1;
        }
        if (column === ViewColumn$2.Beside) {
            return SIDE_GROUP;
        }
        return ACTIVE_GROUP;
    }
    ViewColumn.from = from;
    function to(position) {
        if (typeof position === 'number' && position >= 0) {
            return position + 1;
        }
        throw new Error(`invalid 'EditorGroupColumn'`);
    }
    ViewColumn.to = to;
})(ViewColumn$1 || (ViewColumn$1 = {}))));
function isDecorationOptions(something) {
    return (typeof something.range !== 'undefined');
}
function isDecorationOptionsArr(something) {
    if (something.length === 0) {
        return true;
    }
    return isDecorationOptions(something[0]) ? true : false;
}
var MarkdownString$1;
( ((function(MarkdownString) {
    function fromMany(markup) {
        return (
             (markup.map(MarkdownString.from))
        );
    }
    MarkdownString.fromMany = fromMany;
    function isCodeblock(thing) {
        return thing && typeof thing === 'object'
            && typeof thing.language === 'string'
            && typeof thing.value === 'string';
    }
    function from(markup) {
        let res;
        if (isCodeblock(markup)) {
            const { language, value } = markup;
            res = { value: '```' + language + '\n' + value + '\n```\n' };
        }
        else if (MarkdownString$2.isMarkdownString(markup)) {
            res = { value: markup.value, isTrusted: markup.isTrusted, supportThemeIcons: markup.supportThemeIcons, supportHtml: markup.supportHtml, baseUri: markup.baseUri };
        }
        else if (typeof markup === 'string') {
            res = { value: markup };
        }
        else {
            res = { value: '' };
        }
        const resUris = Object.create(null);
        res.uris = resUris;
        const collectUri = (href) => {
            try {
                let uri = ( (URI.parse(href, true)));
                uri = uri.with({ query: _uriMassage(uri.query, resUris) });
                resUris[href] = uri;
            }
            catch (e) {
            }
            return '';
        };
        const renderer = new marked.Renderer();
        renderer.link = collectUri;
        renderer.image = href => typeof href === 'string' ? collectUri(parseHrefAndDimensions(href).href) : '';
        marked(res.value, { renderer });
        return res;
    }
    MarkdownString.from = from;
    function _uriMassage(part, bucket) {
        if (!part) {
            return part;
        }
        let data;
        try {
            data = parse$1(part);
        }
        catch (e) {
        }
        if (!data) {
            return part;
        }
        let changed = false;
        data = cloneAndChange(data, value => {
            if (URI.isUri(value)) {
                const key = `__uri_${( ( Math.random().toString(16))).slice(2, 8)}`;
                bucket[key] = value;
                changed = true;
                return key;
            }
            else {
                return undefined;
            }
        });
        if (!changed) {
            return part;
        }
        return JSON.stringify(data);
    }
    function to(value) {
        const result = new MarkdownString$2(value.value, value.supportThemeIcons);
        result.isTrusted = value.isTrusted;
        result.supportHtml = value.supportHtml;
        result.baseUri = value.baseUri ? ( (URI.from(value.baseUri))) : undefined;
        return result;
    }
    MarkdownString.to = to;
    function fromStrict(value) {
        if (!value) {
            return undefined;
        }
        return typeof value === 'string' ? value : MarkdownString.from(value);
    }
    MarkdownString.fromStrict = fromStrict;
})(MarkdownString$1 || (MarkdownString$1 = {}))));
function fromRangeOrRangeWithMessage(ranges) {
    if (isDecorationOptionsArr(ranges)) {
        return (
             (ranges.map((r) => {
                return {
                    range: Range$1.from(r.range),
                    hoverMessage: Array.isArray(r.hoverMessage)
                        ? MarkdownString$1.fromMany(r.hoverMessage)
                        : (r.hoverMessage ? MarkdownString$1.from(r.hoverMessage) : undefined),
                    renderOptions:  r.renderOptions
                };
            }))
        );
    }
    else {
        return (
             (ranges.map((r) => {
                return {
                    range: Range$1.from(r)
                };
            }))
        );
    }
}
function pathOrURIToURI(value) {
    if (typeof value === 'undefined') {
        return value;
    }
    if (typeof value === 'string') {
        return URI.file(value);
    }
    else {
        return value;
    }
}
var ThemableDecorationAttachmentRenderOptions;
( ((function(ThemableDecorationAttachmentRenderOptions) {
    function from(options) {
        if (typeof options === 'undefined') {
            return options;
        }
        return {
            contentText: options.contentText,
            contentIconPath: options.contentIconPath ? pathOrURIToURI(options.contentIconPath) : undefined,
            border: options.border,
            borderColor: options.borderColor,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            color: options.color,
            backgroundColor: options.backgroundColor,
            margin: options.margin,
            width: options.width,
            height: options.height,
        };
    }
    ThemableDecorationAttachmentRenderOptions.from = from;
})(
    ThemableDecorationAttachmentRenderOptions || (ThemableDecorationAttachmentRenderOptions = {})
)));
var ThemableDecorationRenderOptions;
( ((function(ThemableDecorationRenderOptions) {
    function from(options) {
        if (typeof options === 'undefined') {
            return options;
        }
        return {
            backgroundColor: options.backgroundColor,
            outline: options.outline,
            outlineColor: options.outlineColor,
            outlineStyle: options.outlineStyle,
            outlineWidth: options.outlineWidth,
            border: options.border,
            borderColor: options.borderColor,
            borderRadius: options.borderRadius,
            borderSpacing: options.borderSpacing,
            borderStyle: options.borderStyle,
            borderWidth: options.borderWidth,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            cursor: options.cursor,
            color: options.color,
            opacity: options.opacity,
            letterSpacing: options.letterSpacing,
            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,
            gutterIconSize: options.gutterIconSize,
            overviewRulerColor: options.overviewRulerColor,
            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
        };
    }
    ThemableDecorationRenderOptions.from = from;
})(ThemableDecorationRenderOptions || (ThemableDecorationRenderOptions = {}))));
var DecorationRangeBehavior$1;
( ((function(DecorationRangeBehavior) {
    function from(value) {
        if (typeof value === 'undefined') {
            return value;
        }
        switch (value) {
            case DecorationRangeBehavior$2.OpenOpen:
                return 0 ;
            case DecorationRangeBehavior$2.ClosedClosed:
                return 1 ;
            case DecorationRangeBehavior$2.OpenClosed:
                return 2 ;
            case DecorationRangeBehavior$2.ClosedOpen:
                return 3 ;
        }
    }
    DecorationRangeBehavior.from = from;
})(DecorationRangeBehavior$1 || (DecorationRangeBehavior$1 = {}))));
var DecorationRenderOptions;
( ((function(DecorationRenderOptions) {
    function from(options) {
        return {
            isWholeLine: options.isWholeLine,
            rangeBehavior: options.rangeBehavior ? DecorationRangeBehavior$1.from(options.rangeBehavior) : undefined,
            overviewRulerLane: options.overviewRulerLane,
            light: options.light ? ThemableDecorationRenderOptions.from(options.light) : undefined,
            dark: options.dark ? ThemableDecorationRenderOptions.from(options.dark) : undefined,
            backgroundColor: options.backgroundColor,
            outline: options.outline,
            outlineColor: options.outlineColor,
            outlineStyle: options.outlineStyle,
            outlineWidth: options.outlineWidth,
            border: options.border,
            borderColor: options.borderColor,
            borderRadius: options.borderRadius,
            borderSpacing: options.borderSpacing,
            borderStyle: options.borderStyle,
            borderWidth: options.borderWidth,
            fontStyle: options.fontStyle,
            fontWeight: options.fontWeight,
            textDecoration: options.textDecoration,
            cursor: options.cursor,
            color: options.color,
            opacity: options.opacity,
            letterSpacing: options.letterSpacing,
            gutterIconPath: options.gutterIconPath ? pathOrURIToURI(options.gutterIconPath) : undefined,
            gutterIconSize: options.gutterIconSize,
            overviewRulerColor: options.overviewRulerColor,
            before: options.before ? ThemableDecorationAttachmentRenderOptions.from(options.before) : undefined,
            after: options.after ? ThemableDecorationAttachmentRenderOptions.from(options.after) : undefined,
        };
    }
    DecorationRenderOptions.from = from;
})(DecorationRenderOptions || (DecorationRenderOptions = {}))));
var TextEdit$1;
( ((function(TextEdit) {
    function from(edit) {
        return {
            text: edit.newText,
            eol: edit.newEol && EndOfLine$1.from(edit.newEol),
            range: Range$1.from(edit.range)
        };
    }
    TextEdit.from = from;
    function to(edit) {
        const result = new TextEdit$2(Range$1.to(edit.range), edit.text);
        result.newEol = (typeof edit.eol === 'undefined' ? undefined : EndOfLine$1.to(edit.eol));
        return result;
    }
    TextEdit.to = to;
})(TextEdit$1 || (TextEdit$1 = {}))));
var WorkspaceEdit$1;
( ((function(WorkspaceEdit) {
    function from(value, versionInfo) {
        const result = {
            edits: []
        };
        if (value instanceof WorkspaceEdit$2) {
            const toCreate = ( (new ResourceSet()));
            for (const entry of value._allEntries()) {
                if (entry._type === 1  && URI.isUri(entry.to) && entry.from === undefined) {
                    toCreate.add(entry.to);
                }
            }
            for (const entry of value._allEntries()) {
                if (entry._type === 1 ) {
                    result.edits.push({
                        oldResource: entry.from,
                        newResource: entry.to,
                        options: { ...entry.options, contentsBase64: entry.options?.contents && encodeBase64(VSBuffer.wrap(entry.options.contents)) },
                        metadata: entry.metadata
                    });
                }
                else if (entry._type === 2 ) {
                    result.edits.push({
                        resource: entry.uri,
                        textEdit: TextEdit$1.from(entry.edit),
                        versionId: !toCreate.has(entry.uri) ? versionInfo?.getTextDocumentVersion(entry.uri) : undefined,
                        metadata: entry.metadata
                    });
                }
                else if (entry._type === 6 ) {
                    result.edits.push({
                        resource: entry.uri,
                        textEdit: {
                            range: Range$1.from(entry.range),
                            text: entry.edit.value,
                            insertAsSnippet: true
                        },
                        versionId: !toCreate.has(entry.uri) ? versionInfo?.getTextDocumentVersion(entry.uri) : undefined,
                        metadata: entry.metadata
                    });
                }
                else if (entry._type === 3 ) {
                    result.edits.push({
                        metadata: entry.metadata,
                        resource: entry.uri,
                        cellEdit: entry.edit,
                        notebookMetadata: entry.notebookMetadata,
                        notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri)
                    });
                }
                else if (entry._type === 5 ) {
                    result.edits.push({
                        metadata: entry.metadata,
                        resource: entry.uri,
                        notebookVersionId: versionInfo?.getNotebookDocumentVersion(entry.uri),
                        cellEdit: {
                            editType: 1 ,
                            index: entry.index,
                            count: entry.count,
                            cells: ( (entry.cells.map(NotebookCellData$1.from)))
                        }
                    });
                }
            }
        }
        return result;
    }
    WorkspaceEdit.from = from;
    function to(value) {
        const result = new WorkspaceEdit$2();
        for (const edit of value.edits) {
            if (edit.textEdit) {
                result.replace(URI.revive(edit.resource), Range$1.to(edit.textEdit.range), edit.textEdit.text);
            }
            else {
                result.renameFile(URI.revive(edit.oldResource), URI.revive(edit.newResource), edit.options);
            }
        }
        return result;
    }
    WorkspaceEdit.to = to;
})(WorkspaceEdit$1 || (WorkspaceEdit$1 = {}))));
var SymbolKind$1;
( ((function(SymbolKind) {
    const _fromMapping = Object.create(null);
    _fromMapping[SymbolKind$2.File] = 0 ;
    _fromMapping[SymbolKind$2.Module] = 1 ;
    _fromMapping[SymbolKind$2.Namespace] = 2 ;
    _fromMapping[SymbolKind$2.Package] = 3 ;
    _fromMapping[SymbolKind$2.Class] = 4 ;
    _fromMapping[SymbolKind$2.Method] = 5 ;
    _fromMapping[SymbolKind$2.Property] = 6 ;
    _fromMapping[SymbolKind$2.Field] = 7 ;
    _fromMapping[SymbolKind$2.Constructor] = 8 ;
    _fromMapping[SymbolKind$2.Enum] = 9 ;
    _fromMapping[SymbolKind$2.Interface] = 10 ;
    _fromMapping[SymbolKind$2.Function] = 11 ;
    _fromMapping[SymbolKind$2.Variable] = 12 ;
    _fromMapping[SymbolKind$2.Constant] = 13 ;
    _fromMapping[SymbolKind$2.String] = 14 ;
    _fromMapping[SymbolKind$2.Number] = 15 ;
    _fromMapping[SymbolKind$2.Boolean] = 16 ;
    _fromMapping[SymbolKind$2.Array] = 17 ;
    _fromMapping[SymbolKind$2.Object] = 18 ;
    _fromMapping[SymbolKind$2.Key] = 19 ;
    _fromMapping[SymbolKind$2.Null] = 20 ;
    _fromMapping[SymbolKind$2.EnumMember] = 21 ;
    _fromMapping[SymbolKind$2.Struct] = 22 ;
    _fromMapping[SymbolKind$2.Event] = 23 ;
    _fromMapping[SymbolKind$2.Operator] = 24 ;
    _fromMapping[SymbolKind$2.TypeParameter] = 25 ;
    function from(kind) {
        return typeof _fromMapping[kind] === 'number' ? _fromMapping[kind] : 6 ;
    }
    SymbolKind.from = from;
    function to(kind) {
        for (const k in _fromMapping) {
            if (_fromMapping[k] === kind) {
                return Number(k);
            }
        }
        return SymbolKind$2.Property;
    }
    SymbolKind.to = to;
})(SymbolKind$1 || (SymbolKind$1 = {}))));
var SymbolTag$1;
( ((function(SymbolTag) {
    function from(kind) {
        switch (kind) {
            case SymbolTag$2.Deprecated: return 1 ;
        }
    }
    SymbolTag.from = from;
    function to(kind) {
        switch (kind) {
            case 1 : return SymbolTag$2.Deprecated;
        }
    }
    SymbolTag.to = to;
})(SymbolTag$1 || (SymbolTag$1 = {}))));
var WorkspaceSymbol;
( ((function(WorkspaceSymbol) {
    function from(info) {
        return {
            name: info.name,
            kind: SymbolKind$1.from(info.kind),
            tags: info.tags && ( (info.tags.map(SymbolTag$1.from))),
            containerName: info.containerName,
            location: location.from(info.location)
        };
    }
    WorkspaceSymbol.from = from;
    function to(info) {
        const result = new SymbolInformation$1(info.name, SymbolKind$1.to(info.kind), info.containerName, location.to(info.location));
        result.tags = info.tags && ( (info.tags.map(SymbolTag$1.to)));
        return result;
    }
    WorkspaceSymbol.to = to;
})(WorkspaceSymbol || (WorkspaceSymbol = {}))));
var DocumentSymbol$1;
( ((function(DocumentSymbol) {
    function from(info) {
        const result = {
            name: info.name || '!!MISSING: name!!',
            detail: info.detail,
            range: Range$1.from(info.range),
            selectionRange: Range$1.from(info.selectionRange),
            kind: SymbolKind$1.from(info.kind),
            tags: info.tags?.map(SymbolTag$1.from) ?? []
        };
        if (info.children) {
            result.children = ( (info.children.map(from)));
        }
        return result;
    }
    DocumentSymbol.from = from;
    function to(info) {
        const result = new DocumentSymbol$2(info.name, info.detail, SymbolKind$1.to(info.kind), Range$1.to(info.range), Range$1.to(info.selectionRange));
        if (isNonEmptyArray(info.tags)) {
            result.tags = ( (info.tags.map(SymbolTag$1.to)));
        }
        if (info.children) {
            result.children = ( (info.children.map(to)));
        }
        return result;
    }
    DocumentSymbol.to = to;
})(DocumentSymbol$1 || (DocumentSymbol$1 = {}))));
var CallHierarchyItem$1;
( ((function(CallHierarchyItem) {
    function to(item) {
        const result = new CallHierarchyItem$2(SymbolKind$1.to(item.kind), item.name, item.detail || '', URI.revive(item.uri), Range$1.to(item.range), Range$1.to(item.selectionRange));
        result._sessionId = item._sessionId;
        result._itemId = item._itemId;
        return result;
    }
    CallHierarchyItem.to = to;
    function from(item, sessionId, itemId) {
        sessionId = sessionId ?? item._sessionId;
        itemId = itemId ?? item._itemId;
        if (sessionId === undefined || itemId === undefined) {
            throw new Error('invalid item');
        }
        return {
            _sessionId: sessionId,
            _itemId: itemId,
            name: item.name,
            detail: item.detail,
            kind: SymbolKind$1.from(item.kind),
            uri: item.uri,
            range: Range$1.from(item.range),
            selectionRange: Range$1.from(item.selectionRange),
            tags: item.tags?.map(SymbolTag$1.from)
        };
    }
    CallHierarchyItem.from = from;
})(CallHierarchyItem$1 || (CallHierarchyItem$1 = {}))));
var location;
( ((function(location) {
    function from(value) {
        return {
            range: value.range && Range$1.from(value.range),
            uri: value.uri
        };
    }
    location.from = from;
    function to(value) {
        return new Location$1(URI.revive(value.uri), Range$1.to(value.range));
    }
    location.to = to;
})(location || (location = {}))));
var DefinitionLink;
( ((function(DefinitionLink) {
    function from(value) {
        const definitionLink = value;
        const location = value;
        return {
            originSelectionRange: definitionLink.originSelectionRange
                ? Range$1.from(definitionLink.originSelectionRange)
                : undefined,
            uri: definitionLink.targetUri ? definitionLink.targetUri : location.uri,
            range: Range$1.from(definitionLink.targetRange ? definitionLink.targetRange : location.range),
            targetSelectionRange: definitionLink.targetSelectionRange
                ? Range$1.from(definitionLink.targetSelectionRange)
                : undefined,
        };
    }
    DefinitionLink.from = from;
    function to(value) {
        return {
            targetUri: URI.revive(value.uri),
            targetRange: Range$1.to(value.range),
            targetSelectionRange: value.targetSelectionRange
                ? Range$1.to(value.targetSelectionRange)
                : undefined,
            originSelectionRange: value.originSelectionRange
                ? Range$1.to(value.originSelectionRange)
                : undefined
        };
    }
    DefinitionLink.to = to;
})(DefinitionLink || (DefinitionLink = {}))));
var Hover$1;
( ((function(Hover) {
    function from(hover) {
        return {
            range: Range$1.from(hover.range),
            contents: MarkdownString$1.fromMany(hover.contents)
        };
    }
    Hover.from = from;
    function to(info) {
        return new Hover$2(( (info.contents.map(MarkdownString$1.to))), Range$1.to(info.range));
    }
    Hover.to = to;
})(Hover$1 || (Hover$1 = {}))));
var EvaluatableExpression$1;
( ((function(EvaluatableExpression) {
    function from(expression) {
        return {
            range: Range$1.from(expression.range),
            expression: expression.expression
        };
    }
    EvaluatableExpression.from = from;
    function to(info) {
        return new EvaluatableExpression$2(Range$1.to(info.range), info.expression);
    }
    EvaluatableExpression.to = to;
})(EvaluatableExpression$1 || (EvaluatableExpression$1 = {}))));
var InlineValue;
( ((function(InlineValue) {
    function from(inlineValue) {
        if (inlineValue instanceof InlineValueText$1) {
            return {
                type: 'text',
                range: Range$1.from(inlineValue.range),
                text: inlineValue.text
            };
        }
        else if (inlineValue instanceof InlineValueVariableLookup$1) {
            return {
                type: 'variable',
                range: Range$1.from(inlineValue.range),
                variableName: inlineValue.variableName,
                caseSensitiveLookup: inlineValue.caseSensitiveLookup
            };
        }
        else if (inlineValue instanceof InlineValueEvaluatableExpression$1) {
            return {
                type: 'expression',
                range: Range$1.from(inlineValue.range),
                expression: inlineValue.expression
            };
        }
        else {
            throw new Error(`Unknown 'InlineValue' type`);
        }
    }
    InlineValue.from = from;
    function to(inlineValue) {
        switch (inlineValue.type) {
            case 'text':
                return {
                    range: Range$1.to(inlineValue.range),
                    text: inlineValue.text
                };
            case 'variable':
                return {
                    range: Range$1.to(inlineValue.range),
                    variableName: inlineValue.variableName,
                    caseSensitiveLookup: inlineValue.caseSensitiveLookup
                };
            case 'expression':
                return {
                    range: Range$1.to(inlineValue.range),
                    expression: inlineValue.expression
                };
        }
    }
    InlineValue.to = to;
})(InlineValue || (InlineValue = {}))));
var InlineValueContext;
( ((function(InlineValueContext) {
    function from(inlineValueContext) {
        return {
            frameId: inlineValueContext.frameId,
            stoppedLocation: Range$1.from(inlineValueContext.stoppedLocation)
        };
    }
    InlineValueContext.from = from;
    function to(inlineValueContext) {
        return new InlineValueContext$1(inlineValueContext.frameId, Range$1.to(inlineValueContext.stoppedLocation));
    }
    InlineValueContext.to = to;
})(InlineValueContext || (InlineValueContext = {}))));
var DocumentHighlight$1;
( ((function(DocumentHighlight) {
    function from(documentHighlight) {
        return {
            range: Range$1.from(documentHighlight.range),
            kind: documentHighlight.kind
        };
    }
    DocumentHighlight.from = from;
    function to(occurrence) {
        return new DocumentHighlight$2(Range$1.to(occurrence.range), occurrence.kind);
    }
    DocumentHighlight.to = to;
})(DocumentHighlight$1 || (DocumentHighlight$1 = {}))));
var CompletionTriggerKind$1;
( ((function(CompletionTriggerKind) {
    function to(kind) {
        switch (kind) {
            case 1 :
                return CompletionTriggerKind$2.TriggerCharacter;
            case 2 :
                return CompletionTriggerKind$2.TriggerForIncompleteCompletions;
            case 0 :
            default:
                return CompletionTriggerKind$2.Invoke;
        }
    }
    CompletionTriggerKind.to = to;
})(CompletionTriggerKind$1 || (CompletionTriggerKind$1 = {}))));
var CompletionContext;
( ((function(CompletionContext) {
    function to(context) {
        return {
            triggerKind: CompletionTriggerKind$1.to(context.triggerKind),
            triggerCharacter: context.triggerCharacter
        };
    }
    CompletionContext.to = to;
})(CompletionContext || (CompletionContext = {}))));
var CompletionItemTag$1;
( ((function(CompletionItemTag) {
    function from(kind) {
        switch (kind) {
            case CompletionItemTag$2.Deprecated: return 1 ;
        }
    }
    CompletionItemTag.from = from;
    function to(kind) {
        switch (kind) {
            case 1 : return CompletionItemTag$2.Deprecated;
        }
    }
    CompletionItemTag.to = to;
})(CompletionItemTag$1 || (CompletionItemTag$1 = {}))));
var CompletionItemKind$1;
( ((function(CompletionItemKind) {
    const _from = ( (new Map([
        [CompletionItemKind$2.Method, 0 ],
        [CompletionItemKind$2.Function, 1 ],
        [CompletionItemKind$2.Constructor, 2 ],
        [CompletionItemKind$2.Field, 3 ],
        [CompletionItemKind$2.Variable, 4 ],
        [CompletionItemKind$2.Class, 5 ],
        [CompletionItemKind$2.Interface, 7 ],
        [CompletionItemKind$2.Struct, 6 ],
        [CompletionItemKind$2.Module, 8 ],
        [CompletionItemKind$2.Property, 9 ],
        [CompletionItemKind$2.Unit, 12 ],
        [CompletionItemKind$2.Value, 13 ],
        [CompletionItemKind$2.Constant, 14 ],
        [CompletionItemKind$2.Enum, 15 ],
        [CompletionItemKind$2.EnumMember, 16 ],
        [CompletionItemKind$2.Keyword, 17 ],
        [CompletionItemKind$2.Snippet, 27 ],
        [CompletionItemKind$2.Text, 18 ],
        [CompletionItemKind$2.Color, 19 ],
        [CompletionItemKind$2.File, 20 ],
        [CompletionItemKind$2.Reference, 21 ],
        [CompletionItemKind$2.Folder, 23 ],
        [CompletionItemKind$2.Event, 10 ],
        [CompletionItemKind$2.Operator, 11 ],
        [CompletionItemKind$2.TypeParameter, 24 ],
        [CompletionItemKind$2.Issue, 26 ],
        [CompletionItemKind$2.User, 25 ],
    ])));
    function from(kind) {
        return _from.get(kind) ?? 9 ;
    }
    CompletionItemKind.from = from;
    const _to = ( (new Map([
        [0 , CompletionItemKind$2.Method],
        [1 , CompletionItemKind$2.Function],
        [2 , CompletionItemKind$2.Constructor],
        [3 , CompletionItemKind$2.Field],
        [4 , CompletionItemKind$2.Variable],
        [5 , CompletionItemKind$2.Class],
        [7 , CompletionItemKind$2.Interface],
        [6 , CompletionItemKind$2.Struct],
        [8 , CompletionItemKind$2.Module],
        [9 , CompletionItemKind$2.Property],
        [12 , CompletionItemKind$2.Unit],
        [13 , CompletionItemKind$2.Value],
        [14 , CompletionItemKind$2.Constant],
        [15 , CompletionItemKind$2.Enum],
        [16 , CompletionItemKind$2.EnumMember],
        [17 , CompletionItemKind$2.Keyword],
        [27 , CompletionItemKind$2.Snippet],
        [18 , CompletionItemKind$2.Text],
        [19 , CompletionItemKind$2.Color],
        [20 , CompletionItemKind$2.File],
        [21 , CompletionItemKind$2.Reference],
        [23 , CompletionItemKind$2.Folder],
        [10 , CompletionItemKind$2.Event],
        [11 , CompletionItemKind$2.Operator],
        [24 , CompletionItemKind$2.TypeParameter],
        [25 , CompletionItemKind$2.User],
        [26 , CompletionItemKind$2.Issue],
    ])));
    function to(kind) {
        return _to.get(kind) ?? CompletionItemKind$2.Property;
    }
    CompletionItemKind.to = to;
})(CompletionItemKind$1 || (CompletionItemKind$1 = {}))));
var ParameterInformation$1;
( ((function(ParameterInformation) {
    function from(info) {
        if (typeof info.label !== 'string' && !Array.isArray(info.label)) {
            throw new TypeError('Invalid label');
        }
        return {
            label: info.label,
            documentation: MarkdownString$1.fromStrict(info.documentation)
        };
    }
    ParameterInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: isMarkdownString(info.documentation) ? MarkdownString$1.to(info.documentation) : info.documentation
        };
    }
    ParameterInformation.to = to;
})(ParameterInformation$1 || (ParameterInformation$1 = {}))));
var SignatureInformation$1;
( ((function(SignatureInformation) {
    function from(info) {
        return {
            label: info.label,
            documentation: MarkdownString$1.fromStrict(info.documentation),
            parameters: Array.isArray(info.parameters) ? ( (info.parameters.map(ParameterInformation$1.from))) : [],
            activeParameter: info.activeParameter,
        };
    }
    SignatureInformation.from = from;
    function to(info) {
        return {
            label: info.label,
            documentation: isMarkdownString(info.documentation) ? MarkdownString$1.to(info.documentation) : info.documentation,
            parameters: Array.isArray(info.parameters) ? ( (info.parameters.map(ParameterInformation$1.to))) : [],
            activeParameter: info.activeParameter,
        };
    }
    SignatureInformation.to = to;
})(SignatureInformation$1 || (SignatureInformation$1 = {}))));
var SignatureHelp$1;
( ((function(SignatureHelp) {
    function from(help) {
        return {
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: Array.isArray(help.signatures) ? ( (help.signatures.map(SignatureInformation$1.from))) : [],
        };
    }
    SignatureHelp.from = from;
    function to(help) {
        return {
            activeSignature: help.activeSignature,
            activeParameter: help.activeParameter,
            signatures: Array.isArray(help.signatures) ? ( (help.signatures.map(SignatureInformation$1.to))) : [],
        };
    }
    SignatureHelp.to = to;
})(SignatureHelp$1 || (SignatureHelp$1 = {}))));
var InlayHintKind$1;
( ((function(InlayHintKind) {
    function from(kind) {
        return kind;
    }
    InlayHintKind.from = from;
    function to(kind) {
        return kind;
    }
    InlayHintKind.to = to;
})(InlayHintKind$1 || (InlayHintKind$1 = {}))));
var DocumentLink$1;
( ((function(DocumentLink) {
    function from(link) {
        return {
            range: Range$1.from(link.range),
            url: link.target,
            tooltip: link.tooltip
        };
    }
    DocumentLink.from = from;
    function to(link) {
        let target = undefined;
        if (link.url) {
            try {
                target = typeof link.url === 'string' ? ( (URI.parse(link.url, true))) : URI.revive(link.url);
            }
            catch (err) {
            }
        }
        return new DocumentLink$2(Range$1.to(link.range), target);
    }
    DocumentLink.to = to;
})(DocumentLink$1 || (DocumentLink$1 = {}))));
var ColorPresentation$1;
( ((function(ColorPresentation) {
    function to(colorPresentation) {
        const cp = new ColorPresentation$2(colorPresentation.label);
        if (colorPresentation.textEdit) {
            cp.textEdit = TextEdit$1.to(colorPresentation.textEdit);
        }
        if (colorPresentation.additionalTextEdits) {
            cp.additionalTextEdits = ( (colorPresentation.additionalTextEdits.map(value => TextEdit$1.to(value))));
        }
        return cp;
    }
    ColorPresentation.to = to;
    function from(colorPresentation) {
        return {
            label: colorPresentation.label,
            textEdit: colorPresentation.textEdit ? TextEdit$1.from(colorPresentation.textEdit) : undefined,
            additionalTextEdits: colorPresentation.additionalTextEdits ? ( (colorPresentation.additionalTextEdits.map(value => TextEdit$1.from(value)))) : undefined
        };
    }
    ColorPresentation.from = from;
})(ColorPresentation$1 || (ColorPresentation$1 = {}))));
var Color$1;
( ((function(Color) {
    function to(c) {
        return new Color$2(c[0], c[1], c[2], c[3]);
    }
    Color.to = to;
    function from(color) {
        return [color.red, color.green, color.blue, color.alpha];
    }
    Color.from = from;
})(Color$1 || (Color$1 = {}))));
var SelectionRange$1;
( ((function(SelectionRange) {
    function from(obj) {
        return { range: Range$1.from(obj.range) };
    }
    SelectionRange.from = from;
    function to(obj) {
        return new SelectionRange$2(Range$1.to(obj.range));
    }
    SelectionRange.to = to;
})(SelectionRange$1 || (SelectionRange$1 = {}))));
var TextEditorLineNumbersStyle$1;
( ((function(TextEditorLineNumbersStyle) {
    function from(style) {
        switch (style) {
            case TextEditorLineNumbersStyle$2.Off:
                return 0 ;
            case TextEditorLineNumbersStyle$2.Relative:
                return 2 ;
            case TextEditorLineNumbersStyle$2.On:
            default:
                return 1 ;
        }
    }
    TextEditorLineNumbersStyle.from = from;
    function to(style) {
        switch (style) {
            case 0 :
                return TextEditorLineNumbersStyle$2.Off;
            case 2 :
                return TextEditorLineNumbersStyle$2.Relative;
            case 1 :
            default:
                return TextEditorLineNumbersStyle$2.On;
        }
    }
    TextEditorLineNumbersStyle.to = to;
})(TextEditorLineNumbersStyle$1 || (TextEditorLineNumbersStyle$1 = {}))));
var EndOfLine$1;
( ((function(EndOfLine) {
    function from(eol) {
        if (eol === EndOfLine$2.CRLF) {
            return 1 ;
        }
        else if (eol === EndOfLine$2.LF) {
            return 0 ;
        }
        return undefined;
    }
    EndOfLine.from = from;
    function to(eol) {
        if (eol === 1 ) {
            return EndOfLine$2.CRLF;
        }
        else if (eol === 0 ) {
            return EndOfLine$2.LF;
        }
        return undefined;
    }
    EndOfLine.to = to;
})(EndOfLine$1 || (EndOfLine$1 = {}))));
var ProgressLocation$1;
( ((function(ProgressLocation) {
    function from(loc) {
        if (typeof loc === 'object') {
            return loc.viewId;
        }
        switch (loc) {
            case ProgressLocation$2.SourceControl: return 3 ;
            case ProgressLocation$2.Window: return 10 ;
            case ProgressLocation$2.Notification: return 15 ;
        }
        throw new Error(`Unknown 'ProgressLocation'`);
    }
    ProgressLocation.from = from;
})(ProgressLocation$1 || (ProgressLocation$1 = {}))));
var FoldingRange$1;
( ((function(FoldingRange) {
    function from(r) {
        const range = { start: r.start + 1, end: r.end + 1 };
        if (r.kind) {
            range.kind = FoldingRangeKind$1.from(r.kind);
        }
        return range;
    }
    FoldingRange.from = from;
    function to(r) {
        const range = { start: r.start - 1, end: r.end - 1 };
        if (r.kind) {
            range.kind = FoldingRangeKind$1.to(r.kind);
        }
        return range;
    }
    FoldingRange.to = to;
})(FoldingRange$1 || (FoldingRange$1 = {}))));
var FoldingRangeKind$1;
( ((function(FoldingRangeKind) {
    function from(kind) {
        if (kind) {
            switch (kind) {
                case FoldingRangeKind$3.Comment:
                    return FoldingRangeKind$2.Comment;
                case FoldingRangeKind$3.Imports:
                    return FoldingRangeKind$2.Imports;
                case FoldingRangeKind$3.Region:
                    return FoldingRangeKind$2.Region;
            }
        }
        return undefined;
    }
    FoldingRangeKind.from = from;
    function to(kind) {
        if (kind) {
            switch (kind.value) {
                case FoldingRangeKind$2.Comment.value:
                    return FoldingRangeKind$3.Comment;
                case FoldingRangeKind$2.Imports.value:
                    return FoldingRangeKind$3.Imports;
                case FoldingRangeKind$2.Region.value:
                    return FoldingRangeKind$3.Region;
            }
        }
        return undefined;
    }
    FoldingRangeKind.to = to;
})(FoldingRangeKind$1 || (FoldingRangeKind$1 = {}))));
var GlobPattern;
( ((function(GlobPattern) {
    function from(pattern) {
        if (pattern instanceof RelativePattern$1) {
            return pattern.toJSON();
        }
        if (typeof pattern === 'string') {
            return pattern;
        }
        if (isRelativePatternShape(pattern) || isLegacyRelativePatternShape(pattern)) {
            return new RelativePattern$1(pattern.baseUri ?? pattern.base, pattern.pattern).toJSON();
        }
        return pattern;
    }
    GlobPattern.from = from;
    function isRelativePatternShape(obj) {
        const rp = obj;
        if (!rp) {
            return false;
        }
        return URI.isUri(rp.baseUri) && typeof rp.pattern === 'string';
    }
    function isLegacyRelativePatternShape(obj) {
        const rp = obj;
        if (!rp) {
            return false;
        }
        return typeof rp.base === 'string' && typeof rp.pattern === 'string';
    }
    function to(pattern) {
        if (typeof pattern === 'string') {
            return pattern;
        }
        return new RelativePattern$1(URI.revive(pattern.baseUri), pattern.pattern);
    }
    GlobPattern.to = to;
})(GlobPattern || (GlobPattern = {}))));
var LanguageSelector;
( ((function(LanguageSelector) {
    function from(selector) {
        if (!selector) {
            return undefined;
        }
        else if (Array.isArray(selector)) {
            return (
                 (selector.map(from))
            );
        }
        else if (typeof selector === 'string') {
            return selector;
        }
        else {
            const filter = selector;
            return {
                language: filter.language,
                scheme: filter.scheme,
                pattern: GlobPattern.from(filter.pattern),
                exclusive: filter.exclusive,
                notebookType: filter.notebookType
            };
        }
    }
    LanguageSelector.from = from;
})(LanguageSelector || (LanguageSelector = {}))));
var NotebookRange$1;
( ((function(NotebookRange) {
    function from(range) {
        return { start: range.start, end: range.end };
    }
    NotebookRange.from = from;
    function to(range) {
        return new NotebookRange$2(range.start, range.end);
    }
    NotebookRange.to = to;
})(NotebookRange$1 || (NotebookRange$1 = {}))));
var NotebookCellExecutionSummary;
( ((function(NotebookCellExecutionSummary) {
    function to(data) {
        return {
            timing: typeof data.runStartTime === 'number' && typeof data.runEndTime === 'number' ? { startTime: data.runStartTime, endTime: data.runEndTime } : undefined,
            executionOrder: data.executionOrder,
            success: data.lastRunSuccess
        };
    }
    NotebookCellExecutionSummary.to = to;
    function from(data) {
        return {
            lastRunSuccess: data.success,
            runStartTime: data.timing?.startTime,
            runEndTime: data.timing?.endTime,
            executionOrder: data.executionOrder
        };
    }
    NotebookCellExecutionSummary.from = from;
})(NotebookCellExecutionSummary || (NotebookCellExecutionSummary = {}))));
var NotebookCellKind$1;
( ((function(NotebookCellKind) {
    function from(data) {
        switch (data) {
            case NotebookCellKind$2.Markup:
                return CellKind.Markup;
            case NotebookCellKind$2.Code:
            default:
                return CellKind.Code;
        }
    }
    NotebookCellKind.from = from;
    function to(data) {
        switch (data) {
            case CellKind.Markup:
                return NotebookCellKind$2.Markup;
            case CellKind.Code:
            default:
                return NotebookCellKind$2.Code;
        }
    }
    NotebookCellKind.to = to;
})(NotebookCellKind$1 || (NotebookCellKind$1 = {}))));
var NotebookCellData$1;
( ((function(NotebookCellData) {
    function from(data) {
        return {
            cellKind: NotebookCellKind$1.from(data.kind),
            language: data.languageId,
            mime: data.mime,
            source: data.value,
            metadata: data.metadata,
            internalMetadata: NotebookCellExecutionSummary.from(data.executionSummary ?? {}),
            outputs: data.outputs ? ( (data.outputs.map(NotebookCellOutput$1.from))) : []
        };
    }
    NotebookCellData.from = from;
    function to(data) {
        return new NotebookCellData$2(NotebookCellKind$1.to(data.cellKind), data.source, data.language, data.mime, data.outputs ? ( (data.outputs.map(NotebookCellOutput$1.to))) : undefined, data.metadata, data.internalMetadata ? NotebookCellExecutionSummary.to(data.internalMetadata) : undefined);
    }
    NotebookCellData.to = to;
})(NotebookCellData$1 || (NotebookCellData$1 = {}))));
var NotebookCellOutputItem$1;
( ((function(NotebookCellOutputItem) {
    function from(item) {
        return {
            mime: item.mime,
            valueBytes: VSBuffer.wrap(item.data),
        };
    }
    NotebookCellOutputItem.from = from;
    function to(item) {
        return new NotebookCellOutputItem$2(item.valueBytes.buffer, item.mime);
    }
    NotebookCellOutputItem.to = to;
})(NotebookCellOutputItem$1 || (NotebookCellOutputItem$1 = {}))));
var NotebookCellOutput$1;
( ((function(NotebookCellOutput) {
    function from(output) {
        return {
            outputId: output.id,
            items: ( (output.items.map(NotebookCellOutputItem$1.from))),
            metadata: output.metadata
        };
    }
    NotebookCellOutput.from = from;
    function to(output) {
        const items = ( (output.items.map(NotebookCellOutputItem$1.to)));
        return new NotebookCellOutput$2(items, output.outputId, output.metadata);
    }
    NotebookCellOutput.to = to;
})(NotebookCellOutput$1 || (NotebookCellOutput$1 = {}))));
var CodeActionTriggerKind$1;
( ((function(CodeActionTriggerKind) {
    function to(value) {
        switch (value) {
            case 1 :
                return CodeActionTriggerKind$2.Invoke;
            case 2 :
                return CodeActionTriggerKind$2.Automatic;
        }
    }
    CodeActionTriggerKind.to = to;
})(CodeActionTriggerKind$1 || (CodeActionTriggerKind$1 = {}))));
var TypeHierarchyItem$1;
( ((function(TypeHierarchyItem) {
    function to(item) {
        const result = new TypeHierarchyItem$2(SymbolKind$1.to(item.kind), item.name, item.detail || '', URI.revive(item.uri), Range$1.to(item.range), Range$1.to(item.selectionRange));
        result._sessionId = item._sessionId;
        result._itemId = item._itemId;
        return result;
    }
    TypeHierarchyItem.to = to;
    function from(item, sessionId, itemId) {
        sessionId = sessionId ?? item._sessionId;
        itemId = itemId ?? item._itemId;
        if (sessionId === undefined || itemId === undefined) {
            throw new Error('invalid item');
        }
        return {
            _sessionId: sessionId,
            _itemId: itemId,
            kind: SymbolKind$1.from(item.kind),
            name: item.name,
            detail: item.detail ?? '',
            uri: item.uri,
            range: Range$1.from(item.range),
            selectionRange: Range$1.from(item.selectionRange),
            tags: item.tags?.map(SymbolTag$1.from)
        };
    }
    TypeHierarchyItem.from = from;
})(TypeHierarchyItem$1 || (TypeHierarchyItem$1 = {}))));
var DataTransferItem$1;
( ((function(DataTransferItem) {
    function to(mime, item, resolveFileData) {
        const file = item.fileData;
        if (file) {
            return new (class extends DataTransferItem$2 {
                asFile() {
                    return {
                        name: file.name,
                        uri: URI.revive(file.uri),
                        data: once(() => resolveFileData()),
                    };
                }
            })('', item.id);
        }
        if (mime === Mimes.uriList && item.uriListData) {
            return new DataTransferItem$2(reviveUriList(item.uriListData));
        }
        return new DataTransferItem$2(item.asString);
    }
    DataTransferItem.to = to;
    async function from(mime, item) {
        const stringValue = await item.asString();
        if (mime === Mimes.uriList) {
            return {
                id: item.id,
                asString: stringValue,
                fileData: undefined,
                uriListData: serializeUriList(stringValue),
            };
        }
        const fileValue = item.asFile();
        return {
            id: item.id,
            asString: stringValue,
            fileData: fileValue ? { name: fileValue.name, uri: fileValue.uri } : undefined,
        };
    }
    DataTransferItem.from = from;
    function serializeUriList(stringValue) {
        return (
             (UriList.split(stringValue).map(part => {
                if (part.startsWith('#')) {
                    return part;
                }
                try {
                    return (
                         (URI.parse(part))
                    );
                }
                catch {
                }
                return part;
            }))
        );
    }
    function reviveUriList(parts) {
        return UriList.create(( (parts.map(part => {
            return typeof part === 'string' ? part : URI.revive(part);
        }))));
    }
})(DataTransferItem$1 || (DataTransferItem$1 = {}))));
var DataTransfer$1;
( ((function(DataTransfer) {
    function toDataTransfer(value, resolveFileData) {
        const init = ( (value.items.map(([type, item]) => {
            return [type, DataTransferItem$1.to(type, item, () => resolveFileData(item.id))];
        })));
        return new DataTransfer$2(init);
    }
    DataTransfer.toDataTransfer = toDataTransfer;
    async function toDataTransferDTO(value) {
        const newDTO = { items: [] };
        const promises = [];
        value.forEach((value, key) => {
            promises.push((async () => {
                newDTO.items.push([key, await DataTransferItem$1.from(key, value)]);
            })());
        });
        await Promise.all(promises);
        return newDTO;
    }
    DataTransfer.toDataTransferDTO = toDataTransferDTO;
})(DataTransfer$1 || (DataTransfer$1 = {}))));
class ProxyIdentifier {
    constructor(sid) {
        this._proxyIdentifierBrand = undefined;
        this.sid = sid;
        this.nid = (++ProxyIdentifier.count);
    }
}
ProxyIdentifier.count = 0;
const identifiers = [];
function createProxyIdentifier(identifier) {
    const result = ( (new ProxyIdentifier(identifier)));
    identifiers[result.nid] = result;
    return result;
}
function getStringIdentifierForProxy(nid) {
    return identifiers[nid].sid;
}
class SerializableObjectWithBuffers {
    constructor(value) {
        this.value = value;
    }
}
var TextEditorRevealType$1;
( ((function(TextEditorRevealType) {
    TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
    TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
    TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
    TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
})(TextEditorRevealType$1 || (TextEditorRevealType$1 = {}))));
const MainContext = {
    MainThreadAuthentication: ( (createProxyIdentifier('MainThreadAuthentication'))),
    MainThreadBulkEdits: ( (createProxyIdentifier('MainThreadBulkEdits'))),
    MainThreadClipboard: ( (createProxyIdentifier('MainThreadClipboard'))),
    MainThreadCommands: ( (createProxyIdentifier('MainThreadCommands'))),
    MainThreadComments: ( (createProxyIdentifier('MainThreadComments'))),
    MainThreadConfiguration: ( (createProxyIdentifier('MainThreadConfiguration'))),
    MainThreadConsole: ( (createProxyIdentifier('MainThreadConsole'))),
    MainThreadDebugService: ( (createProxyIdentifier('MainThreadDebugService'))),
    MainThreadDecorations: ( (createProxyIdentifier('MainThreadDecorations'))),
    MainThreadDiagnostics: ( (createProxyIdentifier('MainThreadDiagnostics'))),
    MainThreadDialogs: ( (createProxyIdentifier('MainThreadDiaglogs'))),
    MainThreadDocuments: ( (createProxyIdentifier('MainThreadDocuments'))),
    MainThreadDocumentContentProviders: ( (createProxyIdentifier('MainThreadDocumentContentProviders'))),
    MainThreadTextEditors: ( (createProxyIdentifier('MainThreadTextEditors'))),
    MainThreadEditorInsets: ( (createProxyIdentifier('MainThreadEditorInsets'))),
    MainThreadEditorTabs: ( (createProxyIdentifier('MainThreadEditorTabs'))),
    MainThreadErrors: ( (createProxyIdentifier('MainThreadErrors'))),
    MainThreadTreeViews: ( (createProxyIdentifier('MainThreadTreeViews'))),
    MainThreadDownloadService: ( (createProxyIdentifier('MainThreadDownloadService'))),
    MainThreadKeytar: ( (createProxyIdentifier('MainThreadKeytar'))),
    MainThreadLanguageFeatures: ( (createProxyIdentifier('MainThreadLanguageFeatures'))),
    MainThreadLanguages: ( (createProxyIdentifier('MainThreadLanguages'))),
    MainThreadLogger: ( (createProxyIdentifier('MainThreadLogger'))),
    MainThreadMessageService: ( (createProxyIdentifier('MainThreadMessageService'))),
    MainThreadOutputService: ( (createProxyIdentifier('MainThreadOutputService'))),
    MainThreadProgress: ( (createProxyIdentifier('MainThreadProgress'))),
    MainThreadQuickDiff: ( (createProxyIdentifier('MainThreadQuickDiff'))),
    MainThreadQuickOpen: ( (createProxyIdentifier('MainThreadQuickOpen'))),
    MainThreadStatusBar: ( (createProxyIdentifier('MainThreadStatusBar'))),
    MainThreadSecretState: ( (createProxyIdentifier('MainThreadSecretState'))),
    MainThreadStorage: ( (createProxyIdentifier('MainThreadStorage'))),
    MainThreadTelemetry: ( (createProxyIdentifier('MainThreadTelemetry'))),
    MainThreadTerminalService: ( (createProxyIdentifier('MainThreadTerminalService'))),
    MainThreadWebviews: ( (createProxyIdentifier('MainThreadWebviews'))),
    MainThreadWebviewPanels: ( (createProxyIdentifier('MainThreadWebviewPanels'))),
    MainThreadWebviewViews: ( (createProxyIdentifier('MainThreadWebviewViews'))),
    MainThreadCustomEditors: ( (createProxyIdentifier('MainThreadCustomEditors'))),
    MainThreadUrls: ( (createProxyIdentifier('MainThreadUrls'))),
    MainThreadUriOpeners: ( (createProxyIdentifier('MainThreadUriOpeners'))),
    MainThreadProfileContentHandlers: ( (createProxyIdentifier('MainThreadProfileContentHandlers'))),
    MainThreadWorkspace: ( (createProxyIdentifier('MainThreadWorkspace'))),
    MainThreadFileSystem: ( (createProxyIdentifier('MainThreadFileSystem'))),
    MainThreadExtensionService: ( (createProxyIdentifier('MainThreadExtensionService'))),
    MainThreadSCM: ( (createProxyIdentifier('MainThreadSCM'))),
    MainThreadSearch: ( (createProxyIdentifier('MainThreadSearch'))),
    MainThreadTask: ( (createProxyIdentifier('MainThreadTask'))),
    MainThreadWindow: ( (createProxyIdentifier('MainThreadWindow'))),
    MainThreadLabelService: ( (createProxyIdentifier('MainThreadLabelService'))),
    MainThreadNotebook: ( (createProxyIdentifier('MainThreadNotebook'))),
    MainThreadNotebookDocuments: ( (createProxyIdentifier('MainThreadNotebookDocumentsShape'))),
    MainThreadNotebookEditors: ( (createProxyIdentifier('MainThreadNotebookEditorsShape'))),
    MainThreadNotebookKernels: ( (createProxyIdentifier('MainThreadNotebookKernels'))),
    MainThreadNotebookRenderers: ( (createProxyIdentifier('MainThreadNotebookRenderers'))),
    MainThreadInteractive: ( (createProxyIdentifier('MainThreadInteractive'))),
    MainThreadTheming: ( (createProxyIdentifier('MainThreadTheming'))),
    MainThreadTunnelService: ( (createProxyIdentifier('MainThreadTunnelService'))),
    MainThreadTimeline: ( (createProxyIdentifier('MainThreadTimeline'))),
    MainThreadTesting: ( (createProxyIdentifier('MainThreadTesting'))),
    MainThreadLocalization: ( (createProxyIdentifier('MainThreadLocalizationShape')))
};
const ExtHostContext = {
    ExtHostCommands: ( (createProxyIdentifier('ExtHostCommands'))),
    ExtHostConfiguration: ( (createProxyIdentifier('ExtHostConfiguration'))),
    ExtHostDiagnostics: ( (createProxyIdentifier('ExtHostDiagnostics'))),
    ExtHostDebugService: ( (createProxyIdentifier('ExtHostDebugService'))),
    ExtHostDecorations: ( (createProxyIdentifier('ExtHostDecorations'))),
    ExtHostDocumentsAndEditors: ( (createProxyIdentifier('ExtHostDocumentsAndEditors'))),
    ExtHostDocuments: ( (createProxyIdentifier('ExtHostDocuments'))),
    ExtHostDocumentContentProviders: ( (createProxyIdentifier('ExtHostDocumentContentProviders'))),
    ExtHostDocumentSaveParticipant: ( (createProxyIdentifier('ExtHostDocumentSaveParticipant'))),
    ExtHostEditors: ( (createProxyIdentifier('ExtHostEditors'))),
    ExtHostTreeViews: ( (createProxyIdentifier('ExtHostTreeViews'))),
    ExtHostFileSystem: ( (createProxyIdentifier('ExtHostFileSystem'))),
    ExtHostFileSystemInfo: ( (createProxyIdentifier('ExtHostFileSystemInfo'))),
    ExtHostFileSystemEventService: ( (createProxyIdentifier('ExtHostFileSystemEventService'))),
    ExtHostLanguages: ( (createProxyIdentifier('ExtHostLanguages'))),
    ExtHostLanguageFeatures: ( (createProxyIdentifier('ExtHostLanguageFeatures'))),
    ExtHostQuickOpen: ( (createProxyIdentifier('ExtHostQuickOpen'))),
    ExtHostQuickDiff: ( (createProxyIdentifier('ExtHostQuickDiff'))),
    ExtHostExtensionService: ( (createProxyIdentifier('ExtHostExtensionService'))),
    ExtHostLogLevelServiceShape: ( (createProxyIdentifier('ExtHostLogLevelServiceShape'))),
    ExtHostTerminalService: ( (createProxyIdentifier('ExtHostTerminalService'))),
    ExtHostSCM: ( (createProxyIdentifier('ExtHostSCM'))),
    ExtHostSearch: ( (createProxyIdentifier('ExtHostSearch'))),
    ExtHostTask: ( (createProxyIdentifier('ExtHostTask'))),
    ExtHostWorkspace: ( (createProxyIdentifier('ExtHostWorkspace'))),
    ExtHostWindow: ( (createProxyIdentifier('ExtHostWindow'))),
    ExtHostWebviews: ( (createProxyIdentifier('ExtHostWebviews'))),
    ExtHostWebviewPanels: ( (createProxyIdentifier('ExtHostWebviewPanels'))),
    ExtHostCustomEditors: ( (createProxyIdentifier('ExtHostCustomEditors'))),
    ExtHostWebviewViews: ( (createProxyIdentifier('ExtHostWebviewViews'))),
    ExtHostEditorInsets: ( (createProxyIdentifier('ExtHostEditorInsets'))),
    ExtHostEditorTabs: ( (createProxyIdentifier('ExtHostEditorTabs'))),
    ExtHostProgress: ( (createProxyIdentifier('ExtHostProgress'))),
    ExtHostComments: ( (createProxyIdentifier('ExtHostComments'))),
    ExtHostSecretState: ( (createProxyIdentifier('ExtHostSecretState'))),
    ExtHostStorage: ( (createProxyIdentifier('ExtHostStorage'))),
    ExtHostUrls: ( (createProxyIdentifier('ExtHostUrls'))),
    ExtHostUriOpeners: ( (createProxyIdentifier('ExtHostUriOpeners'))),
    ExtHostProfileContentHandlers: ( (createProxyIdentifier('ExtHostProfileContentHandlers'))),
    ExtHostOutputService: ( (createProxyIdentifier('ExtHostOutputService'))),
    ExtHosLabelService: ( (createProxyIdentifier('ExtHostLabelService'))),
    ExtHostNotebook: ( (createProxyIdentifier('ExtHostNotebook'))),
    ExtHostNotebookDocuments: ( (createProxyIdentifier('ExtHostNotebookDocuments'))),
    ExtHostNotebookEditors: ( (createProxyIdentifier('ExtHostNotebookEditors'))),
    ExtHostNotebookKernels: ( (createProxyIdentifier('ExtHostNotebookKernels'))),
    ExtHostNotebookRenderers: ( (createProxyIdentifier('ExtHostNotebookRenderers'))),
    ExtHostInteractive: ( (createProxyIdentifier('ExtHostInteractive'))),
    ExtHostTheming: ( (createProxyIdentifier('ExtHostTheming'))),
    ExtHostTunnelService: ( (createProxyIdentifier('ExtHostTunnelService'))),
    ExtHostAuthentication: ( (createProxyIdentifier('ExtHostAuthentication'))),
    ExtHostTimeline: ( (createProxyIdentifier('ExtHostTimeline'))),
    ExtHostTesting: ( (createProxyIdentifier('ExtHostTesting'))),
    ExtHostTelemetry: ( (createProxyIdentifier('ExtHostTelemetry'))),
    ExtHostLocalization: ( (createProxyIdentifier('ExtHostLocalization'))),
};
const IExtHostRpcService = ( (createDecorator$1('IExtHostRpcService')));
class ExtHostRpcService {
    constructor(rpcProtocol) {
        this.getProxy = rpcProtocol.getProxy.bind(rpcProtocol);
        this.set = rpcProtocol.set.bind(rpcProtocol);
        this.dispose = rpcProtocol.dispose.bind(rpcProtocol);
        this.assertRegistered = rpcProtocol.assertRegistered.bind(rpcProtocol);
        this.drain = rpcProtocol.drain.bind(rpcProtocol);
    }
}
const IExtHostInitDataService = ( (createDecorator$1('IExtHostInitDataService')));
let ExtHostTelemetry = class ExtHostTelemetry extends Disposable$1 {
    constructor(initData, loggerService) {
        super();
        this.initData = initData;
        this.loggerService = loggerService;
        this._onDidChangeTelemetryEnabled = this._register(( (new Emitter$1())));
        this.onDidChangeTelemetryEnabled = this._onDidChangeTelemetryEnabled.event;
        this._onDidChangeTelemetryConfiguration = this._register(( (new Emitter$1())));
        this.onDidChangeTelemetryConfiguration = this._onDidChangeTelemetryConfiguration.event;
        this._productConfig = { usage: true, error: true };
        this._level = 0 ;
        this._telemetryIsSupported = false;
        this._inLoggingOnlyMode = false;
        this._telemetryLoggers = ( (new Map()));
        this.extHostTelemetryLogFile = URI.revive(this.initData.environment.extensionTelemetryLogResource);
        this._inLoggingOnlyMode = this.initData.environment.isExtensionTelemetryLoggingOnly;
        this._outputLogger = loggerService.createLogger(this.extHostTelemetryLogFile, { id: extensionTelemetryLogChannelId, name: ( (localize(
            'extensionTelemetryLog',
            "Extension Telemetry{0}",
            this._inLoggingOnlyMode ? ' (Not Sent)' : ''
        ))), hidden: true });
        this._register(loggerService.onDidChangeLogLevel(arg => {
            if (isLogLevel(arg)) {
                this.updateLoggerVisibility();
            }
        }));
        this._outputLogger.info('Below are logs for extension telemetry events sent to the telemetry output channel API once the log level is set to trace.');
        this._outputLogger.info('===========================================================');
    }
    updateLoggerVisibility() {
        this.loggerService.setVisibility(this.extHostTelemetryLogFile, this._telemetryIsSupported && this.loggerService.getLogLevel() === LogLevel$1.Trace);
    }
    getTelemetryConfiguration() {
        return this._level === 3 ;
    }
    getTelemetryDetails() {
        return {
            isCrashEnabled: this._level >= 1 ,
            isErrorsEnabled: this._productConfig.error ? this._level >= 2  : false,
            isUsageEnabled: this._productConfig.usage ? this._level >= 3  : false
        };
    }
    instantiateLogger(extension, sender, options) {
        const telemetryDetails = this.getTelemetryDetails();
        const logger = ( (new ExtHostTelemetryLogger(
            sender,
            options,
            extension,
            this._outputLogger,
            this._inLoggingOnlyMode,
            this.getBuiltInCommonProperties(extension),
            { isUsageEnabled: telemetryDetails.isUsageEnabled, isErrorsEnabled: telemetryDetails.isErrorsEnabled }
        )));
        this._telemetryLoggers.set(extension.identifier.value, logger);
        return logger.apiTelemetryLogger;
    }
    $initializeTelemetryLevel(level, supportsTelemetry, productConfig) {
        this._level = level;
        this._telemetryIsSupported = supportsTelemetry;
        this._productConfig = productConfig ?? { usage: true, error: true };
        this.updateLoggerVisibility();
    }
    getBuiltInCommonProperties(extension) {
        const commonProperties = {};
        commonProperties['common.extname'] = `${extension.publisher}.${extension.name}`;
        commonProperties['common.extversion'] = extension.version;
        commonProperties['common.vscodemachineid'] = this.initData.telemetryInfo.machineId;
        commonProperties['common.vscodesessionid'] = this.initData.telemetryInfo.sessionId;
        commonProperties['common.vscodeversion'] = this.initData.version;
        commonProperties['common.isnewappinstall'] = isNewAppInstall(this.initData.telemetryInfo.firstSessionDate);
        commonProperties['common.product'] = this.initData.environment.appHost;
        switch (this.initData.uiKind) {
            case UIKind$1.Web:
                commonProperties['common.uikind'] = 'web';
                break;
            case UIKind$1.Desktop:
                commonProperties['common.uikind'] = 'desktop';
                break;
            default:
                commonProperties['common.uikind'] = 'unknown';
        }
        commonProperties['common.remotename'] = getRemoteName(cleanRemoteAuthority(this.initData.remote.authority));
        return commonProperties;
    }
    $onDidChangeTelemetryLevel(level) {
        this._oldTelemetryEnablement = this.getTelemetryConfiguration();
        this._level = level;
        const telemetryDetails = this.getTelemetryDetails();
        this._telemetryLoggers.forEach(logger => {
            logger.updateTelemetryEnablements(telemetryDetails.isUsageEnabled, telemetryDetails.isErrorsEnabled);
        });
        if (this._oldTelemetryEnablement !== this.getTelemetryConfiguration()) {
            this._onDidChangeTelemetryEnabled.fire(this.getTelemetryConfiguration());
        }
        this._onDidChangeTelemetryConfiguration.fire(this.getTelemetryDetails());
        this.updateLoggerVisibility();
    }
    onExtensionError(extension, error) {
        const logger = this._telemetryLoggers.get(extension.value);
        if (!logger || logger.ignoreUnhandledExtHostErrors) {
            return false;
        }
        logger.logError(error);
        return true;
    }
};
ExtHostTelemetry = ( (__decorate([
    ( (__param(0, IExtHostInitDataService))),
    ( (__param(1, ILoggerService)))
], ExtHostTelemetry)));
class ExtHostTelemetryLogger {
    static validateSender(sender) {
        if (typeof sender !== 'object') {
            throw new TypeError('TelemetrySender argument is invalid');
        }
        if (typeof sender.sendEventData !== 'function') {
            throw new TypeError('TelemetrySender.sendEventData must be a function');
        }
        if (typeof sender.sendErrorData !== 'function') {
            throw new TypeError('TelemetrySender.sendErrorData must be a function');
        }
        if (typeof sender.flush !== 'undefined' && typeof sender.flush !== 'function') {
            throw new TypeError('TelemetrySender.flush must be a function or undefined');
        }
    }
    constructor(sender, options, _extension, _logger, _inLoggingOnlyMode, _commonProperties, telemetryEnablements) {
        this._extension = _extension;
        this._logger = _logger;
        this._inLoggingOnlyMode = _inLoggingOnlyMode;
        this._commonProperties = _commonProperties;
        this._onDidChangeEnableStates = ( (new Emitter$1()));
        this.ignoreUnhandledExtHostErrors = options?.ignoreUnhandledErrors ?? false;
        this._ignoreBuiltinCommonProperties = options?.ignoreBuiltInCommonProperties ?? false;
        this._additionalCommonProperties = options?.additionalCommonProperties;
        this._sender = sender;
        this._telemetryEnablements = { isUsageEnabled: telemetryEnablements.isUsageEnabled, isErrorsEnabled: telemetryEnablements.isErrorsEnabled };
    }
    updateTelemetryEnablements(isUsageEnabled, isErrorsEnabled) {
        if (this._apiObject) {
            this._telemetryEnablements = { isUsageEnabled, isErrorsEnabled };
            this._onDidChangeEnableStates.fire(this._apiObject);
        }
    }
    mixInCommonPropsAndCleanData(data) {
        let updatedData = data.properties ?? data;
        updatedData = cleanData(updatedData, []);
        if (this._additionalCommonProperties) {
            updatedData = mixin(updatedData, this._additionalCommonProperties);
        }
        if (!this._ignoreBuiltinCommonProperties) {
            updatedData = mixin(updatedData, this._commonProperties);
        }
        if (data.properties) {
            data.properties = updatedData;
        }
        else {
            data = updatedData;
        }
        return data;
    }
    logEvent(eventName, data) {
        if (!this._sender) {
            return;
        }
        if (this._extension.publisher === 'vscode') {
            eventName = this._extension.name + '/' + eventName;
        }
        else {
            eventName = this._extension.identifier.value + '/' + eventName;
        }
        data = this.mixInCommonPropsAndCleanData(data || {});
        if (!this._inLoggingOnlyMode) {
            this._sender?.sendEventData(eventName, data);
        }
        this._logger.trace(eventName, data);
    }
    logUsage(eventName, data) {
        if (!this._telemetryEnablements.isUsageEnabled) {
            return;
        }
        this.logEvent(eventName, data);
    }
    logError(eventNameOrException, data) {
        if (!this._telemetryEnablements.isErrorsEnabled || !this._sender) {
            return;
        }
        if (typeof eventNameOrException === 'string') {
            this.logEvent(eventNameOrException, data);
        }
        else {
            this._sender.sendErrorData(eventNameOrException, data);
        }
    }
    get apiTelemetryLogger() {
        if (!this._apiObject) {
            const that = this;
            const obj = {
                logUsage: that.logUsage.bind(that),
                get isUsageEnabled() {
                    return that._telemetryEnablements.isUsageEnabled;
                },
                get isErrorsEnabled() {
                    return that._telemetryEnablements.isErrorsEnabled;
                },
                logError: that.logError.bind(that),
                dispose: that.dispose.bind(that),
                onDidChangeEnableStates: that._onDidChangeEnableStates.event.bind(that)
            };
            this._apiObject = ( (Object.freeze(obj)));
        }
        return this._apiObject;
    }
    dispose() {
        if (this._sender?.flush) {
            Promise.resolve(this._sender.flush()).then(this._sender = undefined);
            this._apiObject = undefined;
        }
    }
}
function isNewAppInstall(firstSessionDate) {
    const installAge = Date.now() - ( (new Date(firstSessionDate))).getTime();
    return isNaN(installAge) ? false : installAge < 1000 * 60 * 60 * 24;
}
const IExtHostTelemetry = ( (createDecorator$1('IExtHostTelemetry')));
var _ExtHostCommands_proxy, _ExtHostCommands_telemetry, _ExtHostCommands_extHostTelemetry;
let ExtHostCommands = class ExtHostCommands {
    constructor(extHostRpc, logService, extHostTelemetry) {
        _ExtHostCommands_proxy.set(this, void 0);
        this._commands = ( (new Map()));
        this._apiCommands = ( (new Map()));
        _ExtHostCommands_telemetry.set(this, void 0);
        _ExtHostCommands_extHostTelemetry.set(this, void 0);
        __classPrivateFieldSet(this, _ExtHostCommands_proxy, ( (extHostRpc.getProxy(MainContext.MainThreadCommands))), "f");
        this._logService = logService;
        __classPrivateFieldSet(this, _ExtHostCommands_extHostTelemetry, extHostTelemetry, "f");
        __classPrivateFieldSet(this, _ExtHostCommands_telemetry, ( (extHostRpc.getProxy(MainContext.MainThreadTelemetry))), "f");
        this.converter = ( (new CommandsConverter(this, id => {
            const candidate = this._apiCommands.get(id);
            return candidate?.result === ApiCommandResult.Void
                ? candidate : undefined;
        }, logService)));
        this._argumentProcessors = [
            {
                processArgument(a) {
                    return revive(a);
                }
            },
            {
                processArgument(arg) {
                    return cloneAndChange(arg, function (obj) {
                        if (Range$2.isIRange(obj)) {
                            return Range$1.to(obj);
                        }
                        if (Position$2.isIPosition(obj)) {
                            return Position$1.to(obj);
                        }
                        if (Range$2.isIRange(obj.range) && URI.isUri(obj.uri)) {
                            return location.to(obj);
                        }
                        if (obj instanceof VSBuffer) {
                            return obj.buffer.buffer;
                        }
                        if (!Array.isArray(obj)) {
                            return obj;
                        }
                    });
                }
            }
        ];
    }
    registerArgumentProcessor(processor) {
        this._argumentProcessors.push(processor);
    }
    registerApiCommand(apiCommand) {
        const registration = this.registerCommand(false, apiCommand.id, async (...apiArgs) => {
            const internalArgs = ( (apiCommand.args.map((arg, i) => {
                if (!arg.validate(apiArgs[i])) {
                    throw new Error(`Invalid argument '${arg.name}' when running '${apiCommand.id}', received: ${apiArgs[i]}`);
                }
                return arg.convert(apiArgs[i]);
            })));
            const internalResult = await this.executeCommand(apiCommand.internalId, ...internalArgs);
            return apiCommand.result.convert(internalResult, apiArgs, this.converter);
        }, undefined, {
            description: apiCommand.description,
            args: apiCommand.args,
            returns: apiCommand.result.description
        });
        this._apiCommands.set(apiCommand.id, apiCommand);
        return new Disposable$2(() => {
            registration.dispose();
            this._apiCommands.delete(apiCommand.id);
        });
    }
    registerCommand(global, id, callback, thisArg, description, extension) {
        this._logService.trace('ExtHostCommands#registerCommand', id);
        if (!id.trim().length) {
            throw new Error('invalid id');
        }
        if (this._commands.has(id)) {
            throw new Error(`command '${id}' already exists`);
        }
        this._commands.set(id, { callback, thisArg, description, extension });
        if (global) {
            __classPrivateFieldGet(this, _ExtHostCommands_proxy, "f").$registerCommand(id);
        }
        return new Disposable$2(() => {
            if (this._commands.delete(id)) {
                if (global) {
                    __classPrivateFieldGet(this, _ExtHostCommands_proxy, "f").$unregisterCommand(id);
                }
            }
        });
    }
    executeCommand(id, ...args) {
        this._logService.trace('ExtHostCommands#executeCommand', id);
        return this._doExecuteCommand(id, args, true);
    }
    async _doExecuteCommand(id, args, retry) {
        if (this._commands.has(id)) {
            __classPrivateFieldGet(this, _ExtHostCommands_proxy, "f").$fireCommandActivationEvent(id);
            return this._executeContributedCommand(id, args, false);
        }
        else {
            let hasBuffers = false;
            const toArgs = cloneAndChange(args, function (value) {
                if (value instanceof Position$3) {
                    return Position$1.from(value);
                }
                else if (value instanceof Range$3) {
                    return Range$1.from(value);
                }
                else if (value instanceof Location$1) {
                    return location.from(value);
                }
                else if (NotebookRange$2.isNotebookRange(value)) {
                    return NotebookRange$1.from(value);
                }
                else if (value instanceof ArrayBuffer) {
                    hasBuffers = true;
                    return VSBuffer.wrap(( (new Uint8Array(value))));
                }
                else if (value instanceof Uint8Array) {
                    hasBuffers = true;
                    return VSBuffer.wrap(value);
                }
                else if (value instanceof VSBuffer) {
                    hasBuffers = true;
                    return value;
                }
                if (!Array.isArray(value)) {
                    return value;
                }
            });
            try {
                const result = await __classPrivateFieldGet(this, _ExtHostCommands_proxy, "f").$executeCommand(id, hasBuffers ? ( (new SerializableObjectWithBuffers(toArgs))) : toArgs, retry);
                return revive(result);
            }
            catch (e) {
                if (e instanceof Error && e.message === '$executeCommand:retry') {
                    return this._doExecuteCommand(id, args, false);
                }
                else {
                    throw e;
                }
            }
        }
    }
    async _executeContributedCommand(id, args, annotateError) {
        const command = this._commands.get(id);
        if (!command) {
            throw new Error('Unknown command');
        }
        const { callback, thisArg, description } = command;
        if (description) {
            for (let i = 0; i < description.args.length; i++) {
                try {
                    validateConstraint(args[i], description.args[i].constraint);
                }
                catch (err) {
                    throw new Error(`Running the contributed command: '${id}' failed. Illegal argument '${description.args[i].name}' - ${description.args[i].description}`);
                }
            }
        }
        const stopWatch = StopWatch.create();
        try {
            return await callback.apply(thisArg, args);
        }
        catch (err) {
            if (id === this.converter.delegatingCommandId) {
                const actual = this.converter.getActualCommand(...args);
                if (actual) {
                    id = actual.command;
                }
            }
            this._logService.error(err, id, command.extension?.identifier);
            if (!annotateError) {
                throw err;
            }
            if (command.extension?.identifier) {
                const reported = __classPrivateFieldGet(this, _ExtHostCommands_extHostTelemetry, "f").onExtensionError(command.extension.identifier, err);
                this._logService.trace('forwarded error to extension?', reported, command.extension?.identifier);
            }
            throw new (class CommandError extends Error {
                constructor() {
                    super(toErrorMessage(err));
                    this.id = id;
                    this.source = command.extension?.displayName ?? command.extension?.name;
                }
            });
        }
        finally {
            this._reportTelemetry(command, id, stopWatch.elapsed());
        }
    }
    _reportTelemetry(command, id, duration) {
        if (!command.extension) {
            return;
        }
        __classPrivateFieldGet(this, _ExtHostCommands_telemetry, "f").$publicLog2('Extension:ActionExecuted', {
            extensionId: command.extension.identifier.value,
            id: ( (new TelemetryTrustedValue$1(id))),
            duration: duration,
        });
    }
    $executeContributedCommand(id, ...args) {
        this._logService.trace('ExtHostCommands#$executeContributedCommand', id);
        const cmdHandler = this._commands.get(id);
        if (!cmdHandler) {
            return Promise.reject(( (new Error(`Contributed command '${id}' does not exist.`))));
        }
        else {
            args = ( (args.map(
                arg => this._argumentProcessors.reduce((r, p) => p.processArgument(r, cmdHandler.extension?.identifier), arg)
            )));
            return this._executeContributedCommand(id, args, true);
        }
    }
    getCommands(filterUnderscoreCommands = false) {
        this._logService.trace('ExtHostCommands#getCommands', filterUnderscoreCommands);
        return __classPrivateFieldGet(this, _ExtHostCommands_proxy, "f").$getCommands().then(result => {
            if (filterUnderscoreCommands) {
                result = result.filter(command => command[0] !== '_');
            }
            return result;
        });
    }
    $getContributedCommandHandlerDescriptions() {
        const result = Object.create(null);
        for (const [id, command] of this._commands) {
            const { description } = command;
            if (description) {
                result[id] = description;
            }
        }
        return Promise.resolve(result);
    }
};
_ExtHostCommands_proxy = ( (new WeakMap()));
_ExtHostCommands_telemetry = ( (new WeakMap()));
_ExtHostCommands_extHostTelemetry = ( (new WeakMap()));
ExtHostCommands = ( (__decorate([
    ( (__param(0, IExtHostRpcService))),
    ( (__param(1, ILogService))),
    ( (__param(2, IExtHostTelemetry)))
], ExtHostCommands)));
const IExtHostCommands = ( (createDecorator$1('IExtHostCommands')));
class CommandsConverter {
    constructor(_commands, _lookupApiCommand, _logService) {
        this._commands = _commands;
        this._lookupApiCommand = _lookupApiCommand;
        this._logService = _logService;
        this.delegatingCommandId = `__vsc${( ( Date.now().toString(36)))}`;
        this._cache = ( (new Map()));
        this._cachIdPool = 0;
        this._commands.registerCommand(true, this.delegatingCommandId, this._executeConvertedCommand, this);
    }
    toInternal(command, disposables) {
        if (!command) {
            return undefined;
        }
        const result = {
            $ident: undefined,
            id: command.command,
            title: command.title,
            tooltip: command.tooltip
        };
        if (!command.command) {
            return result;
        }
        const apiCommand = this._lookupApiCommand(command.command);
        if (apiCommand) {
            result.id = apiCommand.internalId;
            result.arguments = ( (apiCommand.args.map((arg, i) => arg.convert(command.arguments && command.arguments[i]))));
        }
        else if (isNonEmptyArray(command.arguments)) {
            const id = `${command.command}/${++this._cachIdPool}`;
            this._cache.set(id, command);
            disposables.add(toDisposable(() => {
                this._cache.delete(id);
                this._logService.trace('CommandsConverter#DISPOSE', id);
            }));
            result.$ident = id;
            result.id = this.delegatingCommandId;
            result.arguments = [id];
            this._logService.trace('CommandsConverter#CREATE', command.command, id);
        }
        return result;
    }
    fromInternal(command) {
        if (typeof command.$ident === 'string') {
            return this._cache.get(command.$ident);
        }
        else {
            return {
                command: command.id,
                title: command.title,
                arguments: command.arguments
            };
        }
    }
    getActualCommand(...args) {
        return this._cache.get(args[0]);
    }
    _executeConvertedCommand(...args) {
        const actualCmd = this.getActualCommand(...args);
        this._logService.trace('CommandsConverter#EXECUTE', args[0], actualCmd ? actualCmd.command : 'MISSING');
        if (!actualCmd) {
            return Promise.reject(`Actual command not found, wanted to execute ${args[0]}`);
        }
        return this._commands.executeCommand(actualCmd.command, ...(actualCmd.arguments || []));
    }
}
class ApiCommandResult {
    constructor(description, convert) {
        this.description = description;
        this.convert = convert;
    }
}
ApiCommandResult.Void = ( (new ApiCommandResult('no result', v => v)));
function extHostNamedCustomer(id) {
    return function (ctor) {
        ExtHostCustomersRegistryImpl.INSTANCE.registerNamedCustomer(id, ctor);
    };
}
function extHostCustomer(ctor) {
    ExtHostCustomersRegistryImpl.INSTANCE.registerCustomer(ctor);
}
class ExtHostCustomersRegistryImpl {
    constructor() {
        this._namedCustomers = [];
        this._customers = [];
    }
    registerNamedCustomer(id, ctor) {
        const entry = [id, ctor];
        this._namedCustomers.push(entry);
    }
    getNamedCustomers() {
        return this._namedCustomers;
    }
    registerCustomer(ctor) {
        this._customers.push(ctor);
    }
    getCustomers() {
        return this._customers;
    }
}
ExtHostCustomersRegistryImpl.INSTANCE = ( (new ExtHostCustomersRegistryImpl()));
let MainThreadCommands = class MainThreadCommands {
    constructor(extHostContext, _commandService, _extensionService) {
        this._commandService = _commandService;
        this._extensionService = _extensionService;
        this._commandRegistrations = ( (new DisposableMap()));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostCommands)));
        this._generateCommandsDocumentationRegistration = CommandsRegistry.registerCommand('_generateCommandsDocumentation', () => this._generateCommandsDocumentation());
    }
    dispose() {
        this._commandRegistrations.dispose();
        this._generateCommandsDocumentationRegistration.dispose();
    }
    async _generateCommandsDocumentation() {
        const result = await this._proxy.$getContributedCommandHandlerDescriptions();
        const commands = CommandsRegistry.getCommands();
        for (const [id, command] of commands) {
            if (command.description) {
                result[id] = command.description;
            }
        }
        const all = [];
        for (const id in result) {
            all.push('`' + id + '` - ' + _generateMarkdown(result[id]));
        }
        console.log(all.join('\n'));
    }
    $registerCommand(id) {
        this._commandRegistrations.set(id, CommandsRegistry.registerCommand(id, (accessor, ...args) => {
            return this._proxy.$executeContributedCommand(id, ...args).then(result => {
                return revive(result);
            });
        }));
    }
    $unregisterCommand(id) {
        this._commandRegistrations.deleteAndDispose(id);
    }
    $fireCommandActivationEvent(id) {
        const activationEvent = `onCommand:${id}`;
        if (!this._extensionService.activationEventIsDone(activationEvent)) {
            this._extensionService.activateByEvent(activationEvent);
        }
    }
    async $executeCommand(id, args, retry) {
        if (args instanceof SerializableObjectWithBuffers) {
            args = args.value;
        }
        for (let i = 0; i < args.length; i++) {
            args[i] = revive(args[i]);
        }
        if (retry && args.length > 0 && !CommandsRegistry.getCommand(id)) {
            await this._extensionService.activateByEvent(`onCommand:${id}`);
            throw new Error('$executeCommand:retry');
        }
        return this._commandService.executeCommand(id, ...args);
    }
    $getCommands() {
        return Promise.resolve([...( (CommandsRegistry.getCommands().keys()))]);
    }
};
MainThreadCommands = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadCommands),
    ( (__param(1, ICommandService))),
    ( (__param(2, IExtensionService)))
], MainThreadCommands)));
function _generateMarkdown(description) {
    if (typeof description === 'string') {
        return description;
    }
    else {
        const parts = [description.description];
        parts.push('\n\n');
        if (description.args) {
            for (const arg of description.args) {
                parts.push(`* _${arg.name}_ - ${arg.description || ''}\n`);
            }
        }
        if (description.returns) {
            parts.push(`* _(returns)_ - ${description.returns}`);
        }
        parts.push('\n\n');
        return parts.join('');
    }
}
const IExtHostApiDeprecationService = ( (createDecorator$1('IExtHostApiDeprecationService')));
let ExtHostApiDeprecationService = class ExtHostApiDeprecationService {
    constructor(rpc, _extHostLogService) {
        this._extHostLogService = _extHostLogService;
        this._reportedUsages = ( (new Set()));
        this._telemetryShape = ( (rpc.getProxy(MainContext.MainThreadTelemetry)));
    }
    report(apiId, extension, migrationSuggestion) {
        const key = this.getUsageKey(apiId, extension);
        if (this._reportedUsages.has(key)) {
            return;
        }
        this._reportedUsages.add(key);
        if (extension.isUnderDevelopment) {
            this._extHostLogService.warn(`[Deprecation Warning] '${apiId}' is deprecated. ${migrationSuggestion}`);
        }
        this._telemetryShape.$publicLog2('extHostDeprecatedApiUsage', {
            extensionId: extension.identifier.value,
            apiId: apiId,
        });
    }
    getUsageKey(apiId, extension) {
        return `${apiId}-${extension.identifier.value}`;
    }
};
ExtHostApiDeprecationService = ( (__decorate([
    ( (__param(0, IExtHostRpcService))),
    ( (__param(1, ILogService)))
], ExtHostApiDeprecationService)));
class ExtHostFileSystemInfo {
    constructor() {
        this._systemSchemes = ( (new Set( (Object.keys(Schemas)))));
        this._providerInfo = ( (new Map()));
        this.extUri = ( (new ExtUri(uri => {
            const capabilities = this._providerInfo.get(uri.scheme);
            if (capabilities === undefined) {
                return false;
            }
            if (capabilities & 1024 ) {
                return false;
            }
            return true;
        })));
    }
    $acceptProviderInfos(uri, capabilities) {
        if (capabilities === null) {
            this._providerInfo.delete(uri.scheme);
        }
        else {
            this._providerInfo.set(uri.scheme, capabilities);
        }
    }
    isFreeScheme(scheme) {
        return !this._providerInfo.has(scheme) && !this._systemSchemes.has(scheme);
    }
    getCapabilities(scheme) {
        return this._providerInfo.get(scheme);
    }
}
const IExtHostFileSystemInfo = ( (createDecorator$1('IExtHostFileSystemInfo')));
var _DiagnosticCollection_proxy, _DiagnosticCollection_onDidChangeDiagnostics, _DiagnosticCollection_data;
class DiagnosticCollection {
    constructor(_name, _owner, _maxDiagnosticsPerFile, _modelVersionIdProvider, extUri, proxy, onDidChangeDiagnostics) {
        this._name = _name;
        this._owner = _owner;
        this._maxDiagnosticsPerFile = _maxDiagnosticsPerFile;
        this._modelVersionIdProvider = _modelVersionIdProvider;
        _DiagnosticCollection_proxy.set(this, void 0);
        _DiagnosticCollection_onDidChangeDiagnostics.set(this, void 0);
        _DiagnosticCollection_data.set(this, void 0);
        this._isDisposed = false;
        __classPrivateFieldSet(this, _DiagnosticCollection_data, ( (new ResourceMap$1(uri => extUri.getComparisonKey(uri)))), "f");
        __classPrivateFieldSet(this, _DiagnosticCollection_proxy, proxy, "f");
        __classPrivateFieldSet(this, _DiagnosticCollection_onDidChangeDiagnostics, onDidChangeDiagnostics, "f");
    }
    dispose() {
        if (!this._isDisposed) {
            __classPrivateFieldGet(this, _DiagnosticCollection_onDidChangeDiagnostics, "f").fire([...( (__classPrivateFieldGet(this, _DiagnosticCollection_data, "f").keys()))]);
            __classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f")?.$clear(this._owner);
            __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").clear();
            this._isDisposed = true;
        }
    }
    get name() {
        this._checkDisposed();
        return this._name;
    }
    set(first, diagnostics) {
        if (!first) {
            this.clear();
            return;
        }
        this._checkDisposed();
        let toSync = [];
        if (URI.isUri(first)) {
            if (!diagnostics) {
                this.delete(first);
                return;
            }
            __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").set(first, diagnostics.slice());
            toSync = [first];
        }
        else if (Array.isArray(first)) {
            toSync = [];
            let lastUri;
            first = [...first].sort(DiagnosticCollection._compareIndexedTuplesByUri);
            for (const tuple of first) {
                const [uri, diagnostics] = tuple;
                if (!lastUri || ( (uri.toString())) !== ( (lastUri.toString()))) {
                    if (lastUri && __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(lastUri).length === 0) {
                        __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").delete(lastUri);
                    }
                    lastUri = uri;
                    toSync.push(uri);
                    __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").set(uri, []);
                }
                if (!diagnostics) {
                    const currentDiagnostics = __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri);
                    if (currentDiagnostics) {
                        currentDiagnostics.length = 0;
                    }
                }
                else {
                    const currentDiagnostics = __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri);
                    currentDiagnostics?.push(...diagnostics);
                }
            }
        }
        __classPrivateFieldGet(this, _DiagnosticCollection_onDidChangeDiagnostics, "f").fire(toSync);
        if (!__classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f")) {
            return;
        }
        const entries = [];
        for (const uri of toSync) {
            let marker = [];
            const diagnostics = __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri);
            if (diagnostics) {
                if (diagnostics.length > this._maxDiagnosticsPerFile) {
                    marker = [];
                    const order = [DiagnosticSeverity$2.Error, DiagnosticSeverity$2.Warning, DiagnosticSeverity$2.Information, DiagnosticSeverity$2.Hint];
                    orderLoop: for (let i = 0; i < 4; i++) {
                        for (const diagnostic of diagnostics) {
                            if (diagnostic.severity === order[i]) {
                                const len = marker.push({ ...Diagnostic$1.from(diagnostic), modelVersionId: this._modelVersionIdProvider(uri) });
                                if (len === this._maxDiagnosticsPerFile) {
                                    break orderLoop;
                                }
                            }
                        }
                    }
                    marker.push({
                        severity: MarkerSeverity.Info,
                        message: ( (localize(
                            { key: 'limitHit', comment: ['amount of errors/warning skipped due to limits'] },
                            "Not showing {0} further errors and warnings.",
                            diagnostics.length - this._maxDiagnosticsPerFile
                        ))),
                        startLineNumber: marker[marker.length - 1].startLineNumber,
                        startColumn: marker[marker.length - 1].startColumn,
                        endLineNumber: marker[marker.length - 1].endLineNumber,
                        endColumn: marker[marker.length - 1].endColumn
                    });
                }
                else {
                    marker = ( (diagnostics.map(
                        diag => ({ ...Diagnostic$1.from(diag), modelVersionId: this._modelVersionIdProvider(uri) })
                    )));
                }
            }
            entries.push([uri, marker]);
        }
        __classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f").$changeMany(this._owner, entries);
    }
    delete(uri) {
        this._checkDisposed();
        __classPrivateFieldGet(this, _DiagnosticCollection_onDidChangeDiagnostics, "f").fire([uri]);
        __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").delete(uri);
        __classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f")?.$changeMany(this._owner, [[uri, undefined]]);
    }
    clear() {
        this._checkDisposed();
        __classPrivateFieldGet(this, _DiagnosticCollection_onDidChangeDiagnostics, "f").fire([...( (__classPrivateFieldGet(this, _DiagnosticCollection_data, "f").keys()))]);
        __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").clear();
        __classPrivateFieldGet(this, _DiagnosticCollection_proxy, "f")?.$clear(this._owner);
    }
    forEach(callback, thisArg) {
        this._checkDisposed();
        for (const [uri, values] of this) {
            callback.call(thisArg, uri, values, this);
        }
    }
    *[(_DiagnosticCollection_proxy = ( (new WeakMap())), _DiagnosticCollection_onDidChangeDiagnostics = ( (new WeakMap())), _DiagnosticCollection_data = ( (new WeakMap())), Symbol.iterator)]() {
        this._checkDisposed();
        for (const uri of ( (__classPrivateFieldGet(this, _DiagnosticCollection_data, "f").keys()))) {
            yield [uri, this.get(uri)];
        }
    }
    get(uri) {
        this._checkDisposed();
        const result = __classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri);
        if (Array.isArray(result)) {
            return (
                 (Object.freeze(result.slice(0)))
            );
        }
        return [];
    }
    has(uri) {
        this._checkDisposed();
        return Array.isArray(__classPrivateFieldGet(this, _DiagnosticCollection_data, "f").get(uri));
    }
    _checkDisposed() {
        if (this._isDisposed) {
            throw new Error('illegal state - object is disposed');
        }
    }
    static _compareIndexedTuplesByUri(a, b) {
        if (( (a[0].toString())) < ( (b[0].toString()))) {
            return -1;
        }
        else if (( (a[0].toString())) > ( (b[0].toString()))) {
            return 1;
        }
        else {
            return 0;
        }
    }
}
let ExtHostDiagnostics = class ExtHostDiagnostics {
    static _mapper(last) {
        const map = ( (new ResourceMap$1()));
        for (const uri of last) {
            map.set(uri, uri);
        }
        return { uris: ( (Object.freeze(Array.from(( (map.values())))))) };
    }
    constructor(mainContext, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors) {
        this._logService = _logService;
        this._fileSystemInfoService = _fileSystemInfoService;
        this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
        this._collections = ( (new Map()));
        this._onDidChangeDiagnostics = ( (new DebounceEmitter({ merge: all => all.flat(), delay: 50 })));
        this.onDidChangeDiagnostics = ( (Event.map(this._onDidChangeDiagnostics.event, ExtHostDiagnostics._mapper)));
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadDiagnostics)));
    }
    createDiagnosticCollection(extensionId, name) {
        const { _collections, _proxy, _onDidChangeDiagnostics, _logService, _fileSystemInfoService, _extHostDocumentsAndEditors } = this;
        const loggingProxy = new (class {
            $changeMany(owner, entries) {
                _proxy.$changeMany(owner, entries);
                _logService.trace('[DiagnosticCollection] change many (extension, owner, uris)', extensionId.value, owner, entries.length === 0 ? 'CLEARING' : entries);
            }
            $clear(owner) {
                _proxy.$clear(owner);
                _logService.trace('[DiagnosticCollection] remove all (extension, owner)', extensionId.value, owner);
            }
            dispose() {
                _proxy.dispose();
            }
        });
        let owner;
        if (!name) {
            name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics._idPool++;
            owner = name;
        }
        else if (!_collections.has(name)) {
            owner = name;
        }
        else {
            this._logService.warn(`DiagnosticCollection with name '${name}' does already exist.`);
            do {
                owner = name + ExtHostDiagnostics._idPool++;
            } while (_collections.has(owner));
        }
        const result = new (class extends DiagnosticCollection {
            constructor() {
                super(name, owner, ExtHostDiagnostics._maxDiagnosticsPerFile, uri => _extHostDocumentsAndEditors.getDocument(uri)?.version, _fileSystemInfoService.extUri, loggingProxy, _onDidChangeDiagnostics);
                _collections.set(owner, this);
            }
            dispose() {
                super.dispose();
                _collections.delete(owner);
            }
        });
        return result;
    }
    getDiagnostics(resource) {
        if (resource) {
            return this._getDiagnostics(resource);
        }
        else {
            const index = ( (new Map()));
            const res = [];
            for (const collection of ( (this._collections.values()))) {
                collection.forEach((uri, diagnostics) => {
                    let idx = index.get(( (uri.toString())));
                    if (typeof idx === 'undefined') {
                        idx = res.length;
                        index.set(( (uri.toString())), idx);
                        res.push([uri, []]);
                    }
                    res[idx][1] = res[idx][1].concat(...diagnostics);
                });
            }
            return res;
        }
    }
    _getDiagnostics(resource) {
        let res = [];
        for (const collection of ( (this._collections.values()))) {
            if (collection.has(resource)) {
                res = res.concat(collection.get(resource));
            }
        }
        return res;
    }
    $acceptMarkersChange(data) {
        if (!this._mirrorCollection) {
            const name = '_generated_mirror';
            const collection = ( (new DiagnosticCollection(
                name,
                name,
                ExtHostDiagnostics._maxDiagnosticsPerFile,
                _uri => undefined,
                this._fileSystemInfoService.extUri,
                undefined,
                this._onDidChangeDiagnostics
            )));
            this._collections.set(name, collection);
            this._mirrorCollection = collection;
        }
        for (const [uri, markers] of data) {
            this._mirrorCollection.set(URI.revive(uri), ( (markers.map(Diagnostic$1.to))));
        }
    }
};
ExtHostDiagnostics._idPool = 0;
ExtHostDiagnostics._maxDiagnosticsPerFile = 1000;
ExtHostDiagnostics = ( (__decorate([
    ( (__param(1, ILogService))),
    ( (__param(2, IExtHostFileSystemInfo)))
], ExtHostDiagnostics)));
const _languageId2WordDefinition = ( (new Map()));
function setWordDefinitionFor(languageId, wordDefinition) {
    if (!wordDefinition) {
        _languageId2WordDefinition.delete(languageId);
    }
    else {
        _languageId2WordDefinition.set(languageId, wordDefinition);
    }
}
function getWordDefinitionFor(languageId) {
    return _languageId2WordDefinition.get(languageId);
}
class ExtHostDocumentData extends MirrorTextModel {
    constructor(_proxy, uri, lines, eol, versionId, _languageId, _isDirty, notebook) {
        super(uri, lines, eol, versionId);
        this._proxy = _proxy;
        this._languageId = _languageId;
        this._isDirty = _isDirty;
        this.notebook = notebook;
        this._isDisposed = false;
    }
    dispose() {
        ok(!this._isDisposed);
        this._isDisposed = true;
        this._isDirty = false;
    }
    equalLines(lines) {
        return equals(this._lines, lines);
    }
    get document() {
        if (!this._document) {
            const that = this;
            this._document = {
                get uri() { return that._uri; },
                get fileName() { return that._uri.fsPath; },
                get isUntitled() { return that._uri.scheme === Schemas.untitled; },
                get languageId() { return that._languageId; },
                get version() { return that._versionId; },
                get isClosed() { return that._isDisposed; },
                get isDirty() { return that._isDirty; },
                save() { return that._save(); },
                getText(range) { return range ? that._getTextInRange(range) : that.getText(); },
                get eol() { return that._eol === '\n' ? EndOfLine$2.LF : EndOfLine$2.CRLF; },
                get lineCount() { return that._lines.length; },
                lineAt(lineOrPos) { return that._lineAt(lineOrPos); },
                offsetAt(pos) { return that._offsetAt(pos); },
                positionAt(offset) { return that._positionAt(offset); },
                validateRange(ran) { return that._validateRange(ran); },
                validatePosition(pos) { return that._validatePosition(pos); },
                getWordRangeAtPosition(pos, regexp) { return that._getWordRangeAtPosition(pos, regexp); },
            };
        }
        return (
             (Object.freeze(this._document))
        );
    }
    _acceptLanguageId(newLanguageId) {
        ok(!this._isDisposed);
        this._languageId = newLanguageId;
    }
    _acceptIsDirty(isDirty) {
        ok(!this._isDisposed);
        this._isDirty = isDirty;
    }
    _save() {
        if (this._isDisposed) {
            return Promise.reject(( (new Error('Document has been closed'))));
        }
        return this._proxy.$trySaveDocument(this._uri);
    }
    _getTextInRange(_range) {
        const range = this._validateRange(_range);
        if (range.isEmpty) {
            return '';
        }
        if (range.isSingleLine) {
            return this._lines[range.start.line].substring(range.start.character, range.end.character);
        }
        const lineEnding = this._eol, startLineIndex = range.start.line, endLineIndex = range.end.line, resultLines = [];
        resultLines.push(this._lines[startLineIndex].substring(range.start.character));
        for (let i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i]);
        }
        resultLines.push(this._lines[endLineIndex].substring(0, range.end.character));
        return resultLines.join(lineEnding);
    }
    _lineAt(lineOrPosition) {
        let line;
        if (lineOrPosition instanceof Position$3) {
            line = lineOrPosition.line;
        }
        else if (typeof lineOrPosition === 'number') {
            line = lineOrPosition;
        }
        if (typeof line !== 'number' || line < 0 || line >= this._lines.length || Math.floor(line) !== line) {
            throw new Error('Illegal value for `line`');
        }
        return (
             (new ExtHostDocumentLine(line, this._lines[line], line === this._lines.length - 1))
        );
    }
    _offsetAt(position) {
        position = this._validatePosition(position);
        this._ensureLineStarts();
        return this._lineStarts.getPrefixSum(position.line - 1) + position.character;
    }
    _positionAt(offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        this._ensureLineStarts();
        const out = this._lineStarts.getIndexOf(offset);
        const lineLength = this._lines[out.index].length;
        return (
             (new Position$3(out.index, Math.min(out.remainder, lineLength)))
        );
    }
    _validateRange(range) {
        if (!(range instanceof Range$3)) {
            throw new Error('Invalid argument');
        }
        const start = this._validatePosition(range.start);
        const end = this._validatePosition(range.end);
        if (start === range.start && end === range.end) {
            return range;
        }
        return (
             (new Range$3(start.line, start.character, end.line, end.character))
        );
    }
    _validatePosition(position) {
        if (!(position instanceof Position$3)) {
            throw new Error('Invalid argument');
        }
        if (this._lines.length === 0) {
            return position.with(0, 0);
        }
        let { line, character } = position;
        let hasChanged = false;
        if (line < 0) {
            line = 0;
            character = 0;
            hasChanged = true;
        }
        else if (line >= this._lines.length) {
            line = this._lines.length - 1;
            character = this._lines[line].length;
            hasChanged = true;
        }
        else {
            const maxCharacter = this._lines[line].length;
            if (character < 0) {
                character = 0;
                hasChanged = true;
            }
            else if (character > maxCharacter) {
                character = maxCharacter;
                hasChanged = true;
            }
        }
        if (!hasChanged) {
            return position;
        }
        return (
             (new Position$3(line, character))
        );
    }
    _getWordRangeAtPosition(_position, regexp) {
        const position = this._validatePosition(_position);
        if (!regexp) {
            regexp = getWordDefinitionFor(this._languageId);
        }
        else if (regExpLeadsToEndlessLoop(regexp)) {
            throw new Error(`[getWordRangeAtPosition]: ignoring custom regexp '${regexp.source}' because it matches the empty string.`);
        }
        const wordAtText = getWordAtText(position.character + 1, ensureValidWordDefinition(regexp), this._lines[position.line], 0);
        if (wordAtText) {
            return (
                 (new Range$3(
                    position.line,
                    wordAtText.startColumn - 1,
                    position.line,
                    wordAtText.endColumn - 1
                ))
            );
        }
        return undefined;
    }
}
class ExtHostDocumentLine {
    constructor(line, text, isLastLine) {
        this._line = line;
        this._text = text;
        this._isLastLine = isLastLine;
    }
    get lineNumber() {
        return this._line;
    }
    get text() {
        return this._text;
    }
    get range() {
        return (
             (new Range$3(this._line, 0, this._line, this._text.length))
        );
    }
    get rangeIncludingLineBreak() {
        if (this._isLastLine) {
            return this.range;
        }
        return (
             (new Range$3(this._line, 0, this._line + 1, 0))
        );
    }
    get firstNonWhitespaceCharacterIndex() {
        return /^(\s*)/.exec(this._text)[1].length;
    }
    get isEmptyOrWhitespace() {
        return this.firstNonWhitespaceCharacterIndex === this._text.length;
    }
}
class ExtHostDocuments {
    constructor(mainContext, documentsAndEditors) {
        this._onDidAddDocument = ( (new Emitter$1()));
        this._onDidRemoveDocument = ( (new Emitter$1()));
        this._onDidChangeDocument = ( (new Emitter$1()));
        this._onDidSaveDocument = ( (new Emitter$1()));
        this.onDidAddDocument = this._onDidAddDocument.event;
        this.onDidRemoveDocument = this._onDidRemoveDocument.event;
        this.onDidChangeDocument = this._onDidChangeDocument.event;
        this.onDidSaveDocument = this._onDidSaveDocument.event;
        this._toDispose = ( (new DisposableStore()));
        this._documentLoader = ( (new Map()));
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadDocuments)));
        this._documentsAndEditors = documentsAndEditors;
        this._documentsAndEditors.onDidRemoveDocuments(documents => {
            for (const data of documents) {
                this._onDidRemoveDocument.fire(data.document);
            }
        }, undefined, this._toDispose);
        this._documentsAndEditors.onDidAddDocuments(documents => {
            for (const data of documents) {
                this._onDidAddDocument.fire(data.document);
            }
        }, undefined, this._toDispose);
    }
    dispose() {
        this._toDispose.dispose();
    }
    getAllDocumentData() {
        return [...this._documentsAndEditors.allDocuments()];
    }
    getDocumentData(resource) {
        if (!resource) {
            return undefined;
        }
        const data = this._documentsAndEditors.getDocument(resource);
        if (data) {
            return data;
        }
        return undefined;
    }
    getDocument(resource) {
        const data = this.getDocumentData(resource);
        if (!data?.document) {
            throw new Error(`Unable to retrieve document from URI '${resource}'`);
        }
        return data.document;
    }
    ensureDocumentData(uri) {
        const cached = this._documentsAndEditors.getDocument(uri);
        if (cached) {
            return Promise.resolve(cached);
        }
        let promise = this._documentLoader.get(( (uri.toString())));
        if (!promise) {
            promise = this._proxy.$tryOpenDocument(uri).then(uriData => {
                this._documentLoader.delete(( (uri.toString())));
                const canonicalUri = URI.revive(uriData);
                return assertIsDefined(this._documentsAndEditors.getDocument(canonicalUri));
            }, err => {
                this._documentLoader.delete(( (uri.toString())));
                return Promise.reject(err);
            });
            this._documentLoader.set(( (uri.toString())), promise);
        }
        return promise;
    }
    createDocumentData(options) {
        return this._proxy.$tryCreateDocument(options).then(data => URI.revive(data));
    }
    $acceptModelLanguageChanged(uriComponents, newLanguageId) {
        const uri = URI.revive(uriComponents);
        const data = this._documentsAndEditors.getDocument(uri);
        if (!data) {
            throw new Error('unknown document');
        }
        this._onDidRemoveDocument.fire(data.document);
        data._acceptLanguageId(newLanguageId);
        this._onDidAddDocument.fire(data.document);
    }
    $acceptModelSaved(uriComponents) {
        const uri = URI.revive(uriComponents);
        const data = this._documentsAndEditors.getDocument(uri);
        if (!data) {
            throw new Error('unknown document');
        }
        this.$acceptDirtyStateChanged(uriComponents, false);
        this._onDidSaveDocument.fire(data.document);
    }
    $acceptDirtyStateChanged(uriComponents, isDirty) {
        const uri = URI.revive(uriComponents);
        const data = this._documentsAndEditors.getDocument(uri);
        if (!data) {
            throw new Error('unknown document');
        }
        data._acceptIsDirty(isDirty);
        this._onDidChangeDocument.fire({
            document: data.document,
            contentChanges: [],
            reason: undefined
        });
    }
    $acceptModelChanged(uriComponents, events, isDirty) {
        const uri = URI.revive(uriComponents);
        const data = this._documentsAndEditors.getDocument(uri);
        if (!data) {
            throw new Error('unknown document');
        }
        data._acceptIsDirty(isDirty);
        data.onEvents(events);
        let reason = undefined;
        if (events.isUndoing) {
            reason = TextDocumentChangeReason$1.Undo;
        }
        else if (events.isRedoing) {
            reason = TextDocumentChangeReason$1.Redo;
        }
        this._onDidChangeDocument.fire(deepFreeze({
            document: data.document,
            contentChanges: ( (events.changes.map((change) => {
                return {
                    range: Range$1.to(change.range),
                    rangeOffset: change.rangeOffset,
                    rangeLength: change.rangeLength,
                    text: change.text
                };
            }))),
            reason
        }));
    }
    setWordDefinitionFor(languageId, wordDefinition) {
        setWordDefinitionFor(languageId, wordDefinition);
    }
}
function createExtHostQuickOpen(mainContext, workspace, commands) {
    const proxy = ( (mainContext.getProxy(MainContext.MainThreadQuickOpen)));
    class ExtHostQuickOpenImpl {
        constructor(workspace, commands) {
            this._sessions = ( (new Map()));
            this._instances = 0;
            this._workspace = workspace;
            this._commands = commands;
        }
        showQuickPick(extension, itemsOrItemsPromise, options, token = CancellationToken.None) {
            this._onDidSelectItem = undefined;
            const itemsPromise = Promise.resolve(itemsOrItemsPromise);
            const instance = ++this._instances;
            const quickPickWidget = proxy.$show(instance, {
                title: options?.title,
                placeHolder: options?.placeHolder,
                matchOnDescription: options?.matchOnDescription,
                matchOnDetail: options?.matchOnDetail,
                ignoreFocusLost: options?.ignoreFocusOut,
                canPickMany: options?.canPickMany,
            }, token);
            const widgetClosedMarker = {};
            const widgetClosedPromise = quickPickWidget.then(() => widgetClosedMarker);
            return Promise.race([widgetClosedPromise, itemsPromise]).then(result => {
                if (result === widgetClosedMarker) {
                    return undefined;
                }
                const allowedTooltips = isProposedApiEnabled(extension, 'quickPickItemTooltip');
                return itemsPromise.then(items => {
                    const pickItems = [];
                    for (let handle = 0; handle < items.length; handle++) {
                        const item = items[handle];
                        if (typeof item === 'string') {
                            pickItems.push({ label: item, handle });
                        }
                        else if (item.kind === QuickPickItemKind$1.Separator) {
                            pickItems.push({ type: 'separator', label: item.label });
                        }
                        else {
                            if (item.tooltip && !allowedTooltips) {
                                console.warn(`Extension '${extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${extension.identifier.value}`);
                            }
                            pickItems.push({
                                label: item.label,
                                description: item.description,
                                detail: item.detail,
                                picked: item.picked,
                                alwaysShow: item.alwaysShow,
                                tooltip: allowedTooltips ? MarkdownString$1.fromStrict(item.tooltip) : undefined,
                                handle
                            });
                        }
                    }
                    if (options && typeof options.onDidSelectItem === 'function') {
                        this._onDidSelectItem = (handle) => {
                            options.onDidSelectItem(items[handle]);
                        };
                    }
                    proxy.$setItems(instance, pickItems);
                    return quickPickWidget.then(handle => {
                        if (typeof handle === 'number') {
                            return items[handle];
                        }
                        else if (Array.isArray(handle)) {
                            return (
                                 (handle.map(h => items[h]))
                            );
                        }
                        return undefined;
                    });
                });
            }).then(undefined, err => {
                if (isCancellationError(err)) {
                    return undefined;
                }
                proxy.$setError(instance, err);
                return Promise.reject(err);
            });
        }
        $onItemSelected(handle) {
            this._onDidSelectItem?.(handle);
        }
        showInput(options, token = CancellationToken.None) {
            this._validateInput = options?.validateInput;
            return proxy.$input(options, typeof this._validateInput === 'function', token)
                .then(undefined, err => {
                if (isCancellationError(err)) {
                    return undefined;
                }
                return Promise.reject(err);
            });
        }
        async $validateInput(input) {
            if (!this._validateInput) {
                return;
            }
            const result = await this._validateInput(input);
            if (!result || typeof result === 'string') {
                return result;
            }
            let severity;
            switch (result.severity) {
                case InputBoxValidationSeverity$1.Info:
                    severity = Severity$1.Info;
                    break;
                case InputBoxValidationSeverity$1.Warning:
                    severity = Severity$1.Warning;
                    break;
                case InputBoxValidationSeverity$1.Error:
                    severity = Severity$1.Error;
                    break;
                default:
                    severity = result.message ? Severity$1.Error : Severity$1.Ignore;
                    break;
            }
            return {
                content: result.message,
                severity
            };
        }
        async showWorkspaceFolderPick(options, token = CancellationToken.None) {
            const selectedFolder = await this._commands.executeCommand('_workbench.pickWorkspaceFolder', [options]);
            if (!selectedFolder) {
                return undefined;
            }
            const workspaceFolders = await this._workspace.getWorkspaceFolders2();
            if (!workspaceFolders) {
                return undefined;
            }
            return workspaceFolders.find(folder => ( (folder.uri.toString())) === ( (selectedFolder.uri.toString())));
        }
        createQuickPick(extension) {
            const session = ( (new ExtHostQuickPick(extension, () => this._sessions.delete(session._id))));
            this._sessions.set(session._id, session);
            return session;
        }
        createInputBox(extension) {
            const session = ( (new ExtHostInputBox(extension, () => this._sessions.delete(session._id))));
            this._sessions.set(session._id, session);
            return session;
        }
        $onDidChangeValue(sessionId, value) {
            const session = this._sessions.get(sessionId);
            session?._fireDidChangeValue(value);
        }
        $onDidAccept(sessionId) {
            const session = this._sessions.get(sessionId);
            session?._fireDidAccept();
        }
        $onDidChangeActive(sessionId, handles) {
            const session = this._sessions.get(sessionId);
            if (session instanceof ExtHostQuickPick) {
                session._fireDidChangeActive(handles);
            }
        }
        $onDidChangeSelection(sessionId, handles) {
            const session = this._sessions.get(sessionId);
            if (session instanceof ExtHostQuickPick) {
                session._fireDidChangeSelection(handles);
            }
        }
        $onDidTriggerButton(sessionId, handle) {
            const session = this._sessions.get(sessionId);
            session?._fireDidTriggerButton(handle);
        }
        $onDidTriggerItemButton(sessionId, itemHandle, buttonHandle) {
            const session = this._sessions.get(sessionId);
            if (session instanceof ExtHostQuickPick) {
                session._fireDidTriggerItemButton(itemHandle, buttonHandle);
            }
        }
        $onDidHide(sessionId) {
            const session = this._sessions.get(sessionId);
            session?._fireDidHide();
        }
    }
    class ExtHostQuickInput {
        constructor(_extensionId, _onDidDispose) {
            this._extensionId = _extensionId;
            this._onDidDispose = _onDidDispose;
            this._id = ExtHostQuickPick._nextId++;
            this._visible = false;
            this._expectingHide = false;
            this._enabled = true;
            this._busy = false;
            this._ignoreFocusOut = true;
            this._value = '';
            this._buttons = [];
            this._handlesToButtons = ( (new Map()));
            this._onDidAcceptEmitter = ( (new Emitter$1()));
            this._onDidChangeValueEmitter = ( (new Emitter$1()));
            this._onDidTriggerButtonEmitter = ( (new Emitter$1()));
            this._onDidHideEmitter = ( (new Emitter$1()));
            this._pendingUpdate = { id: this._id };
            this._disposed = false;
            this._disposables = [
                this._onDidTriggerButtonEmitter,
                this._onDidHideEmitter,
                this._onDidAcceptEmitter,
                this._onDidChangeValueEmitter
            ];
            this.onDidChangeValue = this._onDidChangeValueEmitter.event;
            this.onDidAccept = this._onDidAcceptEmitter.event;
            this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event;
            this.onDidHide = this._onDidHideEmitter.event;
        }
        get title() {
            return this._title;
        }
        set title(title) {
            this._title = title;
            this.update({ title });
        }
        get step() {
            return this._steps;
        }
        set step(step) {
            this._steps = step;
            this.update({ step });
        }
        get totalSteps() {
            return this._totalSteps;
        }
        set totalSteps(totalSteps) {
            this._totalSteps = totalSteps;
            this.update({ totalSteps });
        }
        get enabled() {
            return this._enabled;
        }
        set enabled(enabled) {
            this._enabled = enabled;
            this.update({ enabled });
        }
        get busy() {
            return this._busy;
        }
        set busy(busy) {
            this._busy = busy;
            this.update({ busy });
        }
        get ignoreFocusOut() {
            return this._ignoreFocusOut;
        }
        set ignoreFocusOut(ignoreFocusOut) {
            this._ignoreFocusOut = ignoreFocusOut;
            this.update({ ignoreFocusOut });
        }
        get value() {
            return this._value;
        }
        set value(value) {
            this._value = value;
            this.update({ value });
        }
        get placeholder() {
            return this._placeholder;
        }
        set placeholder(placeholder) {
            this._placeholder = placeholder;
            this.update({ placeholder });
        }
        get buttons() {
            return this._buttons;
        }
        set buttons(buttons) {
            this._buttons = buttons.slice();
            this._handlesToButtons.clear();
            buttons.forEach((button, i) => {
                const handle = button === QuickInputButtons$1.Back ? -1 : i;
                this._handlesToButtons.set(handle, button);
            });
            this.update({
                buttons: ( (buttons.map((button, i) => {
                    return {
                        ...getIconPathOrClass(button),
                        tooltip: button.tooltip,
                        handle: button === QuickInputButtons$1.Back ? -1 : i,
                    };
                })))
            });
        }
        show() {
            this._visible = true;
            this._expectingHide = true;
            this.update({ visible: true });
        }
        hide() {
            this._visible = false;
            this.update({ visible: false });
        }
        _fireDidAccept() {
            this._onDidAcceptEmitter.fire();
        }
        _fireDidChangeValue(value) {
            this._value = value;
            this._onDidChangeValueEmitter.fire(value);
        }
        _fireDidTriggerButton(handle) {
            const button = this._handlesToButtons.get(handle);
            if (button) {
                this._onDidTriggerButtonEmitter.fire(button);
            }
        }
        _fireDidHide() {
            if (this._expectingHide) {
                this._expectingHide = this._visible;
                this._onDidHideEmitter.fire();
            }
        }
        dispose() {
            if (this._disposed) {
                return;
            }
            this._disposed = true;
            this._fireDidHide();
            this._disposables = dispose(this._disposables);
            if (this._updateTimeout) {
                clearTimeout(this._updateTimeout);
                this._updateTimeout = undefined;
            }
            this._onDidDispose();
            proxy.$dispose(this._id);
        }
        update(properties) {
            if (this._disposed) {
                return;
            }
            for (const key of ( (Object.keys(properties)))) {
                const value = properties[key];
                this._pendingUpdate[key] = value === undefined ? null : value;
            }
            if ('visible' in this._pendingUpdate) {
                if (this._updateTimeout) {
                    clearTimeout(this._updateTimeout);
                    this._updateTimeout = undefined;
                }
                this.dispatchUpdate();
            }
            else if (this._visible && !this._updateTimeout) {
                this._updateTimeout = setTimeout(() => {
                    this._updateTimeout = undefined;
                    this.dispatchUpdate();
                }, 0);
            }
        }
        dispatchUpdate() {
            proxy.$createOrUpdate(this._pendingUpdate);
            this._pendingUpdate = { id: this._id };
        }
    }
    ExtHostQuickInput._nextId = 1;
    function getIconUris(iconPath) {
        if (iconPath instanceof ThemeIcon$1) {
            return { id: iconPath.id };
        }
        const dark = getDarkIconUri(iconPath);
        const light = getLightIconUri(iconPath);
        return {
            dark: typeof dark === 'string' ? URI.file(dark) : dark,
            light: typeof light === 'string' ? URI.file(light) : light
        };
    }
    function getLightIconUri(iconPath) {
        return typeof iconPath === 'object' && 'light' in iconPath ? iconPath.light : iconPath;
    }
    function getDarkIconUri(iconPath) {
        return typeof iconPath === 'object' && 'dark' in iconPath ? iconPath.dark : iconPath;
    }
    function getIconPathOrClass(button) {
        const iconPathOrIconClass = getIconUris(button.iconPath);
        let iconPath;
        let iconClass;
        if ('id' in iconPathOrIconClass) {
            iconClass = ThemeIcon$2.asClassName(iconPathOrIconClass);
        }
        else {
            iconPath = iconPathOrIconClass;
        }
        return {
            iconPath,
            iconClass
        };
    }
    class ExtHostQuickPick extends ExtHostQuickInput {
        constructor(extension, onDispose) {
            super(extension.identifier, onDispose);
            this.extension = extension;
            this._items = [];
            this._handlesToItems = ( (new Map()));
            this._itemsToHandles = ( (new Map()));
            this._canSelectMany = false;
            this._matchOnDescription = true;
            this._matchOnDetail = true;
            this._sortByLabel = true;
            this._keepScrollPosition = false;
            this._activeItems = [];
            this._onDidChangeActiveEmitter = ( (new Emitter$1()));
            this._selectedItems = [];
            this._onDidChangeSelectionEmitter = ( (new Emitter$1()));
            this._onDidTriggerItemButtonEmitter = ( (new Emitter$1()));
            this.onDidChangeActive = this._onDidChangeActiveEmitter.event;
            this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event;
            this.onDidTriggerItemButton = this._onDidTriggerItemButtonEmitter.event;
            this._disposables.push(this._onDidChangeActiveEmitter, this._onDidChangeSelectionEmitter, this._onDidTriggerItemButtonEmitter);
            this.update({ type: 'quickPick' });
        }
        get items() {
            return this._items;
        }
        set items(items) {
            this._items = items.slice();
            this._handlesToItems.clear();
            this._itemsToHandles.clear();
            items.forEach((item, i) => {
                this._handlesToItems.set(i, item);
                this._itemsToHandles.set(item, i);
            });
            const allowedTooltips = isProposedApiEnabled(this.extension, 'quickPickItemTooltip');
            const pickItems = [];
            for (let handle = 0; handle < items.length; handle++) {
                const item = items[handle];
                if (item.kind === QuickPickItemKind$1.Separator) {
                    pickItems.push({ type: 'separator', label: item.label });
                }
                else {
                    if (item.tooltip && !allowedTooltips) {
                        console.warn(`Extension '${this.extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this.extension.identifier.value}`);
                    }
                    pickItems.push({
                        handle,
                        label: item.label,
                        description: item.description,
                        detail: item.detail,
                        picked: item.picked,
                        alwaysShow: item.alwaysShow,
                        tooltip: allowedTooltips ? MarkdownString$1.fromStrict(item.tooltip) : undefined,
                        buttons: item.buttons?.map((button, i) => {
                            return {
                                ...getIconPathOrClass(button),
                                tooltip: button.tooltip,
                                handle: i
                            };
                        }),
                    });
                }
            }
            this.update({
                items: pickItems,
            });
        }
        get canSelectMany() {
            return this._canSelectMany;
        }
        set canSelectMany(canSelectMany) {
            this._canSelectMany = canSelectMany;
            this.update({ canSelectMany });
        }
        get matchOnDescription() {
            return this._matchOnDescription;
        }
        set matchOnDescription(matchOnDescription) {
            this._matchOnDescription = matchOnDescription;
            this.update({ matchOnDescription });
        }
        get matchOnDetail() {
            return this._matchOnDetail;
        }
        set matchOnDetail(matchOnDetail) {
            this._matchOnDetail = matchOnDetail;
            this.update({ matchOnDetail });
        }
        get sortByLabel() {
            return this._sortByLabel;
        }
        set sortByLabel(sortByLabel) {
            this._sortByLabel = sortByLabel;
            this.update({ sortByLabel });
        }
        get keepScrollPosition() {
            return this._keepScrollPosition;
        }
        set keepScrollPosition(keepScrollPosition) {
            this._keepScrollPosition = keepScrollPosition;
            this.update({ keepScrollPosition });
        }
        get activeItems() {
            return this._activeItems;
        }
        set activeItems(activeItems) {
            this._activeItems = activeItems.filter(item => this._itemsToHandles.has(item));
            this.update({ activeItems: ( (this._activeItems.map(item => this._itemsToHandles.get(item)))) });
        }
        get selectedItems() {
            return this._selectedItems;
        }
        set selectedItems(selectedItems) {
            this._selectedItems = selectedItems.filter(item => this._itemsToHandles.has(item));
            this.update({ selectedItems: ( (this._selectedItems.map(item => this._itemsToHandles.get(item)))) });
        }
        _fireDidChangeActive(handles) {
            const items = coalesce(( (handles.map(handle => this._handlesToItems.get(handle)))));
            this._activeItems = items;
            this._onDidChangeActiveEmitter.fire(items);
        }
        _fireDidChangeSelection(handles) {
            const items = coalesce(( (handles.map(handle => this._handlesToItems.get(handle)))));
            this._selectedItems = items;
            this._onDidChangeSelectionEmitter.fire(items);
        }
        _fireDidTriggerItemButton(itemHandle, buttonHandle) {
            const item = this._handlesToItems.get(itemHandle);
            if (!item || !item.buttons || !item.buttons.length) {
                return;
            }
            const button = item.buttons[buttonHandle];
            if (button) {
                this._onDidTriggerItemButtonEmitter.fire({
                    button,
                    item
                });
            }
        }
    }
    class ExtHostInputBox extends ExtHostQuickInput {
        constructor(extension, onDispose) {
            super(extension.identifier, onDispose);
            this._password = false;
            this.update({ type: 'inputBox' });
        }
        get password() {
            return this._password;
        }
        set password(password) {
            this._password = password;
            this.update({ password });
        }
        get prompt() {
            return this._prompt;
        }
        set prompt(prompt) {
            this._prompt = prompt;
            this.update({ prompt });
        }
        get valueSelection() {
            return this._valueSelection;
        }
        set valueSelection(valueSelection) {
            this._valueSelection = valueSelection;
            this.update({ valueSelection });
        }
        get validationMessage() {
            return this._validationMessage;
        }
        set validationMessage(validationMessage) {
            this._validationMessage = validationMessage;
            if (!validationMessage) {
                this.update({ validationMessage: undefined, severity: Severity$1.Ignore });
            }
            else if (typeof validationMessage === 'string') {
                this.update({ validationMessage, severity: Severity$1.Error });
            }
            else {
                this.update({ validationMessage: validationMessage.message, severity: validationMessage.severity ?? Severity$1.Error });
            }
        }
    }
    return (
         (new ExtHostQuickOpenImpl(workspace, commands))
    );
}
function isFolderEqual(folderA, folderB, extHostFileSystemInfo) {
    return ( (new ExtUri(uri => ignorePathCasing(uri, extHostFileSystemInfo)))).isEqual(folderA, folderB);
}
function compareWorkspaceFolderByUri(a, b, extHostFileSystemInfo) {
    return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? 0 : compare(( (a.uri.toString())), ( (b.uri.toString())));
}
function compareWorkspaceFolderByUriAndNameAndIndex(a, b, extHostFileSystemInfo) {
    if (a.index !== b.index) {
        return a.index < b.index ? -1 : 1;
    }
    return isFolderEqual(a.uri, b.uri, extHostFileSystemInfo) ? compare(a.name, b.name) : compare(( (a.uri.toString())), ( (b.uri.toString())));
}
function delta(oldFolders, newFolders, compare, extHostFileSystemInfo) {
    const oldSortedFolders = oldFolders.slice(0).sort((a, b) => compare(a, b, extHostFileSystemInfo));
    const newSortedFolders = newFolders.slice(0).sort((a, b) => compare(a, b, extHostFileSystemInfo));
    return delta$1(oldSortedFolders, newSortedFolders, (a, b) => compare(a, b, extHostFileSystemInfo));
}
function ignorePathCasing(uri, extHostFileSystemInfo) {
    const capabilities = extHostFileSystemInfo.getCapabilities(uri.scheme);
    return !(capabilities && ((capabilities & 1024) ));
}
class ExtHostWorkspaceImpl extends Workspace {
    static toExtHostWorkspace(data, previousConfirmedWorkspace, previousUnconfirmedWorkspace, extHostFileSystemInfo) {
        if (!data) {
            return { workspace: null, added: [], removed: [] };
        }
        const { id, name, folders, configuration, transient, isUntitled } = data;
        const newWorkspaceFolders = [];
        const oldWorkspace = previousConfirmedWorkspace;
        if (previousConfirmedWorkspace) {
            folders.forEach((folderData, index) => {
                const folderUri = URI.revive(folderData.uri);
                const existingFolder = ExtHostWorkspaceImpl._findFolder(previousUnconfirmedWorkspace || previousConfirmedWorkspace, folderUri, extHostFileSystemInfo);
                if (existingFolder) {
                    existingFolder.name = folderData.name;
                    existingFolder.index = folderData.index;
                    newWorkspaceFolders.push(existingFolder);
                }
                else {
                    newWorkspaceFolders.push({ uri: folderUri, name: folderData.name, index });
                }
            });
        }
        else {
            newWorkspaceFolders.push(...( (folders.map(({ uri, name, index }) => ({ uri: URI.revive(uri), name, index })))));
        }
        newWorkspaceFolders.sort((f1, f2) => f1.index < f2.index ? -1 : 1);
        const workspace = ( (new ExtHostWorkspaceImpl(
            id,
            name,
            newWorkspaceFolders,
            !!transient,
            configuration ? URI.revive(configuration) : null,
            !!isUntitled,
            uri => ignorePathCasing(uri, extHostFileSystemInfo)
        )));
        const { added, removed } = delta(oldWorkspace ? oldWorkspace.workspaceFolders : [], workspace.workspaceFolders, compareWorkspaceFolderByUri, extHostFileSystemInfo);
        return { workspace, added, removed };
    }
    static _findFolder(workspace, folderUriToFind, extHostFileSystemInfo) {
        for (let i = 0; i < workspace.folders.length; i++) {
            const folder = workspace.workspaceFolders[i];
            if (isFolderEqual(folder.uri, folderUriToFind, extHostFileSystemInfo)) {
                return folder;
            }
        }
        return undefined;
    }
    constructor(id, _name, folders, transient, configuration, _isUntitled, ignorePathCasing) {
        super(id, ( (folders.map(f => ( (new WorkspaceFolder(f)))))), transient, configuration, ignorePathCasing);
        this._name = _name;
        this._isUntitled = _isUntitled;
        this._workspaceFolders = [];
        this._structure = TernarySearchTree.forUris(ignorePathCasing);
        folders.forEach(folder => {
            this._workspaceFolders.push(folder);
            this._structure.set(folder.uri, folder);
        });
    }
    get name() {
        return this._name;
    }
    get isUntitled() {
        return this._isUntitled;
    }
    get workspaceFolders() {
        return this._workspaceFolders.slice(0);
    }
    getWorkspaceFolder(uri, resolveParent) {
        if (resolveParent && this._structure.get(uri)) {
            uri = dirname(uri);
        }
        return this._structure.findSubstr(uri);
    }
    resolveWorkspaceFolder(uri) {
        return this._structure.get(uri);
    }
}
let ExtHostWorkspace = class ExtHostWorkspace {
    constructor(extHostRpc, initData, extHostFileSystemInfo, logService, uriTransformerService) {
        this._onDidChangeWorkspace = ( (new Emitter$1()));
        this.onDidChangeWorkspace = this._onDidChangeWorkspace.event;
        this._onDidGrantWorkspaceTrust = ( (new Emitter$1()));
        this.onDidGrantWorkspaceTrust = this._onDidGrantWorkspaceTrust.event;
        this._activeSearchCallbacks = [];
        this._trusted = false;
        this._editSessionIdentityProviders = ( (new Map()));
        this._providerHandlePool = 0;
        this._onWillCreateEditSessionIdentityEvent = ( (new AsyncEmitter()));
        this._logService = logService;
        this._extHostFileSystemInfo = extHostFileSystemInfo;
        this._uriTransformerService = uriTransformerService;
        this._requestIdProvider = ( (new Counter()));
        this._barrier = ( (new Barrier()));
        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadWorkspace)));
        this._messageService = ( (extHostRpc.getProxy(MainContext.MainThreadMessageService)));
        const data = initData.workspace;
        this._confirmedWorkspace = data ? ( (new ExtHostWorkspaceImpl(
            data.id,
            data.name,
            [],
            !!data.transient,
            data.configuration ? URI.revive(data.configuration) : null,
            !!data.isUntitled,
            uri => ignorePathCasing(uri, extHostFileSystemInfo)
        ))) : undefined;
    }
    $initializeWorkspace(data, trusted) {
        this._trusted = trusted;
        this.$acceptWorkspaceData(data);
        this._barrier.open();
    }
    waitForInitializeCall() {
        return this._barrier.wait();
    }
    get workspace() {
        return this._actualWorkspace;
    }
    get name() {
        return this._actualWorkspace ? this._actualWorkspace.name : undefined;
    }
    get workspaceFile() {
        if (this._actualWorkspace) {
            if (this._actualWorkspace.configuration) {
                if (this._actualWorkspace.isUntitled) {
                    return (
                         (URI.from(
                            { scheme: Schemas.untitled, path: basename(dirname(this._actualWorkspace.configuration)) }
                        ))
                    );
                }
                return this._actualWorkspace.configuration;
            }
        }
        return undefined;
    }
    get _actualWorkspace() {
        return this._unconfirmedWorkspace || this._confirmedWorkspace;
    }
    getWorkspaceFolders() {
        if (!this._actualWorkspace) {
            return undefined;
        }
        return this._actualWorkspace.workspaceFolders.slice(0);
    }
    async getWorkspaceFolders2() {
        await this._barrier.wait();
        if (!this._actualWorkspace) {
            return undefined;
        }
        return this._actualWorkspace.workspaceFolders.slice(0);
    }
    updateWorkspaceFolders(extension, index, deleteCount, ...workspaceFoldersToAdd) {
        const validatedDistinctWorkspaceFoldersToAdd = [];
        if (Array.isArray(workspaceFoldersToAdd)) {
            workspaceFoldersToAdd.forEach(folderToAdd => {
                if (URI.isUri(folderToAdd.uri) && !validatedDistinctWorkspaceFoldersToAdd.some(f => isFolderEqual(f.uri, folderToAdd.uri, this._extHostFileSystemInfo))) {
                    validatedDistinctWorkspaceFoldersToAdd.push({ uri: folderToAdd.uri, name: folderToAdd.name || basenameOrAuthority(folderToAdd.uri) });
                }
            });
        }
        if (!!this._unconfirmedWorkspace) {
            return false;
        }
        if ([index, deleteCount].some(i => typeof i !== 'number' || i < 0)) {
            return false;
        }
        if (deleteCount === 0 && validatedDistinctWorkspaceFoldersToAdd.length === 0) {
            return false;
        }
        const currentWorkspaceFolders = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : [];
        if (index + deleteCount > currentWorkspaceFolders.length) {
            return false;
        }
        const newWorkspaceFolders = currentWorkspaceFolders.slice(0);
        newWorkspaceFolders.splice(index, deleteCount, ...( (validatedDistinctWorkspaceFoldersToAdd.map(
            f => ({ uri: f.uri, name: f.name || basenameOrAuthority(f.uri), index: undefined  })
        ))));
        for (let i = 0; i < newWorkspaceFolders.length; i++) {
            const folder = newWorkspaceFolders[i];
            if (newWorkspaceFolders.some((otherFolder, index) => index !== i && isFolderEqual(folder.uri, otherFolder.uri, this._extHostFileSystemInfo))) {
                return false;
            }
        }
        newWorkspaceFolders.forEach((f, index) => f.index = index);
        const { added, removed } = delta(currentWorkspaceFolders, newWorkspaceFolders, compareWorkspaceFolderByUriAndNameAndIndex, this._extHostFileSystemInfo);
        if (added.length === 0 && removed.length === 0) {
            return false;
        }
        if (this._proxy) {
            const extName = extension.displayName || extension.name;
            this._proxy.$updateWorkspaceFolders(extName, index, deleteCount, validatedDistinctWorkspaceFoldersToAdd).then(undefined, error => {
                this._unconfirmedWorkspace = undefined;
                const options = { source: { identifier: extension.identifier, label: extension.displayName || extension.name } };
                this._messageService.$showMessage(Severity.Error, ( (localize(
                    'updateerror',
                    "Extension '{0}' failed to update workspace folders: {1}",
                    extName,
                     (error.toString())
                ))), options, []);
            });
        }
        this.trySetWorkspaceFolders(newWorkspaceFolders);
        return true;
    }
    getWorkspaceFolder(uri, resolveParent) {
        if (!this._actualWorkspace) {
            return undefined;
        }
        return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);
    }
    async getWorkspaceFolder2(uri, resolveParent) {
        await this._barrier.wait();
        if (!this._actualWorkspace) {
            return undefined;
        }
        return this._actualWorkspace.getWorkspaceFolder(uri, resolveParent);
    }
    async resolveWorkspaceFolder(uri) {
        await this._barrier.wait();
        if (!this._actualWorkspace) {
            return undefined;
        }
        return this._actualWorkspace.resolveWorkspaceFolder(uri);
    }
    getPath() {
        if (!this._actualWorkspace) {
            return undefined;
        }
        const { folders } = this._actualWorkspace;
        if (folders.length === 0) {
            return undefined;
        }
        return folders[0].uri.fsPath;
    }
    getRelativePath(pathOrUri, includeWorkspace) {
        let resource;
        let path = '';
        if (typeof pathOrUri === 'string') {
            resource = URI.file(pathOrUri);
            path = pathOrUri;
        }
        else if (typeof pathOrUri !== 'undefined') {
            resource = pathOrUri;
            path = pathOrUri.fsPath;
        }
        if (!resource) {
            return path;
        }
        const folder = this.getWorkspaceFolder(resource, true);
        if (!folder) {
            return path;
        }
        if (typeof includeWorkspace === 'undefined' && this._actualWorkspace) {
            includeWorkspace = this._actualWorkspace.folders.length > 1;
        }
        let result = relativePath(folder.uri, resource);
        if (includeWorkspace && folder.name) {
            result = `${folder.name}/${result}`;
        }
        return result;
    }
    trySetWorkspaceFolders(folders) {
        if (this._actualWorkspace) {
            this._unconfirmedWorkspace = ExtHostWorkspaceImpl.toExtHostWorkspace({
                id: this._actualWorkspace.id,
                name: this._actualWorkspace.name,
                configuration: this._actualWorkspace.configuration,
                folders,
                isUntitled: this._actualWorkspace.isUntitled
            }, this._actualWorkspace, undefined, this._extHostFileSystemInfo).workspace || undefined;
        }
    }
    $acceptWorkspaceData(data) {
        const { workspace, added, removed } = ExtHostWorkspaceImpl.toExtHostWorkspace(data, this._confirmedWorkspace, this._unconfirmedWorkspace, this._extHostFileSystemInfo);
        this._confirmedWorkspace = workspace || undefined;
        this._unconfirmedWorkspace = undefined;
        this._onDidChangeWorkspace.fire(( (Object.freeze({
            added,
            removed,
        }))));
    }
    findFiles(include, exclude, maxResults, extensionId, token = CancellationToken.None) {
        this._logService.trace(`extHostWorkspace#findFiles: fileSearch, extension: ${extensionId.value}, entryPoint: findFiles`);
        let excludePatternOrDisregardExcludes = undefined;
        if (exclude === null) {
            excludePatternOrDisregardExcludes = false;
        }
        else if (exclude) {
            if (typeof exclude === 'string') {
                excludePatternOrDisregardExcludes = exclude;
            }
            else {
                excludePatternOrDisregardExcludes = exclude.pattern;
            }
        }
        if (token && token.isCancellationRequested) {
            return Promise.resolve([]);
        }
        const { includePattern, folder } = parseSearchInclude(GlobPattern.from(include));
        return this._proxy.$startFileSearch(withUndefinedAsNull(includePattern), withUndefinedAsNull(folder), withUndefinedAsNull(excludePatternOrDisregardExcludes), withUndefinedAsNull(maxResults), token)
            .then(data => Array.isArray(data) ? ( (data.map(d => URI.revive(d)))) : []);
    }
    async findTextInFiles(query, options, callback, extensionId, token = CancellationToken.None) {
        this._logService.trace(`extHostWorkspace#findTextInFiles: textSearch, extension: ${extensionId.value}, entryPoint: findTextInFiles`);
        const requestId = this._requestIdProvider.getNext();
        const previewOptions = typeof options.previewOptions === 'undefined' ?
            {
                matchLines: 100,
                charsPerLine: 10000
            } :
            options.previewOptions;
        const { includePattern, folder } = parseSearchInclude(GlobPattern.from(options.include));
        const excludePattern = (typeof options.exclude === 'string') ? options.exclude :
            options.exclude ? options.exclude.pattern : undefined;
        const queryOptions = {
            ignoreSymlinks: typeof options.followSymlinks === 'boolean' ? !options.followSymlinks : undefined,
            disregardIgnoreFiles: typeof options.useIgnoreFiles === 'boolean' ? !options.useIgnoreFiles : undefined,
            disregardGlobalIgnoreFiles: typeof options.useGlobalIgnoreFiles === 'boolean' ? !options.useGlobalIgnoreFiles : undefined,
            disregardParentIgnoreFiles: typeof options.useParentIgnoreFiles === 'boolean' ? !options.useParentIgnoreFiles : undefined,
            disregardExcludeSettings: typeof options.useDefaultExcludes === 'boolean' ? !options.useDefaultExcludes : true,
            fileEncoding: options.encoding,
            maxResults: options.maxResults,
            previewOptions,
            afterContext: options.afterContext,
            beforeContext: options.beforeContext,
            includePattern: includePattern,
            excludePattern: excludePattern
        };
        this._activeSearchCallbacks[requestId] = p => {
            const uri = URI.revive(p.resource);
            p.results.forEach(result => {
                if (resultIsMatch(result)) {
                    callback({
                        uri,
                        preview: {
                            text: result.preview.text,
                            matches: mapArrayOrNot(result.preview.matches, m => ( (new Range$3(m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn))))
                        },
                        ranges: mapArrayOrNot(result.ranges, r => ( (new Range$3(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn))))
                    });
                }
                else {
                    callback({
                        uri,
                        text: result.text,
                        lineNumber: result.lineNumber
                    });
                }
            });
        };
        if (token.isCancellationRequested) {
            return {};
        }
        try {
            const result = await this._proxy.$startTextSearch(query, withUndefinedAsNull(folder), queryOptions, requestId, token);
            delete this._activeSearchCallbacks[requestId];
            return result || {};
        }
        catch (err) {
            delete this._activeSearchCallbacks[requestId];
            throw err;
        }
    }
    $handleTextSearchResult(result, requestId) {
        this._activeSearchCallbacks[requestId]?.(result);
    }
    saveAll(includeUntitled) {
        return this._proxy.$saveAll(includeUntitled);
    }
    resolveProxy(url) {
        return this._proxy.$resolveProxy(url);
    }
    get trusted() {
        return this._trusted;
    }
    requestWorkspaceTrust(options) {
        return this._proxy.$requestWorkspaceTrust(options);
    }
    $onDidGrantWorkspaceTrust() {
        if (!this._trusted) {
            this._trusted = true;
            this._onDidGrantWorkspaceTrust.fire();
        }
    }
    registerEditSessionIdentityProvider(scheme, provider) {
        if (this._editSessionIdentityProviders.has(scheme)) {
            throw new Error(`A provider has already been registered for scheme ${scheme}`);
        }
        this._editSessionIdentityProviders.set(scheme, provider);
        const outgoingScheme = this._uriTransformerService.transformOutgoingScheme(scheme);
        const handle = this._providerHandlePool++;
        this._proxy.$registerEditSessionIdentityProvider(handle, outgoingScheme);
        return toDisposable(() => {
            this._editSessionIdentityProviders.delete(scheme);
            this._proxy.$unregisterEditSessionIdentityProvider(handle);
        });
    }
    async $getEditSessionIdentifier(workspaceFolder, cancellationToken) {
        this._logService.info('Getting edit session identifier for workspaceFolder', workspaceFolder);
        const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));
        if (!folder) {
            this._logService.warn('Unable to resolve workspace folder');
            return undefined;
        }
        this._logService.info('Invoking #provideEditSessionIdentity for workspaceFolder', folder);
        const provider = this._editSessionIdentityProviders.get(folder.uri.scheme);
        this._logService.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);
        if (!provider) {
            return undefined;
        }
        const result = await provider.provideEditSessionIdentity(folder, cancellationToken);
        this._logService.info('Provider returned edit session identifier: ', result);
        if (!result) {
            return undefined;
        }
        return result;
    }
    async $provideEditSessionIdentityMatch(workspaceFolder, identity1, identity2, cancellationToken) {
        this._logService.info('Getting edit session identifier for workspaceFolder', workspaceFolder);
        const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));
        if (!folder) {
            this._logService.warn('Unable to resolve workspace folder');
            return undefined;
        }
        this._logService.info('Invoking #provideEditSessionIdentity for workspaceFolder', folder);
        const provider = this._editSessionIdentityProviders.get(folder.uri.scheme);
        this._logService.info(`Provider for scheme ${folder.uri.scheme} is defined: `, !!provider);
        if (!provider) {
            return undefined;
        }
        const result = await provider.provideEditSessionIdentityMatch?.(identity1, identity2, cancellationToken);
        this._logService.info('Provider returned edit session identifier match result: ', result);
        if (!result) {
            return undefined;
        }
        return result;
    }
    getOnWillCreateEditSessionIdentityEvent(extension) {
        return (listener, thisArg, disposables) => {
            const wrappedListener = function wrapped(e) { listener.call(thisArg, e); };
            wrappedListener.extension = extension;
            return this._onWillCreateEditSessionIdentityEvent.event(wrappedListener, undefined, disposables);
        };
    }
    async $onWillCreateEditSessionIdentity(workspaceFolder, token, timeout) {
        const folder = await this.resolveWorkspaceFolder(URI.revive(workspaceFolder));
        if (folder === undefined) {
            throw new Error('Unable to resolve workspace folder');
        }
        await this._onWillCreateEditSessionIdentityEvent.fireAsync({ workspaceFolder: folder }, token, async (thenable, listener) => {
            const now = Date.now();
            await Promise.resolve(thenable);
            if (Date.now() - now > timeout) {
                this._logService.warn('SLOW edit session create-participant', listener.extension.identifier);
            }
        });
        if (token.isCancellationRequested) {
            return undefined;
        }
    }
};
ExtHostWorkspace = ( (__decorate([
    ( (__param(0, IExtHostRpcService))),
    ( (__param(1, IExtHostInitDataService))),
    ( (__param(2, IExtHostFileSystemInfo))),
    ( (__param(3, ILogService))),
    ( (__param(4, IURITransformerService)))
], ExtHostWorkspace)));
const IExtHostWorkspace = ( (createDecorator$1('IExtHostWorkspace')));
function parseSearchInclude(include) {
    let includePattern;
    let includeFolder;
    if (include) {
        if (typeof include === 'string') {
            includePattern = include;
        }
        else {
            includePattern = include.pattern;
            includeFolder = URI.revive(include.baseUri);
        }
    }
    return {
        includePattern,
        folder: includeFolder
    };
}
function reviveIconPathUris(iconPath) {
    iconPath.dark = URI.revive(iconPath.dark);
    if (iconPath.light) {
        iconPath.light = URI.revive(iconPath.light);
    }
}
let MainThreadQuickOpen = class MainThreadQuickOpen {
    constructor(extHostContext, quickInputService) {
        this._items = {};
        this.sessions = ( (new Map()));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostQuickOpen)));
        this._quickInputService = quickInputService;
    }
    dispose() {
    }
    $show(instance, options, token) {
        const contents = ( (new Promise((resolve, reject) => {
            this._items[instance] = { resolve, reject };
        })));
        options = {
            ...options,
            onDidFocus: el => {
                if (el) {
                    this._proxy.$onItemSelected(el.handle);
                }
            }
        };
        if (options.canPickMany) {
            return this._quickInputService.pick(contents, options, token).then(items => {
                if (items) {
                    return (
                         (items.map(item => item.handle))
                    );
                }
                return undefined;
            });
        }
        else {
            return this._quickInputService.pick(contents, options, token).then(item => {
                if (item) {
                    return item.handle;
                }
                return undefined;
            });
        }
    }
    $setItems(instance, items) {
        if (this._items[instance]) {
            this._items[instance].resolve(items);
            delete this._items[instance];
        }
        return Promise.resolve();
    }
    $setError(instance, error) {
        if (this._items[instance]) {
            this._items[instance].reject(error);
            delete this._items[instance];
        }
        return Promise.resolve();
    }
    $input(options, validateInput, token) {
        const inputOptions = Object.create(null);
        if (options) {
            inputOptions.title = options.title;
            inputOptions.password = options.password;
            inputOptions.placeHolder = options.placeHolder;
            inputOptions.valueSelection = options.valueSelection;
            inputOptions.prompt = options.prompt;
            inputOptions.value = options.value;
            inputOptions.ignoreFocusLost = options.ignoreFocusOut;
        }
        if (validateInput) {
            inputOptions.validateInput = (value) => {
                return this._proxy.$validateInput(value);
            };
        }
        return this._quickInputService.input(inputOptions, token);
    }
    $createOrUpdate(params) {
        const sessionId = params.id;
        let session = this.sessions.get(sessionId);
        if (!session) {
            const input = params.type === 'quickPick' ? this._quickInputService.createQuickPick() : this._quickInputService.createInputBox();
            input.onDidAccept(() => {
                this._proxy.$onDidAccept(sessionId);
            });
            input.onDidTriggerButton(button => {
                this._proxy.$onDidTriggerButton(sessionId, button.handle);
            });
            input.onDidChangeValue(value => {
                this._proxy.$onDidChangeValue(sessionId, value);
            });
            input.onDidHide(() => {
                this._proxy.$onDidHide(sessionId);
            });
            if (params.type === 'quickPick') {
                const quickpick = input;
                quickpick.onDidChangeActive(items => {
                    this._proxy.$onDidChangeActive(sessionId, ( (items.map(item => item.handle))));
                });
                quickpick.onDidChangeSelection(items => {
                    this._proxy.$onDidChangeSelection(sessionId, ( (items.map(item => item.handle))));
                });
                quickpick.onDidTriggerItemButton((e) => {
                    this._proxy.$onDidTriggerItemButton(sessionId, e.item.handle, e.button.handle);
                });
            }
            session = {
                input,
                handlesToItems: ( (new Map()))
            };
            this.sessions.set(sessionId, session);
        }
        const { input, handlesToItems } = session;
        for (const param in params) {
            if (param === 'id' || param === 'type') {
                continue;
            }
            if (param === 'visible') {
                if (params.visible) {
                    input.show();
                }
                else {
                    input.hide();
                }
            }
            else if (param === 'items') {
                handlesToItems.clear();
                params[param].forEach((item) => {
                    if (item.type === 'separator') {
                        return;
                    }
                    if (item.buttons) {
                        item.buttons = ( (item.buttons.map((button) => {
                            if (button.iconPath) {
                                reviveIconPathUris(button.iconPath);
                            }
                            return button;
                        })));
                    }
                    handlesToItems.set(item.handle, item);
                });
                input[param] = params[param];
            }
            else if (param === 'activeItems' || param === 'selectedItems') {
                input[param] = ( (params[param]
                    .filter((handle) => handlesToItems.has(handle))
                    .map((handle) => handlesToItems.get(handle))));
            }
            else if (param === 'buttons') {
                input[param] = ( (params.buttons.map(button => {
                    if (button.handle === -1) {
                        return this._quickInputService.backButton;
                    }
                    if (button.iconPath) {
                        reviveIconPathUris(button.iconPath);
                    }
                    return button;
                })));
            }
            else {
                input[param] = params[param];
            }
        }
        return Promise.resolve(undefined);
    }
    $dispose(sessionId) {
        const session = this.sessions.get(sessionId);
        if (session) {
            session.input.dispose();
            this.sessions.delete(sessionId);
        }
        return Promise.resolve(undefined);
    }
};
MainThreadQuickOpen = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadQuickOpen),
    ( (__param(1, IQuickInputService)))
], MainThreadQuickOpen)));
function isMessageItem(item) {
    return item && item.title;
}
let ExtHostMessageService = class ExtHostMessageService {
    constructor(mainContext, _logService) {
        this._logService = _logService;
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadMessageService)));
    }
    showMessage(extension, severity, message, optionsOrFirstItem, rest) {
        const options = {
            source: { identifier: extension.identifier, label: extension.displayName || extension.name }
        };
        let items;
        if (typeof optionsOrFirstItem === 'string' || isMessageItem(optionsOrFirstItem)) {
            items = [optionsOrFirstItem, ...rest];
        }
        else {
            options.modal = optionsOrFirstItem?.modal;
            options.useCustom = optionsOrFirstItem?.useCustom;
            options.detail = optionsOrFirstItem?.detail;
            items = rest;
        }
        if (options.useCustom) {
            checkProposedApiEnabled(extension, 'resolvers');
        }
        const commands = [];
        for (let handle = 0; handle < items.length; handle++) {
            const command = items[handle];
            if (typeof command === 'string') {
                commands.push({ title: command, handle, isCloseAffordance: false });
            }
            else if (typeof command === 'object') {
                const { title, isCloseAffordance } = command;
                commands.push({ title, isCloseAffordance: !!isCloseAffordance, handle });
            }
            else {
                this._logService.warn('Invalid message item:', command);
            }
        }
        return this._proxy.$showMessage(severity, message, options, commands).then(handle => {
            if (typeof handle === 'number') {
                return items[handle];
            }
            return undefined;
        });
    }
};
ExtHostMessageService = ( (__decorate([
    ( (__param(1, ILogService)))
], ExtHostMessageService)));
let MainThreadMessageService = class MainThreadMessageService {
    constructor(extHostContext, _notificationService, _commandService, _dialogService) {
        this._notificationService = _notificationService;
        this._commandService = _commandService;
        this._dialogService = _dialogService;
    }
    dispose() {
    }
    $showMessage(severity, message, options, commands) {
        if (options.modal) {
            return this._showModalMessage(severity, message, options.detail, commands, options.useCustom);
        }
        else {
            return this._showMessage(severity, message, commands, options);
        }
    }
    _showMessage(severity, message, commands, options) {
        return (
             (new Promise(resolve => {
                const primaryActions = ( (commands.map(command => toAction({
                    id: `_extension_message_handle_${command.handle}`,
                    label: command.title,
                    enabled: true,
                    run: () => {
                        resolve(command.handle);
                        return Promise.resolve();
                    }
                }))));
                let source;
                if (options.source) {
                    source = {
                        label: ( (localize('extensionSource', "{0} (Extension)", options.source.label))),
                        id: options.source.identifier.value
                    };
                }
                if (!source) {
                    source = ( (localize('defaultSource', "Extension")));
                }
                const secondaryActions = [];
                if (options.source) {
                    secondaryActions.push(toAction({
                        id: options.source.identifier.value,
                        label: ( (localize('manageExtension', "Manage Extension"))),
                        run: () => {
                            return this._commandService.executeCommand('_extensions.manage', options.source.identifier.value);
                        }
                    }));
                }
                const messageHandle = this._notificationService.notify({
                    severity,
                    message,
                    actions: { primary: primaryActions, secondary: secondaryActions },
                    source
                });
                Event.once(messageHandle.onDidClose)(() => {
                    resolve(undefined);
                });
            }))
        );
    }
    async _showModalMessage(severity, message, detail, commands, useCustom) {
        const buttons = [];
        let cancelButton = undefined;
        for (const command of commands) {
            const button = {
                label: command.title,
                run: () => command.handle
            };
            if (command.isCloseAffordance) {
                cancelButton = button;
            }
            else {
                buttons.push(button);
            }
        }
        if (!cancelButton) {
            if (buttons.length > 0) {
                cancelButton = {
                    label: ( (localize('cancel', "Cancel"))),
                    run: () => undefined
                };
            }
            else {
                cancelButton = {
                    label: ( (localize({ key: 'ok', comment: ['&& denotes a mnemonic'] }, "&&OK"))),
                    run: () => undefined
                };
            }
        }
        const { result } = await this._dialogService.prompt({
            type: severity,
            message,
            detail,
            buttons,
            cancelButton,
            custom: useCustom
        });
        return result;
    }
};
MainThreadMessageService = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadMessageService),
    ( (__param(1, INotificationService))),
    ( (__param(2, ICommandService))),
    ( (__param(3, IDialogService)))
], MainThreadMessageService)));
class ExtHostProgress {
    constructor(proxy) {
        this._handles = 0;
        this._mapHandleToCancellationSource = ( (new Map()));
        this._proxy = proxy;
    }
    async withProgress(extension, options, task) {
        const handle = this._handles++;
        const { title, location, cancellable } = options;
        const source = { label: ( (localize(
            'extensionSource',
            "{0} (Extension)",
            extension.displayName || extension.name
        ))), id: extension.identifier.value };
        this._proxy.$startProgress(handle, { location: ProgressLocation$1.from(location), title, source, cancellable }, !extension.isUnderDevelopment ? extension.identifier.value : undefined).catch(onUnexpectedExternalError);
        return this._withProgress(handle, task, !!cancellable);
    }
    _withProgress(handle, task, cancellable) {
        let source;
        if (cancellable) {
            source = ( (new CancellationTokenSource$1()));
            this._mapHandleToCancellationSource.set(handle, source);
        }
        const progressEnd = (handle) => {
            this._proxy.$progressEnd(handle);
            this._mapHandleToCancellationSource.delete(handle);
            source?.dispose();
        };
        let p;
        try {
            p = task(( (new ProgressCallback(this._proxy, handle))), cancellable && source ? source.token : CancellationToken.None);
        }
        catch (err) {
            progressEnd(handle);
            throw err;
        }
        p.then(result => progressEnd(handle), err => progressEnd(handle));
        return p;
    }
    $acceptProgressCanceled(handle) {
        const source = this._mapHandleToCancellationSource.get(handle);
        if (source) {
            source.cancel();
            this._mapHandleToCancellationSource.delete(handle);
        }
    }
}
function mergeProgress(result, currentValue) {
    result.message = currentValue.message;
    if (typeof currentValue.increment === 'number') {
        if (typeof result.increment === 'number') {
            result.increment += currentValue.increment;
        }
        else {
            result.increment = currentValue.increment;
        }
    }
    return result;
}
class ProgressCallback extends Progress {
    constructor(_proxy, _handle) {
        super(p => this.throttledReport(p));
        this._proxy = _proxy;
        this._handle = _handle;
    }
    throttledReport(p) {
        this._proxy.$progressReport(this._handle, p);
    }
}
ProgressCallback.__decorator = ( (__decorate([
    throttle(100, (result, currentValue) => mergeProgress(result, currentValue), () => Object.create(null))
], ProgressCallback.prototype, "throttledReport", null)));
class ManageExtensionAction extends Action {
    constructor(extensionId, label, commandService) {
        super(extensionId, label, undefined, true, () => {
            return commandService.executeCommand('_extensions.manage', extensionId);
        });
    }
}
let MainThreadProgress = class MainThreadProgress {
    constructor(extHostContext, progressService, _commandService) {
        this._commandService = _commandService;
        this._progress = ( (new Map()));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostProgress)));
        this._progressService = progressService;
    }
    dispose() {
        this._progress.forEach(handle => handle.resolve());
        this._progress.clear();
    }
    async $startProgress(handle, options, extensionId) {
        const task = this._createTask(handle);
        if (options.location === 15  && extensionId) {
            const notificationOptions = {
                ...options,
                location: 15 ,
                secondaryActions: [( (new ManageExtensionAction(
                    extensionId,
                     (localize('manageExtension', "Manage Extension")),
                    this._commandService
                )))]
            };
            options = notificationOptions;
        }
        this._progressService.withProgress(options, task, () => this._proxy.$acceptProgressCanceled(handle));
    }
    $progressReport(handle, message) {
        const entry = this._progress.get(handle);
        entry?.progress.report(message);
    }
    $progressEnd(handle) {
        const entry = this._progress.get(handle);
        if (entry) {
            entry.resolve();
            this._progress.delete(handle);
        }
    }
    _createTask(handle) {
        return (progress) => {
            return (
                 (new Promise(resolve => {
                    this._progress.set(handle, { resolve, progress });
                }))
            );
        };
    }
};
MainThreadProgress = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadProgress),
    ( (__param(1, IProgressService))),
    ( (__param(2, ICommandService)))
], MainThreadProgress)));
let MainThreadDocumentContentProviders = class MainThreadDocumentContentProviders {
    constructor(extHostContext, _textModelResolverService, _languageService, _modelService, _editorWorkerService) {
        this._textModelResolverService = _textModelResolverService;
        this._languageService = _languageService;
        this._modelService = _modelService;
        this._editorWorkerService = _editorWorkerService;
        this._resourceContentProvider = ( (new DisposableMap()));
        this._pendingUpdate = ( (new Map()));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostDocumentContentProviders)));
    }
    dispose() {
        this._resourceContentProvider.dispose();
        dispose(( (this._pendingUpdate.values())));
    }
    $registerTextContentProvider(handle, scheme) {
        const registration = this._textModelResolverService.registerTextModelContentProvider(scheme, {
            provideTextContent: (uri) => {
                return this._proxy.$provideTextDocumentContent(handle, uri).then(value => {
                    if (typeof value === 'string') {
                        const firstLineText = value.substr(0, 1 + value.search(/\r?\n/));
                        const languageSelection = this._languageService.createByFilepathOrFirstLine(uri, firstLineText);
                        return this._modelService.createModel(value, languageSelection, uri);
                    }
                    return null;
                });
            }
        });
        this._resourceContentProvider.set(handle, registration);
    }
    $unregisterTextContentProvider(handle) {
        this._resourceContentProvider.deleteAndDispose(handle);
    }
    $onVirtualDocumentChange(uri, value) {
        const model = this._modelService.getModel(URI.revive(uri));
        if (!model) {
            return;
        }
        const pending = this._pendingUpdate.get(model.id);
        pending?.cancel();
        const myToken = ( (new CancellationTokenSource$1()));
        this._pendingUpdate.set(model.id, myToken);
        this._editorWorkerService.computeMoreMinimalEdits(model.uri, [{ text: value, range: model.getFullModelRange() }]).then(edits => {
            this._pendingUpdate.delete(model.id);
            if (myToken.token.isCancellationRequested) {
                return;
            }
            if (edits && edits.length > 0) {
                model.applyEdits(( (edits.map(edit => EditOperation.replace(Range$2.lift(edit.range), edit.text)))));
            }
        }).catch(onUnexpectedError);
    }
};
MainThreadDocumentContentProviders = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadDocumentContentProviders),
    ( (__param(1, ITextModelService))),
    ( (__param(2, ILanguageService))),
    ( (__param(3, IModelService))),
    ( (__param(4, IEditorWorkerService)))
], MainThreadDocumentContentProviders)));
class ExtHostDocumentContentProvider {
    constructor(mainContext, _documentsAndEditors, _logService) {
        this._documentsAndEditors = _documentsAndEditors;
        this._logService = _logService;
        this._documentContentProviders = ( (new Map()));
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadDocumentContentProviders)));
    }
    registerTextDocumentContentProvider(scheme, provider) {
        if (( (Object.keys(Schemas))).indexOf(scheme) >= 0) {
            throw new Error(`scheme '${scheme}' already registered`);
        }
        const handle = ExtHostDocumentContentProvider._handlePool++;
        this._documentContentProviders.set(handle, provider);
        this._proxy.$registerTextContentProvider(handle, scheme);
        let subscription;
        if (typeof provider.onDidChange === 'function') {
            subscription = provider.onDidChange(uri => {
                if (uri.scheme !== scheme) {
                    this._logService.warn(`Provider for scheme '${scheme}' is firing event for schema '${uri.scheme}' which will be IGNORED`);
                    return;
                }
                if (this._documentsAndEditors.getDocument(uri)) {
                    this.$provideTextDocumentContent(handle, uri).then(value => {
                        if (!value && typeof value !== 'string') {
                            return;
                        }
                        const document = this._documentsAndEditors.getDocument(uri);
                        if (!document) {
                            return;
                        }
                        const lines = splitLines(value);
                        if (!document.equalLines(lines)) {
                            return this._proxy.$onVirtualDocumentChange(uri, value);
                        }
                    }, onUnexpectedError);
                }
            });
        }
        return (
             (new Disposable$2(() => {
                if (this._documentContentProviders.delete(handle)) {
                    this._proxy.$unregisterTextContentProvider(handle);
                }
                if (subscription) {
                    subscription.dispose();
                    subscription = undefined;
                }
            }))
        );
    }
    $provideTextDocumentContent(handle, uri) {
        const provider = this._documentContentProviders.get(handle);
        if (!provider) {
            return Promise.reject(( (new Error(`unsupported uri-scheme: ${uri.scheme}`))));
        }
        return Promise.resolve(provider.provideTextDocumentContent(URI.revive(uri), CancellationToken.None));
    }
}
ExtHostDocumentContentProvider._handlePool = 0;
class TextEditorDecorationType {
    constructor(proxy, extension, options) {
        const key = TextEditorDecorationType._Keys.nextId();
        proxy.$registerTextEditorDecorationType(extension.identifier, key, DecorationRenderOptions.from(options));
        this.value = ( (Object.freeze({
            key,
            dispose() {
                proxy.$removeTextEditorDecorationType(key);
            }
        })));
    }
}
TextEditorDecorationType._Keys = ( (new IdGenerator('TextEditorDecorationType')));
class TextEditorEdit {
    constructor(document, options) {
        this._collectedEdits = [];
        this._setEndOfLine = undefined;
        this._finalized = false;
        this._document = document;
        this._documentVersionId = document.version;
        this._undoStopBefore = options.undoStopBefore;
        this._undoStopAfter = options.undoStopAfter;
    }
    finalize() {
        this._finalized = true;
        return {
            documentVersionId: this._documentVersionId,
            edits: this._collectedEdits,
            setEndOfLine: this._setEndOfLine,
            undoStopBefore: this._undoStopBefore,
            undoStopAfter: this._undoStopAfter
        };
    }
    _throwIfFinalized() {
        if (this._finalized) {
            throw new Error('Edit is only valid while callback runs');
        }
    }
    replace(location, value) {
        this._throwIfFinalized();
        let range = null;
        if (location instanceof Position$3) {
            range = ( (new Range$3(location, location)));
        }
        else if (location instanceof Range$3) {
            range = location;
        }
        else {
            throw new Error('Unrecognized location');
        }
        this._pushEdit(range, value, false);
    }
    insert(location, value) {
        this._throwIfFinalized();
        this._pushEdit(( (new Range$3(location, location))), value, true);
    }
    delete(location) {
        this._throwIfFinalized();
        let range = null;
        if (location instanceof Range$3) {
            range = location;
        }
        else {
            throw new Error('Unrecognized location');
        }
        this._pushEdit(range, null, true);
    }
    _pushEdit(range, text, forceMoveMarkers) {
        const validRange = this._document.validateRange(range);
        this._collectedEdits.push({
            range: validRange,
            text: text,
            forceMoveMarkers: forceMoveMarkers
        });
    }
    setEndOfLine(endOfLine) {
        this._throwIfFinalized();
        if (endOfLine !== EndOfLine$2.LF && endOfLine !== EndOfLine$2.CRLF) {
            throw illegalArgument('endOfLine');
        }
        this._setEndOfLine = endOfLine;
    }
}
class ExtHostTextEditorOptions {
    constructor(proxy, id, source, logService) {
        this._proxy = proxy;
        this._id = id;
        this._accept(source);
        this._logService = logService;
        const that = this;
        this.value = {
            get tabSize() {
                return that._tabSize;
            },
            set tabSize(value) {
                that._setTabSize(value);
            },
            get indentSize() {
                return that._indentSize;
            },
            set indentSize(value) {
                that._setIndentSize(value);
            },
            get insertSpaces() {
                return that._insertSpaces;
            },
            set insertSpaces(value) {
                that._setInsertSpaces(value);
            },
            get cursorStyle() {
                return that._cursorStyle;
            },
            set cursorStyle(value) {
                that._setCursorStyle(value);
            },
            get lineNumbers() {
                return that._lineNumbers;
            },
            set lineNumbers(value) {
                that._setLineNumbers(value);
            }
        };
    }
    _accept(source) {
        this._tabSize = source.tabSize;
        this._indentSize = source.indentSize;
        this._insertSpaces = source.insertSpaces;
        this._cursorStyle = source.cursorStyle;
        this._lineNumbers = TextEditorLineNumbersStyle$1.to(source.lineNumbers);
    }
    _validateTabSize(value) {
        if (value === 'auto') {
            return 'auto';
        }
        if (typeof value === 'number') {
            const r = Math.floor(value);
            return (r > 0 ? r : null);
        }
        if (typeof value === 'string') {
            const r = parseInt(value, 10);
            if (isNaN(r)) {
                return null;
            }
            return (r > 0 ? r : null);
        }
        return null;
    }
    _setTabSize(value) {
        const tabSize = this._validateTabSize(value);
        if (tabSize === null) {
            return;
        }
        if (typeof tabSize === 'number') {
            if (this._tabSize === tabSize) {
                return;
            }
            this._tabSize = tabSize;
        }
        this._warnOnError('setTabSize', this._proxy.$trySetOptions(this._id, {
            tabSize: tabSize
        }));
    }
    _validateIndentSize(value) {
        if (value === 'tabSize') {
            return 'tabSize';
        }
        if (typeof value === 'number') {
            const r = Math.floor(value);
            return (r > 0 ? r : null);
        }
        if (typeof value === 'string') {
            const r = parseInt(value, 10);
            if (isNaN(r)) {
                return null;
            }
            return (r > 0 ? r : null);
        }
        return null;
    }
    _setIndentSize(value) {
        const indentSize = this._validateIndentSize(value);
        if (indentSize === null) {
            return;
        }
        if (typeof indentSize === 'number') {
            if (this._indentSize === indentSize) {
                return;
            }
            this._indentSize = indentSize;
        }
        this._warnOnError('setIndentSize', this._proxy.$trySetOptions(this._id, {
            indentSize: indentSize
        }));
    }
    _validateInsertSpaces(value) {
        if (value === 'auto') {
            return 'auto';
        }
        return (value === 'false' ? false : Boolean(value));
    }
    _setInsertSpaces(value) {
        const insertSpaces = this._validateInsertSpaces(value);
        if (typeof insertSpaces === 'boolean') {
            if (this._insertSpaces === insertSpaces) {
                return;
            }
            this._insertSpaces = insertSpaces;
        }
        this._warnOnError('setInsertSpaces', this._proxy.$trySetOptions(this._id, {
            insertSpaces: insertSpaces
        }));
    }
    _setCursorStyle(value) {
        if (this._cursorStyle === value) {
            return;
        }
        this._cursorStyle = value;
        this._warnOnError('setCursorStyle', this._proxy.$trySetOptions(this._id, {
            cursorStyle: value
        }));
    }
    _setLineNumbers(value) {
        if (this._lineNumbers === value) {
            return;
        }
        this._lineNumbers = value;
        this._warnOnError('setLineNumbers', this._proxy.$trySetOptions(this._id, {
            lineNumbers: TextEditorLineNumbersStyle$1.from(value)
        }));
    }
    assign(newOptions) {
        const bulkConfigurationUpdate = {};
        let hasUpdate = false;
        if (typeof newOptions.tabSize !== 'undefined') {
            const tabSize = this._validateTabSize(newOptions.tabSize);
            if (tabSize === 'auto') {
                hasUpdate = true;
                bulkConfigurationUpdate.tabSize = tabSize;
            }
            else if (typeof tabSize === 'number' && this._tabSize !== tabSize) {
                this._tabSize = tabSize;
                hasUpdate = true;
                bulkConfigurationUpdate.tabSize = tabSize;
            }
        }
        if (typeof newOptions.indentSize !== 'undefined') {
            const indentSize = this._validateIndentSize(newOptions.indentSize);
            if (indentSize === 'tabSize') {
                hasUpdate = true;
                bulkConfigurationUpdate.indentSize = indentSize;
            }
            else if (typeof indentSize === 'number' && this._indentSize !== indentSize) {
                this._indentSize = indentSize;
                hasUpdate = true;
                bulkConfigurationUpdate.indentSize = indentSize;
            }
        }
        if (typeof newOptions.insertSpaces !== 'undefined') {
            const insertSpaces = this._validateInsertSpaces(newOptions.insertSpaces);
            if (insertSpaces === 'auto') {
                hasUpdate = true;
                bulkConfigurationUpdate.insertSpaces = insertSpaces;
            }
            else if (this._insertSpaces !== insertSpaces) {
                this._insertSpaces = insertSpaces;
                hasUpdate = true;
                bulkConfigurationUpdate.insertSpaces = insertSpaces;
            }
        }
        if (typeof newOptions.cursorStyle !== 'undefined') {
            if (this._cursorStyle !== newOptions.cursorStyle) {
                this._cursorStyle = newOptions.cursorStyle;
                hasUpdate = true;
                bulkConfigurationUpdate.cursorStyle = newOptions.cursorStyle;
            }
        }
        if (typeof newOptions.lineNumbers !== 'undefined') {
            if (this._lineNumbers !== newOptions.lineNumbers) {
                this._lineNumbers = newOptions.lineNumbers;
                hasUpdate = true;
                bulkConfigurationUpdate.lineNumbers = TextEditorLineNumbersStyle$1.from(newOptions.lineNumbers);
            }
        }
        if (hasUpdate) {
            this._warnOnError('setOptions', this._proxy.$trySetOptions(this._id, bulkConfigurationUpdate));
        }
    }
    _warnOnError(action, promise) {
        promise.catch(err => {
            this._logService.warn(`ExtHostTextEditorOptions '${action}' failed:'`);
            this._logService.warn(err);
        });
    }
}
class ExtHostTextEditor {
    constructor(id, _proxy, _logService, document, selections, options, visibleRanges, viewColumn) {
        this.id = id;
        this._proxy = _proxy;
        this._logService = _logService;
        this._disposed = false;
        this._hasDecorationsForKey = ( (new Set()));
        this._selections = selections;
        this._options = ( (new ExtHostTextEditorOptions(this._proxy, this.id, options, _logService)));
        this._visibleRanges = visibleRanges;
        this._viewColumn = viewColumn;
        const that = this;
        this.value = ( (Object.freeze({
            get document() {
                return document.value;
            },
            set document(_value) {
                throw readonly('document');
            },
            get selection() {
                return that._selections && that._selections[0];
            },
            set selection(value) {
                if (!(value instanceof Selection$2)) {
                    throw illegalArgument('selection');
                }
                that._selections = [value];
                that._trySetSelection();
            },
            get selections() {
                return that._selections;
            },
            set selections(value) {
                if (!Array.isArray(value) || value.some(a => !(a instanceof Selection$2))) {
                    throw illegalArgument('selections');
                }
                that._selections = value;
                that._trySetSelection();
            },
            get visibleRanges() {
                return that._visibleRanges;
            },
            set visibleRanges(_value) {
                throw readonly('visibleRanges');
            },
            get options() {
                return that._options.value;
            },
            set options(value) {
                if (!that._disposed) {
                    that._options.assign(value);
                }
            },
            get viewColumn() {
                return that._viewColumn;
            },
            set viewColumn(_value) {
                throw readonly('viewColumn');
            },
            edit(callback, options = { undoStopBefore: true, undoStopAfter: true }) {
                if (that._disposed) {
                    return Promise.reject(( (new Error('TextEditor#edit not possible on closed editors'))));
                }
                const edit = ( (new TextEditorEdit(document.value, options)));
                callback(edit);
                return that._applyEdit(edit);
            },
            insertSnippet(snippet, where, options = { undoStopBefore: true, undoStopAfter: true }) {
                if (that._disposed) {
                    return Promise.reject(( (new Error('TextEditor#insertSnippet not possible on closed editors'))));
                }
                let ranges;
                if (!where || (Array.isArray(where) && where.length === 0)) {
                    ranges = ( (that._selections.map(range => Range$1.from(range))));
                }
                else if (where instanceof Position$3) {
                    const { lineNumber, column } = Position$1.from(where);
                    ranges = [{ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column }];
                }
                else if (where instanceof Range$3) {
                    ranges = [Range$1.from(where)];
                }
                else {
                    ranges = [];
                    for (const posOrRange of where) {
                        if (posOrRange instanceof Range$3) {
                            ranges.push(Range$1.from(posOrRange));
                        }
                        else {
                            const { lineNumber, column } = Position$1.from(posOrRange);
                            ranges.push({ startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: column });
                        }
                    }
                }
                return _proxy.$tryInsertSnippet(id, document.value.version, snippet.value, ranges, options);
            },
            setDecorations(decorationType, ranges) {
                const willBeEmpty = (ranges.length === 0);
                if (willBeEmpty && !that._hasDecorationsForKey.has(decorationType.key)) {
                    return;
                }
                if (willBeEmpty) {
                    that._hasDecorationsForKey.delete(decorationType.key);
                }
                else {
                    that._hasDecorationsForKey.add(decorationType.key);
                }
                that._runOnProxy(() => {
                    if (isDecorationOptionsArr(ranges)) {
                        return _proxy.$trySetDecorations(id, decorationType.key, fromRangeOrRangeWithMessage(ranges));
                    }
                    else {
                        const _ranges = ( (new Array(4 * ranges.length)));
                        for (let i = 0, len = ranges.length; i < len; i++) {
                            const range = ranges[i];
                            _ranges[4 * i] = range.start.line + 1;
                            _ranges[4 * i + 1] = range.start.character + 1;
                            _ranges[4 * i + 2] = range.end.line + 1;
                            _ranges[4 * i + 3] = range.end.character + 1;
                        }
                        return _proxy.$trySetDecorationsFast(id, decorationType.key, _ranges);
                    }
                });
            },
            revealRange(range, revealType) {
                that._runOnProxy(() => _proxy.$tryRevealRange(id, Range$1.from(range), (revealType || TextEditorRevealType$2.Default)));
            },
            show(column) {
                _proxy.$tryShowEditor(id, ViewColumn$1.from(column));
            },
            hide() {
                _proxy.$tryHideEditor(id);
            }
        })));
    }
    dispose() {
        ok(!this._disposed);
        this._disposed = true;
    }
    _acceptOptions(options) {
        ok(!this._disposed);
        this._options._accept(options);
    }
    _acceptVisibleRanges(value) {
        ok(!this._disposed);
        this._visibleRanges = value;
    }
    _acceptViewColumn(value) {
        ok(!this._disposed);
        this._viewColumn = value;
    }
    _acceptSelections(selections) {
        ok(!this._disposed);
        this._selections = selections;
    }
    async _trySetSelection() {
        const selection = ( (this._selections.map(Selection$1.from)));
        await this._runOnProxy(() => this._proxy.$trySetSelections(this.id, selection));
        return this.value;
    }
    _applyEdit(editBuilder) {
        const editData = editBuilder.finalize();
        if (editData.edits.length === 0 && !editData.setEndOfLine) {
            return Promise.resolve(true);
        }
        const editRanges = ( (editData.edits.map(edit => edit.range)));
        editRanges.sort((a, b) => {
            if (a.end.line === b.end.line) {
                if (a.end.character === b.end.character) {
                    if (a.start.line === b.start.line) {
                        return a.start.character - b.start.character;
                    }
                    return a.start.line - b.start.line;
                }
                return a.end.character - b.end.character;
            }
            return a.end.line - b.end.line;
        });
        for (let i = 0, count = editRanges.length - 1; i < count; i++) {
            const rangeEnd = editRanges[i].end;
            const nextRangeStart = editRanges[i + 1].start;
            if (nextRangeStart.isBefore(rangeEnd)) {
                return Promise.reject(( (new Error('Overlapping ranges are not allowed!'))));
            }
        }
        const edits = ( (editData.edits.map((edit) => {
            return {
                range: Range$1.from(edit.range),
                text: edit.text,
                forceMoveMarkers: edit.forceMoveMarkers
            };
        })));
        return this._proxy.$tryApplyEdits(this.id, editData.documentVersionId, edits, {
            setEndOfLine: typeof editData.setEndOfLine === 'number' ? EndOfLine$1.from(editData.setEndOfLine) : undefined,
            undoStopBefore: editData.undoStopBefore,
            undoStopAfter: editData.undoStopAfter
        });
    }
    _runOnProxy(callback) {
        if (this._disposed) {
            this._logService.warn('TextEditor is closed/disposed');
            return Promise.resolve(undefined);
        }
        return callback().then(() => this, err => {
            if (!(err instanceof Error && err.name === 'DISPOSED')) {
                this._logService.warn(err);
            }
            return null;
        });
    }
}
class Reference {
    constructor(value) {
        this.value = value;
        this._count = 0;
    }
    ref() {
        this._count++;
    }
    unref() {
        return --this._count === 0;
    }
}
let ExtHostDocumentsAndEditors = class ExtHostDocumentsAndEditors {
    constructor(_extHostRpc, _logService) {
        this._extHostRpc = _extHostRpc;
        this._logService = _logService;
        this._activeEditorId = null;
        this._editors = ( (new Map()));
        this._documents = ( (new ResourceMap$1()));
        this._onDidAddDocuments = ( (new Emitter$1()));
        this._onDidRemoveDocuments = ( (new Emitter$1()));
        this._onDidChangeVisibleTextEditors = ( (new Emitter$1()));
        this._onDidChangeActiveTextEditor = ( (new Emitter$1()));
        this.onDidAddDocuments = this._onDidAddDocuments.event;
        this.onDidRemoveDocuments = this._onDidRemoveDocuments.event;
        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
    }
    $acceptDocumentsAndEditorsDelta(delta) {
        this.acceptDocumentsAndEditorsDelta(delta);
    }
    acceptDocumentsAndEditorsDelta(delta) {
        const removedDocuments = [];
        const addedDocuments = [];
        const removedEditors = [];
        if (delta.removedDocuments) {
            for (const uriComponent of delta.removedDocuments) {
                const uri = URI.revive(uriComponent);
                const data = this._documents.get(uri);
                if (data?.unref()) {
                    this._documents.delete(uri);
                    removedDocuments.push(data.value);
                }
            }
        }
        if (delta.addedDocuments) {
            for (const data of delta.addedDocuments) {
                const resource = URI.revive(data.uri);
                let ref = this._documents.get(resource);
                if (ref) {
                    if (resource.scheme !== Schemas.vscodeNotebookCell && resource.scheme !== Schemas.vscodeInteractiveInput) {
                        throw new Error(`document '${resource} already exists!'`);
                    }
                }
                if (!ref) {
                    ref = ( (new Reference( (new ExtHostDocumentData(
                         (this._extHostRpc.getProxy(MainContext.MainThreadDocuments)),
                        resource,
                        data.lines,
                        data.EOL,
                        data.versionId,
                        data.languageId,
                        data.isDirty,
                        data.notebook
                    )))));
                    this._documents.set(resource, ref);
                    addedDocuments.push(ref.value);
                }
                ref.ref();
            }
        }
        if (delta.removedEditors) {
            for (const id of delta.removedEditors) {
                const editor = this._editors.get(id);
                this._editors.delete(id);
                if (editor) {
                    removedEditors.push(editor);
                }
            }
        }
        if (delta.addedEditors) {
            for (const data of delta.addedEditors) {
                const resource = URI.revive(data.documentUri);
                ok(this._documents.has(resource), `document '${resource}' does not exist`);
                ok(!this._editors.has(data.id), `editor '${data.id}' already exists!`);
                const documentData = this._documents.get(resource).value;
                const editor = ( (new ExtHostTextEditor(
                    data.id,
                     (this._extHostRpc.getProxy(MainContext.MainThreadTextEditors)),
                    this._logService,
                     (new Lazy(() => documentData.document)),
                     (data.selections.map(Selection$1.to)),
                    data.options,
                     (data.visibleRanges.map(range => Range$1.to(range))),
                    typeof data.editorPosition === 'number' ? ViewColumn$1.to(data.editorPosition) : undefined
                )));
                this._editors.set(data.id, editor);
            }
        }
        if (delta.newActiveEditor !== undefined) {
            ok(delta.newActiveEditor === null || this._editors.has(delta.newActiveEditor), `active editor '${delta.newActiveEditor}' does not exist`);
            this._activeEditorId = delta.newActiveEditor;
        }
        dispose(removedDocuments);
        dispose(removedEditors);
        if (delta.removedDocuments) {
            this._onDidRemoveDocuments.fire(removedDocuments);
        }
        if (delta.addedDocuments) {
            this._onDidAddDocuments.fire(addedDocuments);
        }
        if (delta.removedEditors || delta.addedEditors) {
            this._onDidChangeVisibleTextEditors.fire(( (this.allEditors().map(editor => editor.value))));
        }
        if (delta.newActiveEditor !== undefined) {
            this._onDidChangeActiveTextEditor.fire(this.activeEditor());
        }
    }
    getDocument(uri) {
        return this._documents.get(uri)?.value;
    }
    allDocuments() {
        return (
             (Iterable.map( (this._documents.values()), ref => ref.value))
        );
    }
    getEditor(id) {
        return this._editors.get(id);
    }
    activeEditor(internal) {
        if (!this._activeEditorId) {
            return undefined;
        }
        const editor = this._editors.get(this._activeEditorId);
        if (internal) {
            return editor;
        }
        else {
            return editor?.value;
        }
    }
    allEditors() {
        return [...( (this._editors.values()))];
    }
};
ExtHostDocumentsAndEditors = ( (__decorate([
    ( (__param(0, IExtHostRpcService))),
    ( (__param(1, ILogService)))
], ExtHostDocumentsAndEditors)));
const IExtHostDocumentsAndEditors = ( (createDecorator$1('IExtHostDocumentsAndEditors')));
class ExtHostEditors {
    constructor(mainContext, _extHostDocumentsAndEditors) {
        this._extHostDocumentsAndEditors = _extHostDocumentsAndEditors;
        this._onDidChangeTextEditorSelection = ( (new Emitter$1()));
        this._onDidChangeTextEditorOptions = ( (new Emitter$1()));
        this._onDidChangeTextEditorVisibleRanges = ( (new Emitter$1()));
        this._onDidChangeTextEditorViewColumn = ( (new Emitter$1()));
        this._onDidChangeActiveTextEditor = ( (new Emitter$1()));
        this._onDidChangeVisibleTextEditors = ( (new Emitter$1()));
        this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event;
        this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event;
        this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event;
        this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event;
        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadTextEditors)));
        this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors(e => this._onDidChangeVisibleTextEditors.fire(e));
        this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor(e => this._onDidChangeActiveTextEditor.fire(e));
    }
    getActiveTextEditor() {
        return this._extHostDocumentsAndEditors.activeEditor();
    }
    getVisibleTextEditors(internal) {
        const editors = this._extHostDocumentsAndEditors.allEditors();
        return internal
            ? editors
            : ( (editors.map(editor => editor.value)));
    }
    async showTextDocument(document, columnOrOptions, preserveFocus) {
        let options;
        if (typeof columnOrOptions === 'number') {
            options = {
                position: ViewColumn$1.from(columnOrOptions),
                preserveFocus
            };
        }
        else if (typeof columnOrOptions === 'object') {
            options = {
                position: ViewColumn$1.from(columnOrOptions.viewColumn),
                preserveFocus: columnOrOptions.preserveFocus,
                selection: typeof columnOrOptions.selection === 'object' ? Range$1.from(columnOrOptions.selection) : undefined,
                pinned: typeof columnOrOptions.preview === 'boolean' ? !columnOrOptions.preview : undefined
            };
        }
        else {
            options = {
                preserveFocus: false
            };
        }
        const editorId = await this._proxy.$tryShowTextDocument(document.uri, options);
        const editor = editorId && this._extHostDocumentsAndEditors.getEditor(editorId);
        if (editor) {
            return editor.value;
        }
        if (editorId) {
            throw new Error(`Could NOT open editor for "${document.uri.toString()}" because another editor opened in the meantime.`);
        }
        else {
            throw new Error(`Could NOT open editor for "${document.uri.toString()}".`);
        }
    }
    createTextEditorDecorationType(extension, options) {
        return ( (new TextEditorDecorationType(this._proxy, extension, options))).value;
    }
    $acceptEditorPropertiesChanged(id, data) {
        const textEditor = this._extHostDocumentsAndEditors.getEditor(id);
        if (!textEditor) {
            throw new Error('unknown text editor');
        }
        if (data.options) {
            textEditor._acceptOptions(data.options);
        }
        if (data.selections) {
            const selections = ( (data.selections.selections.map(Selection$1.to)));
            textEditor._acceptSelections(selections);
        }
        if (data.visibleRanges) {
            const visibleRanges = coalesce(( (data.visibleRanges.map(Range$1.to))));
            textEditor._acceptVisibleRanges(visibleRanges);
        }
        if (data.options) {
            this._onDidChangeTextEditorOptions.fire({
                textEditor: textEditor.value,
                options: { ...data.options, lineNumbers: TextEditorLineNumbersStyle$1.to(data.options.lineNumbers) }
            });
        }
        if (data.selections) {
            const kind = TextEditorSelectionChangeKind$1.fromValue(data.selections.source);
            const selections = ( (data.selections.selections.map(Selection$1.to)));
            this._onDidChangeTextEditorSelection.fire({
                textEditor: textEditor.value,
                selections,
                kind
            });
        }
        if (data.visibleRanges) {
            const visibleRanges = coalesce(( (data.visibleRanges.map(Range$1.to))));
            this._onDidChangeTextEditorVisibleRanges.fire({
                textEditor: textEditor.value,
                visibleRanges
            });
        }
    }
    $acceptEditorPositionData(data) {
        for (const id in data) {
            const textEditor = this._extHostDocumentsAndEditors.getEditor(id);
            if (!textEditor) {
                throw new Error('Unknown text editor');
            }
            const viewColumn = ViewColumn$1.to(data[id]);
            if (textEditor.value.viewColumn !== viewColumn) {
                textEditor._acceptViewColumn(viewColumn);
                this._onDidChangeTextEditorViewColumn.fire({ textEditor: textEditor.value, viewColumn });
            }
        }
    }
    getDiffInformation(id) {
        return Promise.resolve(this._proxy.$getDiffInformation(id));
    }
}
class BoundModelReferenceCollection {
    constructor(_extUri, _maxAge = 1000 * 60 * 3,
    _maxLength = 1024 * 1024 * 80,
    _maxSize = 50
    ) {
        this._extUri = _extUri;
        this._maxAge = _maxAge;
        this._maxLength = _maxLength;
        this._maxSize = _maxSize;
        this._data = ( (new Array()));
        this._length = 0;
    }
    dispose() {
        this._data = dispose(this._data);
    }
    remove(uri) {
        for (const entry of [...this._data] ) {
            if (this._extUri.isEqualOrParent(entry.uri, uri)) {
                entry.dispose();
            }
        }
    }
    add(uri, ref, length = 0) {
        const dispose = () => {
            const idx = this._data.indexOf(entry);
            if (idx >= 0) {
                this._length -= length;
                ref.dispose();
                clearTimeout(handle);
                this._data.splice(idx, 1);
            }
        };
        const handle = setTimeout(dispose, this._maxAge);
        const entry = { uri, length, dispose };
        this._data.push(entry);
        this._length += length;
        this._cleanup();
    }
    _cleanup() {
        while (this._length > this._maxLength) {
            this._data[0].dispose();
        }
        const extraSize = Math.ceil(this._maxSize * 1.2);
        if (this._data.length >= extraSize) {
            dispose(this._data.slice(0, extraSize - this._maxSize));
        }
    }
}
class ModelTracker extends Disposable$1 {
    constructor(_model, _onIsCaughtUpWithContentChanges, _proxy, _textFileService) {
        super();
        this._model = _model;
        this._onIsCaughtUpWithContentChanges = _onIsCaughtUpWithContentChanges;
        this._proxy = _proxy;
        this._textFileService = _textFileService;
        this._knownVersionId = this._model.getVersionId();
        this._store.add(this._model.onDidChangeContent((e) => {
            this._knownVersionId = e.versionId;
            this._proxy.$acceptModelChanged(this._model.uri, e, this._textFileService.isDirty(this._model.uri));
            if (this.isCaughtUpWithContentChanges()) {
                this._onIsCaughtUpWithContentChanges.fire(this._model.uri);
            }
        }));
    }
    isCaughtUpWithContentChanges() {
        return (this._model.getVersionId() === this._knownVersionId);
    }
}
let MainThreadDocuments = class MainThreadDocuments extends Disposable$1 {
    constructor(extHostContext, _modelService, _textFileService, _fileService, _textModelResolverService, _environmentService, _uriIdentityService, workingCopyFileService, _pathService) {
        super();
        this._modelService = _modelService;
        this._textFileService = _textFileService;
        this._fileService = _fileService;
        this._textModelResolverService = _textModelResolverService;
        this._environmentService = _environmentService;
        this._uriIdentityService = _uriIdentityService;
        this._pathService = _pathService;
        this._onIsCaughtUpWithContentChanges = this._store.add(( (new Emitter$1())));
        this.onIsCaughtUpWithContentChanges = this._onIsCaughtUpWithContentChanges.event;
        this._modelTrackers = ( (new ResourceMap$1()));
        this._modelReferenceCollection = this._store.add(( (new BoundModelReferenceCollection(_uriIdentityService.extUri))));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostDocuments)));
        this._store.add(_modelService.onModelLanguageChanged(this._onModelModeChanged, this));
        this._store.add(_textFileService.files.onDidSave(e => {
            if (this._shouldHandleFileEvent(e.model.resource)) {
                this._proxy.$acceptModelSaved(e.model.resource);
            }
        }));
        this._store.add(_textFileService.files.onDidChangeDirty(m => {
            if (this._shouldHandleFileEvent(m.resource)) {
                this._proxy.$acceptDirtyStateChanged(m.resource, m.isDirty());
            }
        }));
        this._store.add(workingCopyFileService.onDidRunWorkingCopyFileOperation(e => {
            const isMove = e.operation === 2 ;
            if (isMove || e.operation === 1 ) {
                for (const pair of e.files) {
                    const removed = isMove ? pair.source : pair.target;
                    if (removed) {
                        this._modelReferenceCollection.remove(removed);
                    }
                }
            }
        }));
    }
    dispose() {
        dispose(( (this._modelTrackers.values())));
        this._modelTrackers.clear();
        super.dispose();
    }
    isCaughtUpWithContentChanges(resource) {
        const tracker = this._modelTrackers.get(resource);
        if (tracker) {
            return tracker.isCaughtUpWithContentChanges();
        }
        return true;
    }
    _shouldHandleFileEvent(resource) {
        const model = this._modelService.getModel(resource);
        return !!model && shouldSynchronizeModel(model);
    }
    handleModelAdded(model) {
        if (!shouldSynchronizeModel(model)) {
            return;
        }
        this._modelTrackers.set(model.uri, ( (new ModelTracker(
            model,
            this._onIsCaughtUpWithContentChanges,
            this._proxy,
            this._textFileService
        ))));
    }
    _onModelModeChanged(event) {
        const { model } = event;
        if (!this._modelTrackers.has(model.uri)) {
            return;
        }
        this._proxy.$acceptModelLanguageChanged(model.uri, model.getLanguageId());
    }
    handleModelRemoved(modelUrl) {
        if (!this._modelTrackers.has(modelUrl)) {
            return;
        }
        this._modelTrackers.get(modelUrl).dispose();
        this._modelTrackers.delete(modelUrl);
    }
    async $trySaveDocument(uri) {
        const target = await this._textFileService.save(URI.revive(uri));
        return Boolean(target);
    }
    async $tryOpenDocument(uriData) {
        const inputUri = URI.revive(uriData);
        if (!inputUri.scheme || !(inputUri.fsPath || inputUri.authority)) {
            throw new Error(`Invalid uri. Scheme and authority or path must be set.`);
        }
        const canonicalUri = this._uriIdentityService.asCanonicalUri(inputUri);
        let promise;
        switch (canonicalUri.scheme) {
            case Schemas.untitled:
                promise = this._handleUntitledScheme(canonicalUri);
                break;
            case Schemas.file:
            default:
                promise = this._handleAsResourceInput(canonicalUri);
                break;
        }
        let documentUri;
        try {
            documentUri = await promise;
        }
        catch (err) {
            throw new Error(`cannot open ${canonicalUri.toString()}. Detail: ${toErrorMessage(err)}`);
        }
        if (!documentUri) {
            throw new Error(`cannot open ${canonicalUri.toString()}`);
        }
        else if (!extUri.isEqual(documentUri, canonicalUri)) {
            throw new Error(`cannot open ${canonicalUri.toString()}. Detail: Actual document opened as ${documentUri.toString()}`);
        }
        else if (!this._modelTrackers.has(canonicalUri)) {
            throw new Error(`cannot open ${canonicalUri.toString()}. Detail: Files above 50MB cannot be synchronized with extensions.`);
        }
        else {
            return canonicalUri;
        }
    }
    $tryCreateDocument(options) {
        return this._doCreateUntitled(undefined, options ? options.language : undefined, options ? options.content : undefined);
    }
    async _handleAsResourceInput(uri) {
        const ref = await this._textModelResolverService.createModelReference(uri);
        this._modelReferenceCollection.add(uri, ref, ref.object.textEditorModel.getValueLength());
        return ref.object.textEditorModel.uri;
    }
    async _handleUntitledScheme(uri) {
        const asLocalUri = toLocalResource(uri, this._environmentService.remoteAuthority, this._pathService.defaultUriScheme);
        const exists = await this._fileService.exists(asLocalUri);
        if (exists) {
            return Promise.reject(( (new Error('file already exists'))));
        }
        return await this._doCreateUntitled(Boolean(uri.path) ? uri : undefined);
    }
    async _doCreateUntitled(associatedResource, languageId, initialValue) {
        const model = await this._textFileService.untitled.resolve({
            associatedResource,
            languageId,
            initialValue
        });
        const resource = model.resource;
        if (!this._modelTrackers.has(resource)) {
            throw new Error(`expected URI ${resource.toString()} to have come to LIFE`);
        }
        this._proxy.$acceptDirtyStateChanged(resource, true);
        return resource;
    }
};
MainThreadDocuments = ( (__decorate([
    ( (__param(1, IModelService))),
    ( (__param(2, ITextFileService))),
    ( (__param(3, IFileService))),
    ( (__param(4, ITextModelService))),
    ( (__param(5, IWorkbenchEnvironmentService))),
    ( (__param(6, IUriIdentityService))),
    ( (__param(7, IWorkingCopyFileService))),
    ( (__param(8, IPathService)))
], MainThreadDocuments)));
class MainThreadTextEditorProperties {
    static readFromEditor(previousProperties, model, codeEditor) {
        const selections = MainThreadTextEditorProperties._readSelectionsFromCodeEditor(previousProperties, codeEditor);
        const options = MainThreadTextEditorProperties._readOptionsFromCodeEditor(previousProperties, model, codeEditor);
        const visibleRanges = MainThreadTextEditorProperties._readVisibleRangesFromCodeEditor(previousProperties, codeEditor);
        return (
             (new MainThreadTextEditorProperties(selections, options, visibleRanges))
        );
    }
    static _readSelectionsFromCodeEditor(previousProperties, codeEditor) {
        let result = null;
        if (codeEditor) {
            result = codeEditor.getSelections();
        }
        if (!result && previousProperties) {
            result = previousProperties.selections;
        }
        if (!result) {
            result = [( (new Selection$3(1, 1, 1, 1)))];
        }
        return result;
    }
    static _readOptionsFromCodeEditor(previousProperties, model, codeEditor) {
        if (model.isDisposed()) {
            if (previousProperties) {
                return previousProperties.options;
            }
            else {
                throw new Error('No valid properties');
            }
        }
        let cursorStyle;
        let lineNumbers;
        if (codeEditor) {
            const options = codeEditor.getOptions();
            const lineNumbersOpts = options.get(64 );
            cursorStyle = options.get(25 );
            lineNumbers = lineNumbersOpts.renderType;
        }
        else if (previousProperties) {
            cursorStyle = previousProperties.options.cursorStyle;
            lineNumbers = previousProperties.options.lineNumbers;
        }
        else {
            cursorStyle = TextEditorCursorStyle$2.Line;
            lineNumbers = 1 ;
        }
        const modelOptions = model.getOptions();
        return {
            insertSpaces: modelOptions.insertSpaces,
            tabSize: modelOptions.tabSize,
            indentSize: modelOptions.indentSize,
            cursorStyle: cursorStyle,
            lineNumbers: lineNumbers
        };
    }
    static _readVisibleRangesFromCodeEditor(previousProperties, codeEditor) {
        if (codeEditor) {
            return codeEditor.getVisibleRanges();
        }
        return [];
    }
    constructor(selections, options, visibleRanges) {
        this.selections = selections;
        this.options = options;
        this.visibleRanges = visibleRanges;
    }
    generateDelta(oldProps, selectionChangeSource) {
        const delta = {
            options: null,
            selections: null,
            visibleRanges: null
        };
        if (!oldProps || !MainThreadTextEditorProperties._selectionsEqual(oldProps.selections, this.selections)) {
            delta.selections = {
                selections: this.selections,
                source: withNullAsUndefined(selectionChangeSource)
            };
        }
        if (!oldProps || !MainThreadTextEditorProperties._optionsEqual(oldProps.options, this.options)) {
            delta.options = this.options;
        }
        if (!oldProps || !MainThreadTextEditorProperties._rangesEqual(oldProps.visibleRanges, this.visibleRanges)) {
            delta.visibleRanges = this.visibleRanges;
        }
        if (delta.selections || delta.options || delta.visibleRanges) {
            return delta;
        }
        return null;
    }
    static _selectionsEqual(a, b) {
        return equals(a, b, (aValue, bValue) => aValue.equalsSelection(bValue));
    }
    static _rangesEqual(a, b) {
        return equals(a, b, (aValue, bValue) => aValue.equalsRange(bValue));
    }
    static _optionsEqual(a, b) {
        if (a && !b || !a && b) {
            return false;
        }
        if (!a && !b) {
            return true;
        }
        return (a.tabSize === b.tabSize
            && a.indentSize === b.indentSize
            && a.insertSpaces === b.insertSpaces
            && a.cursorStyle === b.cursorStyle
            && a.lineNumbers === b.lineNumbers);
    }
}
class MainThreadTextEditor {
    constructor(id, model, codeEditor, focusTracker, mainThreadDocuments, modelService, clipboardService) {
        this._modelListeners = ( (new DisposableStore()));
        this._codeEditorListeners = ( (new DisposableStore()));
        this._id = id;
        this._model = model;
        this._codeEditor = null;
        this._properties = null;
        this._focusTracker = focusTracker;
        this._mainThreadDocuments = mainThreadDocuments;
        this._modelService = modelService;
        this._clipboardService = clipboardService;
        this._onPropertiesChanged = ( (new Emitter$1()));
        this._modelListeners.add(this._model.onDidChangeOptions((e) => {
            this._updatePropertiesNow(null);
        }));
        this.setCodeEditor(codeEditor);
        this._updatePropertiesNow(null);
    }
    dispose() {
        this._modelListeners.dispose();
        this._codeEditor = null;
        this._codeEditorListeners.dispose();
    }
    _updatePropertiesNow(selectionChangeSource) {
        this._setProperties(MainThreadTextEditorProperties.readFromEditor(this._properties, this._model, this._codeEditor), selectionChangeSource);
    }
    _setProperties(newProperties, selectionChangeSource) {
        const delta = newProperties.generateDelta(this._properties, selectionChangeSource);
        this._properties = newProperties;
        if (delta) {
            this._onPropertiesChanged.fire(delta);
        }
    }
    getId() {
        return this._id;
    }
    getModel() {
        return this._model;
    }
    getCodeEditor() {
        return this._codeEditor;
    }
    hasCodeEditor(codeEditor) {
        return (this._codeEditor === codeEditor);
    }
    setCodeEditor(codeEditor) {
        if (this.hasCodeEditor(codeEditor)) {
            return;
        }
        this._codeEditorListeners.clear();
        this._codeEditor = codeEditor;
        if (this._codeEditor) {
            this._codeEditorListeners.add(this._codeEditor.onDidChangeModel(() => {
                this.setCodeEditor(null);
            }));
            this._codeEditorListeners.add(this._codeEditor.onDidFocusEditorWidget(() => {
                this._focusTracker.onGainedFocus();
            }));
            this._codeEditorListeners.add(this._codeEditor.onDidBlurEditorWidget(() => {
                this._focusTracker.onLostFocus();
            }));
            let nextSelectionChangeSource = null;
            this._codeEditorListeners.add(this._mainThreadDocuments.onIsCaughtUpWithContentChanges((uri) => {
                if (( (uri.toString())) === ( (this._model.uri.toString()))) {
                    const selectionChangeSource = nextSelectionChangeSource;
                    nextSelectionChangeSource = null;
                    this._updatePropertiesNow(selectionChangeSource);
                }
            }));
            const isValidCodeEditor = () => {
                return (this._codeEditor && this._codeEditor.getModel() === this._model);
            };
            const updateProperties = (selectionChangeSource) => {
                if (this._mainThreadDocuments.isCaughtUpWithContentChanges(this._model.uri)) {
                    nextSelectionChangeSource = null;
                    this._updatePropertiesNow(selectionChangeSource);
                }
                else {
                    nextSelectionChangeSource = selectionChangeSource;
                }
            };
            this._codeEditorListeners.add(this._codeEditor.onDidChangeCursorSelection((e) => {
                if (!isValidCodeEditor()) {
                    return;
                }
                updateProperties(e.source);
            }));
            this._codeEditorListeners.add(this._codeEditor.onDidChangeConfiguration((e) => {
                if (!isValidCodeEditor()) {
                    return;
                }
                updateProperties(null);
            }));
            this._codeEditorListeners.add(this._codeEditor.onDidLayoutChange(() => {
                if (!isValidCodeEditor()) {
                    return;
                }
                updateProperties(null);
            }));
            this._codeEditorListeners.add(this._codeEditor.onDidScrollChange(() => {
                if (!isValidCodeEditor()) {
                    return;
                }
                updateProperties(null);
            }));
            this._updatePropertiesNow(null);
        }
    }
    isVisible() {
        return !!this._codeEditor;
    }
    getProperties() {
        return this._properties;
    }
    get onPropertiesChanged() {
        return this._onPropertiesChanged.event;
    }
    setSelections(selections) {
        if (this._codeEditor) {
            this._codeEditor.setSelections(selections);
            return;
        }
        const newSelections = ( (selections.map(Selection$3.liftSelection)));
        this._setProperties(( (new MainThreadTextEditorProperties(newSelections, this._properties.options, this._properties.visibleRanges))), null);
    }
    _setIndentConfiguration(newConfiguration) {
        const creationOpts = this._modelService.getCreationOptions(this._model.getLanguageId(), this._model.uri, this._model.isForSimpleWidget);
        if (newConfiguration.tabSize === 'auto' || newConfiguration.insertSpaces === 'auto') {
            let insertSpaces = creationOpts.insertSpaces;
            let tabSize = creationOpts.tabSize;
            if (newConfiguration.insertSpaces !== 'auto' && typeof newConfiguration.insertSpaces !== 'undefined') {
                insertSpaces = newConfiguration.insertSpaces;
            }
            if (newConfiguration.tabSize !== 'auto' && typeof newConfiguration.tabSize !== 'undefined') {
                tabSize = newConfiguration.tabSize;
            }
            this._model.detectIndentation(insertSpaces, tabSize);
            return;
        }
        const newOpts = {};
        if (typeof newConfiguration.insertSpaces !== 'undefined') {
            newOpts.insertSpaces = newConfiguration.insertSpaces;
        }
        if (typeof newConfiguration.tabSize !== 'undefined') {
            newOpts.tabSize = newConfiguration.tabSize;
        }
        if (typeof newConfiguration.indentSize !== 'undefined') {
            newOpts.indentSize = newConfiguration.indentSize;
        }
        this._model.updateOptions(newOpts);
    }
    setConfiguration(newConfiguration) {
        this._setIndentConfiguration(newConfiguration);
        if (!this._codeEditor) {
            return;
        }
        if (newConfiguration.cursorStyle) {
            const newCursorStyle = cursorStyleToString(newConfiguration.cursorStyle);
            this._codeEditor.updateOptions({
                cursorStyle: newCursorStyle
            });
        }
        if (typeof newConfiguration.lineNumbers !== 'undefined') {
            let lineNumbers;
            switch (newConfiguration.lineNumbers) {
                case 1 :
                    lineNumbers = 'on';
                    break;
                case 2 :
                    lineNumbers = 'relative';
                    break;
                default:
                    lineNumbers = 'off';
            }
            this._codeEditor.updateOptions({
                lineNumbers: lineNumbers
            });
        }
    }
    setDecorations(key, ranges) {
        if (!this._codeEditor) {
            return;
        }
        this._codeEditor.setDecorationsByType('exthost-api', key, ranges);
    }
    setDecorationsFast(key, _ranges) {
        if (!this._codeEditor) {
            return;
        }
        const ranges = [];
        for (let i = 0, len = Math.floor(_ranges.length / 4); i < len; i++) {
            ranges[i] = ( (new Range$2(_ranges[4 * i], _ranges[4 * i + 1], _ranges[4 * i + 2], _ranges[4 * i + 3])));
        }
        this._codeEditor.setDecorationsByTypeFast(key, ranges);
    }
    revealRange(range, revealType) {
        if (!this._codeEditor) {
            return;
        }
        switch (revealType) {
            case TextEditorRevealType$1.Default:
                this._codeEditor.revealRange(range, 0 );
                break;
            case TextEditorRevealType$1.InCenter:
                this._codeEditor.revealRangeInCenter(range, 0 );
                break;
            case TextEditorRevealType$1.InCenterIfOutsideViewport:
                this._codeEditor.revealRangeInCenterIfOutsideViewport(range, 0 );
                break;
            case TextEditorRevealType$1.AtTop:
                this._codeEditor.revealRangeAtTop(range, 0 );
                break;
            default:
                console.warn(`Unknown revealType: ${revealType}`);
                break;
        }
    }
    isFocused() {
        if (this._codeEditor) {
            return this._codeEditor.hasTextFocus();
        }
        return false;
    }
    matches(editor) {
        if (!editor) {
            return false;
        }
        return editor.getControl() === this._codeEditor;
    }
    applyEdits(versionIdCheck, edits, opts) {
        if (this._model.getVersionId() !== versionIdCheck) {
            return false;
        }
        if (!this._codeEditor) {
            return false;
        }
        if (typeof opts.setEndOfLine !== 'undefined') {
            this._model.pushEOL(opts.setEndOfLine);
        }
        const transformedEdits = ( (edits.map((edit) => {
            return {
                range: Range$2.lift(edit.range),
                text: edit.text,
                forceMoveMarkers: edit.forceMoveMarkers
            };
        })));
        if (opts.undoStopBefore) {
            this._codeEditor.pushUndoStop();
        }
        this._codeEditor.executeEdits('MainThreadTextEditor', transformedEdits);
        if (opts.undoStopAfter) {
            this._codeEditor.pushUndoStop();
        }
        return true;
    }
    async insertSnippet(modelVersionId, template, ranges, opts) {
        if (!this._codeEditor || !this._codeEditor.hasModel()) {
            return false;
        }
        let clipboardText;
        const needsTemplate = SnippetParser.guessNeedsClipboard(template);
        if (needsTemplate) {
            const state = ( (new EditorState(
                this._codeEditor,
                1  | 4
            )));
            clipboardText = await this._clipboardService.readText();
            if (!state.validate(this._codeEditor)) {
                return false;
            }
        }
        if (this._codeEditor.getModel().getVersionId() !== modelVersionId) {
            return false;
        }
        const snippetController = SnippetController2.get(this._codeEditor);
        if (!snippetController) {
            return false;
        }
        const selections = ( (ranges.map(
            r => ( (new Selection$3(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn)))
        )));
        this._codeEditor.setSelections(selections);
        this._codeEditor.focus();
        snippetController.insert(template, {
            overwriteBefore: 0, overwriteAfter: 0,
            undoStopBefore: opts.undoStopBefore, undoStopAfter: opts.undoStopAfter,
            clipboardText
        });
        return true;
    }
}
var EditorActivation;
( ((function(EditorActivation) {
    EditorActivation[EditorActivation["ACTIVATE"] = 1] = "ACTIVATE";
    EditorActivation[EditorActivation["RESTORE"] = 2] = "RESTORE";
    EditorActivation[EditorActivation["PRESERVE"] = 3] = "PRESERVE";
})(EditorActivation || (EditorActivation = {}))));
var EditorResolution;
( ((function(EditorResolution) {
    EditorResolution[EditorResolution["PICK"] = 0] = "PICK";
    EditorResolution[EditorResolution["EXCLUSIVE_ONLY"] = 1] = "EXCLUSIVE_ONLY";
})(EditorResolution || (EditorResolution = {}))));
function columnToEditorGroup(editorGroupService, configurationService, column = ACTIVE_GROUP) {
    if (column === ACTIVE_GROUP || column === SIDE_GROUP) {
        return column;
    }
    let groupInColumn = editorGroupService.getGroups(2 )[column];
    if (!groupInColumn && column < 9) {
        for (let i = 0; i <= column; i++) {
            const editorGroups = editorGroupService.getGroups(2 );
            if (!editorGroups[i]) {
                editorGroupService.addGroup(editorGroups[i - 1], preferredSideBySideGroupDirection(configurationService));
            }
        }
        groupInColumn = editorGroupService.getGroups(2 )[column];
    }
    return groupInColumn?.id ?? SIDE_GROUP;
}
function editorGroupToColumn(editorGroupService, editorGroup) {
    const group = (typeof editorGroup === 'number') ? editorGroupService.getGroup(editorGroup) : editorGroup;
    return editorGroupService.getGroups(2 ).indexOf(group ?? editorGroupService.activeGroup);
}
let MainThreadTextEditors = class MainThreadTextEditors {
    constructor(_editorLocator, extHostContext, _codeEditorService, _editorService, _editorGroupService, _configurationService) {
        this._editorLocator = _editorLocator;
        this._codeEditorService = _codeEditorService;
        this._editorService = _editorService;
        this._editorGroupService = _editorGroupService;
        this._configurationService = _configurationService;
        this._toDispose = ( (new DisposableStore()));
        this._instanceId = String(++MainThreadTextEditors.INSTANCE_COUNT);
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostEditors)));
        this._textEditorsListenersMap = Object.create(null);
        this._editorPositionData = null;
        this._toDispose.add(this._editorService.onDidVisibleEditorsChange(() => this._updateActiveAndVisibleTextEditors()));
        this._toDispose.add(this._editorGroupService.onDidRemoveGroup(() => this._updateActiveAndVisibleTextEditors()));
        this._toDispose.add(this._editorGroupService.onDidMoveGroup(() => this._updateActiveAndVisibleTextEditors()));
        this._registeredDecorationTypes = Object.create(null);
    }
    dispose() {
        ( (Object.keys(this._textEditorsListenersMap))).forEach((editorId) => {
            dispose(this._textEditorsListenersMap[editorId]);
        });
        this._textEditorsListenersMap = Object.create(null);
        this._toDispose.dispose();
        for (const decorationType in this._registeredDecorationTypes) {
            this._codeEditorService.removeDecorationType(decorationType);
        }
        this._registeredDecorationTypes = Object.create(null);
    }
    handleTextEditorAdded(textEditor) {
        const id = textEditor.getId();
        const toDispose = [];
        toDispose.push(textEditor.onPropertiesChanged((data) => {
            this._proxy.$acceptEditorPropertiesChanged(id, data);
        }));
        this._textEditorsListenersMap[id] = toDispose;
    }
    handleTextEditorRemoved(id) {
        dispose(this._textEditorsListenersMap[id]);
        delete this._textEditorsListenersMap[id];
    }
    _updateActiveAndVisibleTextEditors() {
        const editorPositionData = this._getTextEditorPositionData();
        if (!equals$1(this._editorPositionData, editorPositionData)) {
            this._editorPositionData = editorPositionData;
            this._proxy.$acceptEditorPositionData(this._editorPositionData);
        }
    }
    _getTextEditorPositionData() {
        const result = Object.create(null);
        for (const editorPane of this._editorService.visibleEditorPanes) {
            const id = this._editorLocator.findTextEditorIdFor(editorPane);
            if (id) {
                result[id] = editorGroupToColumn(this._editorGroupService, editorPane.group);
            }
        }
        return result;
    }
    async $tryShowTextDocument(resource, options) {
        const uri = URI.revive(resource);
        const editorOptions = {
            preserveFocus: options.preserveFocus,
            pinned: options.pinned,
            selection: options.selection,
            activation: options.preserveFocus ? EditorActivation.RESTORE : undefined,
            override: EditorResolution.EXCLUSIVE_ONLY
        };
        const input = {
            resource: uri,
            options: editorOptions
        };
        const editor = await this._editorService.openEditor(input, columnToEditorGroup(this._editorGroupService, this._configurationService, options.position));
        if (!editor) {
            return undefined;
        }
        const editorControl = editor.getControl();
        const codeEditor = getCodeEditor(editorControl);
        return codeEditor ? this._editorLocator.getIdOfCodeEditor(codeEditor) : undefined;
    }
    async $tryShowEditor(id, position) {
        const mainThreadEditor = this._editorLocator.getEditor(id);
        if (mainThreadEditor) {
            const model = mainThreadEditor.getModel();
            await this._editorService.openEditor({
                resource: model.uri,
                options: { preserveFocus: false }
            }, columnToEditorGroup(this._editorGroupService, this._configurationService, position));
            return;
        }
    }
    async $tryHideEditor(id) {
        const mainThreadEditor = this._editorLocator.getEditor(id);
        if (mainThreadEditor) {
            const editorPanes = this._editorService.visibleEditorPanes;
            for (const editorPane of editorPanes) {
                if (mainThreadEditor.matches(editorPane)) {
                    await editorPane.group.closeEditor(editorPane.input);
                    return;
                }
            }
        }
    }
    $trySetSelections(id, selections) {
        const editor = this._editorLocator.getEditor(id);
        if (!editor) {
            return Promise.reject(disposed(`TextEditor(${id})`));
        }
        editor.setSelections(selections);
        return Promise.resolve(undefined);
    }
    $trySetDecorations(id, key, ranges) {
        key = `${this._instanceId}-${key}`;
        const editor = this._editorLocator.getEditor(id);
        if (!editor) {
            return Promise.reject(disposed(`TextEditor(${id})`));
        }
        editor.setDecorations(key, ranges);
        return Promise.resolve(undefined);
    }
    $trySetDecorationsFast(id, key, ranges) {
        key = `${this._instanceId}-${key}`;
        const editor = this._editorLocator.getEditor(id);
        if (!editor) {
            return Promise.reject(disposed(`TextEditor(${id})`));
        }
        editor.setDecorationsFast(key, ranges);
        return Promise.resolve(undefined);
    }
    $tryRevealRange(id, range, revealType) {
        const editor = this._editorLocator.getEditor(id);
        if (!editor) {
            return Promise.reject(disposed(`TextEditor(${id})`));
        }
        editor.revealRange(range, revealType);
        return Promise.resolve();
    }
    $trySetOptions(id, options) {
        const editor = this._editorLocator.getEditor(id);
        if (!editor) {
            return Promise.reject(disposed(`TextEditor(${id})`));
        }
        editor.setConfiguration(options);
        return Promise.resolve(undefined);
    }
    $tryApplyEdits(id, modelVersionId, edits, opts) {
        const editor = this._editorLocator.getEditor(id);
        if (!editor) {
            return Promise.reject(disposed(`TextEditor(${id})`));
        }
        return Promise.resolve(editor.applyEdits(modelVersionId, edits, opts));
    }
    $tryInsertSnippet(id, modelVersionId, template, ranges, opts) {
        const editor = this._editorLocator.getEditor(id);
        if (!editor) {
            return Promise.reject(disposed(`TextEditor(${id})`));
        }
        return Promise.resolve(editor.insertSnippet(modelVersionId, template, ranges, opts));
    }
    $registerTextEditorDecorationType(extensionId, key, options) {
        key = `${this._instanceId}-${key}`;
        this._registeredDecorationTypes[key] = true;
        this._codeEditorService.registerDecorationType(`exthost-api-${extensionId}`, key, options);
    }
    $removeTextEditorDecorationType(key) {
        key = `${this._instanceId}-${key}`;
        delete this._registeredDecorationTypes[key];
        this._codeEditorService.removeDecorationType(key);
    }
    $getDiffInformation(id) {
        const editor = this._editorLocator.getEditor(id);
        if (!editor) {
            return Promise.reject(( (new Error('No such TextEditor'))));
        }
        const codeEditor = editor.getCodeEditor();
        if (!codeEditor) {
            return Promise.reject(( (new Error('No such CodeEditor'))));
        }
        const codeEditorId = codeEditor.getId();
        const diffEditors = this._codeEditorService.listDiffEditors();
        const [diffEditor] = diffEditors.filter(d => d.getOriginalEditor().getId() === codeEditorId || d.getModifiedEditor().getId() === codeEditorId);
        if (diffEditor) {
            return Promise.resolve(diffEditor.getLineChanges() || []);
        }
        const dirtyDiffContribution = codeEditor.getContribution('editor.contrib.dirtydiff');
        if (dirtyDiffContribution) {
            return Promise.resolve(dirtyDiffContribution.getChanges());
        }
        return Promise.resolve([]);
    }
};
MainThreadTextEditors.INSTANCE_COUNT = 0;
MainThreadTextEditors = ( (__decorate([
    ( (__param(2, ICodeEditorService))),
    ( (__param(3, IEditorService))),
    ( (__param(4, IEditorGroupsService))),
    ( (__param(5, IConfigurationService)))
], MainThreadTextEditors)));
CommandsRegistry.registerCommand('_workbench.revertAllDirty', async function (accessor) {
    const environmentService = accessor.get(IEnvironmentService);
    if (!environmentService.extensionTestsLocationURI) {
        throw new Error('Command is only available when running extension tests.');
    }
    const workingCopyService = accessor.get(IWorkingCopyService);
    for (const workingCopy of workingCopyService.dirtyWorkingCopies) {
        await workingCopy.revert({ soft: true });
    }
});
class AbstractTextEditor {}
class TextEditorSnapshot {
    constructor(editor) {
        this.editor = editor;
        this.id = `${editor.getId()},${editor.getModel().id}`;
    }
}
class DocumentAndEditorStateDelta {
    constructor(removedDocuments, addedDocuments, removedEditors, addedEditors, oldActiveEditor, newActiveEditor) {
        this.removedDocuments = removedDocuments;
        this.addedDocuments = addedDocuments;
        this.removedEditors = removedEditors;
        this.addedEditors = addedEditors;
        this.oldActiveEditor = oldActiveEditor;
        this.newActiveEditor = newActiveEditor;
        this.isEmpty = this.removedDocuments.length === 0
            && this.addedDocuments.length === 0
            && this.removedEditors.length === 0
            && this.addedEditors.length === 0
            && oldActiveEditor === newActiveEditor;
    }
    toString() {
        let ret = 'DocumentAndEditorStateDelta\n';
        ret += `\tRemoved Documents: [${( ( this.removedDocuments.map(d => ( ( d.uri.toString(true)))))).join(', ')}]\n`;
        ret += `\tAdded Documents: [${( ( this.addedDocuments.map(d => ( ( d.uri.toString(true)))))).join(', ')}]\n`;
        ret += `\tRemoved Editors: [${( ( this.removedEditors.map(e => e.id))).join(', ')}]\n`;
        ret += `\tAdded Editors: [${( ( this.addedEditors.map(e => e.id))).join(', ')}]\n`;
        ret += `\tNew Active Editor: ${this.newActiveEditor}\n`;
        return ret;
    }
}
class DocumentAndEditorState {
    static compute(before, after) {
        if (!before) {
            return (
                 (new DocumentAndEditorStateDelta(
                    [],
                    [...( (after.documents.values()))],
                    [],
                    [...( (after.textEditors.values()))],
                    undefined,
                    after.activeEditor
                ))
            );
        }
        const documentDelta = diffSets(before.documents, after.documents);
        const editorDelta = diffMaps(before.textEditors, after.textEditors);
        const oldActiveEditor = before.activeEditor !== after.activeEditor ? before.activeEditor : undefined;
        const newActiveEditor = before.activeEditor !== after.activeEditor ? after.activeEditor : undefined;
        return (
             (new DocumentAndEditorStateDelta(
                documentDelta.removed,
                documentDelta.added,
                editorDelta.removed,
                editorDelta.added,
                oldActiveEditor,
                newActiveEditor
            ))
        );
    }
    constructor(documents, textEditors, activeEditor) {
        this.documents = documents;
        this.textEditors = textEditors;
        this.activeEditor = activeEditor;
    }
}
let MainThreadDocumentAndEditorStateComputer = class MainThreadDocumentAndEditorStateComputer {
    constructor(_onDidChangeState, _modelService, _codeEditorService, _editorService, _paneCompositeService) {
        this._onDidChangeState = _onDidChangeState;
        this._modelService = _modelService;
        this._codeEditorService = _codeEditorService;
        this._editorService = _editorService;
        this._paneCompositeService = _paneCompositeService;
        this._toDispose = ( (new DisposableStore()));
        this._toDisposeOnEditorRemove = ( (new DisposableMap()));
        this._activeEditorOrder = 0 ;
        this._modelService.onModelAdded(this._updateStateOnModelAdd, this, this._toDispose);
        this._modelService.onModelRemoved(_ => this._updateState(), this, this._toDispose);
        this._editorService.onDidActiveEditorChange(_ => this._updateState(), this, this._toDispose);
        this._codeEditorService.onCodeEditorAdd(this._onDidAddEditor, this, this._toDispose);
        this._codeEditorService.onCodeEditorRemove(this._onDidRemoveEditor, this, this._toDispose);
        this._codeEditorService.listCodeEditors().forEach(this._onDidAddEditor, this);
        Event.filter(this._paneCompositeService.onDidPaneCompositeOpen, event => event.viewContainerLocation === 1 )(_ => this._activeEditorOrder = 1 , undefined, this._toDispose);
        Event.filter(this._paneCompositeService.onDidPaneCompositeClose, event => event.viewContainerLocation === 1 )(_ => this._activeEditorOrder = 0 , undefined, this._toDispose);
        this._editorService.onDidVisibleEditorsChange(_ => this._activeEditorOrder = 0 , undefined, this._toDispose);
        this._updateState();
    }
    dispose() {
        this._toDispose.dispose();
        this._toDisposeOnEditorRemove.dispose();
    }
    _onDidAddEditor(e) {
        this._toDisposeOnEditorRemove.set(e.getId(), combinedDisposable(e.onDidChangeModel(() => this._updateState()), e.onDidFocusEditorText(() => this._updateState()), e.onDidFocusEditorWidget(() => this._updateState(e))));
        this._updateState();
    }
    _onDidRemoveEditor(e) {
        const id = e.getId();
        if (this._toDisposeOnEditorRemove.has(id)) {
            this._toDisposeOnEditorRemove.deleteAndDispose(id);
            this._updateState();
        }
    }
    _updateStateOnModelAdd(model) {
        if (!shouldSynchronizeModel(model)) {
            return;
        }
        if (!this._currentState) {
            this._updateState();
            return;
        }
        this._currentState = ( (new DocumentAndEditorState(
            this._currentState.documents.add(model),
            this._currentState.textEditors,
            this._currentState.activeEditor
        )));
        this._onDidChangeState(( (new DocumentAndEditorStateDelta([], [model], [], [], undefined, undefined))));
    }
    _updateState(widgetFocusCandidate) {
        const models = ( (new Set()));
        for (const model of this._modelService.getModels()) {
            if (shouldSynchronizeModel(model)) {
                models.add(model);
            }
        }
        const editors = ( (new Map()));
        let activeEditor = null;
        for (const editor of this._codeEditorService.listCodeEditors()) {
            if (editor.isSimpleWidget) {
                continue;
            }
            const model = editor.getModel();
            if (editor.hasModel() && model && shouldSynchronizeModel(model)
                && !model.isDisposed()
                && Boolean(this._modelService.getModel(model.uri))
            ) {
                const apiEditor = ( (new TextEditorSnapshot(editor)));
                editors.set(apiEditor.id, apiEditor);
                if (editor.hasTextFocus() || (widgetFocusCandidate === editor && editor.hasWidgetFocus())) {
                    activeEditor = apiEditor.id;
                }
            }
        }
        if (!activeEditor) {
            let candidate;
            if (this._activeEditorOrder === 0 ) {
                candidate = this._getActiveEditorFromEditorPart() || this._getActiveEditorFromPanel();
            }
            else {
                candidate = this._getActiveEditorFromPanel() || this._getActiveEditorFromEditorPart();
            }
            if (candidate) {
                for (const snapshot of ( (editors.values()))) {
                    if (candidate === snapshot.editor) {
                        activeEditor = snapshot.id;
                    }
                }
            }
        }
        const newState = ( (new DocumentAndEditorState(models, editors, activeEditor)));
        const delta = DocumentAndEditorState.compute(this._currentState, newState);
        if (!delta.isEmpty) {
            this._currentState = newState;
            this._onDidChangeState(delta);
        }
    }
    _getActiveEditorFromPanel() {
        const panel = this._paneCompositeService.getActivePaneComposite(1 );
        if (panel instanceof AbstractTextEditor) {
            const control = panel.getControl();
            if (isCodeEditor(control)) {
                return control;
            }
        }
        return undefined;
    }
    _getActiveEditorFromEditorPart() {
        let activeTextEditorControl = this._editorService.activeTextEditorControl;
        if (isDiffEditor(activeTextEditorControl)) {
            activeTextEditorControl = activeTextEditorControl.getModifiedEditor();
        }
        return activeTextEditorControl;
    }
};
MainThreadDocumentAndEditorStateComputer = ( (__decorate([
    ( (__param(1, IModelService))),
    ( (__param(2, ICodeEditorService))),
    ( (__param(3, IEditorService))),
    ( (__param(4, IPaneCompositePartService)))
], MainThreadDocumentAndEditorStateComputer)));
let MainThreadDocumentsAndEditors = class MainThreadDocumentsAndEditors {
    constructor(extHostContext, _modelService, _textFileService, _editorService, codeEditorService, fileService, textModelResolverService, _editorGroupService, paneCompositeService, environmentService, workingCopyFileService, uriIdentityService, _clipboardService, pathService, configurationService) {
        this._modelService = _modelService;
        this._textFileService = _textFileService;
        this._editorService = _editorService;
        this._editorGroupService = _editorGroupService;
        this._clipboardService = _clipboardService;
        this._toDispose = ( (new DisposableStore()));
        this._textEditors = ( (new Map()));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostDocumentsAndEditors)));
        this._mainThreadDocuments = this._toDispose.add(( (new MainThreadDocuments(
            extHostContext,
            this._modelService,
            this._textFileService,
            fileService,
            textModelResolverService,
            environmentService,
            uriIdentityService,
            workingCopyFileService,
            pathService
        ))));
        extHostContext.set(MainContext.MainThreadDocuments, this._mainThreadDocuments);
        this._mainThreadEditors = this._toDispose.add(( (new MainThreadTextEditors(
            this,
            extHostContext,
            codeEditorService,
            this._editorService,
            this._editorGroupService,
            configurationService
        ))));
        extHostContext.set(MainContext.MainThreadTextEditors, this._mainThreadEditors);
        this._toDispose.add(( (new MainThreadDocumentAndEditorStateComputer(
            delta => this._onDelta(delta),
            _modelService,
            codeEditorService,
            this._editorService,
            paneCompositeService
        ))));
    }
    dispose() {
        this._toDispose.dispose();
    }
    _onDelta(delta) {
        const removedEditors = [];
        const addedEditors = [];
        const removedDocuments = ( (delta.removedDocuments.map(m => m.uri)));
        for (const apiEditor of delta.addedEditors) {
            const mainThreadEditor = ( (new MainThreadTextEditor(
                apiEditor.id,
                apiEditor.editor.getModel(),
                apiEditor.editor,
                { onGainedFocus() { }, onLostFocus() { } },
                this._mainThreadDocuments,
                this._modelService,
                this._clipboardService
            )));
            this._textEditors.set(apiEditor.id, mainThreadEditor);
            addedEditors.push(mainThreadEditor);
        }
        for (const { id } of delta.removedEditors) {
            const mainThreadEditor = this._textEditors.get(id);
            if (mainThreadEditor) {
                mainThreadEditor.dispose();
                this._textEditors.delete(id);
                removedEditors.push(id);
            }
        }
        const extHostDelta = Object.create(null);
        let empty = true;
        if (delta.newActiveEditor !== undefined) {
            empty = false;
            extHostDelta.newActiveEditor = delta.newActiveEditor;
        }
        if (removedDocuments.length > 0) {
            empty = false;
            extHostDelta.removedDocuments = removedDocuments;
        }
        if (removedEditors.length > 0) {
            empty = false;
            extHostDelta.removedEditors = removedEditors;
        }
        if (delta.addedDocuments.length > 0) {
            empty = false;
            extHostDelta.addedDocuments = ( (delta.addedDocuments.map(m => this._toModelAddData(m))));
        }
        if (delta.addedEditors.length > 0) {
            empty = false;
            extHostDelta.addedEditors = ( (addedEditors.map(e => this._toTextEditorAddData(e))));
        }
        if (!empty) {
            this._proxy.$acceptDocumentsAndEditorsDelta(extHostDelta);
            removedDocuments.forEach(this._mainThreadDocuments.handleModelRemoved, this._mainThreadDocuments);
            delta.addedDocuments.forEach(this._mainThreadDocuments.handleModelAdded, this._mainThreadDocuments);
            removedEditors.forEach(this._mainThreadEditors.handleTextEditorRemoved, this._mainThreadEditors);
            addedEditors.forEach(this._mainThreadEditors.handleTextEditorAdded, this._mainThreadEditors);
        }
    }
    _toModelAddData(model) {
        return {
            uri: model.uri,
            versionId: model.getVersionId(),
            lines: model.getLinesContent(),
            EOL: model.getEOL(),
            languageId: model.getLanguageId(),
            isDirty: this._textFileService.isDirty(model.uri)
        };
    }
    _toTextEditorAddData(textEditor) {
        const props = textEditor.getProperties();
        return {
            id: textEditor.getId(),
            documentUri: textEditor.getModel().uri,
            options: props.options,
            selections: props.selections,
            visibleRanges: props.visibleRanges,
            editorPosition: this._findEditorPosition(textEditor)
        };
    }
    _findEditorPosition(editor) {
        for (const editorPane of this._editorService.visibleEditorPanes) {
            if (editor.matches(editorPane)) {
                return editorGroupToColumn(this._editorGroupService, editorPane.group);
            }
        }
        return undefined;
    }
    findTextEditorIdFor(editorPane) {
        for (const [id, editor] of this._textEditors) {
            if (editor.matches(editorPane)) {
                return id;
            }
        }
        return undefined;
    }
    getIdOfCodeEditor(codeEditor) {
        for (const [id, editor] of this._textEditors) {
            if (editor.getCodeEditor() === codeEditor) {
                return id;
            }
        }
        return undefined;
    }
    getEditor(id) {
        return this._textEditors.get(id);
    }
};
MainThreadDocumentsAndEditors = ( (__decorate([
    extHostCustomer,
    ( (__param(1, IModelService))),
    ( (__param(2, ITextFileService))),
    ( (__param(3, IEditorService))),
    ( (__param(4, ICodeEditorService))),
    ( (__param(5, IFileService))),
    ( (__param(6, ITextModelService))),
    ( (__param(7, IEditorGroupsService))),
    ( (__param(8, IPaneCompositePartService))),
    ( (__param(9, IWorkbenchEnvironmentService))),
    ( (__param(10, IWorkingCopyFileService))),
    ( (__param(11, IUriIdentityService))),
    ( (__param(12, IClipboardService))),
    ( (__param(13, IPathService))),
    ( (__param(14, IConfigurationService)))
], MainThreadDocumentsAndEditors)));
let MainThreadDiagnostics = class MainThreadDiagnostics {
    constructor(extHostContext, _markerService, _uriIdentService) {
        this._markerService = _markerService;
        this._uriIdentService = _uriIdentService;
        this._activeOwners = ( (new Set()));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostDiagnostics)));
        this._markerListener = this._markerService.onMarkerChanged(this._forwardMarkers, this);
    }
    dispose() {
        this._markerListener.dispose();
        this._activeOwners.forEach(owner => this._markerService.changeAll(owner, []));
        this._activeOwners.clear();
    }
    _forwardMarkers(resources) {
        const data = [];
        for (const resource of resources) {
            const allMarkerData = this._markerService.read({ resource });
            if (allMarkerData.length === 0) {
                data.push([resource, []]);
            }
            else {
                const forgeinMarkerData = allMarkerData.filter(marker => !this._activeOwners.has(marker.owner));
                if (forgeinMarkerData.length > 0) {
                    data.push([resource, forgeinMarkerData]);
                }
            }
        }
        if (data.length > 0) {
            this._proxy.$acceptMarkersChange(data);
        }
    }
    $changeMany(owner, entries) {
        for (const entry of entries) {
            const [uri, markers] = entry;
            if (markers) {
                for (const marker of markers) {
                    if (marker.relatedInformation) {
                        for (const relatedInformation of marker.relatedInformation) {
                            relatedInformation.resource = URI.revive(relatedInformation.resource);
                        }
                    }
                    if (marker.code && typeof marker.code !== 'string') {
                        marker.code.target = URI.revive(marker.code.target);
                    }
                }
            }
            this._markerService.changeOne(owner, this._uriIdentService.asCanonicalUri(URI.revive(uri)), markers);
        }
        this._activeOwners.add(owner);
    }
    $clear(owner) {
        this._markerService.changeAll(owner, []);
        this._activeOwners.delete(owner);
    }
};
MainThreadDiagnostics = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadDiagnostics),
    ( (__param(1, IMarkerService))),
    ( (__param(2, IUriIdentityService)))
], MainThreadDiagnostics)));
var MainThreadTelemetry_1;
let MainThreadTelemetry = MainThreadTelemetry_1 = class MainThreadTelemetry extends Disposable$1 {
    constructor(extHostContext, _telemetryService, _configurationService, _environmentService, _productService) {
        super();
        this._telemetryService = _telemetryService;
        this._configurationService = _configurationService;
        this._environmentService = _environmentService;
        this._productService = _productService;
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostTelemetry)));
        if (supportsTelemetry(this._productService, this._environmentService)) {
            this._register(this._configurationService.onDidChangeConfiguration(e => {
                if (e.affectsConfiguration(TELEMETRY_SETTING_ID) || e.affectsConfiguration(TELEMETRY_OLD_SETTING_ID)) {
                    this._proxy.$onDidChangeTelemetryLevel(this.telemetryLevel);
                }
            }));
        }
        this._proxy.$initializeTelemetryLevel(this.telemetryLevel, supportsTelemetry(this._productService, this._environmentService), this._productService.enabledTelemetryLevels);
    }
    get telemetryLevel() {
        if (!supportsTelemetry(this._productService, this._environmentService)) {
            return 0 ;
        }
        return this._telemetryService.telemetryLevel;
    }
    $publicLog(eventName, data = Object.create(null)) {
        data[MainThreadTelemetry_1._name] = true;
        this._telemetryService.publicLog(eventName, data);
    }
    $publicLog2(eventName, data) {
        this.$publicLog(eventName, data);
    }
};
MainThreadTelemetry._name = 'pluginHostTelemetry';
MainThreadTelemetry = MainThreadTelemetry_1 = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadTelemetry),
    ( (__param(1, ITelemetryService))),
    ( (__param(2, IConfigurationService))),
    ( (__param(3, IEnvironmentService))),
    ( (__param(4, IProductService)))
], MainThreadTelemetry)));
let ExtHostBulkEdits = class ExtHostBulkEdits {
    constructor(extHostRpc, extHostDocumentsAndEditors) {
        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadBulkEdits)));
        this._versionInformationProvider = {
            getTextDocumentVersion: uri => extHostDocumentsAndEditors.getDocument(uri)?.version,
            getNotebookDocumentVersion: () => undefined
        };
    }
    applyWorkspaceEdit(edit, extension, metadata) {
        const dto = WorkspaceEdit$1.from(edit, this._versionInformationProvider);
        return this._proxy.$tryApplyWorkspaceEdit(dto, undefined, metadata?.isRefactoring ?? false);
    }
};
ExtHostBulkEdits = ( (__decorate([
    ( (__param(0, IExtHostRpcService)))
], ExtHostBulkEdits)));
class ResourceNotebookCellEdit extends ResourceEdit {
    static is(candidate) {
        if (candidate instanceof ResourceNotebookCellEdit) {
            return true;
        }
        return URI.isUri(candidate.resource)
            && isObject(candidate.cellEdit);
    }
    static lift(edit) {
        if (edit instanceof ResourceNotebookCellEdit) {
            return edit;
        }
        return (
             (new ResourceNotebookCellEdit(edit.resource, edit.cellEdit, edit.notebookVersionId, edit.metadata))
        );
    }
    constructor(resource, cellEdit, notebookVersionId = undefined, metadata) {
        super(metadata);
        this.resource = resource;
        this.cellEdit = cellEdit;
        this.notebookVersionId = notebookVersionId;
    }
}
let MainThreadBulkEdits = class MainThreadBulkEdits {
    constructor(_extHostContext, _bulkEditService, _logService, _uriIdentService) {
        this._bulkEditService = _bulkEditService;
        this._logService = _logService;
        this._uriIdentService = _uriIdentService;
    }
    dispose() { }
    $tryApplyWorkspaceEdit(dto, undoRedoGroupId, isRefactoring) {
        const edits = reviveWorkspaceEditDto(dto, this._uriIdentService);
        return this._bulkEditService.apply(edits, { undoRedoGroupId, respectAutoSaveConfig: isRefactoring }).then((res) => res.isApplied, err => {
            this._logService.warn(`IGNORING workspace edit: ${err}`);
            return false;
        });
    }
};
MainThreadBulkEdits = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadBulkEdits),
    ( (__param(1, IBulkEditService))),
    ( (__param(2, ILogService))),
    ( (__param(3, IUriIdentityService)))
], MainThreadBulkEdits)));
function reviveWorkspaceEditDto(data, uriIdentityService) {
    if (!data || !data.edits) {
        return data;
    }
    const result = revive(data);
    for (const edit of result.edits) {
        if (ResourceTextEdit.is(edit)) {
            edit.resource = uriIdentityService.asCanonicalUri(edit.resource);
        }
        if (ResourceFileEdit.is(edit)) {
            edit.newResource = edit.newResource && uriIdentityService.asCanonicalUri(edit.newResource);
            edit.oldResource = edit.oldResource && uriIdentityService.asCanonicalUri(edit.oldResource);
        }
        if (ResourceNotebookCellEdit.is(edit)) {
            edit.resource = uriIdentityService.asCanonicalUri(edit.resource);
        }
    }
    return data;
}
class ExtHostLanguages {
    constructor(mainContext, _documents, _commands, _uriTransformer) {
        this._documents = _documents;
        this._commands = _commands;
        this._uriTransformer = _uriTransformer;
        this._languageIds = [];
        this._handlePool = 0;
        this._ids = ( (new Set()));
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadLanguages)));
    }
    $acceptLanguageIds(ids) {
        this._languageIds = ids;
    }
    async getLanguages() {
        return this._languageIds.slice(0);
    }
    async changeLanguage(uri, languageId) {
        await this._proxy.$changeLanguage(uri, languageId);
        const data = this._documents.getDocumentData(uri);
        if (!data) {
            throw new Error(`document '${uri.toString()}' NOT found`);
        }
        return data.document;
    }
    async tokenAtPosition(document, position) {
        const versionNow = document.version;
        const pos = Position$1.from(position);
        const info = await this._proxy.$tokensAtPosition(document.uri, pos);
        const defaultRange = {
            type: StandardTokenType.Other,
            range: document.getWordRangeAtPosition(position) ?? ( (new Range$3(position.line, position.character, position.line, position.character)))
        };
        if (!info) {
            return defaultRange;
        }
        const result = {
            range: Range$1.to(info.range),
            type: TokenType.to(info.type)
        };
        if (!result.range.contains(position)) {
            return defaultRange;
        }
        if (versionNow !== document.version) {
            return defaultRange;
        }
        return result;
    }
    createLanguageStatusItem(extension, id, selector) {
        const handle = this._handlePool++;
        const proxy = this._proxy;
        const ids = this._ids;
        const fullyQualifiedId = `${extension.identifier.value}/${id}`;
        if (ids.has(fullyQualifiedId)) {
            throw new Error(`LanguageStatusItem with id '${id}' ALREADY exists`);
        }
        ids.add(fullyQualifiedId);
        const data = {
            selector,
            id,
            name: extension.displayName ?? extension.name,
            severity: LanguageStatusSeverity$1.Information,
            command: undefined,
            text: '',
            detail: '',
            busy: false
        };
        let soonHandle;
        const commandDisposables = ( (new DisposableStore()));
        const updateAsync = () => {
            soonHandle?.dispose();
            soonHandle = disposableTimeout(() => {
                commandDisposables.clear();
                this._proxy.$setLanguageStatus(handle, {
                    id: fullyQualifiedId,
                    name: data.name ?? extension.displayName ?? extension.name,
                    source: extension.displayName ?? extension.name,
                    selector: DocumentSelector.from(data.selector, this._uriTransformer),
                    label: data.text,
                    detail: data.detail ?? '',
                    severity: data.severity === LanguageStatusSeverity$1.Error ? Severity$1.Error : data.severity === LanguageStatusSeverity$1.Warning ? Severity$1.Warning : Severity$1.Info,
                    command: data.command && this._commands.toInternal(data.command, commandDisposables),
                    accessibilityInfo: data.accessibilityInformation,
                    busy: data.busy
                });
            }, 0);
        };
        const result = {
            dispose() {
                commandDisposables.dispose();
                soonHandle?.dispose();
                proxy.$removeLanguageStatus(handle);
                ids.delete(fullyQualifiedId);
            },
            get id() {
                return data.id;
            },
            get name() {
                return data.name;
            },
            set name(value) {
                data.name = value;
                updateAsync();
            },
            get selector() {
                return data.selector;
            },
            set selector(value) {
                data.selector = value;
                updateAsync();
            },
            get text() {
                return data.text;
            },
            set text(value) {
                data.text = value;
                updateAsync();
            },
            get detail() {
                return data.detail;
            },
            set detail(value) {
                data.detail = value;
                updateAsync();
            },
            get severity() {
                return data.severity;
            },
            set severity(value) {
                data.severity = value;
                updateAsync();
            },
            get accessibilityInformation() {
                return data.accessibilityInformation;
            },
            set accessibilityInformation(value) {
                data.accessibilityInformation = value;
                updateAsync();
            },
            get command() {
                return data.command;
            },
            set command(value) {
                data.command = value;
                updateAsync();
            },
            get busy() {
                return data.busy;
            },
            set busy(value) {
                data.busy = value;
                updateAsync();
            }
        };
        updateAsync();
        return result;
    }
}
let MainThreadLanguages = class MainThreadLanguages {
    constructor(_extHostContext, _languageService, _modelService, _resolverService, _languageStatusService) {
        this._languageService = _languageService;
        this._modelService = _modelService;
        this._resolverService = _resolverService;
        this._languageStatusService = _languageStatusService;
        this._disposables = ( (new DisposableStore()));
        this._status = ( (new DisposableMap()));
        this._proxy = ( (_extHostContext.getProxy(ExtHostContext.ExtHostLanguages)));
        this._proxy.$acceptLanguageIds(_languageService.getRegisteredLanguageIds());
        this._disposables.add(_languageService.onDidChange(_ => {
            this._proxy.$acceptLanguageIds(_languageService.getRegisteredLanguageIds());
        }));
    }
    dispose() {
        this._disposables.dispose();
        this._status.dispose();
    }
    async $changeLanguage(resource, languageId) {
        if (!this._languageService.isRegisteredLanguageId(languageId)) {
            return Promise.reject(( (new Error(`Unknown language id: ${languageId}`))));
        }
        const uri = URI.revive(resource);
        const ref = await this._resolverService.createModelReference(uri);
        try {
            this._modelService.setMode(ref.object.textEditorModel, this._languageService.createById(languageId));
        }
        finally {
            ref.dispose();
        }
    }
    async $tokensAtPosition(resource, position) {
        const uri = URI.revive(resource);
        const model = this._modelService.getModel(uri);
        if (!model) {
            return undefined;
        }
        model.tokenization.tokenizeIfCheap(position.lineNumber);
        const tokens = model.tokenization.getLineTokens(position.lineNumber);
        const idx = tokens.findTokenIndexAtOffset(position.column - 1);
        return {
            type: tokens.getStandardTokenType(idx),
            range: ( (new Range$2(
                position.lineNumber,
                1 + tokens.getStartOffset(idx),
                position.lineNumber,
                1 + tokens.getEndOffset(idx)
            )))
        };
    }
    $setLanguageStatus(handle, status) {
        this._status.get(handle)?.dispose();
        this._status.set(handle, this._languageStatusService.addStatus(status));
    }
    $removeLanguageStatus(handle) {
        this._status.get(handle)?.dispose();
    }
};
MainThreadLanguages = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadLanguages),
    ( (__param(1, ILanguageService))),
    ( (__param(2, IModelService))),
    ( (__param(3, ITextModelService))),
    ( (__param(4, ILanguageStatusService)))
], MainThreadLanguages)));
let ExtHostWindow = class ExtHostWindow {
    get state() { return this._state; }
    constructor(extHostRpc) {
        this._onDidChangeWindowState = ( (new Emitter$1()));
        this.onDidChangeWindowState = this._onDidChangeWindowState.event;
        this._state = ExtHostWindow.InitialState;
        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadWindow)));
        this._proxy.$getWindowVisibility().then(isFocused => this.$onDidChangeWindowFocus(isFocused));
    }
    $onDidChangeWindowFocus(focused) {
        if (focused === this._state.focused) {
            return;
        }
        this._state = { ...this._state, focused };
        this._onDidChangeWindowState.fire(this._state);
    }
    openUri(stringOrUri, options) {
        let uriAsString;
        if (typeof stringOrUri === 'string') {
            uriAsString = stringOrUri;
            try {
                stringOrUri = ( (URI.parse(stringOrUri)));
            }
            catch (e) {
                return Promise.reject(`Invalid uri - '${stringOrUri}'`);
            }
        }
        if (isFalsyOrWhitespace(stringOrUri.scheme)) {
            return Promise.reject('Invalid scheme - cannot be empty');
        }
        else if (stringOrUri.scheme === Schemas.command) {
            return Promise.reject(`Invalid scheme '${stringOrUri.scheme}'`);
        }
        return this._proxy.$openUri(stringOrUri, uriAsString, options);
    }
    async asExternalUri(uri, options) {
        if (isFalsyOrWhitespace(uri.scheme)) {
            return Promise.reject('Invalid scheme - cannot be empty');
        }
        const result = await this._proxy.$asExternalUri(uri, options);
        return (
             (URI.from(result))
        );
    }
};
ExtHostWindow.InitialState = {
    focused: true
};
ExtHostWindow = ( (__decorate([
    ( (__param(0, IExtHostRpcService)))
], ExtHostWindow)));
const IExtHostWindow = ( (createDecorator$1('IExtHostWindow')));
let MainThreadWindow = class MainThreadWindow {
    constructor(extHostContext, hostService, openerService) {
        this.hostService = hostService;
        this.openerService = openerService;
        this.disposables = ( (new DisposableStore()));
        this.proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostWindow)));
        Event.latch(hostService.onDidChangeFocus)(this.proxy.$onDidChangeWindowFocus, this.proxy, this.disposables);
    }
    dispose() {
        this.disposables.dispose();
    }
    $getWindowVisibility() {
        return Promise.resolve(this.hostService.hasFocus);
    }
    async $openUri(uriComponents, uriString, options) {
        const uri = ( (URI.from(uriComponents)));
        let target;
        if (uriString && ( (( (URI.parse(uriString))).toString())) === ( (uri.toString()))) {
            target = uriString;
        }
        else {
            target = uri;
        }
        return this.openerService.open(target, {
            openExternal: true,
            allowTunneling: options.allowTunneling,
            allowContributedOpeners: options.allowContributedOpeners,
        });
    }
    async $asExternalUri(uriComponents, options) {
        const result = await this.openerService.resolveExternalUri(URI.revive(uriComponents), options);
        return result.resolved;
    }
};
MainThreadWindow = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadWindow),
    ( (__param(1, IHostService))),
    ( (__param(2, IOpenerService)))
], MainThreadWindow)));
let MainThreadClipboard = class MainThreadClipboard {
    constructor(_context, _clipboardService) {
        this._clipboardService = _clipboardService;
    }
    dispose() {
    }
    $readText() {
        return this._clipboardService.readText();
    }
    $writeText(value) {
        return this._clipboardService.writeText(value);
    }
};
MainThreadClipboard = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadClipboard),
    ( (__param(1, IClipboardService)))
], MainThreadClipboard)));
class ExtHostClipboard {
    constructor(mainContext) {
        const proxy = ( (mainContext.getProxy(MainContext.MainThreadClipboard)));
        this.value = ( (Object.freeze({
            readText() {
                return proxy.$readText();
            },
            writeText(value) {
                return proxy.$writeText(value);
            }
        })));
    }
}
function reverseEndianness(arr) {
    for (let i = 0, len = arr.length; i < len; i += 4) {
        const b0 = arr[i + 0];
        const b1 = arr[i + 1];
        const b2 = arr[i + 2];
        const b3 = arr[i + 3];
        arr[i + 0] = b3;
        arr[i + 1] = b2;
        arr[i + 2] = b1;
        arr[i + 3] = b0;
    }
}
function fromLittleEndianBuffer(buff) {
    const uint8Arr = buff.buffer;
    if (!isLittleEndian()) {
        reverseEndianness(uint8Arr);
    }
    if (uint8Arr.byteOffset % 4 === 0) {
        return (
             (new Uint32Array(uint8Arr.buffer, uint8Arr.byteOffset, uint8Arr.length / 4))
        );
    }
    else {
        const data = ( (new Uint8Array(uint8Arr.byteLength)));
        data.set(uint8Arr);
        return (
             (new Uint32Array(data.buffer, data.byteOffset, data.length / 4))
        );
    }
}
function decodeSemanticTokensDto(_buff) {
    const src = fromLittleEndianBuffer(_buff);
    let offset = 0;
    const id = src[offset++];
    const type = src[offset++];
    if (type === 1 ) {
        const length = src[offset++];
        const data = src.subarray(offset, offset + length);
        offset += length;
        return {
            id: id,
            type: 'full',
            data: data
        };
    }
    const deltaCount = src[offset++];
    const deltas = [];
    for (let i = 0; i < deltaCount; i++) {
        const start = src[offset++];
        const deleteCount = src[offset++];
        const length = src[offset++];
        let data;
        if (length > 0) {
            data = src.subarray(offset, offset + length);
            offset += length;
        }
        deltas[i] = { start, deleteCount, data };
    }
    return {
        id: id,
        type: 'delta',
        deltas: deltas
    };
}
class Cache {
    constructor(id) {
        this.id = id;
        this._data = ( (new Map()));
        this._idPool = 1;
    }
    add(item) {
        const id = this._idPool++;
        this._data.set(id, item);
        this.logDebugInfo();
        return id;
    }
    get(pid, id) {
        return this._data.has(pid) ? this._data.get(pid)[id] : undefined;
    }
    delete(id) {
        this._data.delete(id);
        this.logDebugInfo();
    }
    logDebugInfo() {
        if (!Cache.enableDebugLogging) {
            return;
        }
        console.log(`${this.id} cache size - ${this._data.size}`);
    }
}
Cache.enableDebugLogging = false;
class DocumentSymbolAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentSymbols(resource, token) {
        const doc = this._documents.getDocument(resource);
        const value = await this._provider.provideDocumentSymbols(doc, token);
        if (isFalsyOrEmpty(value)) {
            return undefined;
        }
        else if (value[0] instanceof DocumentSymbol$2) {
            return (
                 (value.map(DocumentSymbol$1.from))
            );
        }
        else {
            return DocumentSymbolAdapter._asDocumentSymbolTree(value);
        }
    }
    static _asDocumentSymbolTree(infos) {
        infos = infos.slice(0).sort((a, b) => {
            let res = a.location.range.start.compareTo(b.location.range.start);
            if (res === 0) {
                res = b.location.range.end.compareTo(a.location.range.end);
            }
            return res;
        });
        const res = [];
        const parentStack = [];
        for (const info of infos) {
            const element = {
                name: info.name || '!!MISSING: name!!',
                kind: SymbolKind$1.from(info.kind),
                tags: info.tags?.map(SymbolTag$1.from) || [],
                detail: '',
                containerName: info.containerName,
                range: Range$1.from(info.location.range),
                selectionRange: Range$1.from(info.location.range),
                children: []
            };
            while (true) {
                if (parentStack.length === 0) {
                    parentStack.push(element);
                    res.push(element);
                    break;
                }
                const parent = parentStack[parentStack.length - 1];
                if (Range$2.containsRange(parent.range, element.range) && !Range$2.equalsRange(parent.range, element.range)) {
                    parent.children?.push(element);
                    parentStack.push(element);
                    break;
                }
                parentStack.pop();
            }
        }
        return res;
    }
}
class CodeLensAdapter {
    constructor(_documents, _commands, _provider) {
        this._documents = _documents;
        this._commands = _commands;
        this._provider = _provider;
        this._cache = ( (new Cache('CodeLens')));
        this._disposables = ( (new Map()));
    }
    async provideCodeLenses(resource, token) {
        const doc = this._documents.getDocument(resource);
        const lenses = await this._provider.provideCodeLenses(doc, token);
        if (!lenses || token.isCancellationRequested) {
            return undefined;
        }
        const cacheId = this._cache.add(lenses);
        const disposables = ( (new DisposableStore()));
        this._disposables.set(cacheId, disposables);
        const result = {
            cacheId,
            lenses: [],
        };
        for (let i = 0; i < lenses.length; i++) {
            result.lenses.push({
                cacheId: [cacheId, i],
                range: Range$1.from(lenses[i].range),
                command: this._commands.toInternal(lenses[i].command, disposables)
            });
        }
        return result;
    }
    async resolveCodeLens(symbol, token) {
        const lens = symbol.cacheId && this._cache.get(...symbol.cacheId);
        if (!lens) {
            return undefined;
        }
        let resolvedLens;
        if (typeof this._provider.resolveCodeLens !== 'function' || lens.isResolved) {
            resolvedLens = lens;
        }
        else {
            resolvedLens = await this._provider.resolveCodeLens(lens, token);
        }
        if (!resolvedLens) {
            resolvedLens = lens;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        const disposables = symbol.cacheId && this._disposables.get(symbol.cacheId[0]);
        if (!disposables) {
            return undefined;
        }
        symbol.command = this._commands.toInternal(resolvedLens.command ?? CodeLensAdapter._badCmd, disposables);
        return symbol;
    }
    releaseCodeLenses(cachedId) {
        this._disposables.get(cachedId)?.dispose();
        this._disposables.delete(cachedId);
        this._cache.delete(cachedId);
    }
}
CodeLensAdapter._badCmd = { command: 'missing', title: '!!MISSING: command!!' };
function convertToLocationLinks(value) {
    if (Array.isArray(value)) {
        return (
             (value.map(DefinitionLink.from))
        );
    }
    else if (value) {
        return [DefinitionLink.from(value)];
    }
    return [];
}
class DefinitionAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDefinition(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideDefinition(doc, pos, token);
        return convertToLocationLinks(value);
    }
}
class DeclarationAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDeclaration(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideDeclaration(doc, pos, token);
        return convertToLocationLinks(value);
    }
}
class ImplementationAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideImplementation(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideImplementation(doc, pos, token);
        return convertToLocationLinks(value);
    }
}
class TypeDefinitionAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideTypeDefinition(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideTypeDefinition(doc, pos, token);
        return convertToLocationLinks(value);
    }
}
class HoverAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideHover(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideHover(doc, pos, token);
        if (!value || isFalsyOrEmpty(value.contents)) {
            return undefined;
        }
        if (!value.range) {
            value.range = doc.getWordRangeAtPosition(pos);
        }
        if (!value.range) {
            value.range = ( (new Range$3(pos, pos)));
        }
        return Hover$1.from(value);
    }
}
class EvaluatableExpressionAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideEvaluatableExpression(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideEvaluatableExpression(doc, pos, token);
        if (value) {
            return EvaluatableExpression$1.from(value);
        }
        return undefined;
    }
}
class InlineValuesAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideInlineValues(resource, viewPort, context, token) {
        const doc = this._documents.getDocument(resource);
        const value = await this._provider.provideInlineValues(doc, Range$1.to(viewPort), InlineValueContext.to(context), token);
        if (Array.isArray(value)) {
            return (
                 (value.map(iv => InlineValue.from(iv)))
            );
        }
        return undefined;
    }
}
class DocumentHighlightAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentHighlights(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideDocumentHighlights(doc, pos, token);
        if (Array.isArray(value)) {
            return (
                 (value.map(DocumentHighlight$1.from))
            );
        }
        return undefined;
    }
}
class LinkedEditingRangeAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideLinkedEditingRanges(resource, position, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideLinkedEditingRanges(doc, pos, token);
        if (value && Array.isArray(value.ranges)) {
            return {
                ranges: coalesce(( (value.ranges.map(Range$1.from)))),
                wordPattern: value.wordPattern
            };
        }
        return undefined;
    }
}
class ReferenceAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideReferences(resource, position, context, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideReferences(doc, pos, context, token);
        if (Array.isArray(value)) {
            return (
                 (value.map(location.from))
            );
        }
        return undefined;
    }
}
class CodeActionAdapter {
    constructor(_documents, _commands, _diagnostics, _provider, _logService, _extension, _apiDeprecation) {
        this._documents = _documents;
        this._commands = _commands;
        this._diagnostics = _diagnostics;
        this._provider = _provider;
        this._logService = _logService;
        this._extension = _extension;
        this._apiDeprecation = _apiDeprecation;
        this._cache = ( (new Cache('CodeAction')));
        this._disposables = ( (new Map()));
    }
    async provideCodeActions(resource, rangeOrSelection, context, token) {
        const doc = this._documents.getDocument(resource);
        const ran = Selection$3.isISelection(rangeOrSelection)
            ? Selection$1.to(rangeOrSelection)
            : Range$1.to(rangeOrSelection);
        const allDiagnostics = [];
        for (const diagnostic of this._diagnostics.getDiagnostics(resource)) {
            if (ran.intersection(diagnostic.range)) {
                const newLen = allDiagnostics.push(diagnostic);
                if (newLen > CodeActionAdapter._maxCodeActionsPerFile) {
                    break;
                }
            }
        }
        const codeActionContext = {
            diagnostics: allDiagnostics,
            only: context.only ? ( (new CodeActionKind$1(context.only))) : undefined,
            triggerKind: CodeActionTriggerKind$1.to(context.trigger),
        };
        const commandsOrActions = await this._provider.provideCodeActions(doc, ran, codeActionContext, token);
        if (!isNonEmptyArray(commandsOrActions) || token.isCancellationRequested) {
            return undefined;
        }
        const cacheId = this._cache.add(commandsOrActions);
        const disposables = ( (new DisposableStore()));
        this._disposables.set(cacheId, disposables);
        const actions = [];
        for (let i = 0; i < commandsOrActions.length; i++) {
            const candidate = commandsOrActions[i];
            if (!candidate) {
                continue;
            }
            if (CodeActionAdapter._isCommand(candidate)) {
                this._apiDeprecation.report('CodeActionProvider.provideCodeActions - return commands', this._extension, `Return 'CodeAction' instances instead.`);
                actions.push({
                    _isSynthetic: true,
                    title: candidate.title,
                    command: this._commands.toInternal(candidate, disposables),
                });
            }
            else {
                if (codeActionContext.only) {
                    if (!candidate.kind) {
                        this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value} 'requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`);
                    }
                    else if (!codeActionContext.only.contains(candidate.kind)) {
                        this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${codeActionContext.only.value} 'requested but returned code action is of kind '${candidate.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`);
                    }
                }
                actions.push({
                    cacheId: [cacheId, i],
                    title: candidate.title,
                    command: candidate.command && this._commands.toInternal(candidate.command, disposables),
                    diagnostics: candidate.diagnostics && ( (candidate.diagnostics.map(Diagnostic$1.from))),
                    edit: candidate.edit && WorkspaceEdit$1.from(candidate.edit, undefined),
                    kind: candidate.kind && candidate.kind.value,
                    isPreferred: candidate.isPreferred,
                    disabled: candidate.disabled?.reason
                });
            }
        }
        return { cacheId, actions };
    }
    async resolveCodeAction(id, token) {
        const [sessionId, itemId] = id;
        const item = this._cache.get(sessionId, itemId);
        if (!item || CodeActionAdapter._isCommand(item)) {
            return undefined;
        }
        if (!this._provider.resolveCodeAction) {
            return;
        }
        const resolvedItem = (await this._provider.resolveCodeAction(item, token)) ?? item;
        return resolvedItem?.edit
            ? WorkspaceEdit$1.from(resolvedItem.edit, undefined)
            : undefined;
    }
    releaseCodeActions(cachedId) {
        this._disposables.get(cachedId)?.dispose();
        this._disposables.delete(cachedId);
        this._cache.delete(cachedId);
    }
    static _isCommand(thing) {
        return typeof thing.command === 'string' && typeof thing.title === 'string';
    }
}
CodeActionAdapter._maxCodeActionsPerFile = 1000;
class DocumentPasteEditProvider {
    constructor(_proxy, _documents, _provider, _handle) {
        this._proxy = _proxy;
        this._documents = _documents;
        this._provider = _provider;
        this._handle = _handle;
    }
    async prepareDocumentPaste(resource, ranges, dataTransferDto, token) {
        if (!this._provider.prepareDocumentPaste) {
            return undefined;
        }
        const doc = this._documents.getDocument(resource);
        const vscodeRanges = ( (ranges.map(range => Range$1.to(range))));
        const dataTransfer = DataTransfer$1.toDataTransfer(dataTransferDto, () => {
            throw new NotImplementedError();
        });
        await this._provider.prepareDocumentPaste(doc, vscodeRanges, dataTransfer, token);
        return DataTransfer$1.toDataTransferDTO(dataTransfer);
    }
    async providePasteEdits(requestId, resource, ranges, dataTransferDto, token) {
        const doc = this._documents.getDocument(resource);
        const vscodeRanges = ( (ranges.map(range => Range$1.to(range))));
        const dataTransfer = DataTransfer$1.toDataTransfer(dataTransferDto, async (id) => {
            return (await this._proxy.$resolvePasteFileData(this._handle, requestId, id)).buffer;
        });
        const edit = await this._provider.provideDocumentPasteEdits(doc, vscodeRanges, dataTransfer, token);
        if (!edit) {
            return;
        }
        return {
            insertText: typeof edit.insertText === 'string' ? edit.insertText : { snippet: edit.insertText.value },
            additionalEdit: edit.additionalEdit ? WorkspaceEdit$1.from(edit.additionalEdit, undefined) : undefined,
        };
    }
}
class DocumentFormattingAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentFormattingEdits(resource, options, token) {
        const document = this._documents.getDocument(resource);
        const value = await this._provider.provideDocumentFormattingEdits(document, options, token);
        if (Array.isArray(value)) {
            return (
                 (value.map(TextEdit$1.from))
            );
        }
        return undefined;
    }
}
class RangeFormattingAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentRangeFormattingEdits(resource, range, options, token) {
        const document = this._documents.getDocument(resource);
        const ran = Range$1.to(range);
        const value = await this._provider.provideDocumentRangeFormattingEdits(document, ran, options, token);
        if (Array.isArray(value)) {
            return (
                 (value.map(TextEdit$1.from))
            );
        }
        return undefined;
    }
}
class OnTypeFormattingAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this.autoFormatTriggerCharacters = [];
    }
    async provideOnTypeFormattingEdits(resource, position, ch, options, token) {
        const document = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const value = await this._provider.provideOnTypeFormattingEdits(document, pos, ch, options, token);
        if (Array.isArray(value)) {
            return (
                 (value.map(TextEdit$1.from))
            );
        }
        return undefined;
    }
}
class NavigateTypeAdapter {
    constructor(_provider, _logService) {
        this._provider = _provider;
        this._logService = _logService;
        this._cache = ( (new Cache('WorkspaceSymbols')));
    }
    async provideWorkspaceSymbols(search, token) {
        const value = await this._provider.provideWorkspaceSymbols(search, token);
        if (!isNonEmptyArray(value)) {
            return { symbols: [] };
        }
        const sid = this._cache.add(value);
        const result = {
            cacheId: sid,
            symbols: []
        };
        for (let i = 0; i < value.length; i++) {
            const item = value[i];
            if (!item || !item.name) {
                this._logService.warn('INVALID SymbolInformation', item);
                continue;
            }
            result.symbols.push({
                ...WorkspaceSymbol.from(item),
                cacheId: [sid, i]
            });
        }
        return result;
    }
    async resolveWorkspaceSymbol(symbol, token) {
        if (typeof this._provider.resolveWorkspaceSymbol !== 'function') {
            return symbol;
        }
        if (!symbol.cacheId) {
            return symbol;
        }
        const item = this._cache.get(...symbol.cacheId);
        if (item) {
            const value = await this._provider.resolveWorkspaceSymbol(item, token);
            return value && mixin(symbol, WorkspaceSymbol.from(value), true);
        }
        return undefined;
    }
    releaseWorkspaceSymbols(id) {
        this._cache.delete(id);
    }
}
class RenameAdapter {
    static supportsResolving(provider) {
        return typeof provider.prepareRename === 'function';
    }
    constructor(_documents, _provider, _logService) {
        this._documents = _documents;
        this._provider = _provider;
        this._logService = _logService;
    }
    async provideRenameEdits(resource, position, newName, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        try {
            const value = await this._provider.provideRenameEdits(doc, pos, newName, token);
            if (!value) {
                return undefined;
            }
            return WorkspaceEdit$1.from(value);
        }
        catch (err) {
            const rejectReason = RenameAdapter._asMessage(err);
            if (rejectReason) {
                return { rejectReason, edits: undefined };
            }
            else {
                return Promise.reject(err);
            }
        }
    }
    async resolveRenameLocation(resource, position, token) {
        if (typeof this._provider.prepareRename !== 'function') {
            return Promise.resolve(undefined);
        }
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        try {
            const rangeOrLocation = await this._provider.prepareRename(doc, pos, token);
            let range;
            let text;
            if (Range$3.isRange(rangeOrLocation)) {
                range = rangeOrLocation;
                text = doc.getText(rangeOrLocation);
            }
            else if (isObject(rangeOrLocation)) {
                range = rangeOrLocation.range;
                text = rangeOrLocation.placeholder;
            }
            if (!range || !text) {
                return undefined;
            }
            if (range.start.line > pos.line || range.end.line < pos.line) {
                this._logService.warn('INVALID rename location: position line must be within range start/end lines');
                return undefined;
            }
            return { range: Range$1.from(range), text };
        }
        catch (err) {
            const rejectReason = RenameAdapter._asMessage(err);
            if (rejectReason) {
                return { rejectReason, range: undefined, text: undefined };
            }
            else {
                return Promise.reject(err);
            }
        }
    }
    static _asMessage(err) {
        if (typeof err === 'string') {
            return err;
        }
        else if (err instanceof Error && typeof err.message === 'string') {
            return err.message;
        }
        else {
            return undefined;
        }
    }
}
class SemanticTokensPreviousResult {
    constructor(resultId, tokens) {
        this.resultId = resultId;
        this.tokens = tokens;
    }
}
class DocumentSemanticTokensAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._nextResultId = 1;
        this._previousResults = ( (new Map()));
    }
    async provideDocumentSemanticTokens(resource, previousResultId, token) {
        const doc = this._documents.getDocument(resource);
        const previousResult = (previousResultId !== 0 ? this._previousResults.get(previousResultId) : null);
        let value = typeof previousResult?.resultId === 'string' && typeof this._provider.provideDocumentSemanticTokensEdits === 'function'
            ? await this._provider.provideDocumentSemanticTokensEdits(doc, previousResult.resultId, token)
            : await this._provider.provideDocumentSemanticTokens(doc, token);
        if (previousResult) {
            this._previousResults.delete(previousResultId);
        }
        if (!value) {
            return null;
        }
        value = DocumentSemanticTokensAdapter._fixProvidedSemanticTokens(value);
        return this._send(DocumentSemanticTokensAdapter._convertToEdits(previousResult, value), value);
    }
    async releaseDocumentSemanticColoring(semanticColoringResultId) {
        this._previousResults.delete(semanticColoringResultId);
    }
    static _fixProvidedSemanticTokens(v) {
        if (DocumentSemanticTokensAdapter._isSemanticTokens(v)) {
            if (DocumentSemanticTokensAdapter._isCorrectSemanticTokens(v)) {
                return v;
            }
            return (
                 (new SemanticTokens$1( (new Uint32Array(v.data)), v.resultId))
            );
        }
        else if (DocumentSemanticTokensAdapter._isSemanticTokensEdits(v)) {
            if (DocumentSemanticTokensAdapter._isCorrectSemanticTokensEdits(v)) {
                return v;
            }
            return (
                 (new SemanticTokensEdits$1(
                     (v.edits.map(edit => ( (new SemanticTokensEdit$1(
                        edit.start,
                        edit.deleteCount,
                        edit.data ? ( (new Uint32Array(edit.data))) : edit.data
                    ))))),
                    v.resultId
                ))
            );
        }
        return v;
    }
    static _isSemanticTokens(v) {
        return v && !!(v.data);
    }
    static _isCorrectSemanticTokens(v) {
        return (v.data instanceof Uint32Array);
    }
    static _isSemanticTokensEdits(v) {
        return v && Array.isArray(v.edits);
    }
    static _isCorrectSemanticTokensEdits(v) {
        for (const edit of v.edits) {
            if (!(edit.data instanceof Uint32Array)) {
                return false;
            }
        }
        return true;
    }
    static _convertToEdits(previousResult, newResult) {
        if (!DocumentSemanticTokensAdapter._isSemanticTokens(newResult)) {
            return newResult;
        }
        if (!previousResult || !previousResult.tokens) {
            return newResult;
        }
        const oldData = previousResult.tokens;
        const oldLength = oldData.length;
        const newData = newResult.data;
        const newLength = newData.length;
        let commonPrefixLength = 0;
        const maxCommonPrefixLength = Math.min(oldLength, newLength);
        while (commonPrefixLength < maxCommonPrefixLength && oldData[commonPrefixLength] === newData[commonPrefixLength]) {
            commonPrefixLength++;
        }
        if (commonPrefixLength === oldLength && commonPrefixLength === newLength) {
            return (
                 (new SemanticTokensEdits$1([], newResult.resultId))
            );
        }
        let commonSuffixLength = 0;
        const maxCommonSuffixLength = maxCommonPrefixLength - commonPrefixLength;
        while (commonSuffixLength < maxCommonSuffixLength && oldData[oldLength - commonSuffixLength - 1] === newData[newLength - commonSuffixLength - 1]) {
            commonSuffixLength++;
        }
        return (
             (new SemanticTokensEdits$1([{
                    start: commonPrefixLength,
                    deleteCount: (oldLength - commonPrefixLength - commonSuffixLength),
                    data: newData.subarray(commonPrefixLength, newLength - commonSuffixLength)
                }], newResult.resultId))
        );
    }
    _send(value, original) {
        if (DocumentSemanticTokensAdapter._isSemanticTokens(value)) {
            const myId = this._nextResultId++;
            this._previousResults.set(myId, ( (new SemanticTokensPreviousResult(value.resultId, value.data))));
            return encodeSemanticTokensDto({
                id: myId,
                type: 'full',
                data: value.data
            });
        }
        if (DocumentSemanticTokensAdapter._isSemanticTokensEdits(value)) {
            const myId = this._nextResultId++;
            if (DocumentSemanticTokensAdapter._isSemanticTokens(original)) {
                this._previousResults.set(myId, ( (new SemanticTokensPreviousResult(original.resultId, original.data))));
            }
            else {
                this._previousResults.set(myId, ( (new SemanticTokensPreviousResult(value.resultId))));
            }
            return encodeSemanticTokensDto({
                id: myId,
                type: 'delta',
                deltas: ( ((value.edits || []).map(
                    edit => ({ start: edit.start, deleteCount: edit.deleteCount, data: edit.data })
                )))
            });
        }
        return null;
    }
}
class DocumentRangeSemanticTokensAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideDocumentRangeSemanticTokens(resource, range, token) {
        const doc = this._documents.getDocument(resource);
        const value = await this._provider.provideDocumentRangeSemanticTokens(doc, Range$1.to(range), token);
        if (!value) {
            return null;
        }
        return this._send(value);
    }
    _send(value) {
        return encodeSemanticTokensDto({
            id: 0,
            type: 'full',
            data: value.data
        });
    }
}
class CompletionsAdapter {
    static supportsResolving(provider) {
        return typeof provider.resolveCompletionItem === 'function';
    }
    constructor(_documents, _commands, _provider, _apiDeprecation, _extension) {
        this._documents = _documents;
        this._commands = _commands;
        this._provider = _provider;
        this._apiDeprecation = _apiDeprecation;
        this._extension = _extension;
        this._cache = ( (new Cache('CompletionItem')));
        this._disposables = ( (new Map()));
    }
    async provideCompletionItems(resource, position, context, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const replaceRange = doc.getWordRangeAtPosition(pos) || ( (new Range$3(pos, pos)));
        const insertRange = replaceRange.with({ end: pos });
        const sw = ( (new StopWatch(true)));
        const itemsOrList = await this._provider.provideCompletionItems(doc, pos, token, CompletionContext.to(context));
        if (!itemsOrList) {
            return undefined;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        const list = Array.isArray(itemsOrList) ? ( (new CompletionList$1(itemsOrList))) : itemsOrList;
        const pid = CompletionsAdapter.supportsResolving(this._provider) ? this._cache.add(list.items) : this._cache.add([]);
        const disposables = ( (new DisposableStore()));
        this._disposables.set(pid, disposables);
        const completions = [];
        const result = {
            x: pid,
            ["b" ]: completions,
            ["a" ]: { replace: Range$1.from(replaceRange), insert: Range$1.from(insertRange) },
            ["c" ]: list.isIncomplete || undefined,
            ["d" ]: sw.elapsed()
        };
        for (let i = 0; i < list.items.length; i++) {
            const item = list.items[i];
            const dto = this._convertCompletionItem(item, [pid, i], insertRange, replaceRange);
            completions.push(dto);
        }
        return result;
    }
    async resolveCompletionItem(id, token) {
        if (typeof this._provider.resolveCompletionItem !== 'function') {
            return undefined;
        }
        const item = this._cache.get(...id);
        if (!item) {
            return undefined;
        }
        const resolvedItem = await this._provider.resolveCompletionItem(item, token);
        if (!resolvedItem) {
            return undefined;
        }
        return this._convertCompletionItem(resolvedItem, id);
    }
    releaseCompletionItems(id) {
        this._disposables.get(id)?.dispose();
        this._disposables.delete(id);
        this._cache.delete(id);
    }
    _convertCompletionItem(item, id, defaultInsertRange, defaultReplaceRange) {
        const disposables = this._disposables.get(id[0]);
        if (!disposables) {
            throw Error('DisposableStore is missing...');
        }
        const command = this._commands.toInternal(item.command, disposables);
        const result = {
            x: id,
            ["a" ]: item.label,
            ["b" ]: item.kind !== undefined ? CompletionItemKind$1.from(item.kind) : undefined,
            ["m" ]: item.tags && ( (item.tags.map(CompletionItemTag$1.from))),
            ["c" ]: item.detail,
            ["d" ]: typeof item.documentation === 'undefined' ? undefined : MarkdownString$1.fromStrict(item.documentation),
            ["e" ]: item.sortText !== item.label ? item.sortText : undefined,
            ["f" ]: item.filterText !== item.label ? item.filterText : undefined,
            ["g" ]: item.preselect || undefined,
            ["i" ]: item.keepWhitespace ? 1  : 0 ,
            ["k" ]: item.commitCharacters?.join(''),
            ["l" ]: item.additionalTextEdits && ( (item.additionalTextEdits.map(TextEdit$1.from))),
            ["n" ]: command?.$ident,
            ["o" ]: command?.id,
            ["p" ]: command?.$ident ? undefined : command?.arguments,
        };
        if (item.textEdit) {
            this._apiDeprecation.report('CompletionItem.textEdit', this._extension, `Use 'CompletionItem.insertText' and 'CompletionItem.range' instead.`);
            result["h" ] = item.textEdit.newText;
        }
        else if (typeof item.insertText === 'string') {
            result["h" ] = item.insertText;
        }
        else if (item.insertText instanceof SnippetString$1) {
            result["h" ] = item.insertText.value;
            result["i" ] |= 4 ;
        }
        let range;
        if (item.textEdit) {
            range = item.textEdit.range;
        }
        else if (item.range) {
            range = item.range;
        }
        if (Range$3.isRange(range)) {
            result["j" ] = Range$1.from(range);
        }
        else if (range && (!defaultInsertRange?.isEqual(range.inserting) || !defaultReplaceRange?.isEqual(range.replacing))) {
            result["j" ] = {
                insert: Range$1.from(range.inserting),
                replace: Range$1.from(range.replacing)
            };
        }
        return result;
    }
}
class InlineCompletionAdapterBase {
    async provideInlineCompletions(resource, position, context, token) {
        return undefined;
    }
    disposeCompletions(pid) { }
    handleDidShowCompletionItem(pid, idx) { }
    handlePartialAccept(pid, idx, acceptedCharacters) { }
}
class InlineCompletionAdapter extends InlineCompletionAdapterBase {
    constructor(_extension, _documents, _provider, _commands) {
        super();
        this._extension = _extension;
        this._documents = _documents;
        this._provider = _provider;
        this._commands = _commands;
        this._references = ( (new ReferenceMap()));
        this._isAdditionsProposedApiEnabled = isProposedApiEnabled(this._extension, 'inlineCompletionsAdditions');
        this.languageTriggerKindToVSCodeTriggerKind = {
            [InlineCompletionTriggerKind$2.Automatic]: InlineCompletionTriggerKind$1.Automatic,
            [InlineCompletionTriggerKind$2.Explicit]: InlineCompletionTriggerKind$1.Invoke,
        };
    }
    get supportsHandleEvents() {
        return isProposedApiEnabled(this._extension, 'inlineCompletionsAdditions')
            && (typeof this._provider.handleDidShowCompletionItem === 'function'
                || typeof this._provider.handleDidPartiallyAcceptCompletionItem === 'function');
    }
    async provideInlineCompletions(resource, position, context, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const result = await this._provider.provideInlineCompletionItems(doc, pos, {
            selectedCompletionInfo: context.selectedSuggestionInfo
                ? {
                    range: Range$1.to(context.selectedSuggestionInfo.range),
                    text: context.selectedSuggestionInfo.text
                }
                : undefined,
            triggerKind: this.languageTriggerKindToVSCodeTriggerKind[context.triggerKind]
        }, token);
        if (!result) {
            return undefined;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        const normalizedResult = Array.isArray(result) ? result : result.items;
        const commands = this._isAdditionsProposedApiEnabled ? Array.isArray(result) ? [] : result.commands || [] : [];
        let disposableStore = undefined;
        const pid = this._references.createReferenceId({
            dispose() {
                disposableStore?.dispose();
            },
            items: normalizedResult
        });
        return {
            pid,
            items: ( (normalizedResult.map((item, idx) => {
                let command = undefined;
                if (item.command) {
                    if (!disposableStore) {
                        disposableStore = ( (new DisposableStore()));
                    }
                    command = this._commands.toInternal(item.command, disposableStore);
                }
                const insertText = item.insertText;
                return ({
                    insertText: typeof insertText === 'string' ? insertText : { snippet: insertText.value },
                    filterText: item.filterText,
                    range: item.range ? Range$1.from(item.range) : undefined,
                    command,
                    idx: idx,
                    completeBracketPairs: this._isAdditionsProposedApiEnabled ? item.completeBracketPairs : false
                });
            }))),
            commands: ( (commands.map(c => {
                if (!disposableStore) {
                    disposableStore = ( (new DisposableStore()));
                }
                return this._commands.toInternal(c, disposableStore);
            })))
        };
    }
    disposeCompletions(pid) {
        const data = this._references.disposeReferenceId(pid);
        data?.dispose();
    }
    handleDidShowCompletionItem(pid, idx) {
        const completionItem = this._references.get(pid)?.items[idx];
        if (completionItem) {
            if (this._provider.handleDidShowCompletionItem && this._isAdditionsProposedApiEnabled) {
                this._provider.handleDidShowCompletionItem(completionItem);
            }
        }
    }
    handlePartialAccept(pid, idx, acceptedCharacters) {
        const completionItem = this._references.get(pid)?.items[idx];
        if (completionItem) {
            if (this._provider.handleDidPartiallyAcceptCompletionItem && this._isAdditionsProposedApiEnabled) {
                this._provider.handleDidPartiallyAcceptCompletionItem(completionItem, acceptedCharacters);
            }
        }
    }
}
class ReferenceMap {
    constructor() {
        this._references = ( (new Map()));
        this._idPool = 1;
    }
    createReferenceId(value) {
        const id = this._idPool++;
        this._references.set(id, value);
        return id;
    }
    disposeReferenceId(referenceId) {
        const value = this._references.get(referenceId);
        this._references.delete(referenceId);
        return value;
    }
    get(referenceId) {
        return this._references.get(referenceId);
    }
}
class SignatureHelpAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._cache = ( (new Cache('SignatureHelp')));
    }
    async provideSignatureHelp(resource, position, context, token) {
        const doc = this._documents.getDocument(resource);
        const pos = Position$1.to(position);
        const vscodeContext = this.reviveContext(context);
        const value = await this._provider.provideSignatureHelp(doc, pos, token, vscodeContext);
        if (value) {
            const id = this._cache.add([value]);
            return { ...SignatureHelp$1.from(value), id };
        }
        return undefined;
    }
    reviveContext(context) {
        let activeSignatureHelp = undefined;
        if (context.activeSignatureHelp) {
            const revivedSignatureHelp = SignatureHelp$1.to(context.activeSignatureHelp);
            const saved = this._cache.get(context.activeSignatureHelp.id, 0);
            if (saved) {
                activeSignatureHelp = saved;
                activeSignatureHelp.activeSignature = revivedSignatureHelp.activeSignature;
                activeSignatureHelp.activeParameter = revivedSignatureHelp.activeParameter;
            }
            else {
                activeSignatureHelp = revivedSignatureHelp;
            }
        }
        return { ...context, activeSignatureHelp };
    }
    releaseSignatureHelp(id) {
        this._cache.delete(id);
    }
}
class InlayHintsAdapter {
    constructor(_documents, _commands, _provider, _logService, _extension) {
        this._documents = _documents;
        this._commands = _commands;
        this._provider = _provider;
        this._logService = _logService;
        this._extension = _extension;
        this._cache = ( (new Cache('InlayHints')));
        this._disposables = ( (new Map()));
    }
    async provideInlayHints(resource, ran, token) {
        const doc = this._documents.getDocument(resource);
        const range = Range$1.to(ran);
        const hints = await this._provider.provideInlayHints(doc, range, token);
        if (!Array.isArray(hints) || hints.length === 0) {
            this._logService.trace(`[InlayHints] NO inlay hints from '${this._extension.identifier.value}' for ${ran}`);
            return undefined;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        const pid = this._cache.add(hints);
        this._disposables.set(pid, ( (new DisposableStore())));
        const result = { hints: [], cacheId: pid };
        for (let i = 0; i < hints.length; i++) {
            if (this._isValidInlayHint(hints[i], range)) {
                result.hints.push(this._convertInlayHint(hints[i], [pid, i]));
            }
        }
        this._logService.trace(`[InlayHints] ${result.hints.length} inlay hints from '${this._extension.identifier.value}' for ${ran}`);
        return result;
    }
    async resolveInlayHint(id, token) {
        if (typeof this._provider.resolveInlayHint !== 'function') {
            return undefined;
        }
        const item = this._cache.get(...id);
        if (!item) {
            return undefined;
        }
        const hint = await this._provider.resolveInlayHint(item, token);
        if (!hint) {
            return undefined;
        }
        if (!this._isValidInlayHint(hint)) {
            return undefined;
        }
        return this._convertInlayHint(hint, id);
    }
    releaseHints(id) {
        this._disposables.get(id)?.dispose();
        this._disposables.delete(id);
        this._cache.delete(id);
    }
    _isValidInlayHint(hint, range) {
        if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every(part => part.value.length === 0)) {
            console.log('INVALID inlay hint, empty label', hint);
            return false;
        }
        if (range && !range.contains(hint.position)) {
            return false;
        }
        return true;
    }
    _convertInlayHint(hint, id) {
        const disposables = this._disposables.get(id[0]);
        if (!disposables) {
            throw Error('DisposableStore is missing...');
        }
        const result = {
            label: '',
            cacheId: id,
            tooltip: MarkdownString$1.fromStrict(hint.tooltip),
            position: Position$1.from(hint.position),
            textEdits: hint.textEdits && ( (hint.textEdits.map(TextEdit$1.from))),
            kind: hint.kind && InlayHintKind$1.from(hint.kind),
            paddingLeft: hint.paddingLeft,
            paddingRight: hint.paddingRight,
        };
        if (typeof hint.label === 'string') {
            result.label = hint.label;
        }
        else {
            result.label = ( (hint.label.map(part => {
                const result = { label: part.value };
                result.tooltip = MarkdownString$1.fromStrict(part.tooltip);
                if (Location$1.isLocation(part.location)) {
                    result.location = location.from(part.location);
                }
                if (part.command) {
                    result.command = this._commands.toInternal(part.command, disposables);
                }
                return result;
            })));
        }
        return result;
    }
}
class LinkProviderAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._cache = ( (new Cache('DocumentLink')));
    }
    async provideLinks(resource, token) {
        const doc = this._documents.getDocument(resource);
        const links = await this._provider.provideDocumentLinks(doc, token);
        if (!Array.isArray(links) || links.length === 0) {
            return undefined;
        }
        if (token.isCancellationRequested) {
            return undefined;
        }
        if (typeof this._provider.resolveDocumentLink !== 'function') {
            return { links: ( (links.filter(LinkProviderAdapter._validateLink).map(DocumentLink$1.from))) };
        }
        else {
            const pid = this._cache.add(links);
            const result = { links: [], cacheId: pid };
            for (let i = 0; i < links.length; i++) {
                if (!LinkProviderAdapter._validateLink(links[i])) {
                    continue;
                }
                const dto = DocumentLink$1.from(links[i]);
                dto.cacheId = [pid, i];
                result.links.push(dto);
            }
            return result;
        }
    }
    static _validateLink(link) {
        if (link.target && link.target.path.length > 50000) {
            console.warn('DROPPING link because it is too long');
            return false;
        }
        return true;
    }
    async resolveLink(id, token) {
        if (typeof this._provider.resolveDocumentLink !== 'function') {
            return undefined;
        }
        const item = this._cache.get(...id);
        if (!item) {
            return undefined;
        }
        const link = await this._provider.resolveDocumentLink(item, token);
        if (!link || !LinkProviderAdapter._validateLink(link)) {
            return undefined;
        }
        return DocumentLink$1.from(link);
    }
    releaseLinks(id) {
        this._cache.delete(id);
    }
}
class ColorProviderAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideColors(resource, token) {
        const doc = this._documents.getDocument(resource);
        const colors = await this._provider.provideDocumentColors(doc, token);
        if (!Array.isArray(colors)) {
            return [];
        }
        const colorInfos = ( (colors.map(ci => {
            return {
                color: Color$1.from(ci.color),
                range: Range$1.from(ci.range)
            };
        })));
        return colorInfos;
    }
    async provideColorPresentations(resource, raw, token) {
        const document = this._documents.getDocument(resource);
        const range = Range$1.to(raw.range);
        const color = Color$1.to(raw.color);
        const value = await this._provider.provideColorPresentations(color, { document, range }, token);
        if (!Array.isArray(value)) {
            return undefined;
        }
        return (
             (value.map(ColorPresentation$1.from))
        );
    }
}
class FoldingProviderAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
    }
    async provideFoldingRanges(resource, context, token) {
        const doc = this._documents.getDocument(resource);
        const ranges = await this._provider.provideFoldingRanges(doc, context, token);
        if (!Array.isArray(ranges)) {
            return undefined;
        }
        return (
             (ranges.map(FoldingRange$1.from))
        );
    }
}
class SelectionRangeAdapter {
    constructor(_documents, _provider, _logService) {
        this._documents = _documents;
        this._provider = _provider;
        this._logService = _logService;
    }
    async provideSelectionRanges(resource, pos, token) {
        const document = this._documents.getDocument(resource);
        const positions = ( (pos.map(Position$1.to)));
        const allProviderRanges = await this._provider.provideSelectionRanges(document, positions, token);
        if (!isNonEmptyArray(allProviderRanges)) {
            return [];
        }
        if (allProviderRanges.length !== positions.length) {
            this._logService.warn('BAD selection ranges, provider must return ranges for each position');
            return [];
        }
        const allResults = [];
        for (let i = 0; i < positions.length; i++) {
            const oneResult = [];
            allResults.push(oneResult);
            let last = positions[i];
            let selectionRange = allProviderRanges[i];
            while (true) {
                if (!selectionRange.range.contains(last)) {
                    throw new Error('INVALID selection range, must contain the previous range');
                }
                oneResult.push(SelectionRange$1.from(selectionRange));
                if (!selectionRange.parent) {
                    break;
                }
                last = selectionRange.range;
                selectionRange = selectionRange.parent;
            }
        }
        return allResults;
    }
}
class CallHierarchyAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._idPool = ( (new IdGenerator('')));
        this._cache = ( (new Map()));
    }
    async prepareSession(uri, position, token) {
        const doc = this._documents.getDocument(uri);
        const pos = Position$1.to(position);
        const items = await this._provider.prepareCallHierarchy(doc, pos, token);
        if (!items) {
            return undefined;
        }
        const sessionId = this._idPool.nextId();
        this._cache.set(sessionId, ( (new Map())));
        if (Array.isArray(items)) {
            return (
                 (items.map(item => this._cacheAndConvertItem(sessionId, item)))
            );
        }
        else {
            return [this._cacheAndConvertItem(sessionId, items)];
        }
    }
    async provideCallsTo(sessionId, itemId, token) {
        const item = this._itemFromCache(sessionId, itemId);
        if (!item) {
            throw new Error('missing call hierarchy item');
        }
        const calls = await this._provider.provideCallHierarchyIncomingCalls(item, token);
        if (!calls) {
            return undefined;
        }
        return (
             (calls.map(call => {
                return {
                    from: this._cacheAndConvertItem(sessionId, call.from),
                    fromRanges: ( (call.fromRanges.map(r => Range$1.from(r))))
                };
            }))
        );
    }
    async provideCallsFrom(sessionId, itemId, token) {
        const item = this._itemFromCache(sessionId, itemId);
        if (!item) {
            throw new Error('missing call hierarchy item');
        }
        const calls = await this._provider.provideCallHierarchyOutgoingCalls(item, token);
        if (!calls) {
            return undefined;
        }
        return (
             (calls.map(call => {
                return {
                    to: this._cacheAndConvertItem(sessionId, call.to),
                    fromRanges: ( (call.fromRanges.map(r => Range$1.from(r))))
                };
            }))
        );
    }
    releaseSession(sessionId) {
        this._cache.delete(sessionId);
    }
    _cacheAndConvertItem(sessionId, item) {
        const map = this._cache.get(sessionId);
        const dto = CallHierarchyItem$1.from(item, sessionId, ( (map.size.toString(36))));
        map.set(dto._itemId, item);
        return dto;
    }
    _itemFromCache(sessionId, itemId) {
        const map = this._cache.get(sessionId);
        return map?.get(itemId);
    }
}
class TypeHierarchyAdapter {
    constructor(_documents, _provider) {
        this._documents = _documents;
        this._provider = _provider;
        this._idPool = ( (new IdGenerator('')));
        this._cache = ( (new Map()));
    }
    async prepareSession(uri, position, token) {
        const doc = this._documents.getDocument(uri);
        const pos = Position$1.to(position);
        const items = await this._provider.prepareTypeHierarchy(doc, pos, token);
        if (!items) {
            return undefined;
        }
        const sessionId = this._idPool.nextId();
        this._cache.set(sessionId, ( (new Map())));
        if (Array.isArray(items)) {
            return (
                 (items.map(item => this._cacheAndConvertItem(sessionId, item)))
            );
        }
        else {
            return [this._cacheAndConvertItem(sessionId, items)];
        }
    }
    async provideSupertypes(sessionId, itemId, token) {
        const item = this._itemFromCache(sessionId, itemId);
        if (!item) {
            throw new Error('missing type hierarchy item');
        }
        const supertypes = await this._provider.provideTypeHierarchySupertypes(item, token);
        if (!supertypes) {
            return undefined;
        }
        return (
             (supertypes.map(supertype => {
                return this._cacheAndConvertItem(sessionId, supertype);
            }))
        );
    }
    async provideSubtypes(sessionId, itemId, token) {
        const item = this._itemFromCache(sessionId, itemId);
        if (!item) {
            throw new Error('missing type hierarchy item');
        }
        const subtypes = await this._provider.provideTypeHierarchySubtypes(item, token);
        if (!subtypes) {
            return undefined;
        }
        return (
             (subtypes.map(subtype => {
                return this._cacheAndConvertItem(sessionId, subtype);
            }))
        );
    }
    releaseSession(sessionId) {
        this._cache.delete(sessionId);
    }
    _cacheAndConvertItem(sessionId, item) {
        const map = this._cache.get(sessionId);
        const dto = TypeHierarchyItem$1.from(item, sessionId, ( (map.size.toString(36))));
        map.set(dto._itemId, item);
        return dto;
    }
    _itemFromCache(sessionId, itemId) {
        const map = this._cache.get(sessionId);
        return map?.get(itemId);
    }
}
class DocumentOnDropEditAdapter {
    constructor(_proxy, _documents, _provider, _handle) {
        this._proxy = _proxy;
        this._documents = _documents;
        this._provider = _provider;
        this._handle = _handle;
    }
    async provideDocumentOnDropEdits(requestId, uri, position, dataTransferDto, token) {
        const doc = this._documents.getDocument(uri);
        const pos = Position$1.to(position);
        const dataTransfer = DataTransfer$1.toDataTransfer(dataTransferDto, async (id) => {
            return (await this._proxy.$resolveDocumentOnDropFileData(this._handle, requestId, id)).buffer;
        });
        const edit = await this._provider.provideDocumentDropEdits(doc, pos, dataTransfer, token);
        if (!edit) {
            return undefined;
        }
        return {
            insertText: typeof edit.insertText === 'string' ? edit.insertText : { snippet: edit.insertText.value },
            additionalEdit: edit.additionalEdit ? WorkspaceEdit$1.from(edit.additionalEdit, undefined) : undefined,
        };
    }
}
class AdapterData {
    constructor(adapter, extension) {
        this.adapter = adapter;
        this.extension = extension;
    }
}
class ExtHostLanguageFeatures {
    constructor(mainContext, _uriTransformer, _documents, _commands, _diagnostics, _logService, _apiDeprecation, _extensionTelemetry) {
        this._uriTransformer = _uriTransformer;
        this._documents = _documents;
        this._commands = _commands;
        this._diagnostics = _diagnostics;
        this._logService = _logService;
        this._apiDeprecation = _apiDeprecation;
        this._extensionTelemetry = _extensionTelemetry;
        this._adapter = ( (new Map()));
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadLanguageFeatures)));
    }
    _transformDocumentSelector(selector) {
        return DocumentSelector.from(selector, this._uriTransformer);
    }
    _createDisposable(handle) {
        return (
             (new Disposable$2(() => {
                this._adapter.delete(handle);
                this._proxy.$unregister(handle);
            }))
        );
    }
    _nextHandle() {
        return ExtHostLanguageFeatures._handlePool++;
    }
    async _withAdapter(handle, ctor, callback, fallbackValue, tokenToRaceAgainst, doNotLog = false) {
        const data = this._adapter.get(handle);
        if (!data || !(data.adapter instanceof ctor)) {
            return fallbackValue;
        }
        const t1 = Date.now();
        if (!doNotLog) {
            this._logService.trace(`[${data.extension.identifier.value}] INVOKE provider '${( ( callback.toString())).replace(/[\r\n]/g, '')}'`);
        }
        const result = callback(data.adapter, data.extension);
        Promise.resolve(result).catch(err => {
            if (!isCancellationError(err)) {
                this._logService.error(`[${data.extension.identifier.value}] provider FAILED`);
                this._logService.error(err);
                this._extensionTelemetry.onExtensionError(data.extension.identifier, err);
            }
        }).finally(() => {
            if (!doNotLog) {
                this._logService.trace(`[${data.extension.identifier.value}] provider DONE after ${Date.now() - t1}ms`);
            }
        });
        if (CancellationToken.isCancellationToken(tokenToRaceAgainst)) {
            return raceCancellationError(result, tokenToRaceAgainst);
        }
        return result;
    }
    _addNewAdapter(adapter, extension) {
        const handle = this._nextHandle();
        this._adapter.set(handle, ( (new AdapterData(adapter, extension))));
        return handle;
    }
    static _extLabel(ext) {
        return ext.displayName || ext.name;
    }
    registerDocumentSymbolProvider(extension, selector, provider, metadata) {
        const handle = this._addNewAdapter(( (new DocumentSymbolAdapter(this._documents, provider))), extension);
        const displayName = (metadata && metadata.label) || ExtHostLanguageFeatures._extLabel(extension);
        this._proxy.$registerDocumentSymbolProvider(handle, this._transformDocumentSelector(selector), displayName);
        return this._createDisposable(handle);
    }
    $provideDocumentSymbols(handle, resource, token) {
        return this._withAdapter(handle, DocumentSymbolAdapter, adapter => adapter.provideDocumentSymbols(URI.revive(resource), token), undefined, token);
    }
    registerCodeLensProvider(extension, selector, provider) {
        const handle = this._nextHandle();
        const eventHandle = typeof provider.onDidChangeCodeLenses === 'function' ? this._nextHandle() : undefined;
        this._adapter.set(handle, ( (new AdapterData(
             (new CodeLensAdapter(this._documents, this._commands.converter, provider)),
            extension
        ))));
        this._proxy.$registerCodeLensSupport(handle, this._transformDocumentSelector(selector), eventHandle);
        let result = this._createDisposable(handle);
        if (eventHandle !== undefined) {
            const subscription = provider.onDidChangeCodeLenses(_ => this._proxy.$emitCodeLensEvent(eventHandle));
            result = Disposable$2.from(result, subscription);
        }
        return result;
    }
    $provideCodeLenses(handle, resource, token) {
        return this._withAdapter(handle, CodeLensAdapter, adapter => adapter.provideCodeLenses(URI.revive(resource), token), undefined, token);
    }
    $resolveCodeLens(handle, symbol, token) {
        return this._withAdapter(handle, CodeLensAdapter, adapter => adapter.resolveCodeLens(symbol, token), undefined, undefined);
    }
    $releaseCodeLenses(handle, cacheId) {
        this._withAdapter(handle, CodeLensAdapter, adapter => Promise.resolve(adapter.releaseCodeLenses(cacheId)), undefined, undefined);
    }
    registerDefinitionProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new DefinitionAdapter(this._documents, provider))), extension);
        this._proxy.$registerDefinitionSupport(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideDefinition(handle, resource, position, token) {
        return this._withAdapter(handle, DefinitionAdapter, adapter => adapter.provideDefinition(URI.revive(resource), position, token), [], token);
    }
    registerDeclarationProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new DeclarationAdapter(this._documents, provider))), extension);
        this._proxy.$registerDeclarationSupport(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideDeclaration(handle, resource, position, token) {
        return this._withAdapter(handle, DeclarationAdapter, adapter => adapter.provideDeclaration(URI.revive(resource), position, token), [], token);
    }
    registerImplementationProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new ImplementationAdapter(this._documents, provider))), extension);
        this._proxy.$registerImplementationSupport(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideImplementation(handle, resource, position, token) {
        return this._withAdapter(handle, ImplementationAdapter, adapter => adapter.provideImplementation(URI.revive(resource), position, token), [], token);
    }
    registerTypeDefinitionProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new TypeDefinitionAdapter(this._documents, provider))), extension);
        this._proxy.$registerTypeDefinitionSupport(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideTypeDefinition(handle, resource, position, token) {
        return this._withAdapter(handle, TypeDefinitionAdapter, adapter => adapter.provideTypeDefinition(URI.revive(resource), position, token), [], token);
    }
    registerHoverProvider(extension, selector, provider, extensionId) {
        const handle = this._addNewAdapter(( (new HoverAdapter(this._documents, provider))), extension);
        this._proxy.$registerHoverProvider(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideHover(handle, resource, position, token) {
        return this._withAdapter(handle, HoverAdapter, adapter => adapter.provideHover(URI.revive(resource), position, token), undefined, token);
    }
    registerEvaluatableExpressionProvider(extension, selector, provider, extensionId) {
        const handle = this._addNewAdapter(( (new EvaluatableExpressionAdapter(this._documents, provider))), extension);
        this._proxy.$registerEvaluatableExpressionProvider(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideEvaluatableExpression(handle, resource, position, token) {
        return this._withAdapter(handle, EvaluatableExpressionAdapter, adapter => adapter.provideEvaluatableExpression(URI.revive(resource), position, token), undefined, token);
    }
    registerInlineValuesProvider(extension, selector, provider, extensionId) {
        const eventHandle = typeof provider.onDidChangeInlineValues === 'function' ? this._nextHandle() : undefined;
        const handle = this._addNewAdapter(( (new InlineValuesAdapter(this._documents, provider))), extension);
        this._proxy.$registerInlineValuesProvider(handle, this._transformDocumentSelector(selector), eventHandle);
        let result = this._createDisposable(handle);
        if (eventHandle !== undefined) {
            const subscription = provider.onDidChangeInlineValues(_ => this._proxy.$emitInlineValuesEvent(eventHandle));
            result = Disposable$2.from(result, subscription);
        }
        return result;
    }
    $provideInlineValues(handle, resource, range, context, token) {
        return this._withAdapter(handle, InlineValuesAdapter, adapter => adapter.provideInlineValues(URI.revive(resource), range, context, token), undefined, token);
    }
    registerDocumentHighlightProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new DocumentHighlightAdapter(this._documents, provider))), extension);
        this._proxy.$registerDocumentHighlightProvider(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideDocumentHighlights(handle, resource, position, token) {
        return this._withAdapter(handle, DocumentHighlightAdapter, adapter => adapter.provideDocumentHighlights(URI.revive(resource), position, token), undefined, token);
    }
    registerLinkedEditingRangeProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new LinkedEditingRangeAdapter(this._documents, provider))), extension);
        this._proxy.$registerLinkedEditingRangeProvider(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideLinkedEditingRanges(handle, resource, position, token) {
        return this._withAdapter(handle, LinkedEditingRangeAdapter, async (adapter) => {
            const res = await adapter.provideLinkedEditingRanges(URI.revive(resource), position, token);
            if (res) {
                return {
                    ranges: res.ranges,
                    wordPattern: res.wordPattern ? ExtHostLanguageFeatures._serializeRegExp(res.wordPattern) : undefined
                };
            }
            return undefined;
        }, undefined, token);
    }
    registerReferenceProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new ReferenceAdapter(this._documents, provider))), extension);
        this._proxy.$registerReferenceSupport(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideReferences(handle, resource, position, context, token) {
        return this._withAdapter(handle, ReferenceAdapter, adapter => adapter.provideReferences(URI.revive(resource), position, context, token), undefined, token);
    }
    registerCodeActionProvider(extension, selector, provider, metadata) {
        const store = ( (new DisposableStore()));
        const handle = this._addNewAdapter(( (new CodeActionAdapter(
            this._documents,
            this._commands.converter,
            this._diagnostics,
            provider,
            this._logService,
            extension,
            this._apiDeprecation
        ))), extension);
        this._proxy.$registerQuickFixSupport(handle, this._transformDocumentSelector(selector), {
            providedKinds: metadata?.providedCodeActionKinds?.map(kind => kind.value),
            documentation: metadata?.documentation?.map(x => ({
                kind: x.kind.value,
                command: this._commands.converter.toInternal(x.command, store),
            }))
        }, ExtHostLanguageFeatures._extLabel(extension), Boolean(provider.resolveCodeAction));
        store.add(this._createDisposable(handle));
        return store;
    }
    $provideCodeActions(handle, resource, rangeOrSelection, context, token) {
        return this._withAdapter(handle, CodeActionAdapter, adapter => adapter.provideCodeActions(URI.revive(resource), rangeOrSelection, context, token), undefined, token);
    }
    $resolveCodeAction(handle, id, token) {
        return this._withAdapter(handle, CodeActionAdapter, adapter => adapter.resolveCodeAction(id, token), undefined, undefined);
    }
    $releaseCodeActions(handle, cacheId) {
        this._withAdapter(handle, CodeActionAdapter, adapter => Promise.resolve(adapter.releaseCodeActions(cacheId)), undefined, undefined);
    }
    registerDocumentFormattingEditProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new DocumentFormattingAdapter(this._documents, provider))), extension);
        this._proxy.$registerDocumentFormattingSupport(handle, this._transformDocumentSelector(selector), extension.identifier, extension.displayName || extension.name);
        return this._createDisposable(handle);
    }
    $provideDocumentFormattingEdits(handle, resource, options, token) {
        return this._withAdapter(handle, DocumentFormattingAdapter, adapter => adapter.provideDocumentFormattingEdits(URI.revive(resource), options, token), undefined, token);
    }
    registerDocumentRangeFormattingEditProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new RangeFormattingAdapter(this._documents, provider))), extension);
        this._proxy.$registerRangeFormattingSupport(handle, this._transformDocumentSelector(selector), extension.identifier, extension.displayName || extension.name);
        return this._createDisposable(handle);
    }
    $provideDocumentRangeFormattingEdits(handle, resource, range, options, token) {
        return this._withAdapter(handle, RangeFormattingAdapter, adapter => adapter.provideDocumentRangeFormattingEdits(URI.revive(resource), range, options, token), undefined, token);
    }
    registerOnTypeFormattingEditProvider(extension, selector, provider, triggerCharacters) {
        const handle = this._addNewAdapter(( (new OnTypeFormattingAdapter(this._documents, provider))), extension);
        this._proxy.$registerOnTypeFormattingSupport(handle, this._transformDocumentSelector(selector), triggerCharacters, extension.identifier);
        return this._createDisposable(handle);
    }
    $provideOnTypeFormattingEdits(handle, resource, position, ch, options, token) {
        return this._withAdapter(handle, OnTypeFormattingAdapter, adapter => adapter.provideOnTypeFormattingEdits(URI.revive(resource), position, ch, options, token), undefined, token);
    }
    registerWorkspaceSymbolProvider(extension, provider) {
        const handle = this._addNewAdapter(( (new NavigateTypeAdapter(provider, this._logService))), extension);
        this._proxy.$registerNavigateTypeSupport(handle, typeof provider.resolveWorkspaceSymbol === 'function');
        return this._createDisposable(handle);
    }
    $provideWorkspaceSymbols(handle, search, token) {
        return this._withAdapter(handle, NavigateTypeAdapter, adapter => adapter.provideWorkspaceSymbols(search, token), { symbols: [] }, token);
    }
    $resolveWorkspaceSymbol(handle, symbol, token) {
        return this._withAdapter(handle, NavigateTypeAdapter, adapter => adapter.resolveWorkspaceSymbol(symbol, token), undefined, undefined);
    }
    $releaseWorkspaceSymbols(handle, id) {
        this._withAdapter(handle, NavigateTypeAdapter, adapter => adapter.releaseWorkspaceSymbols(id), undefined, undefined);
    }
    registerRenameProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new RenameAdapter(this._documents, provider, this._logService))), extension);
        this._proxy.$registerRenameSupport(handle, this._transformDocumentSelector(selector), RenameAdapter.supportsResolving(provider));
        return this._createDisposable(handle);
    }
    $provideRenameEdits(handle, resource, position, newName, token) {
        return this._withAdapter(handle, RenameAdapter, adapter => adapter.provideRenameEdits(URI.revive(resource), position, newName, token), undefined, token);
    }
    $resolveRenameLocation(handle, resource, position, token) {
        return this._withAdapter(handle, RenameAdapter, adapter => adapter.resolveRenameLocation(URI.revive(resource), position, token), undefined, token);
    }
    registerDocumentSemanticTokensProvider(extension, selector, provider, legend) {
        const handle = this._addNewAdapter(( (new DocumentSemanticTokensAdapter(this._documents, provider))), extension);
        const eventHandle = (typeof provider.onDidChangeSemanticTokens === 'function' ? this._nextHandle() : undefined);
        this._proxy.$registerDocumentSemanticTokensProvider(handle, this._transformDocumentSelector(selector), legend, eventHandle);
        let result = this._createDisposable(handle);
        if (eventHandle) {
            const subscription = provider.onDidChangeSemanticTokens(_ => this._proxy.$emitDocumentSemanticTokensEvent(eventHandle));
            result = Disposable$2.from(result, subscription);
        }
        return result;
    }
    $provideDocumentSemanticTokens(handle, resource, previousResultId, token) {
        return this._withAdapter(handle, DocumentSemanticTokensAdapter, adapter => adapter.provideDocumentSemanticTokens(URI.revive(resource), previousResultId, token), null, token);
    }
    $releaseDocumentSemanticTokens(handle, semanticColoringResultId) {
        this._withAdapter(handle, DocumentSemanticTokensAdapter, adapter => adapter.releaseDocumentSemanticColoring(semanticColoringResultId), undefined, undefined);
    }
    registerDocumentRangeSemanticTokensProvider(extension, selector, provider, legend) {
        const handle = this._addNewAdapter(( (new DocumentRangeSemanticTokensAdapter(this._documents, provider))), extension);
        this._proxy.$registerDocumentRangeSemanticTokensProvider(handle, this._transformDocumentSelector(selector), legend);
        return this._createDisposable(handle);
    }
    $provideDocumentRangeSemanticTokens(handle, resource, range, token) {
        return this._withAdapter(handle, DocumentRangeSemanticTokensAdapter, adapter => adapter.provideDocumentRangeSemanticTokens(URI.revive(resource), range, token), null, token);
    }
    registerCompletionItemProvider(extension, selector, provider, triggerCharacters) {
        const handle = this._addNewAdapter(( (new CompletionsAdapter(
            this._documents,
            this._commands.converter,
            provider,
            this._apiDeprecation,
            extension
        ))), extension);
        this._proxy.$registerCompletionsProvider(handle, this._transformDocumentSelector(selector), triggerCharacters, CompletionsAdapter.supportsResolving(provider), `${extension.identifier.value}(${triggerCharacters.join('')})`);
        return this._createDisposable(handle);
    }
    $provideCompletionItems(handle, resource, position, context, token) {
        return this._withAdapter(handle, CompletionsAdapter, adapter => adapter.provideCompletionItems(URI.revive(resource), position, context, token), undefined, token);
    }
    $resolveCompletionItem(handle, id, token) {
        return this._withAdapter(handle, CompletionsAdapter, adapter => adapter.resolveCompletionItem(id, token), undefined, token);
    }
    $releaseCompletionItems(handle, id) {
        this._withAdapter(handle, CompletionsAdapter, adapter => adapter.releaseCompletionItems(id), undefined, undefined);
    }
    registerInlineCompletionsProvider(extension, selector, provider) {
        const adapter = ( (new InlineCompletionAdapter(extension, this._documents, provider, this._commands.converter)));
        const handle = this._addNewAdapter(adapter, extension);
        this._proxy.$registerInlineCompletionsSupport(handle, this._transformDocumentSelector(selector), adapter.supportsHandleEvents);
        return this._createDisposable(handle);
    }
    $provideInlineCompletions(handle, resource, position, context, token) {
        return this._withAdapter(handle, InlineCompletionAdapterBase, adapter => adapter.provideInlineCompletions(URI.revive(resource), position, context, token), undefined, token);
    }
    $handleInlineCompletionDidShow(handle, pid, idx) {
        this._withAdapter(handle, InlineCompletionAdapterBase, async (adapter) => {
            adapter.handleDidShowCompletionItem(pid, idx);
        }, undefined, undefined);
    }
    $handleInlineCompletionPartialAccept(handle, pid, idx, acceptedCharacters) {
        this._withAdapter(handle, InlineCompletionAdapterBase, async (adapter) => {
            adapter.handlePartialAccept(pid, idx, acceptedCharacters);
        }, undefined, undefined);
    }
    $freeInlineCompletionsList(handle, pid) {
        this._withAdapter(handle, InlineCompletionAdapterBase, async (adapter) => { adapter.disposeCompletions(pid); }, undefined, undefined);
    }
    registerSignatureHelpProvider(extension, selector, provider, metadataOrTriggerChars) {
        const metadata = Array.isArray(metadataOrTriggerChars)
            ? { triggerCharacters: metadataOrTriggerChars, retriggerCharacters: [] }
            : metadataOrTriggerChars;
        const handle = this._addNewAdapter(( (new SignatureHelpAdapter(this._documents, provider))), extension);
        this._proxy.$registerSignatureHelpProvider(handle, this._transformDocumentSelector(selector), metadata);
        return this._createDisposable(handle);
    }
    $provideSignatureHelp(handle, resource, position, context, token) {
        return this._withAdapter(handle, SignatureHelpAdapter, adapter => adapter.provideSignatureHelp(URI.revive(resource), position, context, token), undefined, token);
    }
    $releaseSignatureHelp(handle, id) {
        this._withAdapter(handle, SignatureHelpAdapter, adapter => adapter.releaseSignatureHelp(id), undefined, undefined);
    }
    registerInlayHintsProvider(extension, selector, provider) {
        const eventHandle = typeof provider.onDidChangeInlayHints === 'function' ? this._nextHandle() : undefined;
        const handle = this._addNewAdapter(( (new InlayHintsAdapter(
            this._documents,
            this._commands.converter,
            provider,
            this._logService,
            extension
        ))), extension);
        this._proxy.$registerInlayHintsProvider(handle, this._transformDocumentSelector(selector), typeof provider.resolveInlayHint === 'function', eventHandle, ExtHostLanguageFeatures._extLabel(extension));
        let result = this._createDisposable(handle);
        if (eventHandle !== undefined) {
            const subscription = provider.onDidChangeInlayHints(uri => this._proxy.$emitInlayHintsEvent(eventHandle));
            result = Disposable$2.from(result, subscription);
        }
        return result;
    }
    $provideInlayHints(handle, resource, range, token) {
        return this._withAdapter(handle, InlayHintsAdapter, adapter => adapter.provideInlayHints(URI.revive(resource), range, token), undefined, token);
    }
    $resolveInlayHint(handle, id, token) {
        return this._withAdapter(handle, InlayHintsAdapter, adapter => adapter.resolveInlayHint(id, token), undefined, token);
    }
    $releaseInlayHints(handle, id) {
        this._withAdapter(handle, InlayHintsAdapter, adapter => adapter.releaseHints(id), undefined, undefined);
    }
    registerDocumentLinkProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new LinkProviderAdapter(this._documents, provider))), extension);
        this._proxy.$registerDocumentLinkProvider(handle, this._transformDocumentSelector(selector), typeof provider.resolveDocumentLink === 'function');
        return this._createDisposable(handle);
    }
    $provideDocumentLinks(handle, resource, token) {
        return this._withAdapter(handle, LinkProviderAdapter, adapter => adapter.provideLinks(URI.revive(resource), token), undefined, token, resource.scheme === 'output');
    }
    $resolveDocumentLink(handle, id, token) {
        return this._withAdapter(handle, LinkProviderAdapter, adapter => adapter.resolveLink(id, token), undefined, undefined, true);
    }
    $releaseDocumentLinks(handle, id) {
        this._withAdapter(handle, LinkProviderAdapter, adapter => adapter.releaseLinks(id), undefined, undefined, true);
    }
    registerColorProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new ColorProviderAdapter(this._documents, provider))), extension);
        this._proxy.$registerDocumentColorProvider(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideDocumentColors(handle, resource, token) {
        return this._withAdapter(handle, ColorProviderAdapter, adapter => adapter.provideColors(URI.revive(resource), token), [], token);
    }
    $provideColorPresentations(handle, resource, colorInfo, token) {
        return this._withAdapter(handle, ColorProviderAdapter, adapter => adapter.provideColorPresentations(URI.revive(resource), colorInfo, token), undefined, token);
    }
    registerFoldingRangeProvider(extension, selector, provider) {
        const handle = this._nextHandle();
        const eventHandle = typeof provider.onDidChangeFoldingRanges === 'function' ? this._nextHandle() : undefined;
        this._adapter.set(handle, ( (new AdapterData(
             (new FoldingProviderAdapter(this._documents, provider)),
            extension
        ))));
        this._proxy.$registerFoldingRangeProvider(handle, this._transformDocumentSelector(selector), extension.identifier, eventHandle);
        let result = this._createDisposable(handle);
        if (eventHandle !== undefined) {
            const subscription = provider.onDidChangeFoldingRanges(() => this._proxy.$emitFoldingRangeEvent(eventHandle));
            result = Disposable$2.from(result, subscription);
        }
        return result;
    }
    $provideFoldingRanges(handle, resource, context, token) {
        return this._withAdapter(handle, FoldingProviderAdapter, adapter => adapter.provideFoldingRanges(URI.revive(resource), context, token), undefined, token);
    }
    registerSelectionRangeProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new SelectionRangeAdapter(this._documents, provider, this._logService))), extension);
        this._proxy.$registerSelectionRangeProvider(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideSelectionRanges(handle, resource, positions, token) {
        return this._withAdapter(handle, SelectionRangeAdapter, adapter => adapter.provideSelectionRanges(URI.revive(resource), positions, token), [], token);
    }
    registerCallHierarchyProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new CallHierarchyAdapter(this._documents, provider))), extension);
        this._proxy.$registerCallHierarchyProvider(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $prepareCallHierarchy(handle, resource, position, token) {
        return this._withAdapter(handle, CallHierarchyAdapter, adapter => Promise.resolve(adapter.prepareSession(URI.revive(resource), position, token)), undefined, token);
    }
    $provideCallHierarchyIncomingCalls(handle, sessionId, itemId, token) {
        return this._withAdapter(handle, CallHierarchyAdapter, adapter => adapter.provideCallsTo(sessionId, itemId, token), undefined, token);
    }
    $provideCallHierarchyOutgoingCalls(handle, sessionId, itemId, token) {
        return this._withAdapter(handle, CallHierarchyAdapter, adapter => adapter.provideCallsFrom(sessionId, itemId, token), undefined, token);
    }
    $releaseCallHierarchy(handle, sessionId) {
        this._withAdapter(handle, CallHierarchyAdapter, adapter => Promise.resolve(adapter.releaseSession(sessionId)), undefined, undefined);
    }
    registerTypeHierarchyProvider(extension, selector, provider) {
        const handle = this._addNewAdapter(( (new TypeHierarchyAdapter(this._documents, provider))), extension);
        this._proxy.$registerTypeHierarchyProvider(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $prepareTypeHierarchy(handle, resource, position, token) {
        return this._withAdapter(handle, TypeHierarchyAdapter, adapter => Promise.resolve(adapter.prepareSession(URI.revive(resource), position, token)), undefined, token);
    }
    $provideTypeHierarchySupertypes(handle, sessionId, itemId, token) {
        return this._withAdapter(handle, TypeHierarchyAdapter, adapter => adapter.provideSupertypes(sessionId, itemId, token), undefined, token);
    }
    $provideTypeHierarchySubtypes(handle, sessionId, itemId, token) {
        return this._withAdapter(handle, TypeHierarchyAdapter, adapter => adapter.provideSubtypes(sessionId, itemId, token), undefined, token);
    }
    $releaseTypeHierarchy(handle, sessionId) {
        this._withAdapter(handle, TypeHierarchyAdapter, adapter => Promise.resolve(adapter.releaseSession(sessionId)), undefined, undefined);
    }
    registerDocumentOnDropEditProvider(extension, selector, provider) {
        const handle = this._nextHandle();
        this._adapter.set(handle, ( (new AdapterData(
             (new DocumentOnDropEditAdapter(this._proxy, this._documents, provider, handle)),
            extension
        ))));
        this._proxy.$registerDocumentOnDropEditProvider(handle, this._transformDocumentSelector(selector));
        return this._createDisposable(handle);
    }
    $provideDocumentOnDropEdits(handle, requestId, resource, position, dataTransferDto, token) {
        return this._withAdapter(handle, DocumentOnDropEditAdapter, adapter => Promise.resolve(adapter.provideDocumentOnDropEdits(requestId, URI.revive(resource), position, dataTransferDto, token)), undefined, undefined);
    }
    registerDocumentPasteEditProvider(extension, selector, provider, metadata) {
        const handle = this._nextHandle();
        this._adapter.set(handle, ( (new AdapterData(
             (new DocumentPasteEditProvider(this._proxy, this._documents, provider, handle)),
            extension
        ))));
        this._proxy.$registerPasteEditProvider(handle, this._transformDocumentSelector(selector), !!provider.prepareDocumentPaste, metadata.pasteMimeTypes);
        return this._createDisposable(handle);
    }
    $prepareDocumentPaste(handle, resource, ranges, dataTransfer, token) {
        return this._withAdapter(handle, DocumentPasteEditProvider, adapter => adapter.prepareDocumentPaste(URI.revive(resource), ranges, dataTransfer, token), undefined, token);
    }
    $providePasteEdits(handle, requestId, resource, ranges, dataTransferDto, token) {
        return this._withAdapter(handle, DocumentPasteEditProvider, adapter => adapter.providePasteEdits(requestId, URI.revive(resource), ranges, dataTransferDto, token), undefined, token);
    }
    static _serializeRegExp(regExp) {
        return {
            pattern: regExp.source,
            flags: regExpFlags(regExp),
        };
    }
    static _serializeIndentationRule(indentationRule) {
        return {
            decreaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.decreaseIndentPattern),
            increaseIndentPattern: ExtHostLanguageFeatures._serializeRegExp(indentationRule.increaseIndentPattern),
            indentNextLinePattern: indentationRule.indentNextLinePattern ? ExtHostLanguageFeatures._serializeRegExp(indentationRule.indentNextLinePattern) : undefined,
            unIndentedLinePattern: indentationRule.unIndentedLinePattern ? ExtHostLanguageFeatures._serializeRegExp(indentationRule.unIndentedLinePattern) : undefined,
        };
    }
    static _serializeOnEnterRule(onEnterRule) {
        return {
            beforeText: ExtHostLanguageFeatures._serializeRegExp(onEnterRule.beforeText),
            afterText: onEnterRule.afterText ? ExtHostLanguageFeatures._serializeRegExp(onEnterRule.afterText) : undefined,
            previousLineText: onEnterRule.previousLineText ? ExtHostLanguageFeatures._serializeRegExp(onEnterRule.previousLineText) : undefined,
            action: onEnterRule.action
        };
    }
    static _serializeOnEnterRules(onEnterRules) {
        return (
             (onEnterRules.map(ExtHostLanguageFeatures._serializeOnEnterRule))
        );
    }
    setLanguageConfiguration(extension, languageId, configuration) {
        const { wordPattern } = configuration;
        if (wordPattern && regExpLeadsToEndlessLoop(wordPattern)) {
            throw new Error(`Invalid language configuration: wordPattern '${wordPattern}' is not allowed to match the empty string.`);
        }
        if (wordPattern) {
            this._documents.setWordDefinitionFor(languageId, wordPattern);
        }
        else {
            this._documents.setWordDefinitionFor(languageId, undefined);
        }
        if (configuration.__electricCharacterSupport) {
            this._apiDeprecation.report('LanguageConfiguration.__electricCharacterSupport', extension, `Do not use.`);
        }
        if (configuration.__characterPairSupport) {
            this._apiDeprecation.report('LanguageConfiguration.__characterPairSupport', extension, `Do not use.`);
        }
        const handle = this._nextHandle();
        const serializedConfiguration = {
            comments: configuration.comments,
            brackets: configuration.brackets,
            wordPattern: configuration.wordPattern ? ExtHostLanguageFeatures._serializeRegExp(configuration.wordPattern) : undefined,
            indentationRules: configuration.indentationRules ? ExtHostLanguageFeatures._serializeIndentationRule(configuration.indentationRules) : undefined,
            onEnterRules: configuration.onEnterRules ? ExtHostLanguageFeatures._serializeOnEnterRules(configuration.onEnterRules) : undefined,
            __electricCharacterSupport: configuration.__electricCharacterSupport,
            __characterPairSupport: configuration.__characterPairSupport,
        };
        this._proxy.$setLanguageConfiguration(handle, languageId, serializedConfiguration);
        return this._createDisposable(handle);
    }
    $setWordDefinitions(wordDefinitions) {
        for (const wordDefinition of wordDefinitions) {
            this._documents.setWordDefinitionFor(wordDefinition.languageId, ( (new RegExp(wordDefinition.regexSource, wordDefinition.regexFlags))));
        }
    }
}
ExtHostLanguageFeatures._handlePool = 0;
class DataTransferCache {
    constructor() {
        this.requestIdPool = 0;
        this.dataTransfers = ( (new Map()));
    }
    add(dataTransfer) {
        const requestId = this.requestIdPool++;
        this.dataTransfers.set(requestId, [...( (dataTransfer.values()))]);
        return {
            id: requestId,
            dispose: () => {
                this.dataTransfers.delete(requestId);
            }
        };
    }
    async resolveDropFileData(requestId, dataItemId) {
        const entry = this.dataTransfers.get(requestId);
        if (!entry) {
            throw new Error('No data transfer found');
        }
        const item = entry.find(x => x.id === dataItemId);
        if (!item) {
            throw new Error('No item found in data transfer');
        }
        const file = item.asFile();
        if (!file) {
            throw new Error('Found data transfer item is not a file');
        }
        return VSBuffer.wrap(await file.data());
    }
    dispose() {
        this.dataTransfers.clear();
    }
}
const CallHierarchyProviderRegistry = ( (new LanguageFeatureRegistry()));
class CallHierarchyModel {
    static async create(model, position, token) {
        const [provider] = CallHierarchyProviderRegistry.ordered(model);
        if (!provider) {
            return undefined;
        }
        const session = await provider.prepareCallHierarchy(model, position, token);
        if (!session) {
            return undefined;
        }
        return (
             (new CallHierarchyModel(
                session.roots.reduce((p, c) => p + c._sessionId, ''),
                provider,
                session.roots,
                 (new RefCountedDisposable(session))
            ))
        );
    }
    constructor(id, provider, roots, ref) {
        this.id = id;
        this.provider = provider;
        this.roots = roots;
        this.ref = ref;
        this.root = roots[0];
    }
    dispose() {
        this.ref.release();
    }
    fork(item) {
        const that = this;
        return new (class extends CallHierarchyModel {
            constructor() {
                super(that.id, that.provider, [item], that.ref.acquire());
            }
        });
    }
    async resolveIncomingCalls(item, token) {
        try {
            const result = await this.provider.provideIncomingCalls(item, token);
            if (isNonEmptyArray(result)) {
                return result;
            }
        }
        catch (e) {
            onUnexpectedExternalError(e);
        }
        return [];
    }
    async resolveOutgoingCalls(item, token) {
        try {
            const result = await this.provider.provideOutgoingCalls(item, token);
            if (isNonEmptyArray(result)) {
                return result;
            }
        }
        catch (e) {
            onUnexpectedExternalError(e);
        }
        return [];
    }
}
const _models$1 = ( (new Map()));
CommandsRegistry.registerCommand('_executePrepareCallHierarchy', async (accessor, ...args) => {
    const [resource, position] = args;
    assertType(URI.isUri(resource));
    assertType(Position$2.isIPosition(position));
    const modelService = accessor.get(IModelService);
    let textModel = modelService.getModel(resource);
    let textModelReference;
    if (!textModel) {
        const textModelService = accessor.get(ITextModelService);
        const result = await textModelService.createModelReference(resource);
        textModel = result.object.textEditorModel;
        textModelReference = result;
    }
    try {
        const model = await CallHierarchyModel.create(textModel, position, CancellationToken.None);
        if (!model) {
            return [];
        }
        _models$1.set(model.id, model);
        _models$1.forEach((value, key, map) => {
            if (map.size > 10) {
                value.dispose();
                _models$1.delete(key);
            }
        });
        return [model.root];
    }
    finally {
        textModelReference?.dispose();
    }
});
function isCallHierarchyItemDto(obj) {
    return true;
}
CommandsRegistry.registerCommand('_executeProvideIncomingCalls', async (_accessor, ...args) => {
    const [item] = args;
    assertType(isCallHierarchyItemDto());
    const model = _models$1.get(item._sessionId);
    if (!model) {
        return undefined;
    }
    return model.resolveIncomingCalls(item, CancellationToken.None);
});
CommandsRegistry.registerCommand('_executeProvideOutgoingCalls', async (_accessor, ...args) => {
    const [item] = args;
    assertType(isCallHierarchyItemDto());
    const model = _models$1.get(item._sessionId);
    if (!model) {
        return undefined;
    }
    return model.resolveOutgoingCalls(item, CancellationToken.None);
});
var WorkspaceSymbolProviderRegistry;
( ((function(WorkspaceSymbolProviderRegistry) {
    const _supports = [];
    function register(provider) {
        let support = provider;
        if (support) {
            _supports.push(support);
        }
        return {
            dispose() {
                if (support) {
                    const idx = _supports.indexOf(support);
                    if (idx >= 0) {
                        _supports.splice(idx, 1);
                        support = undefined;
                    }
                }
            }
        };
    }
    WorkspaceSymbolProviderRegistry.register = register;
    function all() {
        return _supports.slice(0);
    }
    WorkspaceSymbolProviderRegistry.all = all;
})(WorkspaceSymbolProviderRegistry || (WorkspaceSymbolProviderRegistry = {}))));
const TypeHierarchyProviderRegistry = ( (new LanguageFeatureRegistry()));
class TypeHierarchyModel {
    static async create(model, position, token) {
        const [provider] = TypeHierarchyProviderRegistry.ordered(model);
        if (!provider) {
            return undefined;
        }
        const session = await provider.prepareTypeHierarchy(model, position, token);
        if (!session) {
            return undefined;
        }
        return (
             (new TypeHierarchyModel(
                session.roots.reduce((p, c) => p + c._sessionId, ''),
                provider,
                session.roots,
                 (new RefCountedDisposable(session))
            ))
        );
    }
    constructor(id, provider, roots, ref) {
        this.id = id;
        this.provider = provider;
        this.roots = roots;
        this.ref = ref;
        this.root = roots[0];
    }
    dispose() {
        this.ref.release();
    }
    fork(item) {
        const that = this;
        return new (class extends TypeHierarchyModel {
            constructor() {
                super(that.id, that.provider, [item], that.ref.acquire());
            }
        });
    }
    async provideSupertypes(item, token) {
        try {
            const result = await this.provider.provideSupertypes(item, token);
            if (isNonEmptyArray(result)) {
                return result;
            }
        }
        catch (e) {
            onUnexpectedExternalError(e);
        }
        return [];
    }
    async provideSubtypes(item, token) {
        try {
            const result = await this.provider.provideSubtypes(item, token);
            if (isNonEmptyArray(result)) {
                return result;
            }
        }
        catch (e) {
            onUnexpectedExternalError(e);
        }
        return [];
    }
}
const _models = ( (new Map()));
CommandsRegistry.registerCommand('_executePrepareTypeHierarchy', async (accessor, ...args) => {
    const [resource, position] = args;
    assertType(URI.isUri(resource));
    assertType(Position$2.isIPosition(position));
    const modelService = accessor.get(IModelService);
    let textModel = modelService.getModel(resource);
    let textModelReference;
    if (!textModel) {
        const textModelService = accessor.get(ITextModelService);
        const result = await textModelService.createModelReference(resource);
        textModel = result.object.textEditorModel;
        textModelReference = result;
    }
    try {
        const model = await TypeHierarchyModel.create(textModel, position, CancellationToken.None);
        if (!model) {
            return [];
        }
        _models.set(model.id, model);
        _models.forEach((value, key, map) => {
            if (map.size > 10) {
                value.dispose();
                _models.delete(key);
            }
        });
        return [model.root];
    }
    finally {
        textModelReference?.dispose();
    }
});
function isTypeHierarchyItemDto(obj) {
    const item = obj;
    return typeof obj === 'object'
        && typeof item.name === 'string'
        && typeof item.kind === 'number'
        && URI.isUri(item.uri)
        && Range$2.isIRange(item.range)
        && Range$2.isIRange(item.selectionRange);
}
CommandsRegistry.registerCommand('_executeProvideSupertypes', async (_accessor, ...args) => {
    const [item] = args;
    assertType(isTypeHierarchyItemDto(item));
    const model = _models.get(item._sessionId);
    if (!model) {
        return undefined;
    }
    return model.provideSupertypes(item, CancellationToken.None);
});
CommandsRegistry.registerCommand('_executeProvideSubtypes', async (_accessor, ...args) => {
    const [item] = args;
    assertType(isTypeHierarchyItemDto(item));
    const model = _models.get(item._sessionId);
    if (!model) {
        return undefined;
    }
    return model.provideSubtypes(item, CancellationToken.None);
});
var MainThreadLanguageFeatures_1;
let MainThreadLanguageFeatures = MainThreadLanguageFeatures_1 = class MainThreadLanguageFeatures extends Disposable$1 {
    constructor(extHostContext, _languageService, _languageConfigurationService, _languageFeaturesService, _uriIdentService) {
        super();
        this._languageService = _languageService;
        this._languageConfigurationService = _languageConfigurationService;
        this._languageFeaturesService = _languageFeaturesService;
        this._uriIdentService = _uriIdentService;
        this._registrations = this._register(( (new DisposableMap())));
        this._pasteEditProviders = ( (new Map()));
        this._documentOnDropEditProviders = ( (new Map()));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostLanguageFeatures)));
        if (this._languageService) {
            const updateAllWordDefinitions = () => {
                const wordDefinitionDtos = [];
                for (const languageId of _languageService.getRegisteredLanguageIds()) {
                    const wordDefinition = this._languageConfigurationService.getLanguageConfiguration(languageId).getWordDefinition();
                    wordDefinitionDtos.push({
                        languageId: languageId,
                        regexSource: wordDefinition.source,
                        regexFlags: wordDefinition.flags
                    });
                }
                this._proxy.$setWordDefinitions(wordDefinitionDtos);
            };
            this._languageConfigurationService.onDidChange((e) => {
                if (!e.languageId) {
                    updateAllWordDefinitions();
                }
                else {
                    const wordDefinition = this._languageConfigurationService.getLanguageConfiguration(e.languageId).getWordDefinition();
                    this._proxy.$setWordDefinitions([{
                            languageId: e.languageId,
                            regexSource: wordDefinition.source,
                            regexFlags: wordDefinition.flags
                        }]);
                }
            });
            updateAllWordDefinitions();
        }
    }
    $unregister(handle) {
        this._registrations.deleteAndDispose(handle);
    }
    static _reviveLocationDto(data) {
        if (!data) {
            return data;
        }
        else if (Array.isArray(data)) {
            data.forEach(l => MainThreadLanguageFeatures_1._reviveLocationDto(l));
            return data;
        }
        else {
            data.uri = URI.revive(data.uri);
            return data;
        }
    }
    static _reviveLocationLinkDto(data) {
        if (!data) {
            return data;
        }
        else if (Array.isArray(data)) {
            data.forEach(l => MainThreadLanguageFeatures_1._reviveLocationLinkDto(l));
            return data;
        }
        else {
            data.uri = URI.revive(data.uri);
            return data;
        }
    }
    static _reviveWorkspaceSymbolDto(data) {
        if (!data) {
            return data;
        }
        else if (Array.isArray(data)) {
            data.forEach(MainThreadLanguageFeatures_1._reviveWorkspaceSymbolDto);
            return data;
        }
        else {
            data.location = MainThreadLanguageFeatures_1._reviveLocationDto(data.location);
            return data;
        }
    }
    static _reviveCodeActionDto(data, uriIdentService) {
        data?.forEach(code => reviveWorkspaceEditDto(code.edit, uriIdentService));
        return data;
    }
    static _reviveLinkDTO(data) {
        if (data.url && typeof data.url !== 'string') {
            data.url = URI.revive(data.url);
        }
        return data;
    }
    static _reviveCallHierarchyItemDto(data) {
        if (data) {
            data.uri = URI.revive(data.uri);
        }
        return data;
    }
    static _reviveTypeHierarchyItemDto(data) {
        if (data) {
            data.uri = URI.revive(data.uri);
        }
        return data;
    }
    $registerDocumentSymbolProvider(handle, selector, displayName) {
        this._registrations.set(handle, this._languageFeaturesService.documentSymbolProvider.register(selector, {
            displayName,
            provideDocumentSymbols: (model, token) => {
                return this._proxy.$provideDocumentSymbols(handle, model.uri, token);
            }
        }));
    }
    $registerCodeLensSupport(handle, selector, eventHandle) {
        const provider = {
            provideCodeLenses: async (model, token) => {
                const listDto = await this._proxy.$provideCodeLenses(handle, model.uri, token);
                if (!listDto) {
                    return undefined;
                }
                return {
                    lenses: listDto.lenses,
                    dispose: () => listDto.cacheId && this._proxy.$releaseCodeLenses(handle, listDto.cacheId)
                };
            },
            resolveCodeLens: (_model, codeLens, token) => {
                return this._proxy.$resolveCodeLens(handle, codeLens, token);
            }
        };
        if (typeof eventHandle === 'number') {
            const emitter = ( (new Emitter$1()));
            this._registrations.set(eventHandle, emitter);
            provider.onDidChange = emitter.event;
        }
        this._registrations.set(handle, this._languageFeaturesService.codeLensProvider.register(selector, provider));
    }
    $emitCodeLensEvent(eventHandle, event) {
        const obj = this._registrations.get(eventHandle);
        if (obj instanceof Emitter$1) {
            obj.fire(event);
        }
    }
    $registerDefinitionSupport(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.definitionProvider.register(selector, {
            provideDefinition: (model, position, token) => {
                return this._proxy.$provideDefinition(handle, model.uri, position, token).then(MainThreadLanguageFeatures_1._reviveLocationLinkDto);
            }
        }));
    }
    $registerDeclarationSupport(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.declarationProvider.register(selector, {
            provideDeclaration: (model, position, token) => {
                return this._proxy.$provideDeclaration(handle, model.uri, position, token).then(MainThreadLanguageFeatures_1._reviveLocationLinkDto);
            }
        }));
    }
    $registerImplementationSupport(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.implementationProvider.register(selector, {
            provideImplementation: (model, position, token) => {
                return this._proxy.$provideImplementation(handle, model.uri, position, token).then(MainThreadLanguageFeatures_1._reviveLocationLinkDto);
            }
        }));
    }
    $registerTypeDefinitionSupport(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.typeDefinitionProvider.register(selector, {
            provideTypeDefinition: (model, position, token) => {
                return this._proxy.$provideTypeDefinition(handle, model.uri, position, token).then(MainThreadLanguageFeatures_1._reviveLocationLinkDto);
            }
        }));
    }
    $registerHoverProvider(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.hoverProvider.register(selector, {
            provideHover: (model, position, token) => {
                return this._proxy.$provideHover(handle, model.uri, position, token);
            }
        }));
    }
    $registerEvaluatableExpressionProvider(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.evaluatableExpressionProvider.register(selector, {
            provideEvaluatableExpression: (model, position, token) => {
                return this._proxy.$provideEvaluatableExpression(handle, model.uri, position, token);
            }
        }));
    }
    $registerInlineValuesProvider(handle, selector, eventHandle) {
        const provider = {
            provideInlineValues: (model, viewPort, context, token) => {
                return this._proxy.$provideInlineValues(handle, model.uri, viewPort, context, token);
            }
        };
        if (typeof eventHandle === 'number') {
            const emitter = ( (new Emitter$1()));
            this._registrations.set(eventHandle, emitter);
            provider.onDidChangeInlineValues = emitter.event;
        }
        this._registrations.set(handle, this._languageFeaturesService.inlineValuesProvider.register(selector, provider));
    }
    $emitInlineValuesEvent(eventHandle, event) {
        const obj = this._registrations.get(eventHandle);
        if (obj instanceof Emitter$1) {
            obj.fire(event);
        }
    }
    $registerDocumentHighlightProvider(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.documentHighlightProvider.register(selector, {
            provideDocumentHighlights: (model, position, token) => {
                return this._proxy.$provideDocumentHighlights(handle, model.uri, position, token);
            }
        }));
    }
    $registerLinkedEditingRangeProvider(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.linkedEditingRangeProvider.register(selector, {
            provideLinkedEditingRanges: async (model, position, token) => {
                const res = await this._proxy.$provideLinkedEditingRanges(handle, model.uri, position, token);
                if (res) {
                    return {
                        ranges: res.ranges,
                        wordPattern: res.wordPattern ? MainThreadLanguageFeatures_1._reviveRegExp(res.wordPattern) : undefined
                    };
                }
                return undefined;
            }
        }));
    }
    $registerReferenceSupport(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.referenceProvider.register(selector, {
            provideReferences: (model, position, context, token) => {
                return this._proxy.$provideReferences(handle, model.uri, position, context, token).then(MainThreadLanguageFeatures_1._reviveLocationDto);
            }
        }));
    }
    $registerQuickFixSupport(handle, selector, metadata, displayName, supportsResolve) {
        const provider = {
            provideCodeActions: async (model, rangeOrSelection, context, token) => {
                const listDto = await this._proxy.$provideCodeActions(handle, model.uri, rangeOrSelection, context, token);
                if (!listDto) {
                    return undefined;
                }
                return {
                    actions: MainThreadLanguageFeatures_1._reviveCodeActionDto(listDto.actions, this._uriIdentService),
                    dispose: () => {
                        if (typeof listDto.cacheId === 'number') {
                            this._proxy.$releaseCodeActions(handle, listDto.cacheId);
                        }
                    }
                };
            },
            providedCodeActionKinds: metadata.providedKinds,
            documentation: metadata.documentation,
            displayName
        };
        if (supportsResolve) {
            provider.resolveCodeAction = async (codeAction, token) => {
                const data = await this._proxy.$resolveCodeAction(handle, codeAction.cacheId, token);
                codeAction.edit = reviveWorkspaceEditDto(data, this._uriIdentService);
                return codeAction;
            };
        }
        this._registrations.set(handle, this._languageFeaturesService.codeActionProvider.register(selector, provider));
    }
    $registerPasteEditProvider(handle, selector, supportsCopy, pasteMimeTypes) {
        const provider = ( (new MainThreadPasteEditProvider(handle, this._proxy, supportsCopy, pasteMimeTypes, this._uriIdentService)));
        this._pasteEditProviders.set(handle, provider);
        this._registrations.set(handle, combinedDisposable(this._languageFeaturesService.documentPasteEditProvider.register(selector, provider), toDisposable(() => this._pasteEditProviders.delete(handle))));
    }
    $resolvePasteFileData(handle, requestId, dataId) {
        const provider = this._pasteEditProviders.get(handle);
        if (!provider) {
            throw new Error('Could not find provider');
        }
        return provider.resolveFileData(requestId, dataId);
    }
    $registerDocumentFormattingSupport(handle, selector, extensionId, displayName) {
        this._registrations.set(handle, this._languageFeaturesService.documentFormattingEditProvider.register(selector, {
            extensionId,
            displayName,
            provideDocumentFormattingEdits: (model, options, token) => {
                return this._proxy.$provideDocumentFormattingEdits(handle, model.uri, options, token);
            }
        }));
    }
    $registerRangeFormattingSupport(handle, selector, extensionId, displayName) {
        this._registrations.set(handle, this._languageFeaturesService.documentRangeFormattingEditProvider.register(selector, {
            extensionId,
            displayName,
            provideDocumentRangeFormattingEdits: (model, range, options, token) => {
                return this._proxy.$provideDocumentRangeFormattingEdits(handle, model.uri, range, options, token);
            }
        }));
    }
    $registerOnTypeFormattingSupport(handle, selector, autoFormatTriggerCharacters, extensionId) {
        this._registrations.set(handle, this._languageFeaturesService.onTypeFormattingEditProvider.register(selector, {
            extensionId,
            autoFormatTriggerCharacters,
            provideOnTypeFormattingEdits: (model, position, ch, options, token) => {
                return this._proxy.$provideOnTypeFormattingEdits(handle, model.uri, position, ch, options, token);
            }
        }));
    }
    $registerNavigateTypeSupport(handle, supportsResolve) {
        let lastResultId;
        const provider = {
            provideWorkspaceSymbols: async (search, token) => {
                const result = await this._proxy.$provideWorkspaceSymbols(handle, search, token);
                if (lastResultId !== undefined) {
                    this._proxy.$releaseWorkspaceSymbols(handle, lastResultId);
                }
                lastResultId = result.cacheId;
                return MainThreadLanguageFeatures_1._reviveWorkspaceSymbolDto(result.symbols);
            }
        };
        if (supportsResolve) {
            provider.resolveWorkspaceSymbol = async (item, token) => {
                const resolvedItem = await this._proxy.$resolveWorkspaceSymbol(handle, item, token);
                return resolvedItem && MainThreadLanguageFeatures_1._reviveWorkspaceSymbolDto(resolvedItem);
            };
        }
        this._registrations.set(handle, WorkspaceSymbolProviderRegistry.register(provider));
    }
    $registerRenameSupport(handle, selector, supportResolveLocation) {
        this._registrations.set(handle, this._languageFeaturesService.renameProvider.register(selector, {
            provideRenameEdits: (model, position, newName, token) => {
                return this._proxy.$provideRenameEdits(handle, model.uri, position, newName, token).then(data => reviveWorkspaceEditDto(data, this._uriIdentService));
            },
            resolveRenameLocation: supportResolveLocation
                ? (model, position, token) => this._proxy.$resolveRenameLocation(handle, model.uri, position, token)
                : undefined
        }));
    }
    $registerDocumentSemanticTokensProvider(handle, selector, legend, eventHandle) {
        let event = undefined;
        if (typeof eventHandle === 'number') {
            const emitter = ( (new Emitter$1()));
            this._registrations.set(eventHandle, emitter);
            event = emitter.event;
        }
        this._registrations.set(handle, this._languageFeaturesService.documentSemanticTokensProvider.register(selector, ( (new MainThreadDocumentSemanticTokensProvider(this._proxy, handle, legend, event)))));
    }
    $emitDocumentSemanticTokensEvent(eventHandle) {
        const obj = this._registrations.get(eventHandle);
        if (obj instanceof Emitter$1) {
            obj.fire(undefined);
        }
    }
    $registerDocumentRangeSemanticTokensProvider(handle, selector, legend) {
        this._registrations.set(handle, this._languageFeaturesService.documentRangeSemanticTokensProvider.register(selector, ( (new MainThreadDocumentRangeSemanticTokensProvider(this._proxy, handle, legend)))));
    }
    static _inflateSuggestDto(defaultRange, data) {
        const label = data["a" ];
        const commandId = data["o" ];
        const commandIdent = data["n" ];
        const commitChars = data["k" ];
        return {
            label,
            kind: data["b" ] ?? 9 ,
            tags: data["m" ],
            detail: data["c" ],
            documentation: data["d" ],
            sortText: data["e" ],
            filterText: data["f" ],
            preselect: data["g" ],
            insertText: data["h" ] ?? (typeof label === 'string' ? label : label.label),
            range: data["j" ] ?? defaultRange,
            insertTextRules: data["i" ],
            commitCharacters: commitChars ? Array.from(commitChars) : undefined,
            additionalTextEdits: data["l" ],
            command: commandId ? {
                $ident: commandIdent,
                id: commandId,
                title: '',
                arguments: commandIdent ? [commandIdent] : data["p" ],
            } : undefined,
            _id: data.x,
        };
    }
    $registerCompletionsProvider(handle, selector, triggerCharacters, supportsResolveDetails, displayName) {
        const provider = {
            triggerCharacters,
            _debugDisplayName: displayName,
            provideCompletionItems: async (model, position, context, token) => {
                const result = await this._proxy.$provideCompletionItems(handle, model.uri, position, context, token);
                if (!result) {
                    return result;
                }
                return {
                    suggestions: ( (result["b" ].map(
                        d => MainThreadLanguageFeatures_1._inflateSuggestDto(result["a" ], d)
                    ))),
                    incomplete: result["c" ] || false,
                    duration: result["d" ],
                    dispose: () => {
                        if (typeof result.x === 'number') {
                            this._proxy.$releaseCompletionItems(handle, result.x);
                        }
                    }
                };
            }
        };
        if (supportsResolveDetails) {
            provider.resolveCompletionItem = (suggestion, token) => {
                return this._proxy.$resolveCompletionItem(handle, suggestion._id, token).then(result => {
                    if (!result) {
                        return suggestion;
                    }
                    const newSuggestion = MainThreadLanguageFeatures_1._inflateSuggestDto(suggestion.range, result);
                    return mixin(suggestion, newSuggestion, true);
                });
            };
        }
        this._registrations.set(handle, this._languageFeaturesService.completionProvider.register(selector, provider));
    }
    $registerInlineCompletionsSupport(handle, selector, supportsHandleEvents) {
        const provider = {
            provideInlineCompletions: async (model, position, context, token) => {
                return this._proxy.$provideInlineCompletions(handle, model.uri, position, context, token);
            },
            handleItemDidShow: async (completions, item) => {
                if (supportsHandleEvents) {
                    await this._proxy.$handleInlineCompletionDidShow(handle, completions.pid, item.idx);
                }
            },
            handlePartialAccept: async (completions, item, acceptedCharacters) => {
                if (supportsHandleEvents) {
                    await this._proxy.$handleInlineCompletionPartialAccept(handle, completions.pid, item.idx, acceptedCharacters);
                }
            },
            freeInlineCompletions: (completions) => {
                this._proxy.$freeInlineCompletionsList(handle, completions.pid);
            }
        };
        this._registrations.set(handle, this._languageFeaturesService.inlineCompletionsProvider.register(selector, provider));
    }
    $registerSignatureHelpProvider(handle, selector, metadata) {
        this._registrations.set(handle, this._languageFeaturesService.signatureHelpProvider.register(selector, {
            signatureHelpTriggerCharacters: metadata.triggerCharacters,
            signatureHelpRetriggerCharacters: metadata.retriggerCharacters,
            provideSignatureHelp: async (model, position, token, context) => {
                const result = await this._proxy.$provideSignatureHelp(handle, model.uri, position, context, token);
                if (!result) {
                    return undefined;
                }
                return {
                    value: result,
                    dispose: () => {
                        this._proxy.$releaseSignatureHelp(handle, result.id);
                    }
                };
            }
        }));
    }
    $registerInlayHintsProvider(handle, selector, supportsResolve, eventHandle, displayName) {
        const provider = {
            displayName,
            provideInlayHints: async (model, range, token) => {
                const result = await this._proxy.$provideInlayHints(handle, model.uri, range, token);
                if (!result) {
                    return;
                }
                return {
                    hints: revive(result.hints),
                    dispose: () => {
                        if (result.cacheId) {
                            this._proxy.$releaseInlayHints(handle, result.cacheId);
                        }
                    }
                };
            }
        };
        if (supportsResolve) {
            provider.resolveInlayHint = async (hint, token) => {
                const dto = hint;
                if (!dto.cacheId) {
                    return hint;
                }
                const result = await this._proxy.$resolveInlayHint(handle, dto.cacheId, token);
                if (token.isCancellationRequested) {
                    throw new CancellationError$1();
                }
                if (!result) {
                    return hint;
                }
                return {
                    ...hint,
                    tooltip: result.tooltip,
                    label: revive(result.label)
                };
            };
        }
        if (typeof eventHandle === 'number') {
            const emitter = ( (new Emitter$1()));
            this._registrations.set(eventHandle, emitter);
            provider.onDidChangeInlayHints = emitter.event;
        }
        this._registrations.set(handle, this._languageFeaturesService.inlayHintsProvider.register(selector, provider));
    }
    $emitInlayHintsEvent(eventHandle) {
        const obj = this._registrations.get(eventHandle);
        if (obj instanceof Emitter$1) {
            obj.fire(undefined);
        }
    }
    $registerDocumentLinkProvider(handle, selector, supportsResolve) {
        const provider = {
            provideLinks: (model, token) => {
                return this._proxy.$provideDocumentLinks(handle, model.uri, token).then(dto => {
                    if (!dto) {
                        return undefined;
                    }
                    return {
                        links: ( (dto.links.map(MainThreadLanguageFeatures_1._reviveLinkDTO))),
                        dispose: () => {
                            if (typeof dto.cacheId === 'number') {
                                this._proxy.$releaseDocumentLinks(handle, dto.cacheId);
                            }
                        }
                    };
                });
            }
        };
        if (supportsResolve) {
            provider.resolveLink = (link, token) => {
                const dto = link;
                if (!dto.cacheId) {
                    return link;
                }
                return this._proxy.$resolveDocumentLink(handle, dto.cacheId, token).then(obj => {
                    return obj && MainThreadLanguageFeatures_1._reviveLinkDTO(obj);
                });
            };
        }
        this._registrations.set(handle, this._languageFeaturesService.linkProvider.register(selector, provider));
    }
    $registerDocumentColorProvider(handle, selector) {
        const proxy = this._proxy;
        this._registrations.set(handle, this._languageFeaturesService.colorProvider.register(selector, {
            provideDocumentColors: (model, token) => {
                return proxy.$provideDocumentColors(handle, model.uri, token)
                    .then(documentColors => {
                    return (
                         (documentColors.map(documentColor => {
                            const [red, green, blue, alpha] = documentColor.color;
                            const color = {
                                red: red,
                                green: green,
                                blue: blue,
                                alpha
                            };
                            return {
                                color,
                                range: documentColor.range
                            };
                        }))
                    );
                });
            },
            provideColorPresentations: (model, colorInfo, token) => {
                return proxy.$provideColorPresentations(handle, model.uri, {
                    color: [colorInfo.color.red, colorInfo.color.green, colorInfo.color.blue, colorInfo.color.alpha],
                    range: colorInfo.range
                }, token);
            }
        }));
    }
    $registerFoldingRangeProvider(handle, selector, extensionId, eventHandle) {
        const provider = {
            id: extensionId.value,
            provideFoldingRanges: (model, context, token) => {
                return this._proxy.$provideFoldingRanges(handle, model.uri, context, token);
            }
        };
        if (typeof eventHandle === 'number') {
            const emitter = ( (new Emitter$1()));
            this._registrations.set(eventHandle, emitter);
            provider.onDidChange = emitter.event;
        }
        this._registrations.set(handle, this._languageFeaturesService.foldingRangeProvider.register(selector, provider));
    }
    $emitFoldingRangeEvent(eventHandle, event) {
        const obj = this._registrations.get(eventHandle);
        if (obj instanceof Emitter$1) {
            obj.fire(event);
        }
    }
    $registerSelectionRangeProvider(handle, selector) {
        this._registrations.set(handle, this._languageFeaturesService.selectionRangeProvider.register(selector, {
            provideSelectionRanges: (model, positions, token) => {
                return this._proxy.$provideSelectionRanges(handle, model.uri, positions, token);
            }
        }));
    }
    $registerCallHierarchyProvider(handle, selector) {
        this._registrations.set(handle, CallHierarchyProviderRegistry.register(selector, {
            prepareCallHierarchy: async (document, position, token) => {
                const items = await this._proxy.$prepareCallHierarchy(handle, document.uri, position, token);
                if (!items || items.length === 0) {
                    return undefined;
                }
                return {
                    dispose: () => {
                        for (const item of items) {
                            this._proxy.$releaseCallHierarchy(handle, item._sessionId);
                        }
                    },
                    roots: ( (items.map(MainThreadLanguageFeatures_1._reviveCallHierarchyItemDto)))
                };
            },
            provideOutgoingCalls: async (item, token) => {
                const outgoing = await this._proxy.$provideCallHierarchyOutgoingCalls(handle, item._sessionId, item._itemId, token);
                if (!outgoing) {
                    return outgoing;
                }
                outgoing.forEach(value => {
                    value.to = MainThreadLanguageFeatures_1._reviveCallHierarchyItemDto(value.to);
                });
                return outgoing;
            },
            provideIncomingCalls: async (item, token) => {
                const incoming = await this._proxy.$provideCallHierarchyIncomingCalls(handle, item._sessionId, item._itemId, token);
                if (!incoming) {
                    return incoming;
                }
                incoming.forEach(value => {
                    value.from = MainThreadLanguageFeatures_1._reviveCallHierarchyItemDto(value.from);
                });
                return incoming;
            }
        }));
    }
    static _reviveRegExp(regExp) {
        return (
             (new RegExp(regExp.pattern, regExp.flags))
        );
    }
    static _reviveIndentationRule(indentationRule) {
        return {
            decreaseIndentPattern: MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.decreaseIndentPattern),
            increaseIndentPattern: MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.increaseIndentPattern),
            indentNextLinePattern: indentationRule.indentNextLinePattern ? MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.indentNextLinePattern) : undefined,
            unIndentedLinePattern: indentationRule.unIndentedLinePattern ? MainThreadLanguageFeatures_1._reviveRegExp(indentationRule.unIndentedLinePattern) : undefined,
        };
    }
    static _reviveOnEnterRule(onEnterRule) {
        return {
            beforeText: MainThreadLanguageFeatures_1._reviveRegExp(onEnterRule.beforeText),
            afterText: onEnterRule.afterText ? MainThreadLanguageFeatures_1._reviveRegExp(onEnterRule.afterText) : undefined,
            previousLineText: onEnterRule.previousLineText ? MainThreadLanguageFeatures_1._reviveRegExp(onEnterRule.previousLineText) : undefined,
            action: onEnterRule.action
        };
    }
    static _reviveOnEnterRules(onEnterRules) {
        return (
             (onEnterRules.map(MainThreadLanguageFeatures_1._reviveOnEnterRule))
        );
    }
    $setLanguageConfiguration(handle, languageId, _configuration) {
        const configuration = {
            comments: _configuration.comments,
            brackets: _configuration.brackets,
            wordPattern: _configuration.wordPattern ? MainThreadLanguageFeatures_1._reviveRegExp(_configuration.wordPattern) : undefined,
            indentationRules: _configuration.indentationRules ? MainThreadLanguageFeatures_1._reviveIndentationRule(_configuration.indentationRules) : undefined,
            onEnterRules: _configuration.onEnterRules ? MainThreadLanguageFeatures_1._reviveOnEnterRules(_configuration.onEnterRules) : undefined,
            autoClosingPairs: undefined,
            surroundingPairs: undefined,
            __electricCharacterSupport: undefined
        };
        if (_configuration.__characterPairSupport) {
            configuration.autoClosingPairs = _configuration.__characterPairSupport.autoClosingPairs;
        }
        if (_configuration.__electricCharacterSupport && _configuration.__electricCharacterSupport.docComment) {
            configuration.__electricCharacterSupport = {
                docComment: {
                    open: _configuration.__electricCharacterSupport.docComment.open,
                    close: _configuration.__electricCharacterSupport.docComment.close
                }
            };
        }
        if (this._languageService.isRegisteredLanguageId(languageId)) {
            this._registrations.set(handle, this._languageConfigurationService.register(languageId, configuration, 100));
        }
    }
    $registerTypeHierarchyProvider(handle, selector) {
        this._registrations.set(handle, TypeHierarchyProviderRegistry.register(selector, {
            prepareTypeHierarchy: async (document, position, token) => {
                const items = await this._proxy.$prepareTypeHierarchy(handle, document.uri, position, token);
                if (!items) {
                    return undefined;
                }
                return {
                    dispose: () => {
                        for (const item of items) {
                            this._proxy.$releaseTypeHierarchy(handle, item._sessionId);
                        }
                    },
                    roots: ( (items.map(MainThreadLanguageFeatures_1._reviveTypeHierarchyItemDto)))
                };
            },
            provideSupertypes: async (item, token) => {
                const supertypes = await this._proxy.$provideTypeHierarchySupertypes(handle, item._sessionId, item._itemId, token);
                if (!supertypes) {
                    return supertypes;
                }
                return (
                     (supertypes.map(MainThreadLanguageFeatures_1._reviveTypeHierarchyItemDto))
                );
            },
            provideSubtypes: async (item, token) => {
                const subtypes = await this._proxy.$provideTypeHierarchySubtypes(handle, item._sessionId, item._itemId, token);
                if (!subtypes) {
                    return subtypes;
                }
                return (
                     (subtypes.map(MainThreadLanguageFeatures_1._reviveTypeHierarchyItemDto))
                );
            }
        }));
    }
    $registerDocumentOnDropEditProvider(handle, selector) {
        const provider = ( (new MainThreadDocumentOnDropEditProvider(handle, this._proxy, this._uriIdentService)));
        this._documentOnDropEditProviders.set(handle, provider);
        this._registrations.set(handle, combinedDisposable(this._languageFeaturesService.documentOnDropEditProvider.register(selector, provider), toDisposable(() => this._documentOnDropEditProviders.delete(handle))));
    }
    async $resolveDocumentOnDropFileData(handle, requestId, dataId) {
        const provider = this._documentOnDropEditProviders.get(handle);
        if (!provider) {
            throw new Error('Could not find provider');
        }
        return provider.resolveDocumentOnDropFileData(requestId, dataId);
    }
};
MainThreadLanguageFeatures = MainThreadLanguageFeatures_1 = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadLanguageFeatures),
    ( (__param(1, ILanguageService))),
    ( (__param(2, ILanguageConfigurationService))),
    ( (__param(3, ILanguageFeaturesService))),
    ( (__param(4, IUriIdentityService)))
], MainThreadLanguageFeatures)));
let MainThreadPasteEditProvider = class MainThreadPasteEditProvider {
    constructor(handle, _proxy, supportsCopy, pasteMimeTypes, _uriIdentService) {
        this.handle = handle;
        this._proxy = _proxy;
        this._uriIdentService = _uriIdentService;
        this.dataTransfers = ( (new DataTransferCache()));
        this.pasteMimeTypes = pasteMimeTypes;
        if (supportsCopy) {
            this.prepareDocumentPaste = async (model, selections, dataTransfer, token) => {
                const dataTransferDto = await DataTransfer$1.toDataTransferDTO(dataTransfer);
                if (token.isCancellationRequested) {
                    return undefined;
                }
                const result = await this._proxy.$prepareDocumentPaste(handle, model.uri, selections, dataTransferDto, token);
                if (!result) {
                    return undefined;
                }
                const dataTransferOut = ( (new VSDataTransfer()));
                result.items.forEach(([type, item]) => {
                    dataTransferOut.replace(type, createStringDataTransferItem(item.asString));
                });
                return dataTransferOut;
            };
        }
    }
    async provideDocumentPasteEdits(model, selections, dataTransfer, token) {
        const request = this.dataTransfers.add(dataTransfer);
        try {
            const d = await DataTransfer$1.toDataTransferDTO(dataTransfer);
            const result = await this._proxy.$providePasteEdits(this.handle, request.id, model.uri, selections, d, token);
            if (!result) {
                return undefined;
            }
            return {
                insertText: result.insertText,
                additionalEdit: result.additionalEdit ? reviveWorkspaceEditDto(result.additionalEdit, this._uriIdentService) : undefined,
            };
        }
        finally {
            request.dispose();
        }
    }
    resolveFileData(requestId, dataId) {
        return this.dataTransfers.resolveDropFileData(requestId, dataId);
    }
};
MainThreadPasteEditProvider = ( (__decorate([
    ( (__param(4, IUriIdentityService)))
], MainThreadPasteEditProvider)));
let MainThreadDocumentOnDropEditProvider = class MainThreadDocumentOnDropEditProvider {
    constructor(handle, _proxy, _uriIdentService) {
        this.handle = handle;
        this._proxy = _proxy;
        this._uriIdentService = _uriIdentService;
        this.dataTransfers = ( (new DataTransferCache()));
    }
    async provideDocumentOnDropEdits(model, position, dataTransfer, token) {
        const request = this.dataTransfers.add(dataTransfer);
        try {
            const dataTransferDto = await DataTransfer$1.toDataTransferDTO(dataTransfer);
            const edit = await this._proxy.$provideDocumentOnDropEdits(this.handle, request.id, model.uri, position, dataTransferDto, token);
            if (!edit) {
                return undefined;
            }
            return {
                insertText: edit.insertText,
                additionalEdit: reviveWorkspaceEditDto(edit.additionalEdit, this._uriIdentService),
            };
        }
        finally {
            request.dispose();
        }
    }
    resolveDocumentOnDropFileData(requestId, dataId) {
        return this.dataTransfers.resolveDropFileData(requestId, dataId);
    }
};
MainThreadDocumentOnDropEditProvider = ( (__decorate([
    ( (__param(2, IUriIdentityService)))
], MainThreadDocumentOnDropEditProvider)));
class MainThreadDocumentSemanticTokensProvider {
    constructor(_proxy, _handle, _legend, onDidChange) {
        this._proxy = _proxy;
        this._handle = _handle;
        this._legend = _legend;
        this.onDidChange = onDidChange;
    }
    releaseDocumentSemanticTokens(resultId) {
        if (resultId) {
            this._proxy.$releaseDocumentSemanticTokens(this._handle, parseInt(resultId, 10));
        }
    }
    getLegend() {
        return this._legend;
    }
    async provideDocumentSemanticTokens(model, lastResultId, token) {
        const nLastResultId = lastResultId ? parseInt(lastResultId, 10) : 0;
        const encodedDto = await this._proxy.$provideDocumentSemanticTokens(this._handle, model.uri, nLastResultId, token);
        if (!encodedDto) {
            return null;
        }
        if (token.isCancellationRequested) {
            return null;
        }
        const dto = decodeSemanticTokensDto(encodedDto);
        if (dto.type === 'full') {
            return {
                resultId: String(dto.id),
                data: dto.data
            };
        }
        return {
            resultId: String(dto.id),
            edits: dto.deltas
        };
    }
}
class MainThreadDocumentRangeSemanticTokensProvider {
    constructor(_proxy, _handle, _legend) {
        this._proxy = _proxy;
        this._handle = _handle;
        this._legend = _legend;
    }
    getLegend() {
        return this._legend;
    }
    async provideDocumentRangeSemanticTokens(model, range, token) {
        const encodedDto = await this._proxy.$provideDocumentRangeSemanticTokens(this._handle, model.uri, range, token);
        if (!encodedDto) {
            return null;
        }
        if (token.isCancellationRequested) {
            return null;
        }
        const dto = decodeSemanticTokensDto(encodedDto);
        if (dto.type === 'full') {
            return {
                resultId: String(dto.id),
                data: dto.data
            };
        }
        throw new Error(`Unexpected`);
    }
}
function lookUp(tree, key) {
    if (key) {
        const parts = key.split('.');
        let node = tree;
        for (let i = 0; node && i < parts.length; i++) {
            node = node[parts[i]];
        }
        return node;
    }
}
function isUri(thing) {
    return thing instanceof URI;
}
function isResourceLanguage(thing) {
    return thing
        && thing.uri instanceof URI
        && (thing.languageId && typeof thing.languageId === 'string');
}
function isLanguage(thing) {
    return thing
        && !thing.uri
        && (thing.languageId && typeof thing.languageId === 'string');
}
function isWorkspaceFolder(thing) {
    return thing
        && thing.uri instanceof URI
        && (!thing.name || typeof thing.name === 'string')
        && (!thing.index || typeof thing.index === 'number');
}
function scopeToOverrides(scope) {
    if (isUri(scope)) {
        return { resource: scope };
    }
    if (isResourceLanguage(scope)) {
        return { resource: scope.uri, overrideIdentifier: scope.languageId };
    }
    if (isLanguage(scope)) {
        return { overrideIdentifier: scope.languageId };
    }
    if (isWorkspaceFolder(scope)) {
        return { resource: scope.uri };
    }
    if (scope === null) {
        return { resource: null };
    }
    return undefined;
}
let ExtHostConfiguration = class ExtHostConfiguration {
    constructor(extHostRpc, extHostWorkspace, logService) {
        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadConfiguration)));
        this._extHostWorkspace = extHostWorkspace;
        this._logService = logService;
        this._barrier = ( (new Barrier()));
        this._actual = null;
    }
    getConfigProvider() {
        return this._barrier.wait().then(_ => this._actual);
    }
    $initializeConfiguration(data) {
        this._actual = ( (new ExtHostConfigProvider(this._proxy, this._extHostWorkspace, data, this._logService)));
        this._barrier.open();
    }
    $acceptConfigurationChanged(data, change) {
        this.getConfigProvider().then(provider => provider.$acceptConfigurationChanged(data, change));
    }
};
ExtHostConfiguration = ( (__decorate([
    ( (__param(0, IExtHostRpcService))),
    ( (__param(1, IExtHostWorkspace))),
    ( (__param(2, ILogService)))
], ExtHostConfiguration)));
class ExtHostConfigProvider {
    constructor(proxy, extHostWorkspace, data, logService) {
        this._onDidChangeConfiguration = ( (new Emitter$1()));
        this._proxy = proxy;
        this._logService = logService;
        this._extHostWorkspace = extHostWorkspace;
        this._configuration = Configuration.parse(data);
        this._configurationScopes = this._toMap(data.configurationScopes);
    }
    get onDidChangeConfiguration() {
        return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event;
    }
    $acceptConfigurationChanged(data, change) {
        const previous = { data: this._configuration.toData(), workspace: this._extHostWorkspace.workspace };
        this._configuration = Configuration.parse(data);
        this._configurationScopes = this._toMap(data.configurationScopes);
        this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(change, previous));
    }
    getConfiguration(section, scope, extensionDescription) {
        const overrides = scopeToOverrides(scope) || {};
        const config = this._toReadonlyValue(section
            ? lookUp(this._configuration.getValue(undefined, overrides, this._extHostWorkspace.workspace), section)
            : this._configuration.getValue(undefined, overrides, this._extHostWorkspace.workspace));
        if (section) {
            this._validateConfigurationAccess(section, overrides, extensionDescription?.identifier);
        }
        function parseConfigurationTarget(arg) {
            if (arg === undefined || arg === null) {
                return null;
            }
            if (typeof arg === 'boolean') {
                return arg ? 2  : 5 ;
            }
            switch (arg) {
                case ConfigurationTarget$1.Global: return 2 ;
                case ConfigurationTarget$1.Workspace: return 5 ;
                case ConfigurationTarget$1.WorkspaceFolder: return 6 ;
            }
        }
        const result = {
            has(key) {
                return typeof lookUp(config, key) !== 'undefined';
            },
            get: (key, defaultValue) => {
                this._validateConfigurationAccess(section ? `${section}.${key}` : key, overrides, extensionDescription?.identifier);
                let result = lookUp(config, key);
                if (typeof result === 'undefined') {
                    result = defaultValue;
                }
                else {
                    let clonedConfig = undefined;
                    const cloneOnWriteProxy = (target, accessor) => {
                        let clonedTarget = undefined;
                        const cloneTarget = () => {
                            clonedConfig = clonedConfig ? clonedConfig : deepClone(config);
                            clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
                        };
                        return isObject(target) ?
                            ( (new Proxy(target, {
                                get: (target, property) => {
                                    if (typeof property === 'string' && property.toLowerCase() === 'tojson') {
                                        cloneTarget();
                                        return () => clonedTarget;
                                    }
                                    if (clonedConfig) {
                                        clonedTarget = clonedTarget ? clonedTarget : lookUp(clonedConfig, accessor);
                                        return clonedTarget[property];
                                    }
                                    const result = target[property];
                                    if (typeof property === 'string') {
                                        return cloneOnWriteProxy(result, `${accessor}.${property}`);
                                    }
                                    return result;
                                },
                                set: (_target, property, value) => {
                                    cloneTarget();
                                    if (clonedTarget) {
                                        clonedTarget[property] = value;
                                    }
                                    return true;
                                },
                                deleteProperty: (_target, property) => {
                                    cloneTarget();
                                    if (clonedTarget) {
                                        delete clonedTarget[property];
                                    }
                                    return true;
                                },
                                defineProperty: (_target, property, descriptor) => {
                                    cloneTarget();
                                    if (clonedTarget) {
                                        Object.defineProperty(clonedTarget, property, descriptor);
                                    }
                                    return true;
                                }
                            }))) : target;
                    };
                    result = cloneOnWriteProxy(result, key);
                }
                return result;
            },
            update: (key, value, extHostConfigurationTarget, scopeToLanguage) => {
                key = section ? `${section}.${key}` : key;
                const target = parseConfigurationTarget(extHostConfigurationTarget);
                if (value !== undefined) {
                    return this._proxy.$updateConfigurationOption(target, key, value, overrides, scopeToLanguage);
                }
                else {
                    return this._proxy.$removeConfigurationOption(target, key, overrides, scopeToLanguage);
                }
            },
            inspect: (key) => {
                key = section ? `${section}.${key}` : key;
                const config = this._configuration.inspect(key, overrides, this._extHostWorkspace.workspace);
                if (config) {
                    return {
                        key,
                        defaultValue: deepClone(config.policy?.value ?? config.default?.value),
                        globalValue: deepClone(config.user?.value ?? config.application?.value),
                        workspaceValue: deepClone(config.workspace?.value),
                        workspaceFolderValue: deepClone(config.workspaceFolder?.value),
                        defaultLanguageValue: deepClone(config.default?.override),
                        globalLanguageValue: deepClone(config.user?.override ?? config.application?.override),
                        workspaceLanguageValue: deepClone(config.workspace?.override),
                        workspaceFolderLanguageValue: deepClone(config.workspaceFolder?.override),
                        languageIds: deepClone(config.overrideIdentifiers)
                    };
                }
                return undefined;
            }
        };
        if (typeof config === 'object') {
            mixin(result, config, false);
        }
        return (
             (Object.freeze(result))
        );
    }
    _toReadonlyValue(result) {
        const readonlyProxy = (target) => {
            return isObject(target) ?
                ( (new Proxy(target, {
                    get: (target, property) => readonlyProxy(target[property]),
                    set: (_target, property, _value) => { throw new Error(`TypeError: Cannot assign to read only property '${String(property)}' of object`); },
                    deleteProperty: (_target, property) => { throw new Error(`TypeError: Cannot delete read only property '${String(property)}' of object`); },
                    defineProperty: (_target, property) => { throw new Error(`TypeError: Cannot define property '${String(property)}' for a readonly object`); },
                    setPrototypeOf: (_target) => { throw new Error(`TypeError: Cannot set prototype for a readonly object`); },
                    isExtensible: () => false,
                    preventExtensions: () => true
                }))) : target;
        };
        return readonlyProxy(result);
    }
    _validateConfigurationAccess(key, overrides, extensionId) {
        const scope = OVERRIDE_PROPERTY_REGEX.test(key) ? 4  : this._configurationScopes.get(key);
        const extensionIdText = extensionId ? `[${extensionId.value}] ` : '';
        if (4  === scope) {
            if (typeof overrides?.resource === 'undefined') {
                this._logService.warn(`${extensionIdText}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${key}', provide the URI of a resource or 'null' for any resource.`);
            }
            return;
        }
        if (3  === scope) {
            if (overrides?.resource) {
                this._logService.warn(`${extensionIdText}Accessing a window scoped configuration for a resource is not expected. To associate '${key}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`);
            }
            return;
        }
    }
    _toConfigurationChangeEvent(change, previous) {
        const event = ( (new ConfigurationChangeEvent(change, previous, this._configuration, this._extHostWorkspace.workspace)));
        return (
             (Object.freeze({
                affectsConfiguration: (section, scope) => event.affectsConfiguration(section, scopeToOverrides(scope))
            }))
        );
    }
    _toMap(scopes) {
        return scopes.reduce((result, scope) => { result.set(scope[0], scope[1]); return result; }, ( (new Map())));
    }
}
const IExtHostConfiguration = ( (createDecorator$1('IExtHostConfiguration')));
let MainThreadConfiguration = class MainThreadConfiguration {
    constructor(extHostContext, _workspaceContextService, configurationService, _environmentService) {
        this._workspaceContextService = _workspaceContextService;
        this.configurationService = configurationService;
        this._environmentService = _environmentService;
        const proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostConfiguration)));
        proxy.$initializeConfiguration(this._getConfigurationData());
        this._configurationListener = configurationService.onDidChangeConfiguration(e => {
            proxy.$acceptConfigurationChanged(this._getConfigurationData(), e.change);
        });
    }
    _getConfigurationData() {
        const configurationData = { ...(this.configurationService.getConfigurationData()), configurationScopes: [] };
        if (!this._environmentService.isBuilt || this._environmentService.isExtensionDevelopment) {
            configurationData.configurationScopes = getScopes();
        }
        return configurationData;
    }
    dispose() {
        this._configurationListener.dispose();
    }
    $updateConfigurationOption(target, key, value, overrides, scopeToLanguage) {
        overrides = { resource: overrides?.resource ? URI.revive(overrides.resource) : undefined, overrideIdentifier: overrides?.overrideIdentifier };
        return this.writeConfiguration(target, key, value, overrides, scopeToLanguage);
    }
    $removeConfigurationOption(target, key, overrides, scopeToLanguage) {
        overrides = { resource: overrides?.resource ? URI.revive(overrides.resource) : undefined, overrideIdentifier: overrides?.overrideIdentifier };
        return this.writeConfiguration(target, key, undefined, overrides, scopeToLanguage);
    }
    writeConfiguration(target, key, value, overrides, scopeToLanguage) {
        target = target !== null && target !== undefined ? target : this.deriveConfigurationTarget(key, overrides);
        const configurationValue = this.configurationService.inspect(key, overrides);
        switch (target) {
            case 8 :
                return this._updateValue(key, value, target, configurationValue?.memory?.override, overrides, scopeToLanguage);
            case 6 :
                return this._updateValue(key, value, target, configurationValue?.workspaceFolder?.override, overrides, scopeToLanguage);
            case 5 :
                return this._updateValue(key, value, target, configurationValue?.workspace?.override, overrides, scopeToLanguage);
            case 4 :
                return this._updateValue(key, value, target, configurationValue?.userRemote?.override, overrides, scopeToLanguage);
            default:
                return this._updateValue(key, value, target, configurationValue?.userLocal?.override, overrides, scopeToLanguage);
        }
    }
    _updateValue(key, value, configurationTarget, overriddenValue, overrides, scopeToLanguage) {
        overrides = scopeToLanguage === true ? overrides
            : scopeToLanguage === false ? { resource: overrides.resource }
                : overrides.overrideIdentifier && overriddenValue !== undefined ? overrides
                    : { resource: overrides.resource };
        return this.configurationService.updateValue(key, value, overrides, configurationTarget, { donotNotifyError: true });
    }
    deriveConfigurationTarget(key, overrides) {
        if (overrides.resource && this._workspaceContextService.getWorkbenchState() === 3 ) {
            const configurationProperties = ( (Registry.as(Extensions.Configuration))).getConfigurationProperties();
            if (configurationProperties[key] && ((configurationProperties[key].scope === 4  || configurationProperties[key].scope === 5) )) {
                return 6 ;
            }
        }
        return 5 ;
    }
};
MainThreadConfiguration = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadConfiguration),
    ( (__param(1, IWorkspaceContextService))),
    ( (__param(2, IConfigurationService))),
    ( (__param(3, IEnvironmentService)))
], MainThreadConfiguration)));
const IExtHostEditorTabs = ( (createDecorator$1('IExtHostEditorTabs')));
class ExtHostEditorTab {
    constructor(dto, parentGroup, activeTabIdGetter) {
        this._activeTabIdGetter = activeTabIdGetter;
        this._parentGroup = parentGroup;
        this.acceptDtoUpdate(dto);
    }
    get apiObject() {
        if (!this._apiObject) {
            const that = this;
            const obj = {
                get isActive() {
                    return that._dto.id === that._activeTabIdGetter();
                },
                get label() {
                    return that._dto.label;
                },
                get input() {
                    return that._input;
                },
                get isDirty() {
                    return that._dto.isDirty;
                },
                get isPinned() {
                    return that._dto.isPinned;
                },
                get isPreview() {
                    return that._dto.isPreview;
                },
                get group() {
                    return that._parentGroup.apiObject;
                }
            };
            this._apiObject = ( (Object.freeze(obj)));
        }
        return this._apiObject;
    }
    get tabId() {
        return this._dto.id;
    }
    acceptDtoUpdate(dto) {
        this._dto = dto;
        this._input = this._initInput();
    }
    _initInput() {
        switch (this._dto.input.kind) {
            case 1 :
                return (
                     (new TextTabInput$1(URI.revive(this._dto.input.uri)))
                );
            case 2 :
                return (
                     (new TextDiffTabInput(URI.revive(this._dto.input.original), URI.revive(this._dto.input.modified)))
                );
            case 3 :
                return (
                     (new TextMergeTabInput(
                        URI.revive(this._dto.input.base),
                        URI.revive(this._dto.input.input1),
                        URI.revive(this._dto.input.input2),
                        URI.revive(this._dto.input.result)
                    ))
                );
            case 6 :
                return (
                     (new CustomEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.viewType))
                );
            case 7 :
                return (
                     (new WebviewEditorTabInput(this._dto.input.viewType))
                );
            case 4 :
                return (
                     (new NotebookEditorTabInput(URI.revive(this._dto.input.uri), this._dto.input.notebookType))
                );
            case 5 :
                return (
                     (new NotebookDiffEditorTabInput(
                        URI.revive(this._dto.input.original),
                        URI.revive(this._dto.input.modified),
                        this._dto.input.notebookType
                    ))
                );
            case 8 :
                return (
                     (new TerminalEditorTabInput())
                );
            case 9 :
                return (
                     (new InteractiveWindowInput(URI.revive(this._dto.input.uri), URI.revive(this._dto.input.inputBoxUri)))
                );
            default:
                return undefined;
        }
    }
}
class ExtHostEditorTabGroup {
    constructor(dto, activeGroupIdGetter) {
        this._tabs = [];
        this._activeTabId = '';
        this._dto = dto;
        this._activeGroupIdGetter = activeGroupIdGetter;
        for (const tabDto of dto.tabs) {
            if (tabDto.isActive) {
                this._activeTabId = tabDto.id;
            }
            this._tabs.push(( (new ExtHostEditorTab(tabDto, this, () => this.activeTabId()))));
        }
    }
    get apiObject() {
        if (!this._apiObject) {
            const that = this;
            const obj = {
                get isActive() {
                    return that._dto.groupId === that._activeGroupIdGetter();
                },
                get viewColumn() {
                    return ViewColumn$1.to(that._dto.viewColumn);
                },
                get activeTab() {
                    return that._tabs.find(tab => tab.tabId === that._activeTabId)?.apiObject;
                },
                get tabs() {
                    return (
                         (Object.freeze( (that._tabs.map(tab => tab.apiObject))))
                    );
                }
            };
            this._apiObject = ( (Object.freeze(obj)));
        }
        return this._apiObject;
    }
    get groupId() {
        return this._dto.groupId;
    }
    get tabs() {
        return this._tabs;
    }
    acceptGroupDtoUpdate(dto) {
        this._dto = dto;
    }
    acceptTabOperation(operation) {
        if (operation.kind === 0 ) {
            const tab = ( (new ExtHostEditorTab(operation.tabDto, this, () => this.activeTabId())));
            this._tabs.splice(operation.index, 0, tab);
            if (operation.tabDto.isActive) {
                this._activeTabId = tab.tabId;
            }
            return tab;
        }
        else if (operation.kind === 1 ) {
            const tab = this._tabs.splice(operation.index, 1)[0];
            if (!tab) {
                throw new Error(`Tab close updated received for index ${operation.index} which does not exist`);
            }
            if (tab.tabId === this._activeTabId) {
                this._activeTabId = '';
            }
            return tab;
        }
        else if (operation.kind === 3 ) {
            if (operation.oldIndex === undefined) {
                throw new Error('Invalid old index on move IPC');
            }
            const tab = this._tabs.splice(operation.oldIndex, 1)[0];
            if (!tab) {
                throw new Error(`Tab move updated received for index ${operation.oldIndex} which does not exist`);
            }
            this._tabs.splice(operation.index, 0, tab);
            return tab;
        }
        const tab = this._tabs.find(extHostTab => extHostTab.tabId === operation.tabDto.id);
        if (!tab) {
            throw new Error('INVALID tab');
        }
        if (operation.tabDto.isActive) {
            this._activeTabId = operation.tabDto.id;
        }
        else if (this._activeTabId === operation.tabDto.id && !operation.tabDto.isActive) {
            this._activeTabId = '';
        }
        tab.acceptDtoUpdate(operation.tabDto);
        return tab;
    }
    activeTabId() {
        return this._activeTabId;
    }
}
let ExtHostEditorTabs = class ExtHostEditorTabs {
    constructor(extHostRpc) {
        this._onDidChangeTabs = ( (new Emitter$1()));
        this._onDidChangeTabGroups = ( (new Emitter$1()));
        this._extHostTabGroups = [];
        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadEditorTabs)));
    }
    get tabGroups() {
        if (!this._apiObject) {
            const that = this;
            const obj = {
                onDidChangeTabGroups: that._onDidChangeTabGroups.event,
                onDidChangeTabs: that._onDidChangeTabs.event,
                get all() {
                    return (
                         (Object.freeze( (that._extHostTabGroups.map(group => group.apiObject))))
                    );
                },
                get activeTabGroup() {
                    const activeTabGroupId = that._activeGroupId;
                    const activeTabGroup = assertIsDefined(that._extHostTabGroups.find(candidate => candidate.groupId === activeTabGroupId)?.apiObject);
                    return activeTabGroup;
                },
                close: async (tabOrTabGroup, preserveFocus) => {
                    const tabsOrTabGroups = Array.isArray(tabOrTabGroup) ? tabOrTabGroup : [tabOrTabGroup];
                    if (!tabsOrTabGroups.length) {
                        return true;
                    }
                    if (isTabGroup(tabsOrTabGroups[0])) {
                        return this._closeGroups(tabsOrTabGroups, preserveFocus);
                    }
                    else {
                        return this._closeTabs(tabsOrTabGroups, preserveFocus);
                    }
                },
            };
            this._apiObject = ( (Object.freeze(obj)));
        }
        return this._apiObject;
    }
    $acceptEditorTabModel(tabGroups) {
        const groupIdsBefore = ( (new Set( (this._extHostTabGroups.map(group => group.groupId)))));
        const groupIdsAfter = ( (new Set( (tabGroups.map(dto => dto.groupId)))));
        const diff = diffSets(groupIdsBefore, groupIdsAfter);
        const closed = ( (this._extHostTabGroups.filter(group => diff.removed.includes(group.groupId)).map(group => group.apiObject)));
        const opened = [];
        const changed = [];
        this._extHostTabGroups = ( (tabGroups.map(tabGroup => {
            const group = ( (new ExtHostEditorTabGroup(tabGroup, () => this._activeGroupId)));
            if (diff.added.includes(group.groupId)) {
                opened.push(group.apiObject);
            }
            else {
                changed.push(group.apiObject);
            }
            return group;
        })));
        const activeTabGroupId = assertIsDefined(tabGroups.find(group => group.isActive === true)?.groupId);
        if (activeTabGroupId !== undefined && this._activeGroupId !== activeTabGroupId) {
            this._activeGroupId = activeTabGroupId;
        }
        this._onDidChangeTabGroups.fire(( (Object.freeze({ opened, closed, changed }))));
    }
    $acceptTabGroupUpdate(groupDto) {
        const group = this._extHostTabGroups.find(group => group.groupId === groupDto.groupId);
        if (!group) {
            throw new Error('Update Group IPC call received before group creation.');
        }
        group.acceptGroupDtoUpdate(groupDto);
        if (groupDto.isActive) {
            this._activeGroupId = groupDto.groupId;
        }
        this._onDidChangeTabGroups.fire(( (Object.freeze({ changed: [group.apiObject], opened: [], closed: [] }))));
    }
    $acceptTabOperation(operation) {
        const group = this._extHostTabGroups.find(group => group.groupId === operation.groupId);
        if (!group) {
            throw new Error('Update Tabs IPC call received before group creation.');
        }
        const tab = group.acceptTabOperation(operation);
        switch (operation.kind) {
            case 0 :
                this._onDidChangeTabs.fire(( (Object.freeze({
                    opened: [tab.apiObject],
                    closed: [],
                    changed: []
                }))));
                return;
            case 1 :
                this._onDidChangeTabs.fire(( (Object.freeze({
                    opened: [],
                    closed: [tab.apiObject],
                    changed: []
                }))));
                return;
            case 3 :
            case 2 :
                this._onDidChangeTabs.fire(( (Object.freeze({
                    opened: [],
                    closed: [],
                    changed: [tab.apiObject]
                }))));
                return;
        }
    }
    _findExtHostTabFromApi(apiTab) {
        for (const group of this._extHostTabGroups) {
            for (const tab of group.tabs) {
                if (tab.apiObject === apiTab) {
                    return tab;
                }
            }
        }
        return;
    }
    _findExtHostTabGroupFromApi(apiTabGroup) {
        return this._extHostTabGroups.find(candidate => candidate.apiObject === apiTabGroup);
    }
    async _closeTabs(tabs, preserveFocus) {
        const extHostTabIds = [];
        for (const tab of tabs) {
            const extHostTab = this._findExtHostTabFromApi(tab);
            if (!extHostTab) {
                throw new Error('Tab close: Invalid tab not found!');
            }
            extHostTabIds.push(extHostTab.tabId);
        }
        return this._proxy.$closeTab(extHostTabIds, preserveFocus);
    }
    async _closeGroups(groups, preserverFoucs) {
        const extHostGroupIds = [];
        for (const group of groups) {
            const extHostGroup = this._findExtHostTabGroupFromApi(group);
            if (!extHostGroup) {
                throw new Error('Group close: Invalid group not found!');
            }
            extHostGroupIds.push(extHostGroup.groupId);
        }
        return this._proxy.$closeGroup(extHostGroupIds, preserverFoucs);
    }
};
ExtHostEditorTabs = ( (__decorate([
    ( (__param(0, IExtHostRpcService)))
], ExtHostEditorTabs)));
function isTabGroup(obj) {
    const tabGroup = obj;
    if (tabGroup.tabs !== undefined) {
        return true;
    }
    return false;
}
class DeltaExtensionsResult {
    constructor(removedDueToLooping) {
        this.removedDueToLooping = removedDueToLooping;
    }
}
class ExtensionDescriptionRegistry {
    static isHostExtension(extensionId, myRegistry, globalRegistry) {
        if (myRegistry.getExtensionDescription(extensionId)) {
            return false;
        }
        const extensionDescription = globalRegistry.getExtensionDescription(extensionId);
        if (!extensionDescription) {
            return false;
        }
        if ((extensionDescription.main || extensionDescription.browser) && extensionDescription.api === 'none') {
            return true;
        }
        return false;
    }
    constructor(extensionDescriptions) {
        this._onDidChange = ( (new Emitter$1()));
        this.onDidChange = this._onDidChange.event;
        this._extensionDescriptions = extensionDescriptions;
        this._initialize();
    }
    _initialize() {
        this._extensionDescriptions.sort(extensionCmp);
        this._extensionsMap = ( (new Map()));
        this._extensionsArr = [];
        this._activationMap = ( (new Map()));
        for (const extensionDescription of this._extensionDescriptions) {
            if (this._extensionsMap.has(ExtensionIdentifier.toKey(extensionDescription.identifier))) {
                console.error('Extension `' + extensionDescription.identifier.value + '` is already registered');
                continue;
            }
            this._extensionsMap.set(ExtensionIdentifier.toKey(extensionDescription.identifier), extensionDescription);
            this._extensionsArr.push(extensionDescription);
            if (Array.isArray(extensionDescription.activationEvents)) {
                for (let activationEvent of extensionDescription.activationEvents) {
                    if (activationEvent === 'onUri') {
                        activationEvent = `onUri:${ExtensionIdentifier.toKey(extensionDescription.identifier)}`;
                    }
                    if (!this._activationMap.has(activationEvent)) {
                        this._activationMap.set(activationEvent, []);
                    }
                    this._activationMap.get(activationEvent).push(extensionDescription);
                }
            }
        }
    }
    set(extensionDescriptions) {
        this._extensionDescriptions = extensionDescriptions;
        this._initialize();
        this._onDidChange.fire(undefined);
    }
    deltaExtensions(toAdd, toRemove) {
        this._extensionDescriptions = removeExtensions(this._extensionDescriptions, toRemove);
        this._extensionDescriptions = this._extensionDescriptions.concat(toAdd);
        const looping = ExtensionDescriptionRegistry._findLoopingExtensions(this._extensionDescriptions);
        this._extensionDescriptions = removeExtensions(this._extensionDescriptions, ( (looping.map(ext => ext.identifier))));
        this._initialize();
        this._onDidChange.fire(undefined);
        return (
             (new DeltaExtensionsResult(looping))
        );
    }
    static _findLoopingExtensions(extensionDescriptions) {
        const G = new (class {
            constructor() {
                this._arcs = ( (new Map()));
                this._nodesSet = ( (new Set()));
                this._nodesArr = [];
            }
            addNode(id) {
                if (!this._nodesSet.has(id)) {
                    this._nodesSet.add(id);
                    this._nodesArr.push(id);
                }
            }
            addArc(from, to) {
                this.addNode(from);
                this.addNode(to);
                if (this._arcs.has(from)) {
                    this._arcs.get(from).push(to);
                }
                else {
                    this._arcs.set(from, [to]);
                }
            }
            getArcs(id) {
                if (this._arcs.has(id)) {
                    return this._arcs.get(id);
                }
                return [];
            }
            hasOnlyGoodArcs(id, good) {
                const dependencies = G.getArcs(id);
                for (let i = 0; i < dependencies.length; i++) {
                    if (!good.has(dependencies[i])) {
                        return false;
                    }
                }
                return true;
            }
            getNodes() {
                return this._nodesArr;
            }
        });
        const descs = ( (new Map()));
        for (const extensionDescription of extensionDescriptions) {
            const extensionId = ExtensionIdentifier.toKey(extensionDescription.identifier);
            descs.set(extensionId, extensionDescription);
            if (extensionDescription.extensionDependencies) {
                for (const _depId of extensionDescription.extensionDependencies) {
                    const depId = ExtensionIdentifier.toKey(_depId);
                    G.addArc(extensionId, depId);
                }
            }
        }
        const good = ( (new Set()));
        G.getNodes().filter(id => G.getArcs(id).length === 0).forEach(id => good.add(id));
        const nodes = G.getNodes().filter(id => !good.has(id));
        let madeProgress;
        do {
            madeProgress = false;
            for (let i = 0; i < nodes.length; i++) {
                const id = nodes[i];
                if (G.hasOnlyGoodArcs(id, good)) {
                    nodes.splice(i, 1);
                    i--;
                    good.add(id);
                    madeProgress = true;
                }
            }
        } while (madeProgress);
        return (
             (nodes.map(id => descs.get(id)))
        );
    }
    containsActivationEvent(activationEvent) {
        return this._activationMap.has(activationEvent);
    }
    containsExtension(extensionId) {
        return this._extensionsMap.has(ExtensionIdentifier.toKey(extensionId));
    }
    getExtensionDescriptionsForActivationEvent(activationEvent) {
        const extensions = this._activationMap.get(activationEvent);
        return extensions ? extensions.slice(0) : [];
    }
    getAllExtensionDescriptions() {
        return this._extensionsArr.slice(0);
    }
    getExtensionDescription(extensionId) {
        const extension = this._extensionsMap.get(ExtensionIdentifier.toKey(extensionId));
        return extension ? extension : undefined;
    }
    getExtensionDescriptionByUUID(uuid) {
        for (const extensionDescription of this._extensionsArr) {
            if (extensionDescription.uuid === uuid) {
                return extensionDescription;
            }
        }
        return undefined;
    }
    getExtensionDescriptionByIdOrUUID(extensionId, uuid) {
        return (this.getExtensionDescription(extensionId)
            ?? (uuid ? this.getExtensionDescriptionByUUID(uuid) : undefined));
    }
}
function extensionCmp(a, b) {
    const aSortBucket = ((a.isBuiltin ? 0  : a.isUnderDevelopment ? 2  : 1) );
    const bSortBucket = ((b.isBuiltin ? 0  : b.isUnderDevelopment ? 2  : 1) );
    if (aSortBucket !== bSortBucket) {
        return aSortBucket - bSortBucket;
    }
    const aLastSegment = posix.basename(a.extensionLocation.path);
    const bLastSegment = posix.basename(b.extensionLocation.path);
    if (aLastSegment < bLastSegment) {
        return -1;
    }
    if (aLastSegment > bLastSegment) {
        return 1;
    }
    return 0;
}
function removeExtensions(arr, toRemove) {
    const toRemoveSet = ( (new Set()));
    toRemove.forEach(extensionId => toRemoveSet.add(ExtensionIdentifier.toKey(extensionId)));
    return arr.filter(extension => !toRemoveSet.has(ExtensionIdentifier.toKey(extension.identifier)));
}
class ExtensionActivationTimes {
    constructor(startup, codeLoadingTime, activateCallTime, activateResolvedTime) {
        this.startup = startup;
        this.codeLoadingTime = codeLoadingTime;
        this.activateCallTime = activateCallTime;
        this.activateResolvedTime = activateResolvedTime;
    }
}
ExtensionActivationTimes.NONE = ( (new ExtensionActivationTimes(false, -1, -1, -1)));
class ExtensionActivationTimesBuilder {
    constructor(startup) {
        this._startup = startup;
        this._codeLoadingStart = -1;
        this._codeLoadingStop = -1;
        this._activateCallStart = -1;
        this._activateCallStop = -1;
        this._activateResolveStart = -1;
        this._activateResolveStop = -1;
    }
    _delta(start, stop) {
        if (start === -1 || stop === -1) {
            return -1;
        }
        return stop - start;
    }
    build() {
        return (
             (new ExtensionActivationTimes(
                this._startup,
                this._delta(this._codeLoadingStart, this._codeLoadingStop),
                this._delta(this._activateCallStart, this._activateCallStop),
                this._delta(this._activateResolveStart, this._activateResolveStop)
            ))
        );
    }
    codeLoadingStart() {
        this._codeLoadingStart = Date.now();
    }
    codeLoadingStop() {
        this._codeLoadingStop = Date.now();
    }
    activateCallStart() {
        this._activateCallStart = Date.now();
    }
    activateCallStop() {
        this._activateCallStop = Date.now();
    }
    activateResolveStart() {
        this._activateResolveStart = Date.now();
    }
    activateResolveStop() {
        this._activateResolveStop = Date.now();
    }
}
class ActivatedExtension {
    constructor(activationFailed, activationFailedError, activationTimes, module, exports, subscriptions) {
        this.activationFailed = activationFailed;
        this.activationFailedError = activationFailedError;
        this.activationTimes = activationTimes;
        this.module = module;
        this.exports = exports;
        this.subscriptions = subscriptions;
    }
}
class EmptyExtension extends ActivatedExtension {
    constructor(activationTimes) {
        super(false, null, activationTimes, { activate: undefined, deactivate: undefined }, undefined, []);
    }
}
class HostExtension extends ActivatedExtension {
    constructor() {
        super(false, null, ExtensionActivationTimes.NONE, { activate: undefined, deactivate: undefined }, undefined, []);
    }
}
class FailedExtension extends ActivatedExtension {
    constructor(activationError) {
        super(true, activationError, ExtensionActivationTimes.NONE, { activate: undefined, deactivate: undefined }, undefined, []);
    }
}
let ExtensionsActivator = class ExtensionsActivator {
    constructor(registry, globalRegistry, host, _logService) {
        this._logService = _logService;
        this._registry = registry;
        this._globalRegistry = globalRegistry;
        this._host = host;
        this._operations = ( (new Map()));
        this._alreadyActivatedEvents = Object.create(null);
    }
    dispose() {
        for (const [_, op] of this._operations) {
            op.dispose();
        }
    }
    isActivated(extensionId) {
        const op = this._operations.get(ExtensionIdentifier.toKey(extensionId));
        return Boolean(op && op.value);
    }
    getActivatedExtension(extensionId) {
        const op = this._operations.get(ExtensionIdentifier.toKey(extensionId));
        if (!op || !op.value) {
            throw new Error(`Extension '${extensionId.value}' is not known or not activated`);
        }
        return op.value;
    }
    async activateByEvent(activationEvent, startup) {
        if (this._alreadyActivatedEvents[activationEvent]) {
            return;
        }
        const activateExtensions = this._registry.getExtensionDescriptionsForActivationEvent(activationEvent);
        await this._activateExtensions(( (activateExtensions.map(e => ({
            id: e.identifier,
            reason: { startup, extensionId: e.identifier, activationEvent }
        })))));
        this._alreadyActivatedEvents[activationEvent] = true;
    }
    activateById(extensionId, reason) {
        const desc = this._registry.getExtensionDescription(extensionId);
        if (!desc) {
            throw new Error(`Extension '${extensionId}' is not known`);
        }
        return this._activateExtensions([{ id: desc.identifier, reason }]);
    }
    async _activateExtensions(extensions) {
        const operations = ( (extensions
            .filter((p) => !this.isActivated(p.id))
            .map(ext => this._handleActivationRequest(ext))));
        await Promise.all(( (operations.map(op => op.wait()))));
    }
    _handleActivationRequest(currentActivation) {
        if (this._operations.has(ExtensionIdentifier.toKey(currentActivation.id))) {
            return this._operations.get(ExtensionIdentifier.toKey(currentActivation.id));
        }
        if (this._isHostExtension(currentActivation.id)) {
            return this._createAndSaveOperation(currentActivation, null, [], null);
        }
        const currentExtension = this._registry.getExtensionDescription(currentActivation.id);
        if (!currentExtension) {
            const error = ( (new Error(`Cannot activate unknown extension '${currentActivation.id.value}'`)));
            const result = this._createAndSaveOperation(currentActivation, null, [], ( (new FailedExtension(error))));
            this._host.onExtensionActivationError(currentActivation.id, error, ( (new MissingExtensionDependency(currentActivation.id.value))));
            return result;
        }
        const deps = [];
        const depIds = (typeof currentExtension.extensionDependencies === 'undefined' ? [] : currentExtension.extensionDependencies);
        for (const depId of depIds) {
            if (this._isResolvedExtension(depId)) {
                continue;
            }
            const dep = this._operations.get(ExtensionIdentifier.toKey(depId));
            if (dep) {
                deps.push(dep);
                continue;
            }
            if (this._isHostExtension(depId)) {
                deps.push(this._handleActivationRequest({
                    id: this._globalRegistry.getExtensionDescription(depId).identifier,
                    reason: currentActivation.reason
                }));
                continue;
            }
            const depDesc = this._registry.getExtensionDescription(depId);
            if (depDesc) {
                if (!depDesc.main && !depDesc.browser) {
                    continue;
                }
                deps.push(this._handleActivationRequest({
                    id: depDesc.identifier,
                    reason: currentActivation.reason
                }));
                continue;
            }
            const currentExtensionFriendlyName = currentExtension.displayName || currentExtension.identifier.value;
            const error = ( (new Error(
                `Cannot activate the '${currentExtensionFriendlyName}' extension because it depends on unknown extension '${depId}'`
            )));
            const result = this._createAndSaveOperation(currentActivation, currentExtension.displayName, [], ( (new FailedExtension(error))));
            this._host.onExtensionActivationError(currentExtension.identifier, error, ( (new MissingExtensionDependency(depId))));
            return result;
        }
        return this._createAndSaveOperation(currentActivation, currentExtension.displayName, deps, null);
    }
    _createAndSaveOperation(activation, displayName, deps, value) {
        const operation = ( (new ActivationOperation(
            activation.id,
            displayName,
            activation.reason,
            deps,
            value,
            this._host,
            this._logService
        )));
        this._operations.set(ExtensionIdentifier.toKey(activation.id), operation);
        return operation;
    }
    _isHostExtension(extensionId) {
        return ExtensionDescriptionRegistry.isHostExtension(extensionId, this._registry, this._globalRegistry);
    }
    _isResolvedExtension(extensionId) {
        const extensionDescription = this._globalRegistry.getExtensionDescription(extensionId);
        if (!extensionDescription) {
            return false;
        }
        return (!extensionDescription.main && !extensionDescription.browser);
    }
};
ExtensionsActivator = ( (__decorate([
    ( (__param(3, ILogService)))
], ExtensionsActivator)));
let ActivationOperation = class ActivationOperation {
    get value() {
        return this._value;
    }
    get friendlyName() {
        return this._displayName || this._id.value;
    }
    constructor(_id, _displayName, _reason, _deps, _value, _host, _logService) {
        this._id = _id;
        this._displayName = _displayName;
        this._reason = _reason;
        this._deps = _deps;
        this._value = _value;
        this._host = _host;
        this._logService = _logService;
        this._barrier = ( (new Barrier()));
        this._isDisposed = false;
        this._initialize();
    }
    dispose() {
        this._isDisposed = true;
    }
    wait() {
        return this._barrier.wait();
    }
    async _initialize() {
        await this._waitForDepsThenActivate();
        this._barrier.open();
    }
    async _waitForDepsThenActivate() {
        if (this._value) {
            return;
        }
        while (this._deps.length > 0) {
            for (let i = 0; i < this._deps.length; i++) {
                const dep = this._deps[i];
                if (dep.value && !dep.value.activationFailed) {
                    this._deps.splice(i, 1);
                    i--;
                    continue;
                }
                if (dep.value && dep.value.activationFailed) {
                    const error = ( (new Error(
                        `Cannot activate the '${this.friendlyName}' extension because its dependency '${dep.friendlyName}' failed to activate`
                    )));
                    error.detail = dep.value.activationFailedError;
                    this._value = ( (new FailedExtension(error)));
                    this._host.onExtensionActivationError(this._id, error, null);
                    return;
                }
            }
            if (this._deps.length > 0) {
                await Promise.race(( (this._deps.map(dep => dep.wait()))));
            }
        }
        await this._activate();
    }
    async _activate() {
        try {
            this._value = await this._host.actualActivateExtension(this._id, this._reason);
        }
        catch (err) {
            const error = ( (new Error()));
            if (err && err.name) {
                error.name = err.name;
            }
            if (err && err.message) {
                error.message = `Activating extension '${this._id.value}' failed: ${err.message}.`;
            }
            else {
                error.message = `Activating extension '${this._id.value}' failed: ${err}.`;
            }
            if (err && err.stack) {
                error.stack = err.stack;
            }
            this._value = ( (new FailedExtension(error)));
            if (this._isDisposed && isCancellationError(err)) {
                return;
            }
            this._host.onExtensionActivationError(this._id, error, null);
            this._logService.error(`Activating extension ${this._id.value} failed due to an error:`);
            this._logService.error(err);
        }
    }
};
ActivationOperation = ( (__decorate([
    ( (__param(6, ILogService)))
], ActivationOperation)));
class ExtHostStorage {
    constructor(mainContext, _logService) {
        this._logService = _logService;
        this._onDidChangeStorage = ( (new Emitter$1()));
        this.onDidChangeStorage = this._onDidChangeStorage.event;
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadStorage)));
    }
    registerExtensionStorageKeysToSync(extension, keys) {
        this._proxy.$registerExtensionStorageKeysToSync(extension, keys);
    }
    async initializeExtensionStorage(shared, key, defaultValue) {
        const value = await this._proxy.$initializeExtensionStorage(shared, key);
        let parsedValue;
        if (value) {
            parsedValue = this.safeParseValue(shared, key, value);
        }
        return parsedValue || defaultValue;
    }
    setValue(shared, key, value) {
        return this._proxy.$setValue(shared, key, value);
    }
    $acceptValue(shared, key, value) {
        const parsedValue = this.safeParseValue(shared, key, value);
        if (parsedValue) {
            this._onDidChangeStorage.fire({ shared, key, value: parsedValue });
        }
    }
    safeParseValue(shared, key, value) {
        try {
            return JSON.parse(value);
        }
        catch (error) {
            this._logService.error(`[extHostStorage] unexpected error parsing storage contents (extensionId: ${key}, global: ${shared}): ${error}`);
        }
        return undefined;
    }
}
const IExtHostStorage = ( (createDecorator$1('IExtHostStorage')));
class ExtensionMemento {
    constructor(id, global, storage) {
        this._deferredPromises = ( (new Map()));
        this._id = id;
        this._shared = global;
        this._storage = storage;
        this._init = this._storage.initializeExtensionStorage(this._shared, this._id, Object.create(null)).then(value => {
            this._value = value;
            return this;
        });
        this._storageListener = this._storage.onDidChangeStorage(e => {
            if (e.shared === this._shared && e.key === this._id) {
                this._value = e.value;
            }
        });
        this._scheduler = ( (new RunOnceScheduler(() => {
            const records = this._deferredPromises;
            this._deferredPromises = ( (new Map()));
            (async () => {
                try {
                    await this._storage.setValue(this._shared, this._id, this._value);
                    for (const value of ( (records.values()))) {
                        value.complete();
                    }
                }
                catch (e) {
                    for (const value of ( (records.values()))) {
                        value.error(e);
                    }
                }
            })();
        }, 0)));
    }
    keys() {
        return (
             (Object.entries(this._value ?? {}).filter(([, value]) => value !== undefined).map(([key]) => key))
        );
    }
    get whenReady() {
        return this._init;
    }
    get(key, defaultValue) {
        let value = this._value[key];
        if (typeof value === 'undefined') {
            value = defaultValue;
        }
        return value;
    }
    update(key, value) {
        this._value[key] = value;
        const record = this._deferredPromises.get(key);
        if (record !== undefined) {
            return record.p;
        }
        const promise = ( (new DeferredPromise()));
        this._deferredPromises.set(key, promise);
        if (!this._scheduler.isScheduled()) {
            this._scheduler.schedule();
        }
        return promise.p;
    }
    dispose() {
        this._storageListener.dispose();
    }
}
class ExtensionGlobalMemento extends ExtensionMemento {
    setKeysForSync(keys) {
        this._storage.registerExtensionStorageKeysToSync({ id: this._id, version: this._extension.version }, keys);
    }
    constructor(extensionDescription, storage) {
        super(extensionDescription.identifier.value, true, storage);
        this._extension = extensionDescription;
    }
}
let ExtHostConsumerFileSystem = class ExtHostConsumerFileSystem {
    constructor(extHostRpc, fileSystemInfo) {
        this._fileSystemProvider = ( (new Map()));
        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadFileSystem)));
        const that = this;
        this.value = ( (Object.freeze({
            async stat(uri) {
                try {
                    const provider = that._fileSystemProvider.get(uri.scheme);
                    if (!provider) {
                        return await that._proxy.$stat(uri);
                    }
                    await that._proxy.$ensureActivation(uri.scheme);
                    const stat = await provider.stat(uri);
                    return {
                        type: stat.type,
                        ctime: stat.ctime,
                        mtime: stat.mtime,
                        size: stat.size,
                        permissions: stat.permissions
                    };
                }
                catch (err) {
                    ExtHostConsumerFileSystem._handleError(err);
                }
            },
            async readDirectory(uri) {
                try {
                    const provider = that._fileSystemProvider.get(uri.scheme);
                    if (provider) {
                        await that._proxy.$ensureActivation(uri.scheme);
                        return (await provider.readDirectory(uri)).slice();
                    }
                    else {
                        return await that._proxy.$readdir(uri);
                    }
                }
                catch (err) {
                    return ExtHostConsumerFileSystem._handleError(err);
                }
            },
            async createDirectory(uri) {
                try {
                    return await that._proxy.$mkdir(uri);
                }
                catch (err) {
                    return ExtHostConsumerFileSystem._handleError(err);
                }
            },
            async readFile(uri) {
                try {
                    const provider = that._fileSystemProvider.get(uri.scheme);
                    if (provider) {
                        await that._proxy.$ensureActivation(uri.scheme);
                        return (await provider.readFile(uri)).slice();
                    }
                    else {
                        const buff = await that._proxy.$readFile(uri);
                        return buff.buffer;
                    }
                }
                catch (err) {
                    return ExtHostConsumerFileSystem._handleError(err);
                }
            },
            async writeFile(uri, content) {
                try {
                    return await that._proxy.$writeFile(uri, VSBuffer.wrap(content));
                }
                catch (err) {
                    return ExtHostConsumerFileSystem._handleError(err);
                }
            },
            async delete(uri, options) {
                try {
                    const provider = that._fileSystemProvider.get(uri.scheme);
                    if (provider) {
                        await that._proxy.$ensureActivation(uri.scheme);
                        return await provider.delete(uri, { recursive: false, ...options });
                    }
                    else {
                        return await that._proxy.$delete(uri, { recursive: false, useTrash: false, ...options });
                    }
                }
                catch (err) {
                    return ExtHostConsumerFileSystem._handleError(err);
                }
            },
            async rename(oldUri, newUri, options) {
                try {
                    return await that._proxy.$rename(oldUri, newUri, { ...{ overwrite: false }, ...options });
                }
                catch (err) {
                    return ExtHostConsumerFileSystem._handleError(err);
                }
            },
            async copy(source, destination, options) {
                try {
                    return await that._proxy.$copy(source, destination, { ...{ overwrite: false }, ...options });
                }
                catch (err) {
                    return ExtHostConsumerFileSystem._handleError(err);
                }
            },
            isWritableFileSystem(scheme) {
                const capabilities = fileSystemInfo.getCapabilities(scheme);
                if (typeof capabilities === 'number') {
                    return !((capabilities & 2048) );
                }
                return undefined;
            }
        })));
    }
    static _handleError(err) {
        if (err instanceof FileSystemError$1) {
            throw err;
        }
        if (!(err instanceof Error)) {
            throw new FileSystemError$1(String(err));
        }
        if (err.name === 'ENOPRO' || err.message.includes('ENOPRO')) {
            throw FileSystemError$1.Unavailable(err.message);
        }
        switch (err.name) {
            case FileSystemProviderErrorCode.FileExists: throw FileSystemError$1.FileExists(err.message);
            case FileSystemProviderErrorCode.FileNotFound: throw FileSystemError$1.FileNotFound(err.message);
            case FileSystemProviderErrorCode.FileNotADirectory: throw FileSystemError$1.FileNotADirectory(err.message);
            case FileSystemProviderErrorCode.FileIsADirectory: throw FileSystemError$1.FileIsADirectory(err.message);
            case FileSystemProviderErrorCode.NoPermissions: throw FileSystemError$1.NoPermissions(err.message);
            case FileSystemProviderErrorCode.Unavailable: throw FileSystemError$1.Unavailable(err.message);
            default: throw new FileSystemError$1(err.message, err.name);
        }
    }
    addFileSystemProvider(scheme, provider) {
        this._fileSystemProvider.set(scheme, provider);
        return toDisposable(() => this._fileSystemProvider.delete(scheme));
    }
};
ExtHostConsumerFileSystem = ( (__decorate([
    ( (__param(0, IExtHostRpcService))),
    ( (__param(1, IExtHostFileSystemInfo)))
], ExtHostConsumerFileSystem)));
const IExtHostConsumerFileSystem = ( (createDecorator$1('IExtHostConsumerFileSystem')));
const IExtensionStoragePaths = ( (createDecorator$1('IExtensionStoragePaths')));
let ExtensionStoragePaths = class ExtensionStoragePaths {
    constructor(initData, _logService, _extHostFileSystem) {
        this._logService = _logService;
        this._extHostFileSystem = _extHostFileSystem;
        this._workspace = initData.workspace ?? undefined;
        this._environment = initData.environment;
        this.whenReady = this._getOrCreateWorkspaceStoragePath().then(value => this._value = value);
    }
    async _getWorkspaceStorageURI(storageName) {
        return URI.joinPath(this._environment.workspaceStorageHome, storageName);
    }
    async _getOrCreateWorkspaceStoragePath() {
        if (!this._workspace) {
            return Promise.resolve(undefined);
        }
        const storageName = this._workspace.id;
        const storageUri = await this._getWorkspaceStorageURI(storageName);
        try {
            await this._extHostFileSystem.value.stat(storageUri);
            this._logService.trace('[ExtHostStorage] storage dir already exists', storageUri);
            return storageUri;
        }
        catch {
        }
        try {
            this._logService.trace('[ExtHostStorage] creating dir and metadata-file', storageUri);
            await this._extHostFileSystem.value.createDirectory(storageUri);
            await this._extHostFileSystem.value.writeFile(URI.joinPath(storageUri, 'meta.json'), ( (new TextEncoder())).encode(JSON.stringify({
                id: this._workspace.id,
                configuration: URI.revive(this._workspace.configuration)?.toString(),
                name: this._workspace.name
            }, undefined, 2)));
            return storageUri;
        }
        catch (e) {
            this._logService.error('[ExtHostStorage]', e);
            return undefined;
        }
    }
    workspaceValue(extension) {
        if (this._value) {
            return URI.joinPath(this._value, extension.identifier.value);
        }
        return undefined;
    }
    globalValue(extension) {
        return URI.joinPath(this._environment.globalStorageHome, extension.identifier.value.toLowerCase());
    }
    onWillDeactivateAll() {
    }
};
ExtensionStoragePaths = ( (__decorate([
    ( (__param(0, IExtHostInitDataService))),
    ( (__param(1, ILogService))),
    ( (__param(2, IExtHostConsumerFileSystem)))
], ExtensionStoragePaths)));
const IExtHostTunnelService = ( (createDecorator$1('IExtHostTunnelService')));
let ExtHostTunnelService = class ExtHostTunnelService {
    constructor(extHostRpc) {
        this.onDidChangeTunnels = (( (new Emitter$1()))).event;
    }
    async $applyCandidateFilter(candidates) {
        return candidates;
    }
    async openTunnel(extension, forward) {
        return undefined;
    }
    async getTunnels() {
        return [];
    }
    async setTunnelFactory(provider) {
        return { dispose: () => { } };
    }
    registerPortsAttributesProvider(portSelector, provider) {
        return { dispose: () => { } };
    }
    async $providePortAttributes(handles, ports, pid, commandline, cancellationToken) {
        return [];
    }
    async $forwardPort(tunnelOptions, tunnelCreationOptions) { return undefined; }
    async $closeTunnel(remote) { }
    async $onDidTunnelsChange() { }
    async $registerCandidateFinder() { }
};
ExtHostTunnelService = ( (__decorate([
    ( (__param(0, IExtHostRpcService)))
], ExtHostTunnelService)));
const IExtHostTerminalService = ( (createDecorator$1('IExtHostTerminalService')));
let QueryBuilder = class QueryBuilder {
    constructor(configurationService, workspaceContextService, editorGroupsService, logService, pathService) {
        this.configurationService = configurationService;
        this.workspaceContextService = workspaceContextService;
        this.editorGroupsService = editorGroupsService;
        this.logService = logService;
        this.pathService = pathService;
    }
    text(contentPattern, folderResources, options = {}) {
        contentPattern = this.getContentPattern(contentPattern, options);
        const searchConfig = this.configurationService.getValue();
        const fallbackToPCRE = folderResources && folderResources.some(folder => {
            const folderConfig = this.configurationService.getValue({ resource: folder });
            return !folderConfig.search.useRipgrep;
        });
        const commonQuery = this.commonQuery(folderResources?.map(toWorkspaceFolder), options);
        return {
            ...commonQuery,
            type: 2 ,
            contentPattern,
            previewOptions: options.previewOptions,
            maxFileSize: options.maxFileSize,
            usePCRE2: searchConfig.search.usePCRE2 || fallbackToPCRE || false,
            beforeContext: options.beforeContext,
            afterContext: options.afterContext,
            userDisabledExcludesAndIgnoreFiles: options.disregardExcludeSettings && options.disregardIgnoreFiles
        };
    }
    getContentPattern(inputPattern, options) {
        const searchConfig = this.configurationService.getValue();
        if (inputPattern.isRegExp) {
            inputPattern.pattern = inputPattern.pattern.replace(/\r?\n/g, '\\n');
        }
        const newPattern = {
            ...inputPattern,
            wordSeparators: searchConfig.editor.wordSeparators
        };
        if (this.isCaseSensitive(inputPattern, options)) {
            newPattern.isCaseSensitive = true;
        }
        if (this.isMultiline(inputPattern)) {
            newPattern.isMultiline = true;
        }
        return newPattern;
    }
    file(folders, options = {}) {
        const commonQuery = this.commonQuery(folders, options);
        return {
            ...commonQuery,
            type: 1 ,
            filePattern: options.filePattern
                ? options.filePattern.trim()
                : options.filePattern,
            exists: options.exists,
            sortByScore: options.sortByScore,
            cacheKey: options.cacheKey,
        };
    }
    handleIncludeExclude(pattern, expandPatterns) {
        if (!pattern) {
            return {};
        }
        pattern = Array.isArray(pattern) ? ( (pattern.map(normalizeSlashes))) : normalizeSlashes(pattern);
        return expandPatterns
            ? this.parseSearchPaths(pattern)
            : { pattern: patternListToIExpression(...(Array.isArray(pattern) ? pattern : [pattern])) };
    }
    commonQuery(folderResources = [], options = {}) {
        const includeSearchPathsInfo = this.handleIncludeExclude(options.includePattern, options.expandPatterns);
        const excludeSearchPathsInfo = this.handleIncludeExclude(options.excludePattern, options.expandPatterns);
        const includeFolderName = folderResources.length > 1;
        const folderQueries = (includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length ?
            ( (includeSearchPathsInfo.searchPaths.map(
            searchPath => this.getFolderQueryForSearchPath(searchPath, options, excludeSearchPathsInfo)
        ))) :
            ( (folderResources.map(
            folder => this.getFolderQueryForRoot(folder, options, excludeSearchPathsInfo, includeFolderName)
        ))))
            .filter(query => !!query);
        const queryProps = {
            _reason: options._reason,
            folderQueries,
            usingSearchPaths: !!(includeSearchPathsInfo.searchPaths && includeSearchPathsInfo.searchPaths.length),
            extraFileResources: options.extraFileResources,
            excludePattern: excludeSearchPathsInfo.pattern,
            includePattern: includeSearchPathsInfo.pattern,
            onlyOpenEditors: options.onlyOpenEditors,
            maxResults: options.maxResults
        };
        if (options.onlyOpenEditors) {
            const openEditors = coalesce(flatten(( (this.editorGroupsService.groups.map(group => ( (group.editors.map(editor => editor.resource))))))));
            this.logService.trace('QueryBuilder#commonQuery - openEditor URIs', JSON.stringify(openEditors));
            const openEditorsInQuery = openEditors.filter(editor => pathIncludedInQuery(queryProps, editor.fsPath));
            const openEditorsQueryProps = this.commonQueryFromFileList(openEditorsInQuery);
            this.logService.trace('QueryBuilder#commonQuery - openEditor Query', JSON.stringify(openEditorsQueryProps));
            return { ...queryProps, ...openEditorsQueryProps };
        }
        const extraFileResources = options.extraFileResources && options.extraFileResources.filter(extraFile => pathIncludedInQuery(queryProps, extraFile.fsPath));
        queryProps.extraFileResources = extraFileResources && extraFileResources.length ? extraFileResources : undefined;
        return queryProps;
    }
    commonQueryFromFileList(files) {
        const folderQueries = [];
        const foldersToSearch = ( (new ResourceMap$1()));
        const includePattern = {};
        let hasIncludedFile = false;
        files.forEach(file => {
            if (file.scheme === Schemas.walkThrough) {
                return;
            }
            const providerExists = isAbsolutePath(file);
            if (providerExists) {
                const searchRoot = this.workspaceContextService.getWorkspaceFolder(file)?.uri ?? file.with({ path: dirname$1(file.fsPath) });
                let folderQuery = foldersToSearch.get(searchRoot);
                if (!folderQuery) {
                    hasIncludedFile = true;
                    folderQuery = { folder: searchRoot, includePattern: {} };
                    folderQueries.push(folderQuery);
                    foldersToSearch.set(searchRoot, folderQuery);
                }
                const relPath = relative(searchRoot.fsPath, file.fsPath);
                assertIsDefined(folderQuery.includePattern)[relPath.replace(/\\/g, '/')] = true;
            }
            else {
                if (file.fsPath) {
                    hasIncludedFile = true;
                    includePattern[file.fsPath] = true;
                }
            }
        });
        return {
            folderQueries,
            includePattern,
            usingSearchPaths: true,
            excludePattern: hasIncludedFile ? undefined : { '**/*': true }
        };
    }
    isCaseSensitive(contentPattern, options) {
        if (options.isSmartCase) {
            if (contentPattern.isRegExp) {
                if (containsUppercaseCharacter(contentPattern.pattern, true)) {
                    return true;
                }
            }
            else if (containsUppercaseCharacter(contentPattern.pattern)) {
                return true;
            }
        }
        return !!contentPattern.isCaseSensitive;
    }
    isMultiline(contentPattern) {
        if (contentPattern.isMultiline) {
            return true;
        }
        if (contentPattern.isRegExp && isMultilineRegexSource(contentPattern.pattern)) {
            return true;
        }
        if (contentPattern.pattern.indexOf('\n') >= 0) {
            return true;
        }
        return !!contentPattern.isMultiline;
    }
    parseSearchPaths(pattern) {
        const isSearchPath = (segment) => {
            return isAbsolute(segment) || /^\.\.?([\/\\]|$)/.test(segment);
        };
        const patterns = Array.isArray(pattern) ? pattern : splitGlobPattern(pattern);
        const segments = ( (patterns
            .map(segment => {
            const userHome = this.pathService.resolvedUserHome;
            if (userHome) {
                return untildify(segment, userHome.scheme === Schemas.file ? userHome.fsPath : userHome.path);
            }
            return segment;
        })));
        const groups = groupBy(segments, segment => isSearchPath(segment) ? 'searchPaths' : 'exprSegments');
        const expandedExprSegments = ( (( (( ((groups.exprSegments || [])
            .map(s => rtrim(s, '/'))))
            .map(s => rtrim(s, '\\'))))
            .map(p => {
            if (p[0] === '.') {
                p = '*' + p;
            }
            return expandGlobalGlob(p);
        })));
        const result = {};
        const searchPaths = this.expandSearchPathPatterns(groups.searchPaths || []);
        if (searchPaths && searchPaths.length) {
            result.searchPaths = searchPaths;
        }
        const exprSegments = flatten(expandedExprSegments);
        const includePattern = patternListToIExpression(...exprSegments);
        if (includePattern) {
            result.pattern = includePattern;
        }
        return result;
    }
    getExcludesForFolder(folderConfig, options) {
        return options.disregardExcludeSettings ?
            undefined :
            getExcludes(folderConfig, !options.disregardSearchExcludeSettings);
    }
    expandSearchPathPatterns(searchPaths) {
        if (!searchPaths || !searchPaths.length) {
            return [];
        }
        const expandedSearchPaths = searchPaths.flatMap(searchPath => {
            let { pathPortion, globPortion } = splitGlobFromPath(searchPath);
            if (globPortion) {
                globPortion = normalizeGlobPattern(globPortion);
            }
            const oneExpanded = this.expandOneSearchPath(pathPortion);
            return oneExpanded.flatMap(oneExpandedResult => this.resolveOneSearchPathPattern(oneExpandedResult, globPortion));
        });
        const searchPathPatternMap = ( (new Map()));
        expandedSearchPaths.forEach(oneSearchPathPattern => {
            const key = ( (oneSearchPathPattern.searchPath.toString()));
            const existing = searchPathPatternMap.get(key);
            if (existing) {
                if (oneSearchPathPattern.pattern) {
                    existing.pattern = existing.pattern || {};
                    existing.pattern[oneSearchPathPattern.pattern] = true;
                }
            }
            else {
                searchPathPatternMap.set(key, {
                    searchPath: oneSearchPathPattern.searchPath,
                    pattern: oneSearchPathPattern.pattern ? patternListToIExpression(oneSearchPathPattern.pattern) : undefined
                });
            }
        });
        return Array.from(( (searchPathPatternMap.values())));
    }
    expandOneSearchPath(searchPath) {
        if (isAbsolute(searchPath)) {
            const workspaceFolders = this.workspaceContextService.getWorkspace().folders;
            if (workspaceFolders[0] && workspaceFolders[0].uri.scheme !== Schemas.file) {
                return [{
                        searchPath: workspaceFolders[0].uri.with({ path: searchPath })
                    }];
            }
            return [{
                    searchPath: URI.file(normalize(searchPath))
                }];
        }
        if (this.workspaceContextService.getWorkbenchState() === 2 ) {
            const workspaceUri = this.workspaceContextService.getWorkspace().folders[0].uri;
            searchPath = normalizeSlashes(searchPath);
            if (searchPath.startsWith('../') || searchPath === '..') {
                const resolvedPath = posix.resolve(workspaceUri.path, searchPath);
                return [{
                        searchPath: workspaceUri.with({ path: resolvedPath })
                    }];
            }
            const cleanedPattern = normalizeGlobPattern(searchPath);
            return [{
                    searchPath: workspaceUri,
                    pattern: cleanedPattern
                }];
        }
        else if (searchPath === './' || searchPath === '.\\') {
            return [];
        }
        else {
            const searchPathWithoutDotSlash = searchPath.replace(/^\.[\/\\]/, '');
            const folders = this.workspaceContextService.getWorkspace().folders;
            const folderMatches = ( (folders.map(folder => {
                const match = searchPathWithoutDotSlash.match(( (new RegExp(`^${escapeRegExpCharacters(folder.name)}(?:/(.*)|$)`))));
                return match ? {
                    match,
                    folder
                } : null;
            }))).filter(isDefined);
            if (folderMatches.length) {
                return (
                     (folderMatches.map(match => {
                        const patternMatch = match.match[1];
                        return {
                            searchPath: match.folder.uri,
                            pattern: patternMatch && normalizeGlobPattern(patternMatch)
                        };
                    }))
                );
            }
            else {
                const probableWorkspaceFolderNameMatch = searchPath.match(/\.[\/\\](.+)[\/\\]?/);
                const probableWorkspaceFolderName = probableWorkspaceFolderNameMatch ? probableWorkspaceFolderNameMatch[1] : searchPath;
                const searchPathNotFoundError = ( (localize(
                    'search.noWorkspaceWithName',
                    "Workspace folder does not exist: {0}",
                    probableWorkspaceFolderName
                )));
                throw new Error(searchPathNotFoundError);
            }
        }
    }
    resolveOneSearchPathPattern(oneExpandedResult, globPortion) {
        const pattern = oneExpandedResult.pattern && globPortion ?
            `${oneExpandedResult.pattern}/${globPortion}` :
            oneExpandedResult.pattern || globPortion;
        const results = [
            {
                searchPath: oneExpandedResult.searchPath,
                pattern
            }
        ];
        if (pattern && !pattern.endsWith('**')) {
            results.push({
                searchPath: oneExpandedResult.searchPath,
                pattern: pattern + '/**'
            });
        }
        return results;
    }
    getFolderQueryForSearchPath(searchPath, options, searchPathExcludes) {
        const rootConfig = this.getFolderQueryForRoot(toWorkspaceFolder(searchPath.searchPath), options, searchPathExcludes, false);
        if (!rootConfig) {
            return null;
        }
        return {
            ...rootConfig,
            ...{
                includePattern: searchPath.pattern
            }
        };
    }
    getFolderQueryForRoot(folder, options, searchPathExcludes, includeFolderName) {
        let thisFolderExcludeSearchPathPattern;
        const folderUri = URI.isUri(folder) ? folder : folder.uri;
        if (searchPathExcludes.searchPaths) {
            const thisFolderExcludeSearchPath = searchPathExcludes.searchPaths.filter(sp => isEqual(sp.searchPath, folderUri))[0];
            if (thisFolderExcludeSearchPath && !thisFolderExcludeSearchPath.pattern) {
                return null;
            }
            else if (thisFolderExcludeSearchPath) {
                thisFolderExcludeSearchPathPattern = thisFolderExcludeSearchPath.pattern;
            }
        }
        const folderConfig = this.configurationService.getValue({ resource: folderUri });
        const settingExcludes = this.getExcludesForFolder(folderConfig, options);
        const excludePattern = {
            ...(settingExcludes || {}),
            ...(thisFolderExcludeSearchPathPattern || {})
        };
        const folderName = URI.isUri(folder) ? basename(folder) : folder.name;
        return {
            folder: folderUri,
            folderName: includeFolderName ? folderName : undefined,
            excludePattern: ( (Object.keys(excludePattern))).length > 0 ? excludePattern : undefined,
            fileEncoding: folderConfig.files && folderConfig.files.encoding,
            disregardIgnoreFiles: typeof options.disregardIgnoreFiles === 'boolean' ? options.disregardIgnoreFiles : !folderConfig.search.useIgnoreFiles,
            disregardGlobalIgnoreFiles: typeof options.disregardGlobalIgnoreFiles === 'boolean' ? options.disregardGlobalIgnoreFiles : !folderConfig.search.useGlobalIgnoreFiles,
            disregardParentIgnoreFiles: typeof options.disregardParentIgnoreFiles === 'boolean' ? options.disregardParentIgnoreFiles : !folderConfig.search.useParentIgnoreFiles,
            ignoreSymlinks: typeof options.ignoreSymlinks === 'boolean' ? options.ignoreSymlinks : !folderConfig.search.followSymlinks,
        };
    }
};
QueryBuilder = ( (__decorate([
    ( (__param(0, IConfigurationService))),
    ( (__param(1, IWorkspaceContextService))),
    ( (__param(2, IEditorGroupsService))),
    ( (__param(3, ILogService))),
    ( (__param(4, IPathService)))
], QueryBuilder)));
function splitGlobFromPath(searchPath) {
    const globCharMatch = searchPath.match(/[\*\{\}\(\)\[\]\?]/);
    if (globCharMatch) {
        const globCharIdx = globCharMatch.index;
        const lastSlashMatch = searchPath.substr(0, globCharIdx).match(/[/|\\][^/\\]*$/);
        if (lastSlashMatch) {
            let pathPortion = searchPath.substr(0, lastSlashMatch.index);
            if (!pathPortion.match(/[/\\]/)) {
                pathPortion += '/';
            }
            return {
                pathPortion,
                globPortion: searchPath.substr((lastSlashMatch.index || 0) + 1)
            };
        }
    }
    return {
        pathPortion: searchPath
    };
}
function patternListToIExpression(...patterns) {
    return patterns.length ?
        patterns.reduce((glob, cur) => { glob[cur] = true; return glob; }, Object.create(null)) :
        undefined;
}
function splitGlobPattern(pattern) {
    return ( (splitGlobAware(pattern, ',')
        .map(s => s.trim())))
        .filter(s => !!s.length);
}
function expandGlobalGlob(pattern) {
    const patterns = [
        `**/${pattern}/**`,
        `**/${pattern}`
    ];
    return (
         (patterns.map(p => p.replace(/\*\*\/\*\*/g, '**')))
    );
}
function normalizeSlashes(pattern) {
    return pattern.replace(/\\/g, '/');
}
function normalizeGlobPattern(pattern) {
    return normalizeSlashes(pattern)
        .replace(/^\.\//, '')
        .replace(/\/+$/g, '');
}
const WORKSPACE_CONTAINS_TIMEOUT = 7000;
function checkActivateWorkspaceContainsExtension(host, desc) {
    const activationEvents = desc.activationEvents;
    if (!activationEvents) {
        return Promise.resolve(undefined);
    }
    const fileNames = [];
    const globPatterns = [];
    for (const activationEvent of activationEvents) {
        if (/^workspaceContains:/.test(activationEvent)) {
            const fileNameOrGlob = activationEvent.substr('workspaceContains:'.length);
            if (fileNameOrGlob.indexOf('*') >= 0 || fileNameOrGlob.indexOf('?') >= 0 || host.forceUsingSearch) {
                globPatterns.push(fileNameOrGlob);
            }
            else {
                fileNames.push(fileNameOrGlob);
            }
        }
    }
    if (fileNames.length === 0 && globPatterns.length === 0) {
        return Promise.resolve(undefined);
    }
    let resolveResult;
    const result = ( (new Promise((resolve, reject) => { resolveResult = resolve; })));
    const activate = (activationEvent) => resolveResult({ activationEvent });
    const fileNamePromise = Promise.all(( (fileNames.map((fileName) => _activateIfFileName(host, fileName, activate))))).then(() => { });
    const globPatternPromise = _activateIfGlobPatterns(host, desc.identifier, globPatterns, activate);
    Promise.all([fileNamePromise, globPatternPromise]).then(() => {
        resolveResult(undefined);
    });
    return result;
}
async function _activateIfFileName(host, fileName, activate) {
    for (const uri of host.folders) {
        if (await host.exists(joinPath(URI.revive(uri), fileName))) {
            activate(`workspaceContains:${fileName}`);
            return;
        }
    }
}
async function _activateIfGlobPatterns(host, extensionId, globPatterns, activate) {
    if (globPatterns.length === 0) {
        return Promise.resolve(undefined);
    }
    const tokenSource = ( (new CancellationTokenSource$1()));
    const searchP = host.checkExists(host.folders, globPatterns, tokenSource.token);
    const timer = setTimeout(async () => {
        tokenSource.cancel();
        host.logService.info(`Not activating extension '${extensionId.value}': Timed out while searching for 'workspaceContains' pattern ${globPatterns.join(',')}`);
    }, WORKSPACE_CONTAINS_TIMEOUT);
    let exists = false;
    try {
        exists = await searchP;
    }
    catch (err) {
        if (!isCancellationError(err)) {
            onUnexpectedError(err);
        }
    }
    tokenSource.dispose();
    clearTimeout(timer);
    if (exists) {
        activate(`workspaceContains:${globPatterns.join(',')}`);
    }
}
function checkGlobFileExists(accessor, folders, includes, token) {
    const instantiationService = accessor.get(IInstantiationService);
    const searchService = accessor.get(ISearchService);
    const queryBuilder = instantiationService.createInstance(QueryBuilder);
    const query = queryBuilder.file(( (folders.map(folder => toWorkspaceFolder(URI.revive(folder))))), {
        _reason: 'checkExists',
        includePattern: includes,
        exists: true
    });
    return searchService.fileSearch(query, token).then(result => {
        return !!result.limitHit;
    }, err => {
        if (!isCancellationError(err)) {
            return Promise.reject(err);
        }
        return false;
    });
}
class ExtHostSecretState {
    constructor(mainContext) {
        this._onDidChangePassword = ( (new Emitter$1()));
        this.onDidChangePassword = this._onDidChangePassword.event;
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadSecretState)));
    }
    async $onDidChangePassword(e) {
        this._onDidChangePassword.fire(e);
    }
    get(extensionId, key) {
        return this._proxy.$getPassword(extensionId, key);
    }
    store(extensionId, key, value) {
        return this._proxy.$setPassword(extensionId, key, value);
    }
    delete(extensionId, key) {
        return this._proxy.$deletePassword(extensionId, key);
    }
}
const IExtHostSecretState = ( (createDecorator$1('IExtHostSecretState')));
var _ExtensionSecrets_secretState;
class ExtensionSecrets {
    constructor(extensionDescription, secretState) {
        _ExtensionSecrets_secretState.set(this, void 0);
        this._onDidChange = ( (new Emitter$1()));
        this.onDidChange = this._onDidChange.event;
        this._id = ExtensionIdentifier.toKey(extensionDescription.identifier);
        __classPrivateFieldSet(this, _ExtensionSecrets_secretState, secretState, "f");
        __classPrivateFieldGet(this, _ExtensionSecrets_secretState, "f").onDidChangePassword(e => {
            if (e.extensionId === this._id) {
                this._onDidChange.fire({ key: e.key });
            }
        });
    }
    get(key) {
        return __classPrivateFieldGet(this, _ExtensionSecrets_secretState, "f").get(this._id, key);
    }
    store(key, value) {
        return __classPrivateFieldGet(this, _ExtensionSecrets_secretState, "f").store(this._id, key, value);
    }
    delete(key) {
        return __classPrivateFieldGet(this, _ExtensionSecrets_secretState, "f").delete(this._id, key);
    }
}
_ExtensionSecrets_secretState = ( (new WeakMap()));
let ExtHostLocalizationService = class ExtHostLocalizationService {
    constructor(initData, rpc, logService) {
        this.logService = logService;
        this.bundleCache = ( (new Map()));
        this._proxy = ( (rpc.getProxy(MainContext.MainThreadLocalization)));
        this.currentLanguage = initData.environment.appLanguage;
        this.isDefaultLanguage = this.currentLanguage === LANGUAGE_DEFAULT;
    }
    getMessage(extensionId, details) {
        const { message, args, comment } = details;
        if (this.isDefaultLanguage) {
            return format2(message, (args ?? {}));
        }
        let key = message;
        if (comment && comment.length > 0) {
            key += `/${Array.isArray(comment) ? comment.join('') : comment}`;
        }
        const str = this.bundleCache.get(extensionId)?.contents[key];
        if (!str) {
            this.logService.warn(`Using default string since no string found in i18n bundle that has the key: ${key}`);
        }
        return format2(str ?? message, (args ?? {}));
    }
    getBundle(extensionId) {
        return this.bundleCache.get(extensionId)?.contents;
    }
    getBundleUri(extensionId) {
        return this.bundleCache.get(extensionId)?.uri;
    }
    async initializeLocalizedMessages(extension) {
        if (this.isDefaultLanguage
            || (!extension.l10n && !extension.isBuiltin)) {
            return;
        }
        if (this.bundleCache.has(extension.identifier.value)) {
            return;
        }
        let contents;
        const bundleUri = await this.getBundleLocation(extension);
        if (!bundleUri) {
            this.logService.error(`No bundle location found for extension ${extension.identifier.value}`);
            return;
        }
        try {
            const response = await this._proxy.$fetchBundleContents(bundleUri);
            const result = JSON.parse(response);
            contents = extension.isBuiltin ? result.contents?.bundle : result;
        }
        catch (e) {
            this.logService.error(`Failed to load translations for ${extension.identifier.value} from ${bundleUri}: ${e.message}`);
            return;
        }
        if (contents) {
            this.bundleCache.set(extension.identifier.value, {
                contents,
                uri: bundleUri
            });
        }
    }
    async getBundleLocation(extension) {
        if (extension.isBuiltin) {
            const uri = await this._proxy.$fetchBuiltInBundleUri(extension.identifier.value, this.currentLanguage);
            return URI.revive(uri);
        }
        return extension.l10n
            ? URI.joinPath(extension.extensionLocation, extension.l10n, `bundle.l10n.${this.currentLanguage}.json`)
            : undefined;
    }
};
ExtHostLocalizationService = ( (__decorate([
    ( (__param(0, IExtHostInitDataService))),
    ( (__param(1, IExtHostRpcService))),
    ( (__param(2, ILogService)))
], ExtHostLocalizationService)));
const IExtHostLocalizationService = ( (createDecorator$1('IExtHostLocalizationService')));
var _Extension_extensionService, _Extension_originExtensionId, _Extension_identifier;
const IHostUtils = ( (createDecorator$1('IHostUtils')));
let AbstractExtHostExtensionService = class AbstractExtHostExtensionService extends Disposable$1 {
    constructor(instaService, hostUtils, extHostContext, extHostWorkspace, extHostConfiguration, logService, initData, storagePath, extHostTunnelService, extHostTerminalService, extHostLocalizationService) {
        super();
        this._onDidChangeRemoteConnectionData = this._register(( (new Emitter$1())));
        this.onDidChangeRemoteConnectionData = this._onDidChangeRemoteConnectionData.event;
        this._isTerminating = false;
        this._hostUtils = hostUtils;
        this._extHostContext = extHostContext;
        this._initData = initData;
        this._extHostWorkspace = extHostWorkspace;
        this._extHostConfiguration = extHostConfiguration;
        this._logService = logService;
        this._extHostTunnelService = extHostTunnelService;
        this._extHostTerminalService = extHostTerminalService;
        this._extHostLocalizationService = extHostLocalizationService;
        this._mainThreadWorkspaceProxy = ( (this._extHostContext.getProxy(MainContext.MainThreadWorkspace)));
        this._mainThreadTelemetryProxy = ( (this._extHostContext.getProxy(MainContext.MainThreadTelemetry)));
        this._mainThreadExtensionsProxy = ( (this._extHostContext.getProxy(MainContext.MainThreadExtensionService)));
        this._almostReadyToRunExtensions = ( (new Barrier()));
        this._readyToStartExtensionHost = ( (new Barrier()));
        this._readyToRunExtensions = ( (new Barrier()));
        this._eagerExtensionsActivated = ( (new Barrier()));
        this._globalRegistry = ( (new ExtensionDescriptionRegistry(this._initData.allExtensions)));
        const myExtensionsSet = extensionIdentifiersArrayToSet(this._initData.myExtensions);
        this._myRegistry = ( (new ExtensionDescriptionRegistry(filterExtensions(this._globalRegistry, myExtensionsSet))));
        this._storage = ( (new ExtHostStorage(this._extHostContext, this._logService)));
        this._secretState = ( (new ExtHostSecretState(this._extHostContext)));
        this._storagePath = storagePath;
        this._instaService = instaService.createChild(( (new ServiceCollection([IExtHostStorage, this._storage], [IExtHostSecretState, this._secretState]))));
        this._activator = this._register(( (new ExtensionsActivator(this._myRegistry, this._globalRegistry, {
            onExtensionActivationError: (extensionId, error, missingExtensionDependency) => {
                this._mainThreadExtensionsProxy.$onExtensionActivationError(extensionId, transformErrorForSerialization(error), missingExtensionDependency);
            },
            actualActivateExtension: async (extensionId, reason) => {
                if (ExtensionDescriptionRegistry.isHostExtension(extensionId, this._myRegistry, this._globalRegistry)) {
                    await this._mainThreadExtensionsProxy.$activateExtension(extensionId, reason);
                    return (
                         (new HostExtension())
                    );
                }
                const extensionDescription = this._myRegistry.getExtensionDescription(extensionId);
                return this._activateExtension(extensionDescription, reason);
            }
        }, this._logService))));
        this._extensionPathIndex = null;
        this._resolvers = Object.create(null);
        this._started = false;
        this._remoteConnectionData = this._initData.remote.connectionData;
    }
    getRemoteConnectionData() {
        return this._remoteConnectionData;
    }
    async initialize() {
        try {
            await this._beforeAlmostReadyToRunExtensions();
            this._almostReadyToRunExtensions.open();
            await this._extHostWorkspace.waitForInitializeCall();
            mark('code/extHost/ready');
            this._readyToStartExtensionHost.open();
            if (this._initData.autoStart) {
                this._startExtensionHost();
            }
        }
        catch (err) {
            onUnexpectedError(err);
        }
    }
    async _deactivateAll() {
        this._storagePath.onWillDeactivateAll();
        let allPromises = [];
        try {
            const allExtensions = this._myRegistry.getAllExtensionDescriptions();
            const allExtensionsIds = ( (allExtensions.map(ext => ext.identifier)));
            const activatedExtensions = allExtensionsIds.filter(id => this.isActivated(id));
            allPromises = ( (activatedExtensions.map((extensionId) => {
                return this._deactivate(extensionId);
            })));
        }
        catch (err) {
        }
        await Promise.all(allPromises);
    }
    terminate(reason, code = 0) {
        if (this._isTerminating) {
            return;
        }
        this._isTerminating = true;
        this._logService.info(`Extension host terminating: ${reason}`);
        this._logService.flush();
        this._extHostTerminalService.dispose();
        this._activator.dispose();
        setUnexpectedErrorHandler((err) => {
            this._logService.error(err);
        });
        this._extHostContext.dispose();
        const extensionsDeactivated = this._deactivateAll();
        Promise.race([timeout(5000), extensionsDeactivated]).finally(() => {
            if (this._hostUtils.pid) {
                this._logService.info(`Extension host with pid ${this._hostUtils.pid} exiting with code ${code}`);
            }
            else {
                this._logService.info(`Extension host exiting with code ${code}`);
            }
            this._logService.flush();
            this._logService.dispose();
            this._hostUtils.exit(code);
        });
    }
    isActivated(extensionId) {
        if (this._readyToRunExtensions.isOpen()) {
            return this._activator.isActivated(extensionId);
        }
        return false;
    }
    async getExtension(extensionId) {
        const ext = await this._mainThreadExtensionsProxy.$getExtension(extensionId);
        let browserNlsBundleUris;
        if (ext?.browserNlsBundleUris) {
            browserNlsBundleUris = {};
            for (const language of ( (Object.keys(ext.browserNlsBundleUris)))) {
                browserNlsBundleUris[language] = URI.revive(ext.browserNlsBundleUris[language]);
            }
        }
        return ext && {
            ...ext,
            identifier: ( (new ExtensionIdentifier(ext.identifier.value))),
            extensionLocation: URI.revive(ext.extensionLocation),
            browserNlsBundleUris
        };
    }
    _activateByEvent(activationEvent, startup) {
        return this._activator.activateByEvent(activationEvent, startup);
    }
    _activateById(extensionId, reason) {
        return this._activator.activateById(extensionId, reason);
    }
    activateByIdWithErrors(extensionId, reason) {
        return this._activateById(extensionId, reason).then(() => {
            const extension = this._activator.getActivatedExtension(extensionId);
            if (extension.activationFailed) {
                return Promise.reject(extension.activationFailedError);
            }
            return undefined;
        });
    }
    getExtensionRegistry() {
        return this._readyToRunExtensions.wait().then(_ => this._myRegistry);
    }
    getExtensionExports(extensionId) {
        if (this._readyToRunExtensions.isOpen()) {
            return this._activator.getActivatedExtension(extensionId).exports;
        }
        else {
            return null;
        }
    }
    async _realPathExtensionUri(uri) {
        if (uri.scheme !== Schemas.file) {
            return uri;
        }
        const realpathValue = await this._hostUtils.realpath(uri.fsPath);
        return URI.file(realpathValue);
    }
    async getExtensionPathIndex() {
        if (!this._extensionPathIndex) {
            this._extensionPathIndex = this._createExtensionPathIndex(this._myRegistry.getAllExtensionDescriptions()).then((searchTree) => {
                return (
                     (new ExtensionPaths(searchTree))
                );
            });
        }
        return this._extensionPathIndex;
    }
    async _createExtensionPathIndex(extensions) {
        const tst = TernarySearchTree.forUris(key => {
            return extUriBiasedIgnorePathCase.ignorePathCasing(key);
        });
        await Promise.all(( (extensions.map(async (ext) => {
            if (this._getEntryPoint(ext)) {
                const uri = await this._realPathExtensionUri(ext.extensionLocation);
                tst.set(uri, ext);
            }
        }))));
        return tst;
    }
    _deactivate(extensionId) {
        let result = Promise.resolve(undefined);
        if (!this._readyToRunExtensions.isOpen()) {
            return result;
        }
        if (!this._activator.isActivated(extensionId)) {
            return result;
        }
        const extension = this._activator.getActivatedExtension(extensionId);
        if (!extension) {
            return result;
        }
        try {
            if (typeof extension.module.deactivate === 'function') {
                result = Promise.resolve(extension.module.deactivate()).then(undefined, (err) => {
                    this._logService.error(err);
                    return Promise.resolve(undefined);
                });
            }
        }
        catch (err) {
            this._logService.error(`An error occurred when deactivating the extension '${extensionId.value}':`);
            this._logService.error(err);
        }
        try {
            dispose(extension.subscriptions);
        }
        catch (err) {
            this._logService.error(`An error occurred when deactivating the subscriptions for extension '${extensionId.value}':`);
            this._logService.error(err);
        }
        return result;
    }
    async _activateExtension(extensionDescription, reason) {
        if (!this._initData.remote.isRemote) {
            await this._mainThreadExtensionsProxy.$onWillActivateExtension(extensionDescription.identifier);
        }
        else {
            this._mainThreadExtensionsProxy.$onWillActivateExtension(extensionDescription.identifier);
        }
        return this._doActivateExtension(extensionDescription, reason).then((activatedExtension) => {
            const activationTimes = activatedExtension.activationTimes;
            this._mainThreadExtensionsProxy.$onDidActivateExtension(extensionDescription.identifier, activationTimes.codeLoadingTime, activationTimes.activateCallTime, activationTimes.activateResolvedTime, reason);
            this._logExtensionActivationTimes(extensionDescription, reason, 'success', activationTimes);
            return activatedExtension;
        }, (err) => {
            this._logExtensionActivationTimes(extensionDescription, reason, 'failure');
            throw err;
        });
    }
    _logExtensionActivationTimes(extensionDescription, reason, outcome, activationTimes) {
        const event = getTelemetryActivationEvent(extensionDescription, reason);
        this._mainThreadTelemetryProxy.$publicLog2('extensionActivationTimes', {
            ...event,
            ...(activationTimes || {}),
            outcome
        });
    }
    _doActivateExtension(extensionDescription, reason) {
        const event = getTelemetryActivationEvent(extensionDescription, reason);
        this._mainThreadTelemetryProxy.$publicLog2('activatePlugin', event);
        const entryPoint = this._getEntryPoint(extensionDescription);
        if (!entryPoint) {
            return Promise.resolve(( (new EmptyExtension(ExtensionActivationTimes.NONE))));
        }
        this._logService.info(`ExtensionService#_doActivateExtension ${extensionDescription.identifier.value}, startup: ${reason.startup}, activationEvent: '${reason.activationEvent}'${extensionDescription.identifier.value !== reason.extensionId.value ? `, root cause: ${reason.extensionId.value}` : ``}`);
        this._logService.flush();
        const activationTimesBuilder = ( (new ExtensionActivationTimesBuilder(reason.startup)));
        return Promise.all([
            this._loadCommonJSModule(extensionDescription, joinPath(extensionDescription.extensionLocation, entryPoint), activationTimesBuilder),
            this._loadExtensionContext(extensionDescription)
        ]).then(values => {
            mark(`code/extHost/willActivateExtension/${extensionDescription.identifier.value}`);
            return AbstractExtHostExtensionService._callActivate(this._logService, extensionDescription.identifier, values[0], values[1], activationTimesBuilder);
        }).then((activatedExtension) => {
            mark(`code/extHost/didActivateExtension/${extensionDescription.identifier.value}`);
            return activatedExtension;
        });
    }
    _loadExtensionContext(extensionDescription) {
        const globalState = ( (new ExtensionGlobalMemento(extensionDescription, this._storage)));
        const workspaceState = ( (new ExtensionMemento(extensionDescription.identifier.value, false, this._storage)));
        const secrets = ( (new ExtensionSecrets(extensionDescription, this._secretState)));
        const extensionMode = extensionDescription.isUnderDevelopment
            ? (this._initData.environment.extensionTestsLocationURI ? ExtensionMode$1.Test : ExtensionMode$1.Development)
            : ExtensionMode$1.Production;
        const extensionKind = this._initData.remote.isRemote ? ExtensionKind$1.Workspace : ExtensionKind$1.UI;
        this._logService.trace(`ExtensionService#loadExtensionContext ${extensionDescription.identifier.value}`);
        return Promise.all([
            globalState.whenReady,
            workspaceState.whenReady,
            this._storagePath.whenReady
        ]).then(() => {
            const that = this;
            let extension;
            let messagePassingProtocol;
            const messagePort = isProposedApiEnabled(extensionDescription, 'ipc')
                ? this._initData.messagePorts?.get(ExtensionIdentifier.toKey(extensionDescription.identifier))
                : undefined;
            return (
                 (Object.freeze({
                    globalState,
                    workspaceState,
                    secrets,
                    subscriptions: [],
                    get extensionUri() { return extensionDescription.extensionLocation; },
                    get extensionPath() { return extensionDescription.extensionLocation.fsPath; },
                    asAbsolutePath(relativePath) { return join(extensionDescription.extensionLocation.fsPath, relativePath); },
                    get storagePath() { return that._storagePath.workspaceValue(extensionDescription)?.fsPath; },
                    get globalStoragePath() { return that._storagePath.globalValue(extensionDescription).fsPath; },
                    get logPath() { return join(that._initData.logsLocation.fsPath, extensionDescription.identifier.value); },
                    get logUri() { return URI.joinPath(that._initData.logsLocation, extensionDescription.identifier.value); },
                    get storageUri() { return that._storagePath.workspaceValue(extensionDescription); },
                    get globalStorageUri() { return that._storagePath.globalValue(extensionDescription); },
                    get extensionMode() { return extensionMode; },
                    get extension() {
                        if (extension === undefined) {
                            extension = ( (new Extension(
                                that,
                                extensionDescription.identifier,
                                extensionDescription,
                                extensionKind,
                                false
                            )));
                        }
                        return extension;
                    },
                    get extensionRuntime() {
                        checkProposedApiEnabled(extensionDescription, 'extensionRuntime');
                        return that.extensionRuntime;
                    },
                    get environmentVariableCollection() { return that._extHostTerminalService.getEnvironmentVariableCollection(extensionDescription); },
                    get messagePassingProtocol() {
                        if (!messagePassingProtocol) {
                            if (!messagePort) {
                                return undefined;
                            }
                            const onDidReceiveMessage = Event.buffer(Event.fromDOMEventEmitter(messagePort, 'message', e => e.data));
                            messagePort.start();
                            messagePassingProtocol = {
                                onDidReceiveMessage,
                                postMessage: messagePort.postMessage.bind(messagePort)
                            };
                        }
                        return messagePassingProtocol;
                    }
                }))
            );
        });
    }
    static _callActivate(logService, extensionId, extensionModule, context, activationTimesBuilder) {
        extensionModule = extensionModule || {
            activate: undefined,
            deactivate: undefined
        };
        return this._callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder).then((extensionExports) => {
            return (
                 (new ActivatedExtension(
                    false,
                    null,
                    activationTimesBuilder.build(),
                    extensionModule,
                    extensionExports,
                    context.subscriptions
                ))
            );
        });
    }
    static _callActivateOptional(logService, extensionId, extensionModule, context, activationTimesBuilder) {
        if (typeof extensionModule.activate === 'function') {
            try {
                activationTimesBuilder.activateCallStart();
                logService.trace(`ExtensionService#_callActivateOptional ${extensionId.value}`);
                const scope = typeof global === 'object' ? global : self;
                const activateResult = extensionModule.activate.apply(scope, [context]);
                activationTimesBuilder.activateCallStop();
                activationTimesBuilder.activateResolveStart();
                return Promise.resolve(activateResult).then((value) => {
                    activationTimesBuilder.activateResolveStop();
                    return value;
                });
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        else {
            return Promise.resolve(extensionModule);
        }
    }
    _activateOneStartupFinished(desc, activationEvent) {
        this._activateById(desc.identifier, {
            startup: false,
            extensionId: desc.identifier,
            activationEvent: activationEvent
        }).then(undefined, (err) => {
            this._logService.error(err);
        });
    }
    _activateAllStartupFinishedDeferred(extensions, start = 0) {
        const timeBudget = 50;
        const startTime = Date.now();
        setTimeout0(() => {
            for (let i = start; i < extensions.length; i += 1) {
                const desc = extensions[i];
                for (const activationEvent of (desc.activationEvents ?? [])) {
                    if (activationEvent === 'onStartupFinished') {
                        if (Date.now() - startTime > timeBudget) {
                            this._activateAllStartupFinishedDeferred(extensions, i);
                            break;
                        }
                        else {
                            this._activateOneStartupFinished(desc, activationEvent);
                        }
                    }
                }
            }
        });
    }
    _activateAllStartupFinished() {
        this._mainThreadExtensionsProxy.$setPerformanceMarks(getMarks());
        this._extHostConfiguration.getConfigProvider().then((configProvider) => {
            const shouldDeferActivation = configProvider.getConfiguration('extensions.experimental').get('deferredStartupFinishedActivation');
            const allExtensionDescriptions = this._myRegistry.getAllExtensionDescriptions();
            if (shouldDeferActivation) {
                this._activateAllStartupFinishedDeferred(allExtensionDescriptions);
            }
            else {
                for (const desc of allExtensionDescriptions) {
                    if (desc.activationEvents) {
                        for (const activationEvent of desc.activationEvents) {
                            if (activationEvent === 'onStartupFinished') {
                                this._activateOneStartupFinished(desc, activationEvent);
                            }
                        }
                    }
                }
            }
        });
    }
    _handleEagerExtensions() {
        const starActivation = this._activateByEvent('*', true).then(undefined, (err) => {
            this._logService.error(err);
        });
        this._register(this._extHostWorkspace.onDidChangeWorkspace((e) => this._handleWorkspaceContainsEagerExtensions(e.added)));
        const folders = this._extHostWorkspace.workspace ? this._extHostWorkspace.workspace.folders : [];
        const workspaceContainsActivation = this._handleWorkspaceContainsEagerExtensions(folders);
        const eagerExtensionsActivation = Promise.all([starActivation, workspaceContainsActivation]).then(() => { });
        Promise.race([eagerExtensionsActivation, timeout(10000)]).then(() => {
            this._activateAllStartupFinished();
        });
        return eagerExtensionsActivation;
    }
    _handleWorkspaceContainsEagerExtensions(folders) {
        if (folders.length === 0) {
            return Promise.resolve(undefined);
        }
        return Promise.all(( (this._myRegistry.getAllExtensionDescriptions().map((desc) => {
            return this._handleWorkspaceContainsEagerExtension(folders, desc);
        })))).then(() => { });
    }
    async _handleWorkspaceContainsEagerExtension(folders, desc) {
        if (this.isActivated(desc.identifier)) {
            return;
        }
        const localWithRemote = !this._initData.remote.isRemote && !!this._initData.remote.authority;
        const host = {
            logService: this._logService,
            folders: ( (folders.map(folder => folder.uri))),
            forceUsingSearch: localWithRemote,
            exists: (uri) => this._hostUtils.exists(uri.fsPath),
            checkExists: (folders, includes, token) => this._mainThreadWorkspaceProxy.$checkExists(folders, includes, token)
        };
        const result = await checkActivateWorkspaceContainsExtension(host, desc);
        if (!result) {
            return;
        }
        return (this._activateById(desc.identifier, { startup: true, extensionId: desc.identifier, activationEvent: result.activationEvent })
            .then(undefined, err => this._logService.error(err)));
    }
    async $extensionTestsExecute() {
        await this._eagerExtensionsActivated.wait();
        try {
            return await this._doHandleExtensionTests();
        }
        catch (error) {
            console.error(error);
            throw error;
        }
    }
    async _doHandleExtensionTests() {
        const { extensionDevelopmentLocationURI, extensionTestsLocationURI } = this._initData.environment;
        if (!extensionDevelopmentLocationURI || !extensionTestsLocationURI) {
            throw new Error(localize('extensionTestError1', "Cannot load test runner."));
        }
        const testRunner = await this._loadCommonJSModule(null, extensionTestsLocationURI, ( (new ExtensionActivationTimesBuilder(false))));
        if (!testRunner || typeof testRunner.run !== 'function') {
            throw new Error(localize('extensionTestError', "Path {0} does not point to a valid extension test runner.", extensionTestsLocationURI.toString()));
        }
        return (
             (new Promise((resolve, reject) => {
                const oldTestRunnerCallback = (error, failures) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve((typeof failures === 'number' && failures > 0) ? 1  : 0 );
                    }
                };
                const extensionTestsPath = originalFSPath(extensionTestsLocationURI);
                const runResult = testRunner.run(extensionTestsPath, oldTestRunnerCallback);
                if (runResult && runResult.then) {
                    runResult
                        .then(() => {
                        resolve(0);
                    })
                        .catch((err) => {
                        reject(err instanceof Error && err.stack ? err.stack : String(err));
                    });
                }
            }))
        );
    }
    _startExtensionHost() {
        if (this._started) {
            throw new Error(`Extension host is already started!`);
        }
        this._started = true;
        return this._readyToStartExtensionHost.wait()
            .then(() => this._readyToRunExtensions.open())
            .then(() => this._handleEagerExtensions())
            .then(() => {
            this._eagerExtensionsActivated.open();
            this._logService.info(`Eager extensions activated`);
        });
    }
    registerRemoteAuthorityResolver(authorityPrefix, resolver) {
        this._resolvers[authorityPrefix] = resolver;
        return toDisposable(() => {
            delete this._resolvers[authorityPrefix];
        });
    }
    async _activateAndGetResolver(remoteAuthority) {
        const authorityPlusIndex = remoteAuthority.indexOf('+');
        if (authorityPlusIndex === -1) {
            throw new Error(`Not an authority that can be resolved!`);
        }
        const authorityPrefix = remoteAuthority.substr(0, authorityPlusIndex);
        await this._almostReadyToRunExtensions.wait();
        await this._activateByEvent(`onResolveRemoteAuthority:${authorityPrefix}`, false);
        return { authorityPrefix, resolver: this._resolvers[authorityPrefix] };
    }
    async $resolveAuthority(remoteAuthority, resolveAttempt) {
        const sw = StopWatch.create(false);
        const prefix = () => `[resolveAuthority(${getRemoteAuthorityPrefix(remoteAuthority)},${resolveAttempt})][${sw.elapsed()}ms] `;
        const logInfo = (msg) => this._logService.info(`${prefix()}${msg}`);
        const logError = (msg, err = undefined) => this._logService.error(`${prefix()}${msg}`, err);
        logInfo(`activating resolver...`);
        const { authorityPrefix, resolver } = await this._activateAndGetResolver(remoteAuthority);
        if (!resolver) {
            logError(`no resolver`);
            return {
                type: 'error',
                error: {
                    code: RemoteAuthorityResolverErrorCode.NoResolverFound,
                    message: `No remote extension installed to resolve ${authorityPrefix}.`,
                    detail: undefined
                }
            };
        }
        const intervalLogger = ( (new IntervalTimer()));
        try {
            logInfo(`setting tunnel factory...`);
            this._register(await this._extHostTunnelService.setTunnelFactory(resolver));
            intervalLogger.cancelAndSet(() => logInfo('waiting...'), 1000);
            logInfo(`invoking resolve()...`);
            mark(`code/extHost/willResolveAuthority/${authorityPrefix}`);
            const result = await resolver.resolve(remoteAuthority, { resolveAttempt });
            mark(`code/extHost/didResolveAuthorityOK/${authorityPrefix}`);
            intervalLogger.dispose();
            logInfo(`returned ${result.host}:${result.port}`);
            const authority = {
                authority: remoteAuthority,
                host: result.host,
                port: result.port,
                connectionToken: result.connectionToken
            };
            const options = {
                extensionHostEnv: result.extensionHostEnv,
                isTrusted: result.isTrusted,
                authenticationSession: result.authenticationSessionForInitializingExtensions ? { id: result.authenticationSessionForInitializingExtensions.id, providerId: result.authenticationSessionForInitializingExtensions.providerId } : undefined
            };
            return {
                type: 'ok',
                value: {
                    authority,
                    options,
                    tunnelInformation: {
                        environmentTunnels: result.environmentTunnels,
                        features: result.tunnelFeatures
                    }
                }
            };
        }
        catch (err) {
            mark(`code/extHost/didResolveAuthorityError/${authorityPrefix}`);
            intervalLogger.dispose();
            logError(`returned an error`, err);
            if (err instanceof RemoteAuthorityResolverError) {
                return {
                    type: 'error',
                    error: {
                        code: err._code,
                        message: err._message,
                        detail: err._detail
                    }
                };
            }
            throw err;
        }
    }
    async $getCanonicalURI(remoteAuthority, uriComponents) {
        this._logService.info(`$getCanonicalURI invoked for authority (${getRemoteAuthorityPrefix(remoteAuthority)})`);
        const { resolver } = await this._activateAndGetResolver(remoteAuthority);
        if (!resolver) {
            return null;
        }
        const uri = URI.revive(uriComponents);
        if (typeof resolver.getCanonicalURI === 'undefined') {
            return uri;
        }
        const result = await asPromise(() => resolver.getCanonicalURI(uri));
        if (!result) {
            return uri;
        }
        return result;
    }
    static _applyExtensionsDelta(oldGlobalRegistry, oldMyRegistry, extensionsDelta) {
        const globalRegistry = ( (new ExtensionDescriptionRegistry(oldGlobalRegistry.getAllExtensionDescriptions())));
        globalRegistry.deltaExtensions(extensionsDelta.toAdd, extensionsDelta.toRemove);
        const myExtensionsSet = extensionIdentifiersArrayToSet(( (oldMyRegistry.getAllExtensionDescriptions().map(extension => extension.identifier))));
        for (const extensionId of extensionsDelta.myToRemove) {
            myExtensionsSet.delete(ExtensionIdentifier.toKey(extensionId));
        }
        for (const extensionId of extensionsDelta.myToAdd) {
            myExtensionsSet.add(ExtensionIdentifier.toKey(extensionId));
        }
        const myExtensions = filterExtensions(globalRegistry, myExtensionsSet);
        return { globalRegistry, myExtensions };
    }
    $startExtensionHost(extensionsDelta) {
        extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = URI.revive(extension.extensionLocation));
        const { globalRegistry, myExtensions } = AbstractExtHostExtensionService._applyExtensionsDelta(this._globalRegistry, this._myRegistry, extensionsDelta);
        this._globalRegistry.set(globalRegistry.getAllExtensionDescriptions());
        this._myRegistry.set(myExtensions);
        return this._startExtensionHost();
    }
    $activateByEvent(activationEvent, activationKind) {
        if (activationKind === 1 ) {
            return this._activateByEvent(activationEvent, false);
        }
        return (this._readyToRunExtensions.wait()
            .then(_ => this._activateByEvent(activationEvent, false)));
    }
    async $activate(extensionId, reason) {
        await this._readyToRunExtensions.wait();
        if (!this._myRegistry.getExtensionDescription(extensionId)) {
            return false;
        }
        await this._activateById(extensionId, reason);
        return true;
    }
    async $deltaExtensions(extensionsDelta) {
        extensionsDelta.toAdd.forEach((extension) => extension.extensionLocation = URI.revive(extension.extensionLocation));
        const { globalRegistry, myExtensions } = AbstractExtHostExtensionService._applyExtensionsDelta(this._globalRegistry, this._myRegistry, extensionsDelta);
        const newSearchTree = await this._createExtensionPathIndex(myExtensions);
        const extensionsPaths = await this.getExtensionPathIndex();
        extensionsPaths.setSearchTree(newSearchTree);
        this._globalRegistry.set(globalRegistry.getAllExtensionDescriptions());
        this._myRegistry.set(myExtensions);
        return Promise.resolve(undefined);
    }
    async $test_latency(n) {
        return n;
    }
    async $test_up(b) {
        return b.byteLength;
    }
    async $test_down(size) {
        const buff = VSBuffer.alloc(size);
        const value = Math.random() % 256;
        for (let i = 0; i < size; i++) {
            buff.writeUInt8(value, i);
        }
        return buff;
    }
    async $updateRemoteConnectionData(connectionData) {
        this._remoteConnectionData = connectionData;
        this._onDidChangeRemoteConnectionData.fire();
    }
};
AbstractExtHostExtensionService = ( (__decorate([
    ( (__param(0, IInstantiationService))),
    ( (__param(1, IHostUtils))),
    ( (__param(2, IExtHostRpcService))),
    ( (__param(3, IExtHostWorkspace))),
    ( (__param(4, IExtHostConfiguration))),
    ( (__param(5, ILogService))),
    ( (__param(6, IExtHostInitDataService))),
    ( (__param(7, IExtensionStoragePaths))),
    ( (__param(8, IExtHostTunnelService))),
    ( (__param(9, IExtHostTerminalService))),
    ( (__param(10, IExtHostLocalizationService)))
], AbstractExtHostExtensionService)));
function getTelemetryActivationEvent(extensionDescription, reason) {
    const event = {
        id: extensionDescription.identifier.value,
        name: extensionDescription.name,
        extensionVersion: extensionDescription.version,
        publisherDisplayName: extensionDescription.publisher,
        activationEvents: extensionDescription.activationEvents ? extensionDescription.activationEvents.join(',') : null,
        isBuiltin: extensionDescription.isBuiltin,
        reason: reason.activationEvent,
        reasonId: reason.extensionId.value,
    };
    return event;
}
const IExtHostExtensionService = ( (createDecorator$1('IExtHostExtensionService')));
class Extension {
    constructor(extensionService, originExtensionId, description, kind, isFromDifferentExtensionHost) {
        _Extension_extensionService.set(this, void 0);
        _Extension_originExtensionId.set(this, void 0);
        _Extension_identifier.set(this, void 0);
        __classPrivateFieldSet(this, _Extension_extensionService, extensionService, "f");
        __classPrivateFieldSet(this, _Extension_originExtensionId, originExtensionId, "f");
        __classPrivateFieldSet(this, _Extension_identifier, description.identifier, "f");
        this.id = description.identifier.value;
        this.extensionUri = description.extensionLocation;
        this.extensionPath = normalize(originalFSPath(description.extensionLocation));
        this.packageJSON = description;
        this.extensionKind = kind;
        this.isFromDifferentExtensionHost = isFromDifferentExtensionHost;
    }
    get isActive() {
        return __classPrivateFieldGet(this, _Extension_extensionService, "f").isActivated(__classPrivateFieldGet(this, _Extension_identifier, "f"));
    }
    get exports() {
        if (this.packageJSON.api === 'none' || this.isFromDifferentExtensionHost) {
            return undefined;
        }
        return __classPrivateFieldGet(this, _Extension_extensionService, "f").getExtensionExports(__classPrivateFieldGet(this, _Extension_identifier, "f"));
    }
    async activate() {
        if (this.isFromDifferentExtensionHost) {
            throw new Error('Cannot activate foreign extension');
        }
        await __classPrivateFieldGet(this, _Extension_extensionService, "f").activateByIdWithErrors(__classPrivateFieldGet(this, _Extension_identifier, "f"), { startup: false, extensionId: __classPrivateFieldGet(this, _Extension_originExtensionId, "f"), activationEvent: 'api' });
        return this.exports;
    }
}
_Extension_extensionService = ( (new WeakMap())), _Extension_originExtensionId = ( (new WeakMap())), _Extension_identifier = ( (new WeakMap()));
function filterExtensions(globalRegistry, desiredExtensions) {
    return globalRegistry.getAllExtensionDescriptions().filter(extension => desiredExtensions.has(ExtensionIdentifier.toKey(extension.identifier)));
}
class ExtensionPaths {
    constructor(_searchTree) {
        this._searchTree = _searchTree;
    }
    setSearchTree(searchTree) {
        this._searchTree = searchTree;
    }
    findSubstr(key) {
        return this._searchTree.findSubstr(key);
    }
    forEach(callback) {
        return this._searchTree.forEach(callback);
    }
}
class AbstractDebugAdapter {
    constructor() {
        this.pendingRequests = ( (new Map()));
        this.queue = [];
        this._onError = ( (new Emitter$1()));
        this._onExit = ( (new Emitter$1()));
        this.sequence = 1;
    }
    get onError() {
        return this._onError.event;
    }
    get onExit() {
        return this._onExit.event;
    }
    onMessage(callback) {
        if (this.messageCallback) {
            this._onError.fire(( (new Error(`attempt to set more than one 'Message' callback`))));
        }
        this.messageCallback = callback;
    }
    onEvent(callback) {
        if (this.eventCallback) {
            this._onError.fire(( (new Error(`attempt to set more than one 'Event' callback`))));
        }
        this.eventCallback = callback;
    }
    onRequest(callback) {
        if (this.requestCallback) {
            this._onError.fire(( (new Error(`attempt to set more than one 'Request' callback`))));
        }
        this.requestCallback = callback;
    }
    sendResponse(response) {
        if (response.seq > 0) {
            this._onError.fire(( (new Error(`attempt to send more than one response for command ${response.command}`))));
        }
        else {
            this.internalSend('response', response);
        }
    }
    sendRequest(command, args, clb, timeout) {
        const request = {
            command: command
        };
        if (args && ( (Object.keys(args))).length > 0) {
            request.arguments = args;
        }
        this.internalSend('request', request);
        if (typeof timeout === 'number') {
            const timer = setTimeout(() => {
                clearTimeout(timer);
                const clb = this.pendingRequests.get(request.seq);
                if (clb) {
                    this.pendingRequests.delete(request.seq);
                    const err = {
                        type: 'response',
                        seq: 0,
                        request_seq: request.seq,
                        success: false,
                        command,
                        message: ( (localize('timeout', "Timeout after {0} ms for '{1}'", timeout, command)))
                    };
                    clb(err);
                }
            }, timeout);
        }
        if (clb) {
            this.pendingRequests.set(request.seq, clb);
        }
        return request.seq;
    }
    acceptMessage(message) {
        if (this.messageCallback) {
            this.messageCallback(message);
        }
        else {
            this.queue.push(message);
            if (this.queue.length === 1) {
                this.processQueue();
            }
        }
    }
    needsTaskBoundaryBetween(messageA, messageB) {
        return messageA.type !== 'event' || messageB.type !== 'event';
    }
    async processQueue() {
        let message;
        while (this.queue.length) {
            if (!message || this.needsTaskBoundaryBetween(this.queue[0], message)) {
                await timeout(0);
            }
            message = this.queue.shift();
            if (!message) {
                return;
            }
            switch (message.type) {
                case 'event':
                    this.eventCallback?.(message);
                    break;
                case 'request':
                    this.requestCallback?.(message);
                    break;
                case 'response': {
                    const response = message;
                    const clb = this.pendingRequests.get(response.request_seq);
                    if (clb) {
                        this.pendingRequests.delete(response.request_seq);
                        clb(response);
                    }
                    break;
                }
            }
        }
    }
    internalSend(typ, message) {
        message.type = typ;
        message.seq = this.sequence++;
        this.sendMessage(message);
    }
    async cancelPendingRequests() {
        if (this.pendingRequests.size === 0) {
            return Promise.resolve();
        }
        const pending = ( (new Map()));
        this.pendingRequests.forEach((value, key) => pending.set(key, value));
        await timeout(500);
        pending.forEach((callback, request_seq) => {
            const err = {
                type: 'response',
                seq: 0,
                request_seq,
                success: false,
                command: 'canceled',
                message: 'canceled'
            };
            callback(err);
            this.pendingRequests.delete(request_seq);
        });
    }
    getPendingRequestIds() {
        return Array.from(( (this.pendingRequests.keys())));
    }
    dispose() {
        this.queue = [];
    }
}
const IExtHostVariableResolverProvider = ( (createDecorator$1('IExtHostVariableResolverProvider')));
class ExtHostVariableResolverService extends AbstractVariableResolverService {
    constructor(extensionService, workspaceService, editorService, editorTabs, configProvider, context, homeDir) {
        function getActiveUri() {
            if (editorService) {
                const activeEditor = editorService.activeEditor();
                if (activeEditor) {
                    return activeEditor.document.uri;
                }
                const activeTab = editorTabs.tabGroups.all.find(group => group.isActive)?.activeTab;
                if (activeTab !== undefined) {
                    if (activeTab.input instanceof TextDiffTabInput || activeTab.input instanceof NotebookDiffEditorTabInput) {
                        return activeTab.input.modified;
                    }
                    else if (activeTab.input instanceof TextTabInput$1 || activeTab.input instanceof NotebookEditorTabInput || activeTab.input instanceof CustomEditorTabInput) {
                        return activeTab.input.uri;
                    }
                }
            }
            return undefined;
        }
        super({
            getFolderUri: (folderName) => {
                const found = context.folders.filter(f => f.name === folderName);
                if (found && found.length > 0) {
                    return found[0].uri;
                }
                return undefined;
            },
            getWorkspaceFolderCount: () => {
                return context.folders.length;
            },
            getConfigurationValue: (folderUri, section) => {
                return configProvider.getConfiguration(undefined, folderUri).get(section);
            },
            getAppRoot: () => {
                return cwd();
            },
            getExecPath: () => {
                return env$1['VSCODE_EXEC_PATH'];
            },
            getFilePath: () => {
                const activeUri = getActiveUri();
                if (activeUri) {
                    return normalize(activeUri.fsPath);
                }
                return undefined;
            },
            getWorkspaceFolderPathForFile: () => {
                if (workspaceService) {
                    const activeUri = getActiveUri();
                    if (activeUri) {
                        const ws = workspaceService.getWorkspaceFolder(activeUri);
                        if (ws) {
                            return normalize(ws.uri.fsPath);
                        }
                    }
                }
                return undefined;
            },
            getSelectedText: () => {
                if (editorService) {
                    const activeEditor = editorService.activeEditor();
                    if (activeEditor && !activeEditor.selection.isEmpty) {
                        return activeEditor.document.getText(activeEditor.selection);
                    }
                }
                return undefined;
            },
            getLineNumber: () => {
                if (editorService) {
                    const activeEditor = editorService.activeEditor();
                    if (activeEditor) {
                        return String(activeEditor.selection.end.line + 1);
                    }
                }
                return undefined;
            },
            getExtension: (id) => {
                return extensionService.getExtension(id);
            },
        }, undefined, homeDir ? Promise.resolve(homeDir) : undefined, Promise.resolve(env$1));
    }
}
let ExtHostVariableResolverProviderService = class ExtHostVariableResolverProviderService extends Disposable$1 {
    constructor(extensionService, workspaceService, editorService, configurationService, editorTabs) {
        super();
        this.extensionService = extensionService;
        this.workspaceService = workspaceService;
        this.editorService = editorService;
        this.configurationService = configurationService;
        this.editorTabs = editorTabs;
        this._resolver = ( (new Lazy(async () => {
            const configProvider = await this.configurationService.getConfigProvider();
            const folders = (await this.workspaceService.getWorkspaceFolders2()) || [];
            const dynamic = { folders };
            this._register(this.workspaceService.onDidChangeWorkspace(async (e) => {
                dynamic.folders = (await this.workspaceService.getWorkspaceFolders2()) || [];
            }));
            return (
                 (new ExtHostVariableResolverService(
                    this.extensionService,
                    this.workspaceService,
                    this.editorService,
                    this.editorTabs,
                    configProvider,
                    dynamic,
                    this.homeDir()
                ))
            );
        })));
    }
    getResolver() {
        return this._resolver.value;
    }
    homeDir() {
        return undefined;
    }
};
ExtHostVariableResolverProviderService = ( (__decorate([
    ( (__param(0, IExtHostExtensionService))),
    ( (__param(1, IExtHostWorkspace))),
    ( (__param(2, IExtHostDocumentsAndEditors))),
    ( (__param(3, IExtHostConfiguration))),
    ( (__param(4, IExtHostEditorTabs)))
], ExtHostVariableResolverProviderService)));
const IExtHostDebugService = ( (createDecorator$1('IExtHostDebugService')));
let ExtHostDebugServiceBase = class ExtHostDebugServiceBase {
    get onDidStartDebugSession() { return this._onDidStartDebugSession.event; }
    get onDidTerminateDebugSession() { return this._onDidTerminateDebugSession.event; }
    get onDidChangeActiveDebugSession() { return this._onDidChangeActiveDebugSession.event; }
    get activeDebugSession() { return this._activeDebugSession; }
    get onDidReceiveDebugSessionCustomEvent() { return this._onDidReceiveDebugSessionCustomEvent.event; }
    get activeDebugConsole() { return this._activeDebugConsole.value; }
    constructor(extHostRpcService, _workspaceService, _extensionService, _configurationService, _editorTabs, _variableResolver) {
        this._workspaceService = _workspaceService;
        this._extensionService = _extensionService;
        this._configurationService = _configurationService;
        this._editorTabs = _editorTabs;
        this._variableResolver = _variableResolver;
        this._debugSessions = ( (new Map()));
        this._configProviderHandleCounter = 0;
        this._configProviders = [];
        this._adapterFactoryHandleCounter = 0;
        this._adapterFactories = [];
        this._trackerFactoryHandleCounter = 0;
        this._trackerFactories = [];
        this._debugAdapters = ( (new Map()));
        this._debugAdaptersTrackers = ( (new Map()));
        this._onDidStartDebugSession = ( (new Emitter$1()));
        this._onDidTerminateDebugSession = ( (new Emitter$1()));
        this._onDidChangeActiveDebugSession = ( (new Emitter$1()));
        this._onDidReceiveDebugSessionCustomEvent = ( (new Emitter$1()));
        this._debugServiceProxy = ( (extHostRpcService.getProxy(MainContext.MainThreadDebugService)));
        this._onDidChangeBreakpoints = ( (new Emitter$1({
            onWillAddFirstListener: () => {
                this.startBreakpoints();
            }
        })));
        this._activeDebugConsole = ( (new ExtHostDebugConsole(this._debugServiceProxy)));
        this._breakpoints = ( (new Map()));
        this._breakpointEventsActive = false;
        this._extensionService.getExtensionRegistry().then((extensionRegistry) => {
            extensionRegistry.onDidChange(_ => {
                this.registerAllDebugTypes(extensionRegistry);
            });
            this.registerAllDebugTypes(extensionRegistry);
        });
    }
    asDebugSourceUri(src, session) {
        const source = src;
        if (typeof source.sourceReference === 'number' && source.sourceReference > 0) {
            let debug = `debug:${encodeURIComponent(source.path || '')}`;
            let sep = '?';
            if (session) {
                debug += `${sep}session=${encodeURIComponent(session.id)}`;
                sep = '&';
            }
            debug += `${sep}ref=${source.sourceReference}`;
            return (
                 (URI.parse(debug))
            );
        }
        else if (source.path) {
            return URI.file(source.path);
        }
        else {
            throw new Error(`cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.`);
        }
    }
    registerAllDebugTypes(extensionRegistry) {
        const debugTypes = [];
        for (const ed of extensionRegistry.getAllExtensionDescriptions()) {
            if (ed.contributes) {
                const debuggers = ed.contributes['debuggers'];
                if (debuggers && debuggers.length > 0) {
                    for (const dbg of debuggers) {
                        if (isDebuggerMainContribution(dbg)) {
                            debugTypes.push(dbg.type);
                        }
                    }
                }
            }
        }
        this._debugServiceProxy.$registerDebugTypes(debugTypes);
    }
    get onDidChangeBreakpoints() {
        return this._onDidChangeBreakpoints.event;
    }
    get breakpoints() {
        this.startBreakpoints();
        const result = [];
        this._breakpoints.forEach(bp => result.push(bp));
        return result;
    }
    addBreakpoints(breakpoints0) {
        this.startBreakpoints();
        const breakpoints = breakpoints0.filter(bp => {
            const id = bp.id;
            if (!this._breakpoints.has(id)) {
                this._breakpoints.set(id, bp);
                return true;
            }
            return false;
        });
        this.fireBreakpointChanges(breakpoints, [], []);
        const dtos = [];
        const map = ( (new Map()));
        for (const bp of breakpoints) {
            if (bp instanceof SourceBreakpoint$1) {
                let dto = map.get(( (bp.location.uri.toString())));
                if (!dto) {
                    dto = {
                        type: 'sourceMulti',
                        uri: bp.location.uri,
                        lines: []
                    };
                    map.set(( (bp.location.uri.toString())), dto);
                    dtos.push(dto);
                }
                dto.lines.push({
                    id: bp.id,
                    enabled: bp.enabled,
                    condition: bp.condition,
                    hitCondition: bp.hitCondition,
                    logMessage: bp.logMessage,
                    line: bp.location.range.start.line,
                    character: bp.location.range.start.character
                });
            }
            else if (bp instanceof FunctionBreakpoint$1) {
                dtos.push({
                    type: 'function',
                    id: bp.id,
                    enabled: bp.enabled,
                    hitCondition: bp.hitCondition,
                    logMessage: bp.logMessage,
                    condition: bp.condition,
                    functionName: bp.functionName
                });
            }
        }
        return this._debugServiceProxy.$registerBreakpoints(dtos);
    }
    removeBreakpoints(breakpoints0) {
        this.startBreakpoints();
        const breakpoints = breakpoints0.filter(b => this._breakpoints.delete(b.id));
        this.fireBreakpointChanges([], breakpoints, []);
        const ids = ( (breakpoints.filter(bp => bp instanceof SourceBreakpoint$1).map(bp => bp.id)));
        const fids = ( (breakpoints.filter(bp => bp instanceof FunctionBreakpoint$1).map(bp => bp.id)));
        const dids = ( (breakpoints.filter(bp => bp instanceof DataBreakpoint).map(bp => bp.id)));
        return this._debugServiceProxy.$unregisterBreakpoints(ids, fids, dids);
    }
    startDebugging(folder, nameOrConfig, options) {
        return this._debugServiceProxy.$startDebugging(folder ? folder.uri : undefined, nameOrConfig, {
            parentSessionID: options.parentSession ? options.parentSession.id : undefined,
            lifecycleManagedByParent: options.lifecycleManagedByParent,
            repl: options.consoleMode === DebugConsoleMode$1.MergeWithParent ? 'mergeWithParent' : 'separate',
            noDebug: options.noDebug,
            compact: options.compact,
            suppressSaveBeforeStart: options.suppressSaveBeforeStart,
            suppressDebugStatusbar: options.suppressDebugStatusbar ?? options.debugUI?.simple,
            suppressDebugToolbar: options.suppressDebugToolbar ?? options.debugUI?.simple,
            suppressDebugView: options.suppressDebugView ?? options.debugUI?.simple,
        });
    }
    stopDebugging(session) {
        return this._debugServiceProxy.$stopDebugging(session ? session.id : undefined);
    }
    registerDebugConfigurationProvider(type, provider, trigger) {
        if (!provider) {
            return (
                 (new Disposable$2(() => { }))
            );
        }
        const handle = this._configProviderHandleCounter++;
        this._configProviders.push({ type, handle, provider });
        this._debugServiceProxy.$registerDebugConfigurationProvider(type, trigger, !!provider.provideDebugConfigurations, !!provider.resolveDebugConfiguration, !!provider.resolveDebugConfigurationWithSubstitutedVariables, handle);
        return (
             (new Disposable$2(() => {
                this._configProviders = this._configProviders.filter(p => p.provider !== provider);
                this._debugServiceProxy.$unregisterDebugConfigurationProvider(handle);
            }))
        );
    }
    registerDebugAdapterDescriptorFactory(extension, type, factory) {
        if (!factory) {
            return (
                 (new Disposable$2(() => { }))
            );
        }
        if (!this.definesDebugType(extension, type)) {
            throw new Error(`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${type}' debugger.`);
        }
        if (this.getAdapterDescriptorFactoryByType(type)) {
            throw new Error(`a DebugAdapterDescriptorFactory can only be registered once per a type.`);
        }
        const handle = this._adapterFactoryHandleCounter++;
        this._adapterFactories.push({ type, handle, factory });
        this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(type, handle);
        return (
             (new Disposable$2(() => {
                this._adapterFactories = this._adapterFactories.filter(p => p.factory !== factory);
                this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(handle);
            }))
        );
    }
    registerDebugAdapterTrackerFactory(type, factory) {
        if (!factory) {
            return (
                 (new Disposable$2(() => { }))
            );
        }
        const handle = this._trackerFactoryHandleCounter++;
        this._trackerFactories.push({ type, handle, factory });
        return (
             (new Disposable$2(() => {
                this._trackerFactories = this._trackerFactories.filter(p => p.factory !== factory);
            }))
        );
    }
    async $runInTerminal(args, sessionId) {
        return Promise.resolve(undefined);
    }
    async $substituteVariables(folderUri, config) {
        let ws;
        const folder = await this.getFolder(folderUri);
        if (folder) {
            ws = {
                uri: folder.uri,
                name: folder.name,
                index: folder.index,
                toResource: () => {
                    throw new Error('Not implemented');
                }
            };
        }
        const variableResolver = await this._variableResolver.getResolver();
        return variableResolver.resolveAnyAsync(ws, config);
    }
    createDebugAdapter(adapter, session) {
        if (adapter.type === 'implementation') {
            return (
                 (new DirectDebugAdapter(adapter.implementation))
            );
        }
        return undefined;
    }
    createSignService() {
        return undefined;
    }
    async $startDASession(debugAdapterHandle, sessionDto) {
        const mythis = this;
        const session = await this.getSession(sessionDto);
        return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(session.type), session).then(daDescriptor => {
            if (!daDescriptor) {
                throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}' (extension might have failed to activate)`);
            }
            const adapterDescriptor = this.convertToDto(daDescriptor);
            const da = this.createDebugAdapter(adapterDescriptor, session);
            if (!da) {
                throw new Error(`Couldn't create a debug adapter for type '${session.type}'.`);
            }
            const debugAdapter = da;
            this._debugAdapters.set(debugAdapterHandle, debugAdapter);
            return this.getDebugAdapterTrackers(session).then(tracker => {
                if (tracker) {
                    this._debugAdaptersTrackers.set(debugAdapterHandle, tracker);
                }
                debugAdapter.onMessage(async (message) => {
                    if (message.type === 'request' && message.command === 'handshake') {
                        const request = message;
                        const response = {
                            type: 'response',
                            seq: 0,
                            command: request.command,
                            request_seq: request.seq,
                            success: true
                        };
                        if (!this._signService) {
                            this._signService = this.createSignService();
                        }
                        try {
                            if (this._signService) {
                                const signature = await this._signService.sign(request.arguments.value);
                                response.body = {
                                    signature: signature
                                };
                                debugAdapter.sendResponse(response);
                            }
                            else {
                                throw new Error('no signer');
                            }
                        }
                        catch (e) {
                            response.success = false;
                            response.message = e.message;
                            debugAdapter.sendResponse(response);
                        }
                    }
                    else {
                        if (tracker && tracker.onDidSendMessage) {
                            tracker.onDidSendMessage(message);
                        }
                        message = convertToVSCPaths(message, true);
                        mythis._debugServiceProxy.$acceptDAMessage(debugAdapterHandle, message);
                    }
                });
                debugAdapter.onError(err => {
                    if (tracker && tracker.onError) {
                        tracker.onError(err);
                    }
                    this._debugServiceProxy.$acceptDAError(debugAdapterHandle, err.name, err.message, err.stack);
                });
                debugAdapter.onExit((code) => {
                    if (tracker && tracker.onExit) {
                        tracker.onExit(withNullAsUndefined(code), undefined);
                    }
                    this._debugServiceProxy.$acceptDAExit(debugAdapterHandle, withNullAsUndefined(code), undefined);
                });
                if (tracker && tracker.onWillStartSession) {
                    tracker.onWillStartSession();
                }
                return debugAdapter.startSession();
            });
        });
    }
    $sendDAMessage(debugAdapterHandle, message) {
        message = convertToDAPaths(message, false);
        const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);
        if (tracker && tracker.onWillReceiveMessage) {
            tracker.onWillReceiveMessage(message);
        }
        const da = this._debugAdapters.get(debugAdapterHandle);
        da?.sendMessage(message);
    }
    $stopDASession(debugAdapterHandle) {
        const tracker = this._debugAdaptersTrackers.get(debugAdapterHandle);
        this._debugAdaptersTrackers.delete(debugAdapterHandle);
        if (tracker && tracker.onWillStopSession) {
            tracker.onWillStopSession();
        }
        const da = this._debugAdapters.get(debugAdapterHandle);
        this._debugAdapters.delete(debugAdapterHandle);
        if (da) {
            return da.stopSession();
        }
        else {
            return Promise.resolve(void 0);
        }
    }
    $acceptBreakpointsDelta(delta) {
        const a = [];
        const r = [];
        const c = [];
        if (delta.added) {
            for (const bpd of delta.added) {
                const id = bpd.id;
                if (id && !this._breakpoints.has(id)) {
                    let bp;
                    if (bpd.type === 'function') {
                        bp = ( (new FunctionBreakpoint$1(
                            bpd.functionName,
                            bpd.enabled,
                            bpd.condition,
                            bpd.hitCondition,
                            bpd.logMessage
                        )));
                    }
                    else if (bpd.type === 'data') {
                        bp = ( (new DataBreakpoint(
                            bpd.label,
                            bpd.dataId,
                            bpd.canPersist,
                            bpd.enabled,
                            bpd.hitCondition,
                            bpd.condition,
                            bpd.logMessage
                        )));
                    }
                    else {
                        const uri = URI.revive(bpd.uri);
                        bp = ( (new SourceBreakpoint$1(
                             (new Location$1(uri,  (new Position$3(bpd.line, bpd.character)))),
                            bpd.enabled,
                            bpd.condition,
                            bpd.hitCondition,
                            bpd.logMessage
                        )));
                    }
                    setBreakpointId(bp, id);
                    this._breakpoints.set(id, bp);
                    a.push(bp);
                }
            }
        }
        if (delta.removed) {
            for (const id of delta.removed) {
                const bp = this._breakpoints.get(id);
                if (bp) {
                    this._breakpoints.delete(id);
                    r.push(bp);
                }
            }
        }
        if (delta.changed) {
            for (const bpd of delta.changed) {
                if (bpd.id) {
                    const bp = this._breakpoints.get(bpd.id);
                    if (bp) {
                        if (bp instanceof FunctionBreakpoint$1 && bpd.type === 'function') {
                            const fbp = bp;
                            fbp.enabled = bpd.enabled;
                            fbp.condition = bpd.condition;
                            fbp.hitCondition = bpd.hitCondition;
                            fbp.logMessage = bpd.logMessage;
                            fbp.functionName = bpd.functionName;
                        }
                        else if (bp instanceof SourceBreakpoint$1 && bpd.type === 'source') {
                            const sbp = bp;
                            sbp.enabled = bpd.enabled;
                            sbp.condition = bpd.condition;
                            sbp.hitCondition = bpd.hitCondition;
                            sbp.logMessage = bpd.logMessage;
                            sbp.location = ( (new Location$1(
                                URI.revive(bpd.uri),
                                 (new Position$3(bpd.line, bpd.character))
                            )));
                        }
                        c.push(bp);
                    }
                }
            }
        }
        this.fireBreakpointChanges(a, r, c);
    }
    $provideDebugConfigurations(configProviderHandle, folderUri, token) {
        return asPromise(async () => {
            const provider = this.getConfigProviderByHandle(configProviderHandle);
            if (!provider) {
                throw new Error('no DebugConfigurationProvider found');
            }
            if (!provider.provideDebugConfigurations) {
                throw new Error('DebugConfigurationProvider has no method provideDebugConfigurations');
            }
            const folder = await this.getFolder(folderUri);
            return provider.provideDebugConfigurations(folder, token);
        }).then(debugConfigurations => {
            if (!debugConfigurations) {
                throw new Error('nothing returned from DebugConfigurationProvider.provideDebugConfigurations');
            }
            return debugConfigurations;
        });
    }
    $resolveDebugConfiguration(configProviderHandle, folderUri, debugConfiguration, token) {
        return asPromise(async () => {
            const provider = this.getConfigProviderByHandle(configProviderHandle);
            if (!provider) {
                throw new Error('no DebugConfigurationProvider found');
            }
            if (!provider.resolveDebugConfiguration) {
                throw new Error('DebugConfigurationProvider has no method resolveDebugConfiguration');
            }
            const folder = await this.getFolder(folderUri);
            return provider.resolveDebugConfiguration(folder, debugConfiguration, token);
        });
    }
    $resolveDebugConfigurationWithSubstitutedVariables(configProviderHandle, folderUri, debugConfiguration, token) {
        return asPromise(async () => {
            const provider = this.getConfigProviderByHandle(configProviderHandle);
            if (!provider) {
                throw new Error('no DebugConfigurationProvider found');
            }
            if (!provider.resolveDebugConfigurationWithSubstitutedVariables) {
                throw new Error('DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables');
            }
            const folder = await this.getFolder(folderUri);
            return provider.resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfiguration, token);
        });
    }
    async $provideDebugAdapter(adapterFactoryHandle, sessionDto) {
        const adapterDescriptorFactory = this.getAdapterDescriptorFactoryByHandle(adapterFactoryHandle);
        if (!adapterDescriptorFactory) {
            return Promise.reject(( (new Error('no adapter descriptor factory found for handle'))));
        }
        const session = await this.getSession(sessionDto);
        return this.getAdapterDescriptor(adapterDescriptorFactory, session).then(adapterDescriptor => {
            if (!adapterDescriptor) {
                throw new Error(`Couldn't find a debug adapter descriptor for debug type '${session.type}'`);
            }
            return this.convertToDto(adapterDescriptor);
        });
    }
    async $acceptDebugSessionStarted(sessionDto) {
        const session = await this.getSession(sessionDto);
        this._onDidStartDebugSession.fire(session);
    }
    async $acceptDebugSessionTerminated(sessionDto) {
        const session = await this.getSession(sessionDto);
        if (session) {
            this._onDidTerminateDebugSession.fire(session);
            this._debugSessions.delete(session.id);
        }
    }
    async $acceptDebugSessionActiveChanged(sessionDto) {
        this._activeDebugSession = sessionDto ? await this.getSession(sessionDto) : undefined;
        this._onDidChangeActiveDebugSession.fire(this._activeDebugSession);
    }
    async $acceptDebugSessionNameChanged(sessionDto, name) {
        const session = await this.getSession(sessionDto);
        session?._acceptNameChanged(name);
    }
    async $acceptDebugSessionCustomEvent(sessionDto, event) {
        const session = await this.getSession(sessionDto);
        const ee = {
            session: session,
            event: event.event,
            body: event.body
        };
        this._onDidReceiveDebugSessionCustomEvent.fire(ee);
    }
    convertToDto(x) {
        if (x instanceof DebugAdapterExecutable$1) {
            return {
                type: 'executable',
                command: x.command,
                args: x.args,
                options: x.options
            };
        }
        else if (x instanceof DebugAdapterServer$1) {
            return {
                type: 'server',
                port: x.port,
                host: x.host
            };
        }
        else if (x instanceof DebugAdapterNamedPipeServer$1) {
            return {
                type: 'pipeServer',
                path: x.path
            };
        }
        else if (x instanceof DebugAdapterInlineImplementation$1) {
            return {
                type: 'implementation',
                implementation: x.implementation
            };
        }
        else {
            throw new Error('convertToDto unexpected type');
        }
    }
    getAdapterDescriptorFactoryByType(type) {
        const results = this._adapterFactories.filter(p => p.type === type);
        if (results.length > 0) {
            return results[0].factory;
        }
        return undefined;
    }
    getAdapterDescriptorFactoryByHandle(handle) {
        const results = this._adapterFactories.filter(p => p.handle === handle);
        if (results.length > 0) {
            return results[0].factory;
        }
        return undefined;
    }
    getConfigProviderByHandle(handle) {
        const results = this._configProviders.filter(p => p.handle === handle);
        if (results.length > 0) {
            return results[0].provider;
        }
        return undefined;
    }
    definesDebugType(ed, type) {
        if (ed.contributes) {
            const debuggers = ed.contributes['debuggers'];
            if (debuggers && debuggers.length > 0) {
                for (const dbg of debuggers) {
                    if (dbg.label && dbg.type) {
                        if (dbg.type === type) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
    getDebugAdapterTrackers(session) {
        const config = session.configuration;
        const type = config.type;
        const promises = ( (this._trackerFactories
            .filter(tuple => tuple.type === type || tuple.type === '*')
            .map(
            tuple => asPromise(() => tuple.factory.createDebugAdapterTracker(session)).then(p => p, err => null)
        )));
        return Promise.race([
            Promise.all(promises).then(result => {
                const trackers = result.filter(t => !!t);
                if (trackers.length > 0) {
                    return (
                         (new MultiTracker(trackers))
                    );
                }
                return undefined;
            }),
            ( (new Promise(resolve => setTimeout(() => resolve(undefined), 1000)))),
        ]).catch(err => {
            return undefined;
        });
    }
    async getAdapterDescriptor(adapterDescriptorFactory, session) {
        const serverPort = session.configuration.debugServer;
        if (typeof serverPort === 'number') {
            return Promise.resolve(( (new DebugAdapterServer$1(serverPort))));
        }
        if (adapterDescriptorFactory) {
            const extensionRegistry = await this._extensionService.getExtensionRegistry();
            return asPromise(() => adapterDescriptorFactory.createDebugAdapterDescriptor(session, this.daExecutableFromPackage(session, extensionRegistry))).then(daDescriptor => {
                if (daDescriptor) {
                    return daDescriptor;
                }
                return undefined;
            });
        }
        const extensionRegistry = await this._extensionService.getExtensionRegistry();
        return Promise.resolve(this.daExecutableFromPackage(session, extensionRegistry));
    }
    daExecutableFromPackage(session, extensionRegistry) {
        return undefined;
    }
    startBreakpoints() {
        if (!this._breakpointEventsActive) {
            this._breakpointEventsActive = true;
            this._debugServiceProxy.$startBreakpointEvents();
        }
    }
    fireBreakpointChanges(added, removed, changed) {
        if (added.length > 0 || removed.length > 0 || changed.length > 0) {
            this._onDidChangeBreakpoints.fire(( (Object.freeze({
                added,
                removed,
                changed,
            }))));
        }
    }
    async getSession(dto) {
        if (dto) {
            if (typeof dto === 'string') {
                const ds = this._debugSessions.get(dto);
                if (ds) {
                    return ds;
                }
            }
            else {
                let ds = this._debugSessions.get(dto.id);
                if (!ds) {
                    const folder = await this.getFolder(dto.folderUri);
                    const parent = dto.parent ? this._debugSessions.get(dto.parent) : undefined;
                    ds = ( (new ExtHostDebugSession(
                        this._debugServiceProxy,
                        dto.id,
                        dto.type,
                        dto.name,
                        folder,
                        dto.configuration,
                        parent
                    )));
                    this._debugSessions.set(ds.id, ds);
                    this._debugServiceProxy.$sessionCached(ds.id);
                }
                return ds;
            }
        }
        throw new Error('cannot find session');
    }
    getFolder(_folderUri) {
        if (_folderUri) {
            const folderURI = URI.revive(_folderUri);
            return this._workspaceService.resolveWorkspaceFolder(folderURI);
        }
        return Promise.resolve(undefined);
    }
};
ExtHostDebugServiceBase = ( (__decorate([
    ( (__param(0, IExtHostRpcService))),
    ( (__param(1, IExtHostWorkspace))),
    ( (__param(2, IExtHostExtensionService))),
    ( (__param(3, IExtHostConfiguration))),
    ( (__param(4, IExtHostEditorTabs))),
    ( (__param(5, IExtHostVariableResolverProvider)))
], ExtHostDebugServiceBase)));
class ExtHostDebugSession {
    constructor(_debugServiceProxy, _id, _type, _name, _workspaceFolder, _configuration, _parentSession) {
        this._debugServiceProxy = _debugServiceProxy;
        this._id = _id;
        this._type = _type;
        this._name = _name;
        this._workspaceFolder = _workspaceFolder;
        this._configuration = _configuration;
        this._parentSession = _parentSession;
    }
    get id() {
        return this._id;
    }
    get type() {
        return this._type;
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
        this._debugServiceProxy.$setDebugSessionName(this._id, name);
    }
    get parentSession() {
        return this._parentSession;
    }
    _acceptNameChanged(name) {
        this._name = name;
    }
    get workspaceFolder() {
        return this._workspaceFolder;
    }
    get configuration() {
        return this._configuration;
    }
    customRequest(command, args) {
        return this._debugServiceProxy.$customDebugAdapterRequest(this._id, command, args);
    }
    getDebugProtocolBreakpoint(breakpoint) {
        return this._debugServiceProxy.$getDebugProtocolBreakpoint(this._id, breakpoint.id);
    }
}
class ExtHostDebugConsole {
    constructor(proxy) {
        this.value = ( (Object.freeze({
            append(value) {
                proxy.$appendDebugConsole(value);
            },
            appendLine(value) {
                this.append(value + '\n');
            }
        })));
    }
}
class MultiTracker {
    constructor(trackers) {
        this.trackers = trackers;
    }
    onWillStartSession() {
        this.trackers.forEach(t => t.onWillStartSession ? t.onWillStartSession() : undefined);
    }
    onWillReceiveMessage(message) {
        this.trackers.forEach(t => t.onWillReceiveMessage ? t.onWillReceiveMessage(message) : undefined);
    }
    onDidSendMessage(message) {
        this.trackers.forEach(t => t.onDidSendMessage ? t.onDidSendMessage(message) : undefined);
    }
    onWillStopSession() {
        this.trackers.forEach(t => t.onWillStopSession ? t.onWillStopSession() : undefined);
    }
    onError(error) {
        this.trackers.forEach(t => t.onError ? t.onError(error) : undefined);
    }
    onExit(code, signal) {
        this.trackers.forEach(t => t.onExit ? t.onExit(code, signal) : undefined);
    }
}
class DirectDebugAdapter extends AbstractDebugAdapter {
    constructor(implementation) {
        super();
        this.implementation = implementation;
        implementation.onDidSendMessage((message) => {
            this.acceptMessage(message);
        });
    }
    startSession() {
        return Promise.resolve(undefined);
    }
    sendMessage(message) {
        this.implementation.handleMessage(message);
    }
    stopSession() {
        this.implementation.dispose();
        return Promise.resolve(undefined);
    }
}
let WorkerExtHostDebugService = class WorkerExtHostDebugService extends ExtHostDebugServiceBase {
    constructor(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver) {
        super(extHostRpcService, workspaceService, extensionService, configurationService, editorTabs, variableResolver);
    }
};
WorkerExtHostDebugService = ( (__decorate([
    ( (__param(0, IExtHostRpcService))),
    ( (__param(1, IExtHostWorkspace))),
    ( (__param(2, IExtHostExtensionService))),
    ( (__param(3, IExtHostConfiguration))),
    ( (__param(4, IExtHostEditorTabs))),
    ( (__param(5, IExtHostVariableResolverProvider)))
], WorkerExtHostDebugService)));
let MainThreadDebugService = class MainThreadDebugService {
    constructor(extHostContext, debugService) {
        this.debugService = debugService;
        this._toDispose = ( (new DisposableStore()));
        this._debugAdaptersHandleCounter = 1;
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostDebugService)));
        this._toDispose.add(debugService.onDidNewSession(session => {
            this._proxy.$acceptDebugSessionStarted(this.getSessionDto(session));
            this._toDispose.add(session.onDidChangeName(name => {
                this._proxy.$acceptDebugSessionNameChanged(this.getSessionDto(session), name);
            }));
        }));
        this._toDispose.add(debugService.onWillNewSession(session => {
            this._toDispose.add(session.onDidCustomEvent(event => this._proxy.$acceptDebugSessionCustomEvent(this.getSessionDto(session), event)));
        }));
        this._toDispose.add(debugService.onDidEndSession(session => {
            this._proxy.$acceptDebugSessionTerminated(this.getSessionDto(session));
            this._sessions.delete(session.getId());
        }));
        this._toDispose.add(debugService.getViewModel().onDidFocusSession(session => {
            this._proxy.$acceptDebugSessionActiveChanged(this.getSessionDto(session));
        }));
        this._debugAdapters = ( (new Map()));
        this._debugConfigurationProviders = ( (new Map()));
        this._debugAdapterDescriptorFactories = ( (new Map()));
        this._sessions = ( (new Set()));
    }
    dispose() {
        this._toDispose.dispose();
    }
    createDebugAdapter(session) {
        const handle = this._debugAdaptersHandleCounter++;
        const da = ( (new ExtensionHostDebugAdapter(this, handle, this._proxy, session)));
        this._debugAdapters.set(handle, da);
        return da;
    }
    substituteVariables(folder, config) {
        return Promise.resolve(this._proxy.$substituteVariables(folder ? folder.uri : undefined, config));
    }
    runInTerminal(args, sessionId) {
        return this._proxy.$runInTerminal(args, sessionId);
    }
    $registerDebugTypes(debugTypes) {
        this._toDispose.add(this.debugService.getAdapterManager().registerDebugAdapterFactory(debugTypes, this));
    }
    $startBreakpointEvents() {
        if (!this._breakpointEventsActive) {
            this._breakpointEventsActive = true;
            this._toDispose.add(this.debugService.getModel().onDidChangeBreakpoints(e => {
                if (e && !e.sessionOnly) {
                    const delta = {};
                    if (e.added) {
                        delta.added = this.convertToDto(e.added);
                    }
                    if (e.removed) {
                        delta.removed = ( (e.removed.map(x => x.getId())));
                    }
                    if (e.changed) {
                        delta.changed = this.convertToDto(e.changed);
                    }
                    if (delta.added || delta.removed || delta.changed) {
                        this._proxy.$acceptBreakpointsDelta(delta);
                    }
                }
            }));
            const bps = this.debugService.getModel().getBreakpoints();
            const fbps = this.debugService.getModel().getFunctionBreakpoints();
            const dbps = this.debugService.getModel().getDataBreakpoints();
            if (bps.length > 0 || fbps.length > 0) {
                this._proxy.$acceptBreakpointsDelta({
                    added: this.convertToDto(bps).concat(this.convertToDto(fbps)).concat(this.convertToDto(dbps))
                });
            }
        }
    }
    $registerBreakpoints(DTOs) {
        for (const dto of DTOs) {
            if (dto.type === 'sourceMulti') {
                const rawbps = ( (dto.lines.map(l => ({
                    id: l.id,
                    enabled: l.enabled,
                    lineNumber: l.line + 1,
                    column: l.character > 0 ? l.character + 1 : undefined,
                    condition: l.condition,
                    hitCondition: l.hitCondition,
                    logMessage: l.logMessage
                }))));
                this.debugService.addBreakpoints(URI.revive(dto.uri), rawbps);
            }
            else if (dto.type === 'function') {
                this.debugService.addFunctionBreakpoint(dto.functionName, dto.id);
            }
            else if (dto.type === 'data') {
                this.debugService.addDataBreakpoint(dto.label, dto.dataId, dto.canPersist, dto.accessTypes, dto.accessType);
            }
        }
        return Promise.resolve();
    }
    $unregisterBreakpoints(breakpointIds, functionBreakpointIds, dataBreakpointIds) {
        breakpointIds.forEach(id => this.debugService.removeBreakpoints(id));
        functionBreakpointIds.forEach(id => this.debugService.removeFunctionBreakpoints(id));
        dataBreakpointIds.forEach(id => this.debugService.removeDataBreakpoints(id));
        return Promise.resolve();
    }
    $registerDebugConfigurationProvider(debugType, providerTriggerKind, hasProvide, hasResolve, hasResolve2, handle) {
        const provider = {
            type: debugType,
            triggerKind: providerTriggerKind
        };
        if (hasProvide) {
            provider.provideDebugConfigurations = (folder, token) => {
                return this._proxy.$provideDebugConfigurations(handle, folder, token);
            };
        }
        if (hasResolve) {
            provider.resolveDebugConfiguration = (folder, config, token) => {
                return this._proxy.$resolveDebugConfiguration(handle, folder, config, token);
            };
        }
        if (hasResolve2) {
            provider.resolveDebugConfigurationWithSubstitutedVariables = (folder, config, token) => {
                return this._proxy.$resolveDebugConfigurationWithSubstitutedVariables(handle, folder, config, token);
            };
        }
        this._debugConfigurationProviders.set(handle, provider);
        this._toDispose.add(this.debugService.getConfigurationManager().registerDebugConfigurationProvider(provider));
        return Promise.resolve(undefined);
    }
    $unregisterDebugConfigurationProvider(handle) {
        const provider = this._debugConfigurationProviders.get(handle);
        if (provider) {
            this._debugConfigurationProviders.delete(handle);
            this.debugService.getConfigurationManager().unregisterDebugConfigurationProvider(provider);
        }
    }
    $registerDebugAdapterDescriptorFactory(debugType, handle) {
        const provider = {
            type: debugType,
            createDebugAdapterDescriptor: session => {
                return Promise.resolve(this._proxy.$provideDebugAdapter(handle, this.getSessionDto(session)));
            }
        };
        this._debugAdapterDescriptorFactories.set(handle, provider);
        this._toDispose.add(this.debugService.getAdapterManager().registerDebugAdapterDescriptorFactory(provider));
        return Promise.resolve(undefined);
    }
    $unregisterDebugAdapterDescriptorFactory(handle) {
        const provider = this._debugAdapterDescriptorFactories.get(handle);
        if (provider) {
            this._debugAdapterDescriptorFactories.delete(handle);
            this.debugService.getAdapterManager().unregisterDebugAdapterDescriptorFactory(provider);
        }
    }
    getSession(sessionId) {
        if (sessionId) {
            return this.debugService.getModel().getSession(sessionId, true);
        }
        return undefined;
    }
    async $startDebugging(folder, nameOrConfig, options) {
        const folderUri = folder ? URI.revive(folder) : undefined;
        const launch = this.debugService.getConfigurationManager().getLaunch(folderUri);
        const parentSession = this.getSession(options.parentSessionID);
        const saveBeforeStart = typeof options.suppressSaveBeforeStart === 'boolean' ? !options.suppressSaveBeforeStart : undefined;
        const debugOptions = {
            noDebug: options.noDebug,
            parentSession,
            lifecycleManagedByParent: options.lifecycleManagedByParent,
            repl: options.repl,
            compact: options.compact,
            compoundRoot: parentSession?.compoundRoot,
            saveBeforeRestart: saveBeforeStart,
            suppressDebugStatusbar: options.suppressDebugStatusbar,
            suppressDebugToolbar: options.suppressDebugToolbar,
            suppressDebugView: options.suppressDebugView,
        };
        try {
            return this.debugService.startDebugging(launch, nameOrConfig, debugOptions, saveBeforeStart);
        }
        catch (err) {
            throw new ErrorNoTelemetry(err && err.message ? err.message : 'cannot start debugging');
        }
    }
    $setDebugSessionName(sessionId, name) {
        const session = this.debugService.getModel().getSession(sessionId);
        session?.setName(name);
    }
    $customDebugAdapterRequest(sessionId, request, args) {
        const session = this.debugService.getModel().getSession(sessionId, true);
        if (session) {
            return session.customRequest(request, args).then(response => {
                if (response && response.success) {
                    return response.body;
                }
                else {
                    return Promise.reject(( (new ErrorNoTelemetry(response ? response.message : 'custom request failed'))));
                }
            });
        }
        return Promise.reject(( (new ErrorNoTelemetry('debug session not found'))));
    }
    $getDebugProtocolBreakpoint(sessionId, breakpoinId) {
        const session = this.debugService.getModel().getSession(sessionId, true);
        if (session) {
            return Promise.resolve(session.getDebugProtocolBreakpoint(breakpoinId));
        }
        return Promise.reject(( (new ErrorNoTelemetry('debug session not found'))));
    }
    $stopDebugging(sessionId) {
        if (sessionId) {
            const session = this.debugService.getModel().getSession(sessionId, true);
            if (session) {
                return this.debugService.stopSession(session, isSessionAttach(session));
            }
        }
        else {
            return this.debugService.stopSession(undefined);
        }
        return Promise.reject(( (new ErrorNoTelemetry('debug session not found'))));
    }
    $appendDebugConsole(value) {
        const session = this.debugService.getViewModel().focusedSession;
        session?.appendToRepl({ output: value, sev: Severity$1.Warning });
    }
    $acceptDAMessage(handle, message) {
        this.getDebugAdapter(handle).acceptMessage(convertToVSCPaths(message, false));
    }
    $acceptDAError(handle, name, message, stack) {
        this.getDebugAdapter(handle).fireError(handle, ( (new Error(`${name}: ${message}\n${stack}`))));
    }
    $acceptDAExit(handle, code, signal) {
        this.getDebugAdapter(handle).fireExit(handle, code, signal);
    }
    getDebugAdapter(handle) {
        const adapter = this._debugAdapters.get(handle);
        if (!adapter) {
            throw new Error('Invalid debug adapter');
        }
        return adapter;
    }
    $sessionCached(sessionID) {
        this._sessions.add(sessionID);
    }
    getSessionDto(session) {
        if (session) {
            const sessionID = session.getId();
            if (this._sessions.has(sessionID)) {
                return sessionID;
            }
            else {
                return {
                    id: sessionID,
                    type: session.configuration.type,
                    name: session.name,
                    folderUri: session.root ? session.root.uri : undefined,
                    configuration: session.configuration,
                    parent: session.parentSession?.getId(),
                };
            }
        }
        return undefined;
    }
    convertToDto(bps) {
        return (
             (bps.map(bp => {
                if ('name' in bp) {
                    const fbp = bp;
                    return {
                        type: 'function',
                        id: fbp.getId(),
                        enabled: fbp.enabled,
                        condition: fbp.condition,
                        hitCondition: fbp.hitCondition,
                        logMessage: fbp.logMessage,
                        functionName: fbp.name
                    };
                }
                else if ('dataId' in bp) {
                    const dbp = bp;
                    return {
                        type: 'data',
                        id: dbp.getId(),
                        dataId: dbp.dataId,
                        enabled: dbp.enabled,
                        condition: dbp.condition,
                        hitCondition: dbp.hitCondition,
                        logMessage: dbp.logMessage,
                        label: dbp.description,
                        canPersist: dbp.canPersist
                    };
                }
                else {
                    const sbp = bp;
                    return {
                        type: 'source',
                        id: sbp.getId(),
                        enabled: sbp.enabled,
                        condition: sbp.condition,
                        hitCondition: sbp.hitCondition,
                        logMessage: sbp.logMessage,
                        uri: sbp.uri,
                        line: sbp.lineNumber > 0 ? sbp.lineNumber - 1 : 0,
                        character: (typeof sbp.column === 'number' && sbp.column > 0) ? sbp.column - 1 : 0,
                    };
                }
            }))
        );
    }
};
MainThreadDebugService = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadDebugService),
    ( (__param(1, IDebugService)))
], MainThreadDebugService)));
class ExtensionHostDebugAdapter extends AbstractDebugAdapter {
    constructor(_ds, _handle, _proxy, _session) {
        super();
        this._ds = _ds;
        this._handle = _handle;
        this._proxy = _proxy;
        this._session = _session;
    }
    fireError(handle, err) {
        this._onError.fire(err);
    }
    fireExit(handle, code, signal) {
        this._onExit.fire(code);
    }
    startSession() {
        return Promise.resolve(this._proxy.$startDASession(this._handle, this._ds.getSessionDto(this._session)));
    }
    sendMessage(message) {
        this._proxy.$sendDAMessage(this._handle, convertToDAPaths(message, true));
    }
    async stopSession() {
        await this.cancelPendingRequests();
        return Promise.resolve(this._proxy.$stopDASession(this._handle));
    }
}
class BufferedEmitter {
    constructor() {
        this._hasListeners = false;
        this._isDeliveringMessages = false;
        this._bufferedMessages = [];
        this._emitter = ( (new Emitter$1({
            onWillAddFirstListener: () => {
                this._hasListeners = true;
                queueMicrotask(() => this._deliverMessages());
            },
            onDidRemoveLastListener: () => {
                this._hasListeners = false;
            }
        })));
        this.event = this._emitter.event;
    }
    _deliverMessages() {
        if (this._isDeliveringMessages) {
            return;
        }
        this._isDeliveringMessages = true;
        while (this._hasListeners && this._bufferedMessages.length > 0) {
            this._emitter.fire(this._bufferedMessages.shift());
        }
        this._isDeliveringMessages = false;
    }
    fire(event) {
        if (this._hasListeners) {
            if (this._bufferedMessages.length > 0) {
                this._bufferedMessages.push(event);
            }
            else {
                this._emitter.fire(event);
            }
        }
        else {
            this._bufferedMessages.push(event);
        }
    }
    flushBuffer() {
        this._bufferedMessages = [];
    }
}
function _transformIncomingURIs(obj, transformer, revive, depth) {
    if (!obj || depth > 200) {
        return null;
    }
    if (typeof obj === 'object') {
        if (obj.$mid === 1 ) {
            return revive ? URI.revive(transformer.transformIncoming(obj)) : transformer.transformIncoming(obj);
        }
        if (obj instanceof VSBuffer) {
            return null;
        }
        for (const key in obj) {
            if (Object.hasOwnProperty.call(obj, key)) {
                const r = _transformIncomingURIs(obj[key], transformer, revive, depth + 1);
                if (r !== null) {
                    obj[key] = r;
                }
            }
        }
    }
    return null;
}
function transformIncomingURIs(obj, transformer) {
    const result = _transformIncomingURIs(obj, transformer, false, 0);
    if (result === null) {
        return obj;
    }
    return result;
}
class LazyPromise {
    constructor() {
        this._actual = null;
        this._actualOk = null;
        this._actualErr = null;
        this._hasValue = false;
        this._value = null;
        this._hasErr = false;
        this._err = null;
    }
    get [Symbol.toStringTag]() {
        return (
             (this.toString())
        );
    }
    _ensureActual() {
        if (!this._actual) {
            this._actual = ( (new Promise((c, e) => {
                this._actualOk = c;
                this._actualErr = e;
                if (this._hasValue) {
                    this._actualOk(this._value);
                }
                if (this._hasErr) {
                    this._actualErr(this._err);
                }
            })));
        }
        return this._actual;
    }
    resolveOk(value) {
        if (this._hasValue || this._hasErr) {
            return;
        }
        this._hasValue = true;
        this._value = value;
        if (this._actual) {
            this._actualOk(value);
        }
    }
    resolveErr(err) {
        if (this._hasValue || this._hasErr) {
            return;
        }
        this._hasErr = true;
        this._err = err;
        if (this._actual) {
            this._actualErr(err);
        }
        else {
            onUnexpectedError(err);
        }
    }
    then(success, error) {
        return this._ensureActual().then(success, error);
    }
    catch(error) {
        return this._ensureActual().then(undefined, error);
    }
    finally(callback) {
        return this._ensureActual().finally(callback);
    }
}
class CanceledLazyPromise extends LazyPromise {
    constructor() {
        super();
        this._hasErr = true;
        this._err = ( (new CancellationError$1()));
    }
}
var _a;
function safeStringify(obj, replacer) {
    try {
        return JSON.stringify(obj, replacer);
    }
    catch (err) {
        return 'null';
    }
}
const refSymbolName = '$$ref$$';
const undefinedRef = { [refSymbolName]: -1 };
function stringifyJsonWithBufferRefs(obj, replacer = null, useSafeStringify = false) {
    const foundBuffers = [];
    const serialized = (useSafeStringify ? safeStringify : JSON.stringify)(obj, (key, value) => {
        if (typeof value === 'undefined') {
            return undefinedRef;
        }
        else if (typeof value === 'object') {
            if (value instanceof VSBuffer) {
                const bufferIndex = foundBuffers.push(value) - 1;
                return { [refSymbolName]: bufferIndex };
            }
            if (replacer) {
                return replacer(key, value);
            }
        }
        return value;
    });
    return {
        jsonString: serialized,
        referencedBuffers: foundBuffers
    };
}
function parseJsonAndRestoreBufferRefs(jsonString, buffers, uriTransformer) {
    return JSON.parse(jsonString, (_key, value) => {
        if (value) {
            const ref = value[refSymbolName];
            if (typeof ref === 'number') {
                return buffers[ref];
            }
            if (uriTransformer && value.$mid === 1 ) {
                return uriTransformer.transformIncoming(value);
            }
        }
        return value;
    });
}
function stringify(obj, replacer) {
    return JSON.stringify(obj, replacer);
}
function createURIReplacer(transformer) {
    if (!transformer) {
        return null;
    }
    return (key, value) => {
        if (value && value.$mid === 1 ) {
            return transformer.transformOutgoing(value);
        }
        return value;
    };
}
const noop = () => { };
const _RPCProtocolSymbol = Symbol.for('rpcProtocol');
const _RPCProxySymbol = Symbol.for('rpcProxy');
class RPCProtocol extends Disposable$1 {
    constructor(protocol, logger = null, transformer = null) {
        super();
        this[_a] = true;
        this._onDidChangeResponsiveState = this._register(( (new Emitter$1())));
        this.onDidChangeResponsiveState = this._onDidChangeResponsiveState.event;
        this._protocol = protocol;
        this._logger = logger;
        this._uriTransformer = transformer;
        this._uriReplacer = createURIReplacer(this._uriTransformer);
        this._isDisposed = false;
        this._locals = [];
        this._proxies = [];
        for (let i = 0, len = ProxyIdentifier.count; i < len; i++) {
            this._locals[i] = null;
            this._proxies[i] = null;
        }
        this._lastMessageId = 0;
        this._cancelInvokedHandlers = Object.create(null);
        this._pendingRPCReplies = {};
        this._responsiveState = 0 ;
        this._unacknowledgedCount = 0;
        this._unresponsiveTime = 0;
        this._asyncCheckUresponsive = this._register(( (new RunOnceScheduler(() => this._checkUnresponsive(), 1000))));
        this._protocol.onMessage((msg) => this._receiveOneMessage(msg));
    }
    dispose() {
        this._isDisposed = true;
        ( (Object.keys(this._pendingRPCReplies))).forEach((msgId) => {
            const pending = this._pendingRPCReplies[msgId];
            pending.resolveErr(canceled());
        });
    }
    drain() {
        if (typeof this._protocol.drain === 'function') {
            return this._protocol.drain();
        }
        return Promise.resolve();
    }
    _onWillSendRequest(req) {
        if (this._unacknowledgedCount === 0) {
            this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;
        }
        this._unacknowledgedCount++;
        if (!this._asyncCheckUresponsive.isScheduled()) {
            this._asyncCheckUresponsive.schedule();
        }
    }
    _onDidReceiveAcknowledge(req) {
        this._unresponsiveTime = Date.now() + RPCProtocol.UNRESPONSIVE_TIME;
        this._unacknowledgedCount--;
        if (this._unacknowledgedCount === 0) {
            this._asyncCheckUresponsive.cancel();
        }
        this._setResponsiveState(0 );
    }
    _checkUnresponsive() {
        if (this._unacknowledgedCount === 0) {
            return;
        }
        if (Date.now() > this._unresponsiveTime) {
            this._setResponsiveState(1 );
        }
        else {
            this._asyncCheckUresponsive.schedule();
        }
    }
    _setResponsiveState(newResponsiveState) {
        if (this._responsiveState === newResponsiveState) {
            return;
        }
        this._responsiveState = newResponsiveState;
        this._onDidChangeResponsiveState.fire(this._responsiveState);
    }
    get responsiveState() {
        return this._responsiveState;
    }
    transformIncomingURIs(obj) {
        if (!this._uriTransformer) {
            return obj;
        }
        return transformIncomingURIs(obj, this._uriTransformer);
    }
    getProxy(identifier) {
        const { nid: rpcId, sid } = identifier;
        if (!this._proxies[rpcId]) {
            this._proxies[rpcId] = this._createProxy(rpcId, sid);
        }
        return this._proxies[rpcId];
    }
    _createProxy(rpcId, debugName) {
        const handler = {
            get: (target, name) => {
                if (typeof name === 'string' && !target[name] && name.charCodeAt(0) === 36 ) {
                    target[name] = (...myArgs) => {
                        return this._remoteCall(rpcId, name, myArgs);
                    };
                }
                if (name === _RPCProxySymbol) {
                    return debugName;
                }
                return target[name];
            }
        };
        return (
             (new Proxy(Object.create(null), handler))
        );
    }
    set(identifier, value) {
        this._locals[identifier.nid] = value;
        return value;
    }
    assertRegistered(identifiers) {
        for (let i = 0, len = identifiers.length; i < len; i++) {
            const identifier = identifiers[i];
            if (!this._locals[identifier.nid]) {
                throw new Error(`Missing proxy instance ${identifier.sid}`);
            }
        }
    }
    _receiveOneMessage(rawmsg) {
        if (this._isDisposed) {
            return;
        }
        const msgLength = rawmsg.byteLength;
        const buff = MessageBuffer.read(rawmsg, 0);
        const messageType = buff.readUInt8();
        const req = buff.readUInt32();
        switch (messageType) {
            case 1 :
            case 2 : {
                let { rpcId, method, args } = MessageIO.deserializeRequestJSONArgs(buff);
                if (this._uriTransformer) {
                    args = transformIncomingURIs(args, this._uriTransformer);
                }
                this._receiveRequest(msgLength, req, rpcId, method, args, ((messageType === 2) ));
                break;
            }
            case 3 :
            case 4 : {
                let { rpcId, method, args } = MessageIO.deserializeRequestMixedArgs(buff);
                if (this._uriTransformer) {
                    args = transformIncomingURIs(args, this._uriTransformer);
                }
                this._receiveRequest(msgLength, req, rpcId, method, args, ((messageType === 4) ));
                break;
            }
            case 5 : {
                this._logger?.logIncoming(msgLength, req, 0 , `ack`);
                this._onDidReceiveAcknowledge(req);
                break;
            }
            case 6 : {
                this._receiveCancel(msgLength, req);
                break;
            }
            case 7 : {
                this._receiveReply(msgLength, req, undefined);
                break;
            }
            case 9 : {
                let value = MessageIO.deserializeReplyOKJSON(buff);
                if (this._uriTransformer) {
                    value = transformIncomingURIs(value, this._uriTransformer);
                }
                this._receiveReply(msgLength, req, value);
                break;
            }
            case 10 : {
                const value = MessageIO.deserializeReplyOKJSONWithBuffers(buff, this._uriTransformer);
                this._receiveReply(msgLength, req, value);
                break;
            }
            case 8 : {
                const value = MessageIO.deserializeReplyOKVSBuffer(buff);
                this._receiveReply(msgLength, req, value);
                break;
            }
            case 11 : {
                let err = MessageIO.deserializeReplyErrError(buff);
                if (this._uriTransformer) {
                    err = transformIncomingURIs(err, this._uriTransformer);
                }
                this._receiveReplyErr(msgLength, req, err);
                break;
            }
            case 12 : {
                this._receiveReplyErr(msgLength, req, undefined);
                break;
            }
            default:
                console.error(`received unexpected message`);
                console.error(rawmsg);
        }
    }
    _receiveRequest(msgLength, req, rpcId, method, args, usesCancellationToken) {
        this._logger?.logIncoming(msgLength, req, 1 , `receiveRequest ${getStringIdentifierForProxy(rpcId)}.${method}(`, args);
        const callId = String(req);
        let promise;
        let cancel;
        if (usesCancellationToken) {
            const cancellationTokenSource = ( (new CancellationTokenSource$1()));
            args.push(cancellationTokenSource.token);
            promise = this._invokeHandler(rpcId, method, args);
            cancel = () => cancellationTokenSource.cancel();
        }
        else {
            promise = this._invokeHandler(rpcId, method, args);
            cancel = noop;
        }
        this._cancelInvokedHandlers[callId] = cancel;
        const msg = MessageIO.serializeAcknowledged(req);
        this._logger?.logOutgoing(msg.byteLength, req, 1 , `ack`);
        this._protocol.send(msg);
        promise.then((r) => {
            delete this._cancelInvokedHandlers[callId];
            const msg = MessageIO.serializeReplyOK(req, r, this._uriReplacer);
            this._logger?.logOutgoing(msg.byteLength, req, 1 , `reply:`, r);
            this._protocol.send(msg);
        }, (err) => {
            delete this._cancelInvokedHandlers[callId];
            const msg = MessageIO.serializeReplyErr(req, err);
            this._logger?.logOutgoing(msg.byteLength, req, 1 , `replyErr:`, err);
            this._protocol.send(msg);
        });
    }
    _receiveCancel(msgLength, req) {
        this._logger?.logIncoming(msgLength, req, 1 , `receiveCancel`);
        const callId = String(req);
        this._cancelInvokedHandlers[callId]?.();
    }
    _receiveReply(msgLength, req, value) {
        this._logger?.logIncoming(msgLength, req, 0 , `receiveReply:`, value);
        const callId = String(req);
        if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
            return;
        }
        const pendingReply = this._pendingRPCReplies[callId];
        delete this._pendingRPCReplies[callId];
        pendingReply.resolveOk(value);
    }
    _receiveReplyErr(msgLength, req, value) {
        this._logger?.logIncoming(msgLength, req, 0 , `receiveReplyErr:`, value);
        const callId = String(req);
        if (!this._pendingRPCReplies.hasOwnProperty(callId)) {
            return;
        }
        const pendingReply = this._pendingRPCReplies[callId];
        delete this._pendingRPCReplies[callId];
        let err = undefined;
        if (value) {
            if (value.$isError) {
                err = ( (new Error()));
                err.name = value.name;
                err.message = value.message;
                err.stack = value.stack;
            }
            else {
                err = value;
            }
        }
        pendingReply.resolveErr(err);
    }
    _invokeHandler(rpcId, methodName, args) {
        try {
            return Promise.resolve(this._doInvokeHandler(rpcId, methodName, args));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    _doInvokeHandler(rpcId, methodName, args) {
        const actor = this._locals[rpcId];
        if (!actor) {
            throw new Error('Unknown actor ' + getStringIdentifierForProxy(rpcId));
        }
        const method = actor[methodName];
        if (typeof method !== 'function') {
            throw new Error('Unknown method ' + methodName + ' on actor ' + getStringIdentifierForProxy(rpcId));
        }
        return method.apply(actor, args);
    }
    _remoteCall(rpcId, methodName, args) {
        if (this._isDisposed) {
            return (
                 (new CanceledLazyPromise())
            );
        }
        let cancellationToken = null;
        if (args.length > 0 && CancellationToken.isCancellationToken(args[args.length - 1])) {
            cancellationToken = args.pop();
        }
        if (cancellationToken && cancellationToken.isCancellationRequested) {
            return Promise.reject(canceled());
        }
        const serializedRequestArguments = MessageIO.serializeRequestArguments(args, this._uriReplacer);
        const req = ++this._lastMessageId;
        const callId = String(req);
        const result = ( (new LazyPromise()));
        if (cancellationToken) {
            cancellationToken.onCancellationRequested(() => {
                const msg = MessageIO.serializeCancel(req);
                this._logger?.logOutgoing(msg.byteLength, req, 0 , `cancel`);
                this._protocol.send(MessageIO.serializeCancel(req));
            });
        }
        this._pendingRPCReplies[callId] = result;
        this._onWillSendRequest(req);
        const msg = MessageIO.serializeRequest(req, rpcId, methodName, serializedRequestArguments, !!cancellationToken);
        this._logger?.logOutgoing(msg.byteLength, req, 0 , `request: ${getStringIdentifierForProxy(rpcId)}.${methodName}(`, args);
        this._protocol.send(msg);
        return result;
    }
}
_a = _RPCProtocolSymbol;
RPCProtocol.UNRESPONSIVE_TIME = 3 * 1000;
class MessageBuffer {
    static alloc(type, req, messageSize) {
        const result = ( (new MessageBuffer(VSBuffer.alloc(messageSize + 1  + 4 ), 0)));
        result.writeUInt8(type);
        result.writeUInt32(req);
        return result;
    }
    static read(buff, offset) {
        return (
             (new MessageBuffer(buff, offset))
        );
    }
    get buffer() {
        return this._buff;
    }
    constructor(buff, offset) {
        this._buff = buff;
        this._offset = offset;
    }
    static sizeUInt8() {
        return 1;
    }
    writeUInt8(n) {
        this._buff.writeUInt8(n, this._offset);
        this._offset += 1;
    }
    readUInt8() {
        const n = this._buff.readUInt8(this._offset);
        this._offset += 1;
        return n;
    }
    writeUInt32(n) {
        this._buff.writeUInt32BE(n, this._offset);
        this._offset += 4;
    }
    readUInt32() {
        const n = this._buff.readUInt32BE(this._offset);
        this._offset += 4;
        return n;
    }
    static sizeShortString(str) {
        return 1  + str.byteLength ;
    }
    writeShortString(str) {
        this._buff.writeUInt8(str.byteLength, this._offset);
        this._offset += 1;
        this._buff.set(str, this._offset);
        this._offset += str.byteLength;
    }
    readShortString() {
        const strByteLength = this._buff.readUInt8(this._offset);
        this._offset += 1;
        const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);
        const str = ( (strBuff.toString()));
        this._offset += strByteLength;
        return str;
    }
    static sizeLongString(str) {
        return 4  + str.byteLength ;
    }
    writeLongString(str) {
        this._buff.writeUInt32BE(str.byteLength, this._offset);
        this._offset += 4;
        this._buff.set(str, this._offset);
        this._offset += str.byteLength;
    }
    readLongString() {
        const strByteLength = this._buff.readUInt32BE(this._offset);
        this._offset += 4;
        const strBuff = this._buff.slice(this._offset, this._offset + strByteLength);
        const str = ( (strBuff.toString()));
        this._offset += strByteLength;
        return str;
    }
    writeBuffer(buff) {
        this._buff.writeUInt32BE(buff.byteLength, this._offset);
        this._offset += 4;
        this._buff.set(buff, this._offset);
        this._offset += buff.byteLength;
    }
    static sizeVSBuffer(buff) {
        return 4  + buff.byteLength ;
    }
    writeVSBuffer(buff) {
        this._buff.writeUInt32BE(buff.byteLength, this._offset);
        this._offset += 4;
        this._buff.set(buff, this._offset);
        this._offset += buff.byteLength;
    }
    readVSBuffer() {
        const buffLength = this._buff.readUInt32BE(this._offset);
        this._offset += 4;
        const buff = this._buff.slice(this._offset, this._offset + buffLength);
        this._offset += buffLength;
        return buff;
    }
    static sizeMixedArray(arr) {
        let size = 0;
        size += 1;
        for (let i = 0, len = arr.length; i < len; i++) {
            const el = arr[i];
            size += 1;
            switch (el.type) {
                case 1 :
                    size += this.sizeLongString(el.value);
                    break;
                case 2 :
                    size += this.sizeVSBuffer(el.value);
                    break;
                case 3 :
                    size += this.sizeUInt32;
                    size += this.sizeLongString(el.value);
                    for (let i = 0; i < el.buffers.length; ++i) {
                        size += this.sizeVSBuffer(el.buffers[i]);
                    }
                    break;
            }
        }
        return size;
    }
    writeMixedArray(arr) {
        this._buff.writeUInt8(arr.length, this._offset);
        this._offset += 1;
        for (let i = 0, len = arr.length; i < len; i++) {
            const el = arr[i];
            switch (el.type) {
                case 1 :
                    this.writeUInt8(1 );
                    this.writeLongString(el.value);
                    break;
                case 2 :
                    this.writeUInt8(2 );
                    this.writeVSBuffer(el.value);
                    break;
                case 3 :
                    this.writeUInt8(3 );
                    this.writeUInt32(el.buffers.length);
                    this.writeLongString(el.value);
                    for (let i = 0; i < el.buffers.length; ++i) {
                        this.writeBuffer(el.buffers[i]);
                    }
                    break;
                case 4 :
                    this.writeUInt8(4 );
                    break;
            }
        }
    }
    readMixedArray() {
        const arrLen = this._buff.readUInt8(this._offset);
        this._offset += 1;
        const arr = ( (new Array(arrLen)));
        for (let i = 0; i < arrLen; i++) {
            const argType = this.readUInt8();
            switch (argType) {
                case 1 :
                    arr[i] = this.readLongString();
                    break;
                case 2 :
                    arr[i] = this.readVSBuffer();
                    break;
                case 3 : {
                    const bufferCount = this.readUInt32();
                    const jsonString = this.readLongString();
                    const buffers = [];
                    for (let i = 0; i < bufferCount; ++i) {
                        buffers.push(this.readVSBuffer());
                    }
                    arr[i] = ( (new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(jsonString, buffers, null))));
                    break;
                }
                case 4 :
                    arr[i] = undefined;
                    break;
            }
        }
        return arr;
    }
}
MessageBuffer.sizeUInt32 = 4;
class MessageIO {
    static _useMixedArgSerialization(arr) {
        for (let i = 0, len = arr.length; i < len; i++) {
            if (arr[i] instanceof VSBuffer) {
                return true;
            }
            if (arr[i] instanceof SerializableObjectWithBuffers) {
                return true;
            }
            if (typeof arr[i] === 'undefined') {
                return true;
            }
        }
        return false;
    }
    static serializeRequestArguments(args, replacer) {
        if (this._useMixedArgSerialization(args)) {
            const massagedArgs = [];
            for (let i = 0, len = args.length; i < len; i++) {
                const arg = args[i];
                if (arg instanceof VSBuffer) {
                    massagedArgs[i] = { type: 2 , value: arg };
                }
                else if (typeof arg === 'undefined') {
                    massagedArgs[i] = { type: 4  };
                }
                else if (arg instanceof SerializableObjectWithBuffers) {
                    const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(arg.value, replacer);
                    massagedArgs[i] = { type: 3 , value: VSBuffer.fromString(jsonString), buffers: referencedBuffers };
                }
                else {
                    massagedArgs[i] = { type: 1 , value: VSBuffer.fromString(stringify(arg, replacer)) };
                }
            }
            return {
                type: 1 ,
                args: massagedArgs,
            };
        }
        return {
            type: 0 ,
            args: stringify(args, replacer)
        };
    }
    static serializeRequest(req, rpcId, method, serializedArgs, usesCancellationToken) {
        switch (serializedArgs.type) {
            case 0 :
                return this._requestJSONArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);
            case 1 :
                return this._requestMixedArgs(req, rpcId, method, serializedArgs.args, usesCancellationToken);
        }
    }
    static _requestJSONArgs(req, rpcId, method, args, usesCancellationToken) {
        const methodBuff = VSBuffer.fromString(method);
        const argsBuff = VSBuffer.fromString(args);
        let len = 0;
        len += MessageBuffer.sizeUInt8();
        len += MessageBuffer.sizeShortString(methodBuff);
        len += MessageBuffer.sizeLongString(argsBuff);
        const result = MessageBuffer.alloc(usesCancellationToken ? 2  : 1 , req, len);
        result.writeUInt8(rpcId);
        result.writeShortString(methodBuff);
        result.writeLongString(argsBuff);
        return result.buffer;
    }
    static deserializeRequestJSONArgs(buff) {
        const rpcId = buff.readUInt8();
        const method = buff.readShortString();
        const args = buff.readLongString();
        return {
            rpcId: rpcId,
            method: method,
            args: JSON.parse(args)
        };
    }
    static _requestMixedArgs(req, rpcId, method, args, usesCancellationToken) {
        const methodBuff = VSBuffer.fromString(method);
        let len = 0;
        len += MessageBuffer.sizeUInt8();
        len += MessageBuffer.sizeShortString(methodBuff);
        len += MessageBuffer.sizeMixedArray(args);
        const result = MessageBuffer.alloc(usesCancellationToken ? 4  : 3 , req, len);
        result.writeUInt8(rpcId);
        result.writeShortString(methodBuff);
        result.writeMixedArray(args);
        return result.buffer;
    }
    static deserializeRequestMixedArgs(buff) {
        const rpcId = buff.readUInt8();
        const method = buff.readShortString();
        const rawargs = buff.readMixedArray();
        const args = ( (new Array(rawargs.length)));
        for (let i = 0, len = rawargs.length; i < len; i++) {
            const rawarg = rawargs[i];
            if (typeof rawarg === 'string') {
                args[i] = JSON.parse(rawarg);
            }
            else {
                args[i] = rawarg;
            }
        }
        return {
            rpcId: rpcId,
            method: method,
            args: args
        };
    }
    static serializeAcknowledged(req) {
        return MessageBuffer.alloc(5 , req, 0).buffer;
    }
    static serializeCancel(req) {
        return MessageBuffer.alloc(6 , req, 0).buffer;
    }
    static serializeReplyOK(req, res, replacer) {
        if (typeof res === 'undefined') {
            return this._serializeReplyOKEmpty(req);
        }
        else if (res instanceof VSBuffer) {
            return this._serializeReplyOKVSBuffer(req, res);
        }
        else if (res instanceof SerializableObjectWithBuffers) {
            const { jsonString, referencedBuffers } = stringifyJsonWithBufferRefs(res.value, replacer, true);
            return this._serializeReplyOKJSONWithBuffers(req, jsonString, referencedBuffers);
        }
        else {
            return this._serializeReplyOKJSON(req, safeStringify(res, replacer));
        }
    }
    static _serializeReplyOKEmpty(req) {
        return MessageBuffer.alloc(7 , req, 0).buffer;
    }
    static _serializeReplyOKVSBuffer(req, res) {
        let len = 0;
        len += MessageBuffer.sizeVSBuffer(res);
        const result = MessageBuffer.alloc(8 , req, len);
        result.writeVSBuffer(res);
        return result.buffer;
    }
    static deserializeReplyOKVSBuffer(buff) {
        return buff.readVSBuffer();
    }
    static _serializeReplyOKJSON(req, res) {
        const resBuff = VSBuffer.fromString(res);
        let len = 0;
        len += MessageBuffer.sizeLongString(resBuff);
        const result = MessageBuffer.alloc(9 , req, len);
        result.writeLongString(resBuff);
        return result.buffer;
    }
    static _serializeReplyOKJSONWithBuffers(req, res, buffers) {
        const resBuff = VSBuffer.fromString(res);
        let len = 0;
        len += MessageBuffer.sizeUInt32;
        len += MessageBuffer.sizeLongString(resBuff);
        for (const buffer of buffers) {
            len += MessageBuffer.sizeVSBuffer(buffer);
        }
        const result = MessageBuffer.alloc(10 , req, len);
        result.writeUInt32(buffers.length);
        result.writeLongString(resBuff);
        for (const buffer of buffers) {
            result.writeBuffer(buffer);
        }
        return result.buffer;
    }
    static deserializeReplyOKJSON(buff) {
        const res = buff.readLongString();
        return JSON.parse(res);
    }
    static deserializeReplyOKJSONWithBuffers(buff, uriTransformer) {
        const bufferCount = buff.readUInt32();
        const res = buff.readLongString();
        const buffers = [];
        for (let i = 0; i < bufferCount; ++i) {
            buffers.push(buff.readVSBuffer());
        }
        return (
             (new SerializableObjectWithBuffers(parseJsonAndRestoreBufferRefs(res, buffers, uriTransformer)))
        );
    }
    static serializeReplyErr(req, err) {
        const errStr = (err ? safeStringify(transformErrorForSerialization(err), null) : undefined);
        if (typeof errStr !== 'string') {
            return this._serializeReplyErrEmpty(req);
        }
        const errBuff = VSBuffer.fromString(errStr);
        let len = 0;
        len += MessageBuffer.sizeLongString(errBuff);
        const result = MessageBuffer.alloc(11 , req, len);
        result.writeLongString(errBuff);
        return result.buffer;
    }
    static deserializeReplyErrError(buff) {
        const err = buff.readLongString();
        return JSON.parse(err);
    }
    static _serializeReplyErrEmpty(req) {
        return MessageBuffer.alloc(12 , req, 0).buffer;
    }
}
let ExtHostDecorations = class ExtHostDecorations {
    constructor(extHostRpc, _logService) {
        this._logService = _logService;
        this._provider = ( (new Map()));
        this._proxy = ( (extHostRpc.getProxy(MainContext.MainThreadDecorations)));
    }
    registerFileDecorationProvider(provider, extensionDescription) {
        const handle = ExtHostDecorations._handlePool++;
        this._provider.set(handle, { provider, extensionDescription });
        this._proxy.$registerDecorationProvider(handle, extensionDescription.identifier.value);
        const listener = provider.onDidChangeFileDecorations && provider.onDidChangeFileDecorations(e => {
            if (!e) {
                this._proxy.$onDidChange(handle, null);
                return;
            }
            const array = asArray(e);
            if (array.length <= ExtHostDecorations._maxEventSize) {
                this._proxy.$onDidChange(handle, array);
                return;
            }
            this._logService.warn('[Decorations] CAPPING events from decorations provider', extensionDescription.identifier.value, array.length);
            const mapped = ( (array.map(uri => ({ uri, rank: count(uri.path, '/') }))));
            const groups = groupBy$1(mapped, (a, b) => a.rank - b.rank || compare(a.uri.path, b.uri.path));
            const picked = [];
            outer: for (const uris of groups) {
                let lastDirname;
                for (const obj of uris) {
                    const myDirname = dirname$1(obj.uri.path);
                    if (lastDirname !== myDirname) {
                        lastDirname = myDirname;
                        if (picked.push(obj.uri) >= ExtHostDecorations._maxEventSize) {
                            break outer;
                        }
                    }
                }
            }
            this._proxy.$onDidChange(handle, picked);
        });
        return (
             (new Disposable$2(() => {
                listener?.dispose();
                this._proxy.$unregisterDecorationProvider(handle);
                this._provider.delete(handle);
            }))
        );
    }
    async $provideDecorations(handle, requests, token) {
        if (!this._provider.has(handle)) {
            return Object.create(null);
        }
        const result = Object.create(null);
        const { provider, extensionDescription: extensionId } = this._provider.get(handle);
        await Promise.all(( (requests.map(async (request) => {
            try {
                const { uri, id } = request;
                const data = await Promise.resolve(provider.provideFileDecoration(URI.revive(uri), token));
                if (!data) {
                    return;
                }
                try {
                    FileDecoration$1.validate(data);
                    if (data.badge && typeof data.badge !== 'string') {
                        checkProposedApiEnabled(extensionId, 'codiconDecoration');
                    }
                    result[id] = [data.propagate, data.tooltip, data.badge, data.color];
                }
                catch (e) {
                    this._logService.warn(`INVALID decoration from extension '${extensionId}': ${e}`);
                }
            }
            catch (err) {
                this._logService.error(err);
            }
        }))));
        return result;
    }
};
ExtHostDecorations._handlePool = 0;
ExtHostDecorations._maxEventSize = 250;
ExtHostDecorations = ( (__decorate([
    ( (__param(0, IExtHostRpcService))),
    ( (__param(1, ILogService)))
], ExtHostDecorations)));
const IExtHostDecorations = ( (createDecorator$1('IExtHostDecorations')));
function parse(entry) {
    const args = [];
    let stack;
    try {
        const parsedArguments = JSON.parse(entry.arguments);
        const stackArgument = parsedArguments[parsedArguments.length - 1];
        if (stackArgument && stackArgument.__$stack) {
            parsedArguments.pop();
            stack = stackArgument.__$stack;
        }
        args.push(...parsedArguments);
    }
    catch (error) {
        args.push('Unable to log remote console arguments', entry.arguments);
    }
    return { args, stack };
}
function findFirstFrame(stack) {
    if (!stack) {
        return stack;
    }
    const newlineIndex = stack.indexOf('\n');
    if (newlineIndex === -1) {
        return stack;
    }
    return stack.substring(0, newlineIndex);
}
function log(entry, label) {
    const { args, stack } = parse(entry);
    const isOneStringArg = typeof args[0] === 'string' && args.length === 1;
    let topFrame = findFirstFrame(stack);
    if (topFrame) {
        topFrame = `(${topFrame.trim()})`;
    }
    let consoleArgs = [];
    if (typeof args[0] === 'string') {
        if (topFrame && isOneStringArg) {
            consoleArgs = [`%c[${label}] %c${args[0]} %c${topFrame}`, color('blue'), color(''), color('grey')];
        }
        else {
            consoleArgs = [`%c[${label}] %c${args[0]}`, color('blue'), color(''), ...args.slice(1)];
        }
    }
    else {
        consoleArgs = [`%c[${label}]%`, color('blue'), ...args];
    }
    if (topFrame && !isOneStringArg) {
        consoleArgs.push(topFrame);
    }
    if (typeof console[entry.severity] !== 'function') {
        throw new Error('Unknown console method');
    }
    console[entry.severity].apply(console, consoleArgs);
}
function color(color) {
    return `color: ${color}`;
}
function logRemoteEntry(logService, entry, label = null) {
    const args = parse(entry).args;
    let firstArg = args.shift();
    if (typeof firstArg !== 'string') {
        return;
    }
    if (!entry.severity) {
        entry.severity = 'info';
    }
    if (label) {
        if (!/^\[/.test(label)) {
            label = `[${label}]`;
        }
        if (!/ $/.test(label)) {
            label = `${label} `;
        }
        firstArg = label + firstArg;
    }
    switch (entry.severity) {
        case 'log':
        case 'info':
            logService.info(firstArg, ...args);
            break;
        case 'warn':
            logService.warn(firstArg, ...args);
            break;
        case 'error':
            logService.error(firstArg, ...args);
            break;
    }
}
function logRemoteEntryIfError(logService, entry, label) {
    const args = parse(entry).args;
    const firstArg = args.shift();
    if (typeof firstArg !== 'string' || entry.severity !== 'error') {
        return;
    }
    if (!/^\[/.test(label)) {
        label = `[${label}]`;
    }
    if (!/ $/.test(label)) {
        label = `${label} `;
    }
    logService.error(label + firstArg, ...args);
}
function parseExtensionDevOptions(environmentService) {
    const isExtensionDevHost = environmentService.isExtensionDevelopment;
    let debugOk = true;
    const extDevLocs = environmentService.extensionDevelopmentLocationURI;
    if (extDevLocs) {
        for (const x of extDevLocs) {
            if (x.scheme !== Schemas.file) {
                debugOk = false;
            }
        }
    }
    const isExtensionDevDebug = debugOk && typeof environmentService.debugExtensionHost.port === 'number';
    const isExtensionDevDebugBrk = debugOk && !!environmentService.debugExtensionHost.break;
    const isExtensionDevTestFromCli = isExtensionDevHost && !!environmentService.extensionTestsLocationURI && !environmentService.debugExtensionHost.debugId;
    return {
        isExtensionDevHost,
        isExtensionDevDebug,
        isExtensionDevDebugBrk,
        isExtensionDevTestFromCli
    };
}
let MainThreadConsole = class MainThreadConsole {
    constructor(_extHostContext, _environmentService, _logService) {
        this._environmentService = _environmentService;
        this._logService = _logService;
        const devOpts = parseExtensionDevOptions(this._environmentService);
        this._isExtensionDevTestFromCli = devOpts.isExtensionDevTestFromCli;
    }
    dispose() {
    }
    $logExtensionHostMessage(entry) {
        if (this._isExtensionDevTestFromCli) {
            logRemoteEntry(this._logService, entry);
        }
        else {
            logRemoteEntryIfError(this._logService, entry, 'Extension Host');
            log(entry, 'Extension Host');
        }
    }
};
MainThreadConsole = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadConsole),
    ( (__param(1, IEnvironmentService))),
    ( (__param(2, ILogService)))
], MainThreadConsole)));
let MainThreadWorkspace = class MainThreadWorkspace {
    constructor(extHostContext, _searchService, _contextService, _editSessionIdentityService, _editorService, _workspaceEditingService, _notificationService, _requestService, _instantiationService, _labelService, _environmentService, fileService, _workspaceTrustManagementService, _workspaceTrustRequestService) {
        this._searchService = _searchService;
        this._contextService = _contextService;
        this._editSessionIdentityService = _editSessionIdentityService;
        this._editorService = _editorService;
        this._workspaceEditingService = _workspaceEditingService;
        this._notificationService = _notificationService;
        this._requestService = _requestService;
        this._instantiationService = _instantiationService;
        this._labelService = _labelService;
        this._environmentService = _environmentService;
        this._workspaceTrustManagementService = _workspaceTrustManagementService;
        this._workspaceTrustRequestService = _workspaceTrustRequestService;
        this._toDispose = ( (new DisposableStore()));
        this._activeCancelTokens = Object.create(null);
        this._queryBuilder = this._instantiationService.createInstance(QueryBuilder);
        this.registeredEditSessionProviders = ( (new Map()));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostWorkspace)));
        const workspace = this._contextService.getWorkspace();
        if (workspace.configuration && !isNative && !fileService.hasProvider(workspace.configuration)) {
            this._proxy.$initializeWorkspace(this.getWorkspaceData(workspace), this.isWorkspaceTrusted());
        }
        else {
            this._contextService.getCompleteWorkspace().then(workspace => this._proxy.$initializeWorkspace(this.getWorkspaceData(workspace), this.isWorkspaceTrusted()));
        }
        this._contextService.onDidChangeWorkspaceFolders(this._onDidChangeWorkspace, this, this._toDispose);
        this._contextService.onDidChangeWorkbenchState(this._onDidChangeWorkspace, this, this._toDispose);
        this._workspaceTrustManagementService.onDidChangeTrust(this._onDidGrantWorkspaceTrust, this, this._toDispose);
    }
    dispose() {
        this._toDispose.dispose();
        for (const requestId in this._activeCancelTokens) {
            const tokenSource = this._activeCancelTokens[requestId];
            tokenSource.cancel();
        }
    }
    $updateWorkspaceFolders(extensionName, index, deleteCount, foldersToAdd) {
        const workspaceFoldersToAdd = ( (foldersToAdd.map(f => ({ uri: URI.revive(f.uri), name: f.name }))));
        this._notificationService.status(this.getStatusMessage(extensionName, workspaceFoldersToAdd.length, deleteCount), { hideAfter: 10 * 1000  });
        return this._workspaceEditingService.updateFolders(index, deleteCount, workspaceFoldersToAdd, true);
    }
    getStatusMessage(extensionName, addCount, removeCount) {
        let message;
        const wantsToAdd = addCount > 0;
        const wantsToDelete = removeCount > 0;
        if (wantsToAdd && !wantsToDelete) {
            if (addCount === 1) {
                message = ( (localize(
                    'folderStatusMessageAddSingleFolder',
                    "Extension '{0}' added 1 folder to the workspace",
                    extensionName
                )));
            }
            else {
                message = ( (localize(
                    'folderStatusMessageAddMultipleFolders',
                    "Extension '{0}' added {1} folders to the workspace",
                    extensionName,
                    addCount
                )));
            }
        }
        else if (wantsToDelete && !wantsToAdd) {
            if (removeCount === 1) {
                message = ( (localize(
                    'folderStatusMessageRemoveSingleFolder',
                    "Extension '{0}' removed 1 folder from the workspace",
                    extensionName
                )));
            }
            else {
                message = ( (localize(
                    'folderStatusMessageRemoveMultipleFolders',
                    "Extension '{0}' removed {1} folders from the workspace",
                    extensionName,
                    removeCount
                )));
            }
        }
        else {
            message = ( (localize(
                'folderStatusChangeFolder',
                "Extension '{0}' changed folders of the workspace",
                extensionName
            )));
        }
        return message;
    }
    _onDidChangeWorkspace() {
        this._proxy.$acceptWorkspaceData(this.getWorkspaceData(this._contextService.getWorkspace()));
    }
    getWorkspaceData(workspace) {
        if (this._contextService.getWorkbenchState() === 1 ) {
            return null;
        }
        return {
            configuration: workspace.configuration || undefined,
            isUntitled: workspace.configuration ? isUntitledWorkspace(workspace.configuration, this._environmentService) : false,
            folders: workspace.folders,
            id: workspace.id,
            name: this._labelService.getWorkspaceLabel(workspace),
            transient: workspace.transient
        };
    }
    $startFileSearch(includePattern, _includeFolder, excludePatternOrDisregardExcludes, maxResults, token) {
        const includeFolder = URI.revive(_includeFolder);
        const workspace = this._contextService.getWorkspace();
        if (!workspace.folders.length) {
            return Promise.resolve(null);
        }
        const query = this._queryBuilder.file(includeFolder ? [includeFolder] : workspace.folders, {
            maxResults: withNullAsUndefined(maxResults),
            disregardExcludeSettings: (excludePatternOrDisregardExcludes === false) || undefined,
            disregardSearchExcludeSettings: true,
            disregardIgnoreFiles: true,
            includePattern: withNullAsUndefined(includePattern),
            excludePattern: typeof excludePatternOrDisregardExcludes === 'string' ? excludePatternOrDisregardExcludes : undefined,
            _reason: 'startFileSearch'
        });
        return this._searchService.fileSearch(query, token).then(result => {
            return (
                 (result.results.map(m => m.resource))
            );
        }, err => {
            if (!isCancellationError(err)) {
                return Promise.reject(err);
            }
            return null;
        });
    }
    $startTextSearch(pattern, _folder, options, requestId, token) {
        const folder = URI.revive(_folder);
        const workspace = this._contextService.getWorkspace();
        const folders = folder ? [folder] : ( (workspace.folders.map(folder => folder.uri)));
        const query = this._queryBuilder.text(pattern, folders, options);
        query._reason = 'startTextSearch';
        const onProgress = (p) => {
            if (p.results) {
                this._proxy.$handleTextSearchResult(p, requestId);
            }
        };
        const search = this._searchService.textSearch(query, token, onProgress).then(result => {
            return { limitHit: result.limitHit };
        }, err => {
            if (!isCancellationError(err)) {
                return Promise.reject(err);
            }
            return null;
        });
        return search;
    }
    $checkExists(folders, includes, token) {
        return this._instantiationService.invokeFunction((accessor) => checkGlobFileExists(accessor, folders, includes, token));
    }
    $saveAll(includeUntitled) {
        return this._editorService.saveAll({ includeUntitled });
    }
    $resolveProxy(url) {
        return this._requestService.resolveProxy(url);
    }
    $requestWorkspaceTrust(options) {
        return this._workspaceTrustRequestService.requestWorkspaceTrust(options);
    }
    isWorkspaceTrusted() {
        return this._workspaceTrustManagementService.isWorkspaceTrusted();
    }
    _onDidGrantWorkspaceTrust() {
        this._proxy.$onDidGrantWorkspaceTrust();
    }
    $registerEditSessionIdentityProvider(handle, scheme) {
        const disposable = this._editSessionIdentityService.registerEditSessionIdentityProvider({
            scheme: scheme,
            getEditSessionIdentifier: async (workspaceFolder, token) => {
                return this._proxy.$getEditSessionIdentifier(workspaceFolder.uri, token);
            },
            provideEditSessionIdentityMatch: async (workspaceFolder, identity1, identity2, token) => {
                return this._proxy.$provideEditSessionIdentityMatch(workspaceFolder.uri, identity1, identity2, token);
            }
        });
        this.registeredEditSessionProviders.set(handle, disposable);
        this._toDispose.add(disposable);
    }
    $unregisterEditSessionIdentityProvider(handle) {
        const disposable = this.registeredEditSessionProviders.get(handle);
        disposable?.dispose();
        this.registeredEditSessionProviders.delete(handle);
    }
};
MainThreadWorkspace = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadWorkspace),
    ( (__param(1, ISearchService))),
    ( (__param(2, IWorkspaceContextService))),
    ( (__param(3, IEditSessionIdentityService))),
    ( (__param(4, IEditorService))),
    ( (__param(5, IWorkspaceEditingService))),
    ( (__param(6, INotificationService))),
    ( (__param(7, IRequestService))),
    ( (__param(8, IInstantiationService))),
    ( (__param(9, ILabelService))),
    ( (__param(10, IEnvironmentService))),
    ( (__param(11, IFileService))),
    ( (__param(12, IWorkspaceTrustManagementService))),
    ( (__param(13, IWorkspaceTrustRequestService)))
], MainThreadWorkspace)));
let MainThreadExtensionService = class MainThreadExtensionService {
    constructor(extHostContext, _extensionService, _notificationService, _extensionsWorkbenchService, _hostService, _extensionEnablementService, _timerService, _commandService, _environmentService) {
        this._extensionService = _extensionService;
        this._notificationService = _notificationService;
        this._extensionsWorkbenchService = _extensionsWorkbenchService;
        this._hostService = _hostService;
        this._extensionEnablementService = _extensionEnablementService;
        this._timerService = _timerService;
        this._commandService = _commandService;
        this._environmentService = _environmentService;
        this._extensionHostKind = extHostContext.extensionHostKind;
        const internalExtHostContext = extHostContext;
        this._internalExtensionService = internalExtHostContext.internalExtensionService;
    }
    dispose() {
    }
    $getExtension(extensionId) {
        return this._extensionService.getExtension(extensionId);
    }
    $activateExtension(extensionId, reason) {
        return this._internalExtensionService._activateById(extensionId, reason);
    }
    async $onWillActivateExtension(extensionId) {
        this._internalExtensionService._onWillActivateExtension(extensionId);
    }
    $onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) {
        this._internalExtensionService._onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason);
    }
    $onExtensionRuntimeError(extensionId, data) {
        const error = ( (new Error()));
        error.name = data.name;
        error.message = data.message;
        error.stack = data.stack;
        this._internalExtensionService._onExtensionRuntimeError(extensionId, error);
        console.error(`[${extensionId}]${error.message}`);
        console.error(error.stack);
    }
    async $onExtensionActivationError(extensionId, data, missingExtensionDependency) {
        const error = ( (new Error()));
        error.name = data.name;
        error.message = data.message;
        error.stack = data.stack;
        this._internalExtensionService._onDidActivateExtensionError(extensionId, error);
        if (missingExtensionDependency) {
            const extension = await this._extensionService.getExtension(extensionId.value);
            if (extension) {
                const local = await this._extensionsWorkbenchService.queryLocal();
                const installedDependency = local.find(i => areSameExtensions(i.identifier, { id: missingExtensionDependency.dependency }));
                if (installedDependency?.local) {
                    await this._handleMissingInstalledDependency(extension, installedDependency.local);
                    return;
                }
                else {
                    await this._handleMissingNotInstalledDependency(extension, missingExtensionDependency.dependency);
                    return;
                }
            }
        }
        const isDev = !this._environmentService.isBuilt || this._environmentService.isExtensionDevelopment;
        if (isDev) {
            this._notificationService.error(error);
            return;
        }
        console.error(error.message);
    }
    async _handleMissingInstalledDependency(extension, missingInstalledDependency) {
        const extName = extension.displayName || extension.name;
        if (this._extensionEnablementService.isEnabled(missingInstalledDependency)) {
            this._notificationService.notify({
                severity: Severity$1.Error,
                message: ( (localize(
                    'reload window',
                    "Cannot activate the '{0}' extension because it depends on the '{1}' extension, which is not loaded. Would you like to reload the window to load the extension?",
                    extName,
                    missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                ))),
                actions: {
                    primary: [( (new Action(
                        'reload',
                         (localize('reload', "Reload Window")),
                        '',
                        true,
                        () => this._hostService.reload()
                    )))]
                }
            });
        }
        else {
            const enablementState = this._extensionEnablementService.getEnablementState(missingInstalledDependency);
            if (enablementState === 4 ) {
                this._notificationService.notify({
                    severity: Severity$1.Error,
                    message: ( (localize(
                        'notSupportedInWorkspace',
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is not supported in the current workspace",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    ))),
                });
            }
            else if (enablementState === 0 ) {
                this._notificationService.notify({
                    severity: Severity$1.Error,
                    message: ( (localize(
                        'restrictedMode',
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is not supported in Restricted Mode",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    ))),
                    actions: {
                        primary: [( (new Action(
                            'manageWorkspaceTrust',
                             (localize('manageWorkspaceTrust', "Manage Workspace Trust")),
                            '',
                            true,
                            () => this._commandService.executeCommand('workbench.trust.manage')
                        )))]
                    }
                });
            }
            else if (this._extensionEnablementService.canChangeEnablement(missingInstalledDependency)) {
                this._notificationService.notify({
                    severity: Severity$1.Error,
                    message: ( (localize(
                        'disabledDep',
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is disabled. Would you like to enable the extension and reload the window?",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    ))),
                    actions: {
                        primary: [( (new Action(
                            'enable',
                             (localize('enable dep', "Enable and Reload")),
                            '',
                            true,
                            () => this._extensionEnablementService.setEnablement([missingInstalledDependency], enablementState === 6  ? 8  : 9 )
                                    .then(() => this._hostService.reload(), e => this._notificationService.error(e))
                        )))]
                    }
                });
            }
            else {
                this._notificationService.notify({
                    severity: Severity$1.Error,
                    message: ( (localize(
                        'disabledDepNoAction',
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is disabled.",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    ))),
                });
            }
        }
    }
    async _handleMissingNotInstalledDependency(extension, missingDependency) {
        const extName = extension.displayName || extension.name;
        let dependencyExtension = null;
        try {
            dependencyExtension = (await this._extensionsWorkbenchService.getExtensions([{ id: missingDependency }], CancellationToken.None))[0];
        }
        catch (err) {
        }
        if (dependencyExtension) {
            this._notificationService.notify({
                severity: Severity$1.Error,
                message: ( (localize(
                    'uninstalledDep',
                    "Cannot activate the '{0}' extension because it depends on the '{1}' extension, which is not installed. Would you like to install the extension and reload the window?",
                    extName,
                    dependencyExtension.displayName
                ))),
                actions: {
                    primary: [( (new Action(
                        'install',
                         (localize('install missing dep', "Install and Reload")),
                        '',
                        true,
                        () => this._extensionsWorkbenchService.install(dependencyExtension)
                                .then(() => this._hostService.reload(), e => this._notificationService.error(e))
                    )))]
                }
            });
        }
        else {
            this._notificationService.error(( (localize(
                'unknownDep',
                "Cannot activate the '{0}' extension because it depends on an unknown '{1}' extension.",
                extName,
                missingDependency
            ))));
        }
    }
    async $setPerformanceMarks(marks) {
        if (this._extensionHostKind === 1 ) {
            this._timerService.setPerformanceMarks('localExtHost', marks);
        }
        else if (this._extensionHostKind === 2 ) {
            this._timerService.setPerformanceMarks('workerExtHost', marks);
        }
        else {
            this._timerService.setPerformanceMarks('remoteExtHost', marks);
        }
    }
    async $asBrowserUri(uri) {
        return FileAccess.uriToBrowserUri(URI.revive(uri));
    }
};
MainThreadExtensionService = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadExtensionService),
    ( (__param(1, IExtensionService))),
    ( (__param(2, INotificationService))),
    ( (__param(3, IExtensionsWorkbenchService))),
    ( (__param(4, IHostService))),
    ( (__param(5, IWorkbenchExtensionEnablementService))),
    ( (__param(6, ITimerService))),
    ( (__param(7, ICommandService))),
    ( (__param(8, IWorkbenchEnvironmentService)))
], MainThreadExtensionService)));
class FsLinkProvider {
    constructor() {
        this._schemes = [];
    }
    add(scheme) {
        this._stateMachine = undefined;
        this._schemes.push(scheme);
    }
    delete(scheme) {
        const idx = this._schemes.indexOf(scheme);
        if (idx >= 0) {
            this._schemes.splice(idx, 1);
            this._stateMachine = undefined;
        }
    }
    _initStateMachine() {
        if (!this._stateMachine) {
            const schemes = this._schemes.sort();
            const edges = [];
            let prevScheme;
            let prevState;
            let lastState = 14 ;
            let nextState = 14 ;
            for (const scheme of schemes) {
                let pos = !prevScheme ? 0 : commonPrefixLength(prevScheme, scheme);
                if (pos === 0) {
                    prevState = 1 ;
                }
                else {
                    prevState = nextState;
                }
                for (; pos < scheme.length; pos++) {
                    if (pos + 1 === scheme.length) {
                        lastState = nextState;
                        nextState = 9 ;
                    }
                    else {
                        nextState += 1;
                    }
                    edges.push([prevState, scheme.toUpperCase().charCodeAt(pos), nextState]);
                    edges.push([prevState, scheme.toLowerCase().charCodeAt(pos), nextState]);
                    prevState = nextState;
                }
                prevScheme = scheme;
                nextState = lastState;
            }
            edges.push([9 , 58 , 10 ]);
            edges.push([10 , 47 , 12 ]);
            this._stateMachine = ( (new StateMachine(edges)));
        }
    }
    provideDocumentLinks(document) {
        this._initStateMachine();
        const result = [];
        const links = LinkComputer.computeLinks({
            getLineContent(lineNumber) {
                return document.lineAt(lineNumber - 1).text;
            },
            getLineCount() {
                return document.lineCount;
            }
        }, this._stateMachine);
        for (const link of links) {
            const docLink = DocumentLink$1.to(link);
            if (docLink.target) {
                result.push(docLink);
            }
        }
        return result;
    }
}
class ExtHostFileSystem {
    constructor(mainContext, _extHostLanguageFeatures) {
        this._extHostLanguageFeatures = _extHostLanguageFeatures;
        this._linkProvider = ( (new FsLinkProvider()));
        this._fsProvider = ( (new Map()));
        this._registeredSchemes = ( (new Set()));
        this._watches = ( (new Map()));
        this._handlePool = 0;
        this._proxy = ( (mainContext.getProxy(MainContext.MainThreadFileSystem)));
    }
    dispose() {
        this._linkProviderRegistration?.dispose();
    }
    registerFileSystemProvider(extension, scheme, provider, options = {}) {
        if (this._registeredSchemes.has(scheme)) {
            throw new Error(`a provider for the scheme '${scheme}' is already registered`);
        }
        if (!this._linkProviderRegistration) {
            this._linkProviderRegistration = this._extHostLanguageFeatures.registerDocumentLinkProvider(extension, '*', this._linkProvider);
        }
        const handle = this._handlePool++;
        this._linkProvider.add(scheme);
        this._registeredSchemes.add(scheme);
        this._fsProvider.set(handle, provider);
        let capabilities = 2 ;
        if (options.isCaseSensitive) {
            capabilities += 1024 ;
        }
        if (options.isReadonly) {
            capabilities += 2048 ;
        }
        if (typeof provider.copy === 'function') {
            capabilities += 8 ;
        }
        if (typeof provider.open === 'function' && typeof provider.close === 'function'
            && typeof provider.read === 'function' && typeof provider.write === 'function') {
            checkProposedApiEnabled(extension, 'fsChunks');
            capabilities += 4 ;
        }
        this._proxy.$registerFileSystemProvider(handle, scheme, capabilities).catch(err => {
            console.error(`FAILED to register filesystem provider of ${extension.identifier.value}-extension for the scheme ${scheme}`);
            console.error(err);
        });
        const subscription = provider.onDidChangeFile(event => {
            const mapped = [];
            for (const e of event) {
                const { uri: resource, type } = e;
                if (resource.scheme !== scheme) {
                    continue;
                }
                let newType;
                switch (type) {
                    case FileChangeType$1.Changed:
                        newType = 0 ;
                        break;
                    case FileChangeType$1.Created:
                        newType = 1 ;
                        break;
                    case FileChangeType$1.Deleted:
                        newType = 2 ;
                        break;
                    default:
                        throw new Error('Unknown FileChangeType');
                }
                mapped.push({ resource, type: newType });
            }
            this._proxy.$onFileSystemChange(handle, mapped);
        });
        return toDisposable(() => {
            subscription.dispose();
            this._linkProvider.delete(scheme);
            this._registeredSchemes.delete(scheme);
            this._fsProvider.delete(handle);
            this._proxy.$unregisterProvider(handle);
        });
    }
    static _asIStat(stat) {
        const { type, ctime, mtime, size, permissions } = stat;
        return { type, ctime, mtime, size, permissions };
    }
    $stat(handle, resource) {
        return Promise.resolve(this._getFsProvider(handle).stat(URI.revive(resource))).then(stat => ExtHostFileSystem._asIStat(stat));
    }
    $readdir(handle, resource) {
        return Promise.resolve(this._getFsProvider(handle).readDirectory(URI.revive(resource)));
    }
    $readFile(handle, resource) {
        return Promise.resolve(this._getFsProvider(handle).readFile(URI.revive(resource))).then(data => VSBuffer.wrap(data));
    }
    $writeFile(handle, resource, content, opts) {
        return Promise.resolve(this._getFsProvider(handle).writeFile(URI.revive(resource), content.buffer, opts));
    }
    $delete(handle, resource, opts) {
        return Promise.resolve(this._getFsProvider(handle).delete(URI.revive(resource), opts));
    }
    $rename(handle, oldUri, newUri, opts) {
        return Promise.resolve(this._getFsProvider(handle).rename(URI.revive(oldUri), URI.revive(newUri), opts));
    }
    $copy(handle, oldUri, newUri, opts) {
        const provider = this._getFsProvider(handle);
        if (!provider.copy) {
            throw new Error('FileSystemProvider does not implement "copy"');
        }
        return Promise.resolve(provider.copy(URI.revive(oldUri), URI.revive(newUri), opts));
    }
    $mkdir(handle, resource) {
        return Promise.resolve(this._getFsProvider(handle).createDirectory(URI.revive(resource)));
    }
    $watch(handle, session, resource, opts) {
        const subscription = this._getFsProvider(handle).watch(URI.revive(resource), opts);
        this._watches.set(session, subscription);
    }
    $unwatch(_handle, session) {
        const subscription = this._watches.get(session);
        if (subscription) {
            subscription.dispose();
            this._watches.delete(session);
        }
    }
    $open(handle, resource, opts) {
        const provider = this._getFsProvider(handle);
        if (!provider.open) {
            throw new Error('FileSystemProvider does not implement "open"');
        }
        return Promise.resolve(provider.open(URI.revive(resource), opts));
    }
    $close(handle, fd) {
        const provider = this._getFsProvider(handle);
        if (!provider.close) {
            throw new Error('FileSystemProvider does not implement "close"');
        }
        return Promise.resolve(provider.close(fd));
    }
    $read(handle, fd, pos, length) {
        const provider = this._getFsProvider(handle);
        if (!provider.read) {
            throw new Error('FileSystemProvider does not implement "read"');
        }
        const data = VSBuffer.alloc(length);
        return Promise.resolve(provider.read(fd, pos, data.buffer, 0, length)).then(read => {
            return data.slice(0, read);
        });
    }
    $write(handle, fd, pos, data) {
        const provider = this._getFsProvider(handle);
        if (!provider.write) {
            throw new Error('FileSystemProvider does not implement "write"');
        }
        return Promise.resolve(provider.write(fd, pos, data.buffer, 0, data.byteLength));
    }
    _getFsProvider(handle) {
        const provider = this._fsProvider.get(handle);
        if (!provider) {
            const err = ( (new Error()));
            err.name = 'ENOPRO';
            err.message = `no provider`;
            throw err;
        }
        return provider;
    }
}
const IWorkbenchFileService = refineServiceDecorator(IFileService);
class AbstractWatcherClient extends Disposable$1 {
    constructor(onFileChanges, onLogMessage, verboseLogging, options) {
        super();
        this.onFileChanges = onFileChanges;
        this.onLogMessage = onLogMessage;
        this.verboseLogging = verboseLogging;
        this.options = options;
        this.watcherDisposables = this._register(( (new MutableDisposable())));
        this.requests = undefined;
        this.restartCounter = 0;
    }
    init() {
        const disposables = ( (new DisposableStore()));
        this.watcherDisposables.value = disposables;
        this.watcher = this.createWatcher(disposables);
        this.watcher.setVerboseLogging(this.verboseLogging);
        disposables.add(this.watcher.onDidChangeFile(changes => this.onFileChanges(changes)));
        disposables.add(this.watcher.onDidLogMessage(msg => this.onLogMessage(msg)));
        disposables.add(this.watcher.onDidError(error => this.onError(error)));
    }
    onError(error) {
        if (this.options.restartOnError) {
            if (this.restartCounter < AbstractWatcherClient.MAX_RESTARTS && this.requests) {
                this.error(`restarting watcher after error: ${error}`);
                this.restart(this.requests);
            }
            else {
                this.error(`gave up attempting to restart watcher after error: ${error}`);
            }
        }
        else {
            this.error(error);
        }
    }
    restart(requests) {
        this.restartCounter++;
        this.init();
        this.watch(requests);
    }
    async watch(requests) {
        this.requests = requests;
        await this.watcher?.watch(requests);
    }
    async setVerboseLogging(verboseLogging) {
        this.verboseLogging = verboseLogging;
        await this.watcher?.setVerboseLogging(verboseLogging);
    }
    error(message) {
        this.onLogMessage({ type: 'error', message: `[File Watcher (${this.options.type})] ${message}` });
    }
    trace(message) {
        this.onLogMessage({ type: 'trace', message: `[File Watcher (${this.options.type})] ${message}` });
    }
    dispose() {
        this.watcher = undefined;
        return super.dispose();
    }
}
AbstractWatcherClient.MAX_RESTARTS = 5;
function normalizeWatcherPattern(path, pattern) {
    if (typeof pattern === 'string' && !pattern.startsWith(GLOBSTAR) && !isAbsolute(pattern)) {
        return { base: path, pattern };
    }
    return pattern;
}
var MainThreadFileSystem_1;
let MainThreadFileSystem = MainThreadFileSystem_1 = class MainThreadFileSystem {
    constructor(extHostContext, _fileService, _contextService, _logService, _configurationService) {
        this._fileService = _fileService;
        this._contextService = _contextService;
        this._logService = _logService;
        this._configurationService = _configurationService;
        this._fileProvider = ( (new DisposableMap()));
        this._disposables = ( (new DisposableStore()));
        this._watches = ( (new DisposableMap()));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostFileSystem)));
        const infoProxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostFileSystemInfo)));
        for (const entry of _fileService.listCapabilities()) {
            infoProxy.$acceptProviderInfos(( (URI.from({ scheme: entry.scheme, path: '/dummy' }))), entry.capabilities);
        }
        this._disposables.add(_fileService.onDidChangeFileSystemProviderRegistrations(e => infoProxy.$acceptProviderInfos(( (URI.from({ scheme: e.scheme, path: '/dummy' }))), e.provider?.capabilities ?? null)));
        this._disposables.add(_fileService.onDidChangeFileSystemProviderCapabilities(e => infoProxy.$acceptProviderInfos(( (URI.from({ scheme: e.scheme, path: '/dummy' }))), e.provider.capabilities)));
    }
    dispose() {
        this._disposables.dispose();
        this._fileProvider.dispose();
        this._watches.dispose();
    }
    async $registerFileSystemProvider(handle, scheme, capabilities) {
        this._fileProvider.set(handle, ( (new RemoteFileSystemProvider(this._fileService, scheme, capabilities, handle, this._proxy))));
    }
    $unregisterProvider(handle) {
        this._fileProvider.deleteAndDispose(handle);
    }
    $onFileSystemChange(handle, changes) {
        const fileProvider = this._fileProvider.get(handle);
        if (!fileProvider) {
            throw new Error('Unknown file provider');
        }
        fileProvider.$onFileSystemChange(changes);
    }
    $stat(uri) {
        return this._fileService.stat(URI.revive(uri)).then(stat => {
            return {
                ctime: stat.ctime,
                mtime: stat.mtime,
                size: stat.size,
                permissions: stat.readonly ? FilePermission$1.Readonly : undefined,
                type: MainThreadFileSystem_1._asFileType(stat)
            };
        }).catch(MainThreadFileSystem_1._handleError);
    }
    $readdir(uri) {
        return this._fileService.resolve(URI.revive(uri), { resolveMetadata: false }).then(stat => {
            if (!stat.isDirectory) {
                const err = ( (new Error(stat.name)));
                err.name = FileSystemProviderErrorCode.FileNotADirectory;
                throw err;
            }
            return !stat.children ? [] : ( (stat.children.map(child => [child.name, MainThreadFileSystem_1._asFileType(child)])));
        }).catch(MainThreadFileSystem_1._handleError);
    }
    static _asFileType(stat) {
        let res = 0;
        if (stat.isFile) {
            res += FileType$1.File;
        }
        else if (stat.isDirectory) {
            res += FileType$1.Directory;
        }
        if (stat.isSymbolicLink) {
            res += FileType$1.SymbolicLink;
        }
        return res;
    }
    $readFile(uri) {
        return this._fileService.readFile(URI.revive(uri)).then(file => file.value).catch(MainThreadFileSystem_1._handleError);
    }
    $writeFile(uri, content) {
        return this._fileService.writeFile(URI.revive(uri), content)
            .then(() => undefined).catch(MainThreadFileSystem_1._handleError);
    }
    $rename(source, target, opts) {
        return this._fileService.move(URI.revive(source), URI.revive(target), opts.overwrite)
            .then(() => undefined).catch(MainThreadFileSystem_1._handleError);
    }
    $copy(source, target, opts) {
        return this._fileService.copy(URI.revive(source), URI.revive(target), opts.overwrite)
            .then(() => undefined).catch(MainThreadFileSystem_1._handleError);
    }
    $mkdir(uri) {
        return this._fileService.createFolder(URI.revive(uri))
            .then(() => undefined).catch(MainThreadFileSystem_1._handleError);
    }
    $delete(uri, opts) {
        return this._fileService.del(URI.revive(uri), opts).catch(MainThreadFileSystem_1._handleError);
    }
    static _handleError(err) {
        if (err instanceof FileOperationError) {
            switch (err.fileOperationResult) {
                case 1 :
                    err.name = FileSystemProviderErrorCode.FileNotFound;
                    break;
                case 0 :
                    err.name = FileSystemProviderErrorCode.FileIsADirectory;
                    break;
                case 6 :
                    err.name = FileSystemProviderErrorCode.NoPermissions;
                    break;
                case 4 :
                    err.name = FileSystemProviderErrorCode.FileExists;
                    break;
            }
        }
        else if (err instanceof Error) {
            const code = toFileSystemProviderErrorCode(err);
            if (code !== FileSystemProviderErrorCode.Unknown) {
                err.name = code;
            }
        }
        throw err;
    }
    $ensureActivation(scheme) {
        return this._fileService.activateProvider(scheme);
    }
    async $watch(extensionId, session, resource, unvalidatedOpts) {
        const uri = URI.revive(resource);
        const workspaceFolder = this._contextService.getWorkspaceFolder(uri);
        const opts = { ...unvalidatedOpts };
        if (opts.recursive) {
            try {
                const stat = await this._fileService.stat(uri);
                if (!stat.isDirectory) {
                    opts.recursive = false;
                }
            }
            catch (error) {
                this._logService.error(`MainThreadFileSystem#$watch(): failed to stat a resource for file watching (extension: ${extensionId}, path: ${( ( uri.toString(true)))}, recursive: ${opts.recursive}, session: ${session}): ${error}`);
            }
        }
        if (workspaceFolder && opts.recursive) {
            this._logService.trace(`MainThreadFileSystem#$watch(): ignoring request to start watching because path is inside workspace (extension: ${extensionId}, path: ${( ( uri.toString(true)))}, recursive: ${opts.recursive}, session: ${session})`);
            return;
        }
        this._logService.trace(`MainThreadFileSystem#$watch(): request to start watching (extension: ${extensionId}, path: ${( ( uri.toString(true)))}, recursive: ${opts.recursive}, session: ${session})`);
        if (opts.recursive) {
            const config = this._configurationService.getValue();
            if (config.files?.watcherExclude) {
                for (const key in config.files.watcherExclude) {
                    if (config.files.watcherExclude[key] === true) {
                        opts.excludes.push(key);
                    }
                }
            }
        }
        else if (workspaceFolder) {
            const config = this._configurationService.getValue();
            if (config.files?.watcherExclude) {
                for (const key in config.files.watcherExclude) {
                    if (config.files.watcherExclude[key] === true) {
                        if (!opts.includes) {
                            opts.includes = [];
                        }
                        const includePattern = `${rtrim(key, '/')}/${GLOBSTAR}`;
                        opts.includes.push(normalizeWatcherPattern(workspaceFolder.uri.fsPath, includePattern));
                    }
                }
            }
            if (!opts.includes || opts.includes.length === 0) {
                this._logService.trace(`MainThreadFileSystem#$watch(): ignoring request to start watching because path is inside workspace and no excludes are configured (extension: ${extensionId}, path: ${( ( uri.toString(true)))}, recursive: ${opts.recursive}, session: ${session})`);
                return;
            }
        }
        const subscription = this._fileService.watch(uri, opts);
        this._watches.set(session, subscription);
    }
    $unwatch(session) {
        if (this._watches.has(session)) {
            this._logService.trace(`MainThreadFileSystem#$unwatch(): request to stop watching (session: ${session})`);
            this._watches.deleteAndDispose(session);
        }
    }
};
MainThreadFileSystem = MainThreadFileSystem_1 = ( (__decorate([
    extHostNamedCustomer(MainContext.MainThreadFileSystem),
    ( (__param(1, IWorkbenchFileService))),
    ( (__param(2, IWorkspaceContextService))),
    ( (__param(3, ILogService))),
    ( (__param(4, IConfigurationService)))
], MainThreadFileSystem)));
class RemoteFileSystemProvider {
    constructor(fileService, scheme, capabilities, _handle, _proxy) {
        this._handle = _handle;
        this._proxy = _proxy;
        this._onDidChange = ( (new Emitter$1()));
        this.onDidChangeFile = this._onDidChange.event;
        this.onDidChangeCapabilities = Event.None;
        this.capabilities = capabilities;
        this._registration = fileService.registerProvider(scheme, this);
    }
    dispose() {
        this._registration.dispose();
        this._onDidChange.dispose();
    }
    watch(resource, opts) {
        const session = Math.random();
        this._proxy.$watch(this._handle, session, resource, opts);
        return toDisposable(() => {
            this._proxy.$unwatch(this._handle, session);
        });
    }
    $onFileSystemChange(changes) {
        this._onDidChange.fire(( (changes.map(RemoteFileSystemProvider._createFileChange))));
    }
    static _createFileChange(dto) {
        return { resource: URI.revive(dto.resource), type: dto.type };
    }
    stat(resource) {
        return this._proxy.$stat(this._handle, resource).then(undefined, err => {
            throw err;
        });
    }
    readFile(resource) {
        return this._proxy.$readFile(this._handle, resource).then(buffer => buffer.buffer);
    }
    writeFile(resource, content, opts) {
        return this._proxy.$writeFile(this._handle, resource, VSBuffer.wrap(content), opts);
    }
    delete(resource, opts) {
        return this._proxy.$delete(this._handle, resource, opts);
    }
    mkdir(resource) {
        return this._proxy.$mkdir(this._handle, resource);
    }
    readdir(resource) {
        return this._proxy.$readdir(this._handle, resource);
    }
    rename(resource, target, opts) {
        return this._proxy.$rename(this._handle, resource, target, opts);
    }
    copy(resource, target, opts) {
        return this._proxy.$copy(this._handle, resource, target, opts);
    }
    open(resource, opts) {
        return this._proxy.$open(this._handle, resource, opts);
    }
    close(fd) {
        return this._proxy.$close(this._handle, fd);
    }
    read(fd, pos, data, offset, length) {
        return this._proxy.$read(this._handle, fd, pos, length).then(readData => {
            data.set(readData.buffer, offset);
            return readData.byteLength;
        });
    }
    write(fd, pos, data, offset, length) {
        return this._proxy.$write(this._handle, fd, pos, VSBuffer.wrap(data).slice(offset, offset + length));
    }
}
class MainThreadMessageServiceWithoutSource extends MainThreadMessageService {
    constructor() {
        super(...arguments);
        this.$showMessage = (severity, message, options, commands) => {
            const _options = {
                ...options,
                source: undefined
            };
            return super.$showMessage(severity, message, _options, commands);
        };
    }
}
let SyncExtHostConfiguration = class SyncExtHostConfiguration extends ExtHostConfiguration {
    constructor(extHostRpc, extHostWorkspace, logService) {
        super(extHostRpc, extHostWorkspace, logService);
    }
    getConfigProviderSync() {
        return this['_actual'];
    }
};
SyncExtHostConfiguration = ( __decorate([
    ( __param(0, IExtHostRpcService)),
    ( __param(1, IExtHostWorkspace)),
    ( __param(2, ILogService))
], SyncExtHostConfiguration));
class SimpleMessagePassingProtocol {
    constructor() {
        this._onMessage = new BufferedEmitter();
        this.onMessage = this._onMessage.event;
    }
    send(buffer) {
        this._onMessage.fire(buffer);
    }
}
const imessagePassingProtocol = new SimpleMessagePassingProtocol();
const rpcProtocol = new RPCProtocol(imessagePassingProtocol);
class InjectedExtHostRpcService extends ExtHostRpcService {
    constructor() {
        super(rpcProtocol);
    }
}
const environment = {
    isExtensionDevelopmentDebug: false,
    appName: 'Monaco',
    appHost: 'web',
    appLanguage: window.navigator.language ?? 'en-US',
    extensionTelemetryLogResource: ( URI.from({ scheme: 'user', path: '/extensionTelemetryLogResource.log' })),
    isExtensionTelemetryLoggingOnly: false,
    get appUriScheme() { return unsupported$1(); },
    get globalStorageHome() { return unsupported$1(); },
    get workspaceStorageHome() { return unsupported$1(); }
};
registerSingleton(IExtHostInitDataService, class ExtHostInitDataService {
    constructor() {
        this.version = '1.0.0';
        this.parentPid = 0;
        this.environment = environment;
        this.allExtensions = [];
        this.myExtensions = [];
        this.consoleForward = {
            includeStack: false,
            logNative: false
        };
        this.logLevel = LogLevel$1.Trace;
        this.autoStart = true;
        this.remote = {
            isRemote: false,
            authority: undefined,
            connectionData: null
        };
        this.uiKind = UIKind$1.Web;
        this.loggers = [];
        this.logName = 'browser';
    }
    get telemetryInfo() { return unsupported$1(); }
    get logsLocation() { return unsupported$1(); }
    get logFile() { return unsupported$1(); }
}, 0 );
registerSingleton(IHostUtils, class HostUtils {
    constructor() {
        this.pid = undefined;
    }
    exit() {
        window.close();
    }
    async exists() {
        return true;
    }
    async realpath(path) {
        return path;
    }
}, 0 );
registerSingleton(IExtHostRpcService, InjectedExtHostRpcService, 0 );
registerSingleton(IExtHostFileSystemInfo, ExtHostFileSystemInfo, 0 );
registerSingleton(IExtHostConsumerFileSystem, ExtHostConsumerFileSystem, 0 );
registerSingleton(IExtensionStoragePaths, ExtensionStoragePaths, 0 );
registerSingleton(IExtHostLocalizationService, ExtHostLocalizationService, 1 );
registerSingleton(IExtHostDocumentsAndEditors, ExtHostDocumentsAndEditors, 0 );
class ExtHostExtensionService extends AbstractExtHostExtensionService {
    constructor() {
        super(...arguments);
        this.extensionRuntime = ExtensionRuntime.Webworker;
        this._getEntryPoint = unsupported$1;
        this._loadCommonJSModule = unsupported$1;
        this.$setRemoteEnvironment = unsupported$1;
    }
    async _beforeAlmostReadyToRunExtensions() { }
    getExtensionRegistries() {
        return { mine: this._myRegistry, all: this._globalRegistry };
    }
}
registerSingleton(IExtHostExtensionService, ExtHostExtensionService, 0 );
registerSingleton(IExtHostConfiguration, SyncExtHostConfiguration, 0 );
registerSingleton(IExtHostTunnelService, ExtHostTunnelService, 0 );
registerSingleton(IExtHostFileSystemInfo, ExtHostFileSystemInfo, 0 );
registerSingleton(IExtHostTelemetry, ExtHostTelemetry, 0 );
registerSingleton(IExtHostCommands, ExtHostCommands, 0 );
registerSingleton(IExtHostDocumentsAndEditors, ExtHostDocumentsAndEditors, 0 );
registerSingleton(IExtHostWindow, ExtHostWindow, 0 );
registerSingleton(IExtHostWorkspace, ExtHostWorkspace, 0 );
registerSingleton(IExtHostEditorTabs, ExtHostEditorTabs, 0 );
registerSingleton(IExtHostApiDeprecationService, ExtHostApiDeprecationService, 0 );
registerSingleton(IExtHostDecorations, ExtHostDecorations, 0 );
registerSingleton(IExtHostDebugService, WorkerExtHostDebugService, 0 );
registerSingleton(IExtHostVariableResolverProvider, ExtHostVariableResolverProviderService, 0 );
registerSingleton(IExtHostTerminalService, class ExtHostTerminalService {
    constructor() {
        this.activeTerminal = undefined;
        this.terminals = [];
        this.onDidCloseTerminal = Event.None;
        this.onDidOpenTerminal = Event.None;
        this.onDidChangeActiveTerminal = Event.None;
        this.onDidChangeTerminalDimensions = Event.None;
        this.onDidChangeTerminalState = Event.None;
        this.onDidWriteTerminalData = Event.None;
        this.onDidChangeShell = Event.None;
        this.createTerminal = unsupported$1;
        this.createTerminalFromOptions = unsupported$1;
        this.createExtensionTerminal = unsupported$1;
        this.attachPtyToTerminal = unsupported$1;
        this.getDefaultShell = unsupported$1;
        this.getDefaultShellArgs = unsupported$1;
        this.registerLinkProvider = unsupported$1;
        this.registerProfileProvider = unsupported$1;
        this.registerTerminalQuickFixProvider = unsupported$1;
        this.getEnvironmentVariableCollection = unsupported$1;
        this.$acceptTerminalClosed = unsupported$1;
        this.$acceptTerminalOpened = unsupported$1;
        this.$acceptActiveTerminalChanged = unsupported$1;
        this.$acceptTerminalProcessId = unsupported$1;
        this.$acceptTerminalProcessData = unsupported$1;
        this.$acceptTerminalTitleChange = unsupported$1;
        this.$acceptTerminalDimensions = unsupported$1;
        this.$acceptTerminalMaximumDimensions = unsupported$1;
        this.$acceptTerminalInteraction = unsupported$1;
        this.$startExtensionTerminal = unsupported$1;
        this.$acceptProcessAckDataEvent = unsupported$1;
        this.$acceptProcessInput = unsupported$1;
        this.$acceptProcessResize = unsupported$1;
        this.$acceptProcessShutdown = unsupported$1;
        this.$acceptProcessRequestInitialCwd = unsupported$1;
        this.$acceptProcessRequestCwd = unsupported$1;
        this.$acceptProcessRequestLatency = unsupported$1;
        this.$provideLinks = unsupported$1;
        this.$activateLink = unsupported$1;
        this.$initEnvironmentVariableCollections = unsupported$1;
        this.$acceptDefaultProfile = unsupported$1;
        this.$createContributedProfileTerminal = unsupported$1;
        this.$provideTerminalQuickFixes = unsupported$1;
        this.dispose = unsupported$1;
    }
}, 0 );
function createExtHostServices() {
    const instantiationService = StandaloneServices.get(IInstantiationService);
    const labelService = StandaloneServices.get(ILabelService);
    const commandService = StandaloneServices.get(ICommandService);
    const notificationService = StandaloneServices.get(INotificationService);
    const dialogService = StandaloneServices.get(IDialogService);
    const textModelService = StandaloneServices.get(ITextModelService);
    const modelService = StandaloneServices.get(IModelService);
    const languageService = StandaloneServices.get(ILanguageService);
    const editorWorkerService = StandaloneServices.get(IEditorWorkerService);
    const quickInputService = StandaloneServices.get(IQuickInputService);
    const codeEditorService = StandaloneServices.get(ICodeEditorService);
    const markerService = StandaloneServices.get(IMarkerService);
    const clipboardService = StandaloneServices.get(IClipboardService);
    const editorService = StandaloneServices.get(IEditorService);
    const uriIdentityService = StandaloneServices.get(IUriIdentityService);
    const paneCompositePartService = StandaloneServices.get(IPaneCompositePartService);
    const textFileService = StandaloneServices.get(ITextFileService);
    const fileService = StandaloneServices.get(IFileService);
    const editorGroupsService = StandaloneServices.get(IEditorGroupsService);
    const workbenchEnvironmentService = StandaloneServices.get(IWorkbenchEnvironmentService);
    const workingCopyFileService = StandaloneServices.get(IWorkingCopyFileService);
    const pathService = StandaloneServices.get(IPathService);
    const progressService = StandaloneServices.get(IProgressService);
    const telemetryService = StandaloneServices.get(ITelemetryService);
    const productService = StandaloneServices.get(IProductService);
    const bulkEditService = StandaloneServices.get(IBulkEditService);
    const languageStatusService = StandaloneServices.get(ILanguageStatusService);
    const openerService = StandaloneServices.get(IOpenerService);
    const hostService = StandaloneServices.get(IHostService);
    const languageConfigurationService = StandaloneServices.get(ILanguageConfigurationService);
    const languageFeaturesService = StandaloneServices.get(ILanguageFeaturesService);
    const configurationService = StandaloneServices.get(IConfigurationService);
    const workspaceContextService = StandaloneServices.get(IWorkspaceContextService);
    const extensionService = StandaloneServices.get(IExtensionService);
    const logService = StandaloneServices.get(ILogService);
    const rpcProtocol = StandaloneServices.get(IExtHostRpcService);
    const debugService = StandaloneServices.get(IDebugService);
    const searchService = StandaloneServices.get(ISearchService);
    const workspaceTrustRequestService = StandaloneServices.get(IWorkspaceTrustRequestService);
    const workspaceTrustManagementService = StandaloneServices.get(IWorkspaceTrustManagementService);
    const requestService = StandaloneServices.get(IRequestService);
    const editSessionIdentityService = StandaloneServices.get(IEditSessionIdentityService);
    const workspaceEditingService = StandaloneServices.get(IWorkspaceEditingService);
    const timerService = StandaloneServices.get(ITimerService);
    const extensionsWorkbenchService = StandaloneServices.get(IExtensionsWorkbenchService);
    const workbenchExtensionEnablementService = StandaloneServices.get(IWorkbenchExtensionEnablementService);
    const extHostConsumerFileSystem = StandaloneServices.get(IExtHostConsumerFileSystem);
    const mainContext = {
        remoteAuthority: null,
        extensionHostKind: 1 ,
        getProxy: function (identifier) {
            return ( rpcProtocol.getProxy(identifier));
        },
        set: function (identifier, instance) {
            return rpcProtocol.set(identifier, instance);
        },
        assertRegistered: function (identifiers) {
            rpcProtocol.assertRegistered(identifiers);
        },
        drain: function () {
            return rpcProtocol.drain();
        },
        dispose() {
            rpcProtocol.dispose();
        }
    };
    const extHostApiDeprecationService = StandaloneServices.get(IExtHostApiDeprecationService);
    const extHostMessageService = new ExtHostMessageService(rpcProtocol, logService);
    const uriTransformerService = new URITransformerService(null);
    rpcProtocol.set(MainContext.MainThreadWindow, new MainThreadWindow(mainContext, hostService, openerService));
    rpcProtocol.set(MainContext.MainThreadCommands, new MainThreadCommands(mainContext, commandService, extensionService));
    const extHostFileSystemInfo = rpcProtocol.set(ExtHostContext.ExtHostFileSystemInfo, StandaloneServices.get(IExtHostFileSystemInfo));
    rpcProtocol.set(ExtHostContext.ExtHostTunnelService, StandaloneServices.get(IExtHostTunnelService));
    const extHostTelemetry = rpcProtocol.set(ExtHostContext.ExtHostTelemetry, StandaloneServices.get(IExtHostTelemetry));
    const extHostCommands = rpcProtocol.set(ExtHostContext.ExtHostCommands, StandaloneServices.get(IExtHostCommands));
    const extHostDocumentsAndEditors = rpcProtocol.set(ExtHostContext.ExtHostDocumentsAndEditors, StandaloneServices.get(IExtHostDocumentsAndEditors));
    const extHostQuickOpen = rpcProtocol.set(ExtHostContext.ExtHostQuickOpen, createExtHostQuickOpen(mainContext, null, extHostCommands));
    const extHostDocuments = rpcProtocol.set(ExtHostContext.ExtHostDocuments, new ExtHostDocuments(mainContext, extHostDocumentsAndEditors));
    const extHostLanguages = rpcProtocol.set(ExtHostContext.ExtHostLanguages, new ExtHostLanguages(mainContext, extHostDocuments, extHostCommands.converter, uriTransformerService));
    const extHostDiagnostics = rpcProtocol.set(ExtHostContext.ExtHostDiagnostics, new ExtHostDiagnostics(mainContext, logService, extHostFileSystemInfo, extHostDocumentsAndEditors));
    const extHostProgress = rpcProtocol.set(ExtHostContext.ExtHostProgress, new ExtHostProgress(( rpcProtocol.getProxy(MainContext.MainThreadProgress))));
    const extHostDocumentContentProviders = rpcProtocol.set(ExtHostContext.ExtHostDocumentContentProviders, new ExtHostDocumentContentProvider(mainContext, extHostDocumentsAndEditors, logService));
    const extHostEditors = rpcProtocol.set(ExtHostContext.ExtHostEditors, new ExtHostEditors(mainContext, extHostDocumentsAndEditors));
    const extHostLanguageFeatures = rpcProtocol.set(ExtHostContext.ExtHostLanguageFeatures, new ExtHostLanguageFeatures(rpcProtocol, uriTransformerService, extHostDocuments, extHostCommands, extHostDiagnostics, logService, extHostApiDeprecationService, extHostTelemetry));
    const extHostClipboard = new ExtHostClipboard(mainContext);
    const extHostDebugService = rpcProtocol.set(ExtHostContext.ExtHostDebugService, StandaloneServices.get(IExtHostDebugService));
    const extHostWindow = rpcProtocol.set(ExtHostContext.ExtHostWindow, StandaloneServices.get(IExtHostWindow));
    const extHostWorkspace = rpcProtocol.set(ExtHostContext.ExtHostWorkspace, StandaloneServices.get(IExtHostWorkspace));
    const extHostConfiguration = rpcProtocol.set(ExtHostContext.ExtHostConfiguration, StandaloneServices.get(IExtHostConfiguration));
    const extHostExtensionService = rpcProtocol.set(ExtHostContext.ExtHostExtensionService, StandaloneServices.get(IExtHostExtensionService));
    const extHostFileSystem = rpcProtocol.set(ExtHostContext.ExtHostFileSystem, new ExtHostFileSystem(rpcProtocol, extHostLanguageFeatures));
    rpcProtocol.set(MainContext.MainThreadMessageService, new MainThreadMessageServiceWithoutSource(mainContext, notificationService, commandService, dialogService));
    rpcProtocol.set(MainContext.MainThreadDiagnostics, new MainThreadDiagnostics(mainContext, markerService, uriIdentityService));
    rpcProtocol.set(MainContext.MainThreadQuickOpen, new MainThreadQuickOpen(mainContext, quickInputService));
    rpcProtocol.set(MainContext.MainThreadTelemetry, new MainThreadTelemetry(mainContext, telemetryService, configurationService, workbenchEnvironmentService, productService));
    rpcProtocol.set(MainContext.MainThreadProgress, new MainThreadProgress(mainContext, progressService, commandService));
    rpcProtocol.set(MainContext.MainThreadDocumentContentProviders, new MainThreadDocumentContentProviders(mainContext, textModelService, languageService, modelService, editorWorkerService));
    rpcProtocol.set(MainContext.MainThreadBulkEdits, new MainThreadBulkEdits(mainContext, bulkEditService, logService, uriIdentityService));
    rpcProtocol.set(MainContext.MainThreadLanguages, new MainThreadLanguages(mainContext, languageService, modelService, textModelService, languageStatusService));
    rpcProtocol.set(MainContext.MainThreadClipboard, new MainThreadClipboard(mainContext, clipboardService));
    rpcProtocol.set(MainContext.MainThreadLanguageFeatures, new MainThreadLanguageFeatures(mainContext, languageService, languageConfigurationService, languageFeaturesService, uriIdentityService));
    rpcProtocol.set(MainContext.MainThreadConfiguration, new MainThreadConfiguration(mainContext, workspaceContextService, configurationService, workbenchEnvironmentService));
    rpcProtocol.set(MainContext.MainThreadDebugService, new MainThreadDebugService(mainContext, debugService));
    rpcProtocol.set(MainContext.MainThreadConsole, new MainThreadConsole(mainContext, workbenchEnvironmentService, logService));
    rpcProtocol.set(MainContext.MainThreadWorkspace, new MainThreadWorkspace(mainContext, searchService, workspaceContextService, editSessionIdentityService, editorService, workspaceEditingService, notificationService, requestService, instantiationService, labelService, workbenchEnvironmentService, fileService, workspaceTrustManagementService, workspaceTrustRequestService));
    rpcProtocol.set(MainContext.MainThreadExtensionService, new MainThreadExtensionService(mainContext, extensionService, notificationService, extensionsWorkbenchService, hostService, workbenchExtensionEnablementService, timerService, commandService, workbenchEnvironmentService));
    rpcProtocol.set(MainContext.MainThreadFileSystem, new MainThreadFileSystem(mainContext, fileService, workspaceContextService, logService, configurationService));
    void new MainThreadDocumentsAndEditors(mainContext, modelService, textFileService, editorService, codeEditorService, fileService, textModelService, editorGroupsService, paneCompositePartService, workbenchEnvironmentService, workingCopyFileService, uriIdentityService, clipboardService, pathService, configurationService);
    const extHostBulkEdits = new ExtHostBulkEdits(rpcProtocol, extHostDocumentsAndEditors);
    void extHostExtensionService.initialize();
    return {
        extHostLogService: logService,
        extHostApiDeprecationService,
        extHostMessageService,
        extHostDocumentsAndEditors,
        extHostBulkEdits,
        extHostDocuments,
        extHostDocumentContentProviders,
        extHostQuickOpen,
        extHostProgress,
        extHostDiagnostics,
        extHostEditors,
        extHostCommands,
        extHostLanguages,
        extHostWindow,
        extHostClipboard,
        extHostLanguageFeatures,
        extHostWorkspace,
        extHostConfiguration,
        extHostTelemetry,
        extHostDebugService,
        extHostFileSystem,
        extHostConsumerFileSystem,
        extHostExtensionService
    };
}
let extHostServices;
function getExtHostServices() {
    if (extHostServices == null) {
        extHostServices = createExtHostServices();
    }
    return extHostServices;
}
function checkSelector(selector) {
    return selector;
}
function create$6(getExtension) {
    return {
        createDiagnosticCollection(name) {
            const { extHostDiagnostics } = getExtHostServices();
            const extension = getExtension();
            return extHostDiagnostics.createDiagnosticCollection(extension.identifier, name);
        },
        get onDidChangeDiagnostics() {
            const { extHostDiagnostics } = getExtHostServices();
            return extHostDiagnostics.onDidChangeDiagnostics;
        },
        getDiagnostics: (resource) => {
            const { extHostDiagnostics } = getExtHostServices();
            return extHostDiagnostics.getDiagnostics(resource);
        },
        getLanguages() {
            const { extHostLanguages } = getExtHostServices();
            return extHostLanguages.getLanguages();
        },
        setTextDocumentLanguage(document, languageId) {
            const { extHostLanguages } = getExtHostServices();
            return extHostLanguages.changeLanguage(document.uri, languageId);
        },
        match(selector, document) {
            return score(LanguageSelector.from(selector), document.uri, document.languageId, true, undefined, undefined);
        },
        registerCodeActionsProvider(selector, provider, metadata) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerCodeActionProvider(extension, checkSelector(selector), provider, metadata);
        },
        registerCodeLensProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerCodeLensProvider(extension, checkSelector(selector), provider);
        },
        registerDefinitionProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDefinitionProvider(extension, checkSelector(selector), provider);
        },
        registerDeclarationProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDeclarationProvider(extension, checkSelector(selector), provider);
        },
        registerImplementationProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerImplementationProvider(extension, checkSelector(selector), provider);
        },
        registerTypeDefinitionProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerTypeDefinitionProvider(extension, checkSelector(selector), provider);
        },
        registerHoverProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerHoverProvider(extension, checkSelector(selector), provider, extension.identifier);
        },
        registerEvaluatableExpressionProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerEvaluatableExpressionProvider(extension, checkSelector(selector), provider, extension.identifier);
        },
        registerInlineValuesProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerInlineValuesProvider(extension, checkSelector(selector), provider, extension.identifier);
        },
        registerDocumentHighlightProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDocumentHighlightProvider(extension, checkSelector(selector), provider);
        },
        registerLinkedEditingRangeProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerLinkedEditingRangeProvider(extension, checkSelector(selector), provider);
        },
        registerReferenceProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerReferenceProvider(extension, checkSelector(selector), provider);
        },
        registerRenameProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerRenameProvider(extension, checkSelector(selector), provider);
        },
        registerDocumentSymbolProvider(selector, provider, metadata) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDocumentSymbolProvider(extension, checkSelector(selector), provider, metadata);
        },
        registerWorkspaceSymbolProvider(provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerWorkspaceSymbolProvider(extension, provider);
        },
        registerDocumentFormattingEditProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDocumentFormattingEditProvider(extension, checkSelector(selector), provider);
        },
        registerDocumentRangeFormattingEditProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDocumentRangeFormattingEditProvider(extension, checkSelector(selector), provider);
        },
        registerOnTypeFormattingEditProvider(selector, provider, firstTriggerCharacter, ...moreTriggerCharacters) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerOnTypeFormattingEditProvider(extension, checkSelector(selector), provider, [firstTriggerCharacter].concat(moreTriggerCharacters));
        },
        registerDocumentSemanticTokensProvider(selector, provider, legend) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDocumentSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
        },
        registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDocumentRangeSemanticTokensProvider(extension, checkSelector(selector), provider, legend);
        },
        registerSignatureHelpProvider(selector, provider, firstItem, ...remaining) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            if (typeof firstItem === 'object') {
                return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, firstItem);
            }
            return extHostLanguageFeatures.registerSignatureHelpProvider(extension, checkSelector(selector), provider, typeof firstItem === 'undefined' ? [] : [firstItem, ...remaining]);
        },
        registerCompletionItemProvider(selector, provider, ...triggerCharacters) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerCompletionItemProvider(extension, checkSelector(selector), provider, triggerCharacters);
        },
        registerDocumentLinkProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDocumentLinkProvider(extension, checkSelector(selector), provider);
        },
        registerColorProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerColorProvider(extension, checkSelector(selector), provider);
        },
        registerFoldingRangeProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerFoldingRangeProvider(extension, checkSelector(selector), provider);
        },
        registerSelectionRangeProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerSelectionRangeProvider(extension, selector, provider);
        },
        registerCallHierarchyProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerCallHierarchyProvider(extension, selector, provider);
        },
        registerTypeHierarchyProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerTypeHierarchyProvider(extension, selector, provider);
        },
        setLanguageConfiguration: (language, configuration) => {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.setLanguageConfiguration(extension, language, configuration);
        },
        registerInlayHintsProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerInlayHintsProvider(extension, selector, provider);
        },
        createLanguageStatusItem(id, selector) {
            const { extHostLanguages } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguages.createLanguageStatusItem(extension, id, selector);
        },
        registerInlineCompletionItemProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerInlineCompletionsProvider(extension, checkSelector(selector), provider);
        },
        registerDocumentDropEditProvider(selector, provider) {
            const { extHostLanguageFeatures } = getExtHostServices();
            const extension = getExtension();
            return extHostLanguageFeatures.registerDocumentOnDropEditProvider(extension, selector, provider);
        }
    };
}
function create$5(getExtension) {
    return {
        registerCommand(id, command, thisArgs) {
            const { extHostCommands } = getExtHostServices();
            return extHostCommands.registerCommand(true, id, command, thisArgs, undefined, getExtension());
        },
        registerTextEditorCommand(id, callback, thisArg) {
            const { extHostCommands, extHostEditors, extHostLogService } = getExtHostServices();
            return extHostCommands.registerCommand(true, id, (...args) => {
                const activeTextEditor = extHostEditors.getActiveTextEditor();
                if (activeTextEditor == null) {
                    extHostLogService.warn('Cannot execute ' + id + ' because there is no active text editor.');
                    return undefined;
                }
                return activeTextEditor.edit((edit) => {
                    callback.apply(thisArg, [activeTextEditor, edit, ...args]);
                }).then((result) => {
                    if (!result) {
                        extHostLogService.warn('Edits from command ' + id + ' were not applied.');
                    }
                }, (err) => {
                    extHostLogService.warn('An error occurred while running command ' + id, err);
                });
            }, undefined, undefined, getExtension());
        },
        executeCommand(id, ...args) {
            const { extHostCommands } = getExtHostServices();
            return extHostCommands.executeCommand(id, ...args);
        },
        getCommands(filterInternal = false) {
            const { extHostCommands } = getExtHostServices();
            return extHostCommands.getCommands(filterInternal);
        }
    };
}
function create$4(getExtension) {
    return {
        get fs() {
            const { extHostConsumerFileSystem } = getExtHostServices();
            return extHostConsumerFileSystem.value;
        },
        get workspaceFile() {
            const { extHostWorkspace } = getExtHostServices();
            return extHostWorkspace.workspaceFile;
        },
        createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
            const { workspace } = Services.get();
            if (workspace?.createFileSystemWatcher != null) {
                return workspace.createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
            }
            return {
                ignoreCreateEvents: ignoreCreateEvents ?? false,
                ignoreChangeEvents: ignoreChangeEvents ?? false,
                ignoreDeleteEvents: ignoreDeleteEvents ?? false,
                onDidCreate: Event.None,
                onDidChange: Event.None,
                onDidDelete: Event.None,
                dispose: () => { }
            };
        },
        applyEdit: async (edit, metadata) => {
            const { extHostBulkEdits } = getExtHostServices();
            return extHostBulkEdits.applyWorkspaceEdit(edit, getExtension(), metadata);
        },
        getConfiguration: (section, scope) => {
            const { extHostConfiguration } = getExtHostServices();
            const configProvider = extHostConfiguration.getConfigProviderSync();
            return configProvider.getConfiguration(section, scope, getExtension());
        },
        onDidChangeConfiguration(listener, thisArgs, disposables) {
            const { extHostConfiguration } = getExtHostServices();
            const configProvider = extHostConfiguration.getConfigProviderSync();
            return configProvider.onDidChangeConfiguration(listener, thisArgs, disposables);
        },
        get rootPath() {
            const { workspace } = Services.get();
            return workspace?.rootPath;
        },
        get workspaceFolders() {
            const { workspace } = Services.get();
            if (workspace == null) {
                return undefined;
            }
            if ('workspaceFolders' in workspace) {
                return workspace.workspaceFolders;
            }
            const rootPath = workspace.rootPath;
            if (rootPath == null) {
                return undefined;
            }
            const uri = URI.file(rootPath);
            return [{
                    uri,
                    index: 0,
                    name: ( uri.toString())
                }];
        },
        getWorkspaceFolder(uri) {
            return this.workspaceFolders?.find(folder => {
                return uri.path.startsWith(folder.uri.path);
            });
        },
        get onDidChangeWorkspaceFolders() {
            const { workspace } = Services.get();
            return workspace?.onDidChangeWorkspaceFolders ?? Event.None;
        },
        get textDocuments() {
            const { extHostDocuments } = getExtHostServices();
            return Array.from(( extHostDocuments.getAllDocumentData().map(data => data.document)));
        },
        get onDidOpenTextDocument() {
            const { extHostDocuments } = getExtHostServices();
            return extHostDocuments.onDidAddDocument;
        },
        get onDidCloseTextDocument() {
            const { extHostDocuments } = getExtHostServices();
            return extHostDocuments.onDidRemoveDocument;
        },
        get onDidChangeTextDocument() {
            const { extHostDocuments } = getExtHostServices();
            return extHostDocuments.onDidChangeDocument;
        },
        get onWillSaveTextDocument() {
            const { workspace } = Services.get();
            return workspace?.onWillSaveTextDocument ?? Event.None;
        },
        get onDidSaveTextDocument() {
            const { workspace } = Services.get();
            return workspace?.onDidSaveTextDocument ?? Event.None;
        },
        get onWillCreateFiles() {
            return Event.None;
        },
        get onDidCreateFiles() {
            return Event.None;
        },
        get onWillDeleteFiles() {
            return Event.None;
        },
        get onDidDeleteFiles() {
            return Event.None;
        },
        get onWillRenameFiles() {
            return Event.None;
        },
        get onDidRenameFiles() {
            return Event.None;
        },
        get onDidGrantWorkspaceTrust() {
            return Event.None;
        },
        asRelativePath: unsupported$1,
        updateWorkspaceFolders(start, deleteCount, ...workspaceFoldersToAdd) {
            const { workspace } = Services.get();
            if (workspace?.updateWorkspaceFolders != null) {
                return workspace.updateWorkspaceFolders(start, deleteCount, ...workspaceFoldersToAdd);
            }
            return false;
        },
        findFiles: unsupported$1,
        saveAll: unsupported$1,
        openTextDocument(uriOrFileNameOrOptions) {
            const { extHostDocuments } = getExtHostServices();
            let uriPromise;
            const options = uriOrFileNameOrOptions;
            if (typeof uriOrFileNameOrOptions === 'string') {
                uriPromise = Promise.resolve(URI.file(uriOrFileNameOrOptions));
            }
            else if (URI.isUri(uriOrFileNameOrOptions)) {
                uriPromise = Promise.resolve(uriOrFileNameOrOptions);
            }
            else if (options == null || typeof options === 'object') {
                uriPromise = extHostDocuments.createDocumentData(options);
            }
            else {
                throw new Error('illegal argument - uriOrFileNameOrOptions');
            }
            return uriPromise.then(uri => {
                return extHostDocuments.ensureDocumentData(uri).then(documentData => {
                    return documentData.document;
                });
            });
        },
        registerTextDocumentContentProvider(scheme, provider) {
            const { extHostDocumentContentProviders } = getExtHostServices();
            return extHostDocumentContentProviders.registerTextDocumentContentProvider(scheme, provider);
        },
        registerTaskProvider: unsupported$1,
        registerFileSystemProvider(scheme, provider, options) {
            const { extHostFileSystem, extHostConsumerFileSystem } = getExtHostServices();
            const extension = getExtension();
            return combinedDisposable(extHostFileSystem.registerFileSystemProvider(extension, scheme, provider, options), extHostConsumerFileSystem.addFileSystemProvider(scheme, provider));
        },
        openNotebookDocument: unsupported$1,
        registerNotebookSerializer: unsupported$1,
        notebookDocuments: [],
        onDidOpenNotebookDocument: unsupported$1,
        onDidCloseNotebookDocument: unsupported$1,
        isTrusted: true,
        name: undefined,
        onDidChangeNotebookDocument: unsupported$1,
        onDidSaveNotebookDocument: unsupported$1
    };
}
class TextTabInput {
    constructor(uri) {
        this.uri = uri;
    }
}
function getTabFromModel(model, tabGroup) {
    return {
        label: model.uri.fsPath,
        group: tabGroup,
        get isActive() { return model.isAttachedToEditor(); },
        isDirty: false,
        isPinned: false,
        isPreview: false,
        input: new TextTabInput(model.uri)
    };
}
const tabGroup = {
    isActive: true,
    activeTab: undefined,
    viewColumn: ViewColumn$2.One,
    get tabs() {
        const modelService = StandaloneServices.get(IModelService);
        return ( modelService.getModels().map(model => getTabFromModel(model, tabGroup)));
    }
};
function create$3(getExtension, workspace) {
    return {
        showInformationMessage(message, ...rest) {
            const { extHostMessageService } = getExtHostServices();
            return extHostMessageService.showMessage(getExtension(), Severity$1.Info, message, rest[0], rest.slice(1));
        },
        showWarningMessage(message, ...rest) {
            const { extHostMessageService } = getExtHostServices();
            return extHostMessageService.showMessage(getExtension(), Severity$1.Warning, message, rest[0], rest.slice(1));
        },
        showErrorMessage(message, ...rest) {
            const { extHostMessageService } = getExtHostServices();
            return extHostMessageService.showMessage(getExtension(), Severity$1.Error, message, rest[0], rest.slice(1));
        },
        createOutputChannel(name, options) {
            const { window } = Services.get();
            const createOutputChannel = window?.createOutputChannel;
            const channel = createOutputChannel?.call(window, name, options);
            return channel ?? {
                name,
                append: () => { },
                appendLine: () => { },
                clear: unsupported$1,
                show: () => { },
                hide: unsupported$1,
                replace: unsupported$1,
                dispose: () => { },
                logLevel: LogLevel$1.Off,
                onDidChangeLogLevel: Event.None,
                trace: unsupported$1,
                debug: unsupported$1,
                info: unsupported$1,
                warn: unsupported$1,
                error: unsupported$1
            };
        },
        withScmProgress(task) {
            const { extHostProgress } = getExtHostServices();
            return extHostProgress.withProgress(getExtension(), { location: ProgressLocation$2.SourceControl }, () => task({ report() { } }));
        },
        withProgress(options, task) {
            const { extHostProgress } = getExtHostServices();
            return extHostProgress.withProgress(getExtension(), options, task);
        },
        showTextDocument: async (documentOrUri, columnOrOptions, preserveFocus) => {
            const { extHostEditors } = getExtHostServices();
            const document = await (URI.isUri(documentOrUri)
                ? Promise.resolve(workspace.openTextDocument(documentOrUri))
                : Promise.resolve(documentOrUri));
            return extHostEditors.showTextDocument(document, columnOrOptions, preserveFocus);
        },
        createQuickPick() {
            const { extHostQuickOpen } = getExtHostServices();
            return extHostQuickOpen.createQuickPick(getExtension());
        },
        showQuickPick(items, options, token) {
            const { extHostQuickOpen } = getExtHostServices();
            const extension = getExtension();
            return extHostQuickOpen.showQuickPick(extension, items, options, token);
        },
        createInputBox() {
            const { extHostQuickOpen } = getExtHostServices();
            const extension = getExtension();
            return extHostQuickOpen.createInputBox(extension);
        },
        showInputBox(options, token) {
            const { extHostQuickOpen } = getExtHostServices();
            return extHostQuickOpen.showInput(options, token);
        },
        createTextEditorDecorationType: unsupported$1,
        showWorkspaceFolderPick: unsupported$1,
        showOpenDialog: unsupported$1,
        showSaveDialog: unsupported$1,
        createWebviewPanel: unsupported$1,
        setStatusBarMessage: unsupported$1,
        createStatusBarItem: unsupported$1,
        createTerminal: unsupported$1,
        registerTreeDataProvider: unsupported$1,
        createTreeView: unsupported$1,
        registerWebviewPanelSerializer: unsupported$1,
        get activeTextEditor() {
            const { extHostEditors } = getExtHostServices();
            return extHostEditors.getActiveTextEditor();
        },
        get visibleTextEditors() {
            const { extHostEditors } = getExtHostServices();
            return extHostEditors.getVisibleTextEditors();
        },
        onDidChangeActiveTextEditor(listener, thisArg, disposables) {
            const { extHostEditors } = getExtHostServices();
            return extHostEditors.onDidChangeActiveTextEditor(listener, thisArg, disposables);
        },
        onDidChangeVisibleTextEditors(listener, thisArg, disposables) {
            const { extHostEditors } = getExtHostServices();
            return extHostEditors.onDidChangeVisibleTextEditors(listener, thisArg, disposables);
        },
        onDidChangeTextEditorSelection(listener, thisArgs, disposables) {
            const { extHostEditors } = getExtHostServices();
            return extHostEditors.onDidChangeTextEditorSelection(listener, thisArgs, disposables);
        },
        onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables) {
            const { extHostEditors } = getExtHostServices();
            return extHostEditors.onDidChangeTextEditorVisibleRanges(listener, thisArgs, disposables);
        },
        onDidChangeTextEditorOptions(listener, thisArgs, disposables) {
            const { extHostEditors } = getExtHostServices();
            return extHostEditors.onDidChangeTextEditorOptions(listener, thisArgs, disposables);
        },
        onDidChangeTextEditorViewColumn(listener, thisArg, disposables) {
            const { extHostEditors } = getExtHostServices();
            return extHostEditors.onDidChangeTextEditorViewColumn(listener, thisArg, disposables);
        },
        get terminals() {
            return unsupported$1();
        },
        get activeTerminal() {
            return unsupported$1();
        },
        onDidChangeActiveTerminal: Event.None,
        onDidOpenTerminal: Event.None,
        onDidCloseTerminal: Event.None,
        get state() {
            return unsupported$1();
        },
        onDidChangeWindowState: Event.None,
        registerUriHandler: unsupported$1,
        registerWebviewViewProvider: unsupported$1,
        registerCustomEditorProvider: unsupported$1,
        registerTerminalLinkProvider: unsupported$1,
        get activeColorTheme() {
            return unsupported$1();
        },
        onDidChangeActiveColorTheme: Event.None,
        registerFileDecorationProvider: unsupported$1,
        registerTerminalProfileProvider: unsupported$1,
        onDidChangeTerminalState: Event.None,
        tabGroups: {
            get all() {
                return [tabGroup];
            },
            activeTabGroup: tabGroup,
            onDidChangeTabGroups: Event.None,
            onDidChangeTabs(listener) {
                const modelService = StandaloneServices.get(IModelService);
                const store = new DisposableStore();
                store.add(modelService.onModelAdded((model) => {
                    listener({
                        opened: [getTabFromModel(model, tabGroup)],
                        closed: [],
                        changed: []
                    });
                }));
                store.add(modelService.onModelRemoved((model) => {
                    listener({
                        opened: [],
                        closed: [getTabFromModel(model, tabGroup)],
                        changed: []
                    });
                }));
                return store;
            },
            close: unsupported$1
        },
        showNotebookDocument: unsupported$1,
        visibleNotebookEditors: [],
        onDidChangeVisibleNotebookEditors: Event.None,
        activeNotebookEditor: undefined,
        onDidChangeActiveNotebookEditor: Event.None,
        onDidChangeNotebookEditorSelection: Event.None,
        onDidChangeNotebookEditorVisibleRanges: Event.None
    };
}
function create$2(getExtension) {
    return {
        get machineId() { return StandaloneServices.get(IExtHostInitDataService).telemetryInfo.machineId; },
        get sessionId() { return StandaloneServices.get(IExtHostInitDataService).telemetryInfo.sessionId; },
        get language() { return StandaloneServices.get(IExtHostInitDataService).environment.appLanguage; },
        get appName() { return StandaloneServices.get(IExtHostInitDataService).environment.appName; },
        get appRoot() { return StandaloneServices.get(IExtHostInitDataService).environment.appRoot?.fsPath ?? ''; },
        get appHost() { return StandaloneServices.get(IExtHostInitDataService).environment.appHost; },
        get uriScheme() { return StandaloneServices.get(IExtHostInitDataService).environment.appUriScheme; },
        get clipboard() {
            const { extHostClipboard } = getExtHostServices();
            return extHostClipboard.value;
        },
        remoteName: undefined,
        get shell() { return unsupported$1(); },
        get uiKind() {
            return StandaloneServices.get(IExtHostInitDataService).uiKind;
        },
        async asExternalUri(uri) {
            const { extHostWindow } = getExtHostServices();
            try {
                return await extHostWindow.asExternalUri(uri, { allowTunneling: false });
            }
            catch (err) {
                if (matchesScheme(uri, Schemas.http) || matchesScheme(uri, Schemas.https)) {
                    return uri;
                }
                throw err;
            }
        },
        openExternal: async (uri, options) => {
            const { extHostWindow } = getExtHostServices();
            return extHostWindow.openUri(uri, {
                allowTunneling: false,
                allowContributedOpeners: options?.allowContributedOpeners
            });
        },
        isNewAppInstall: false,
        get isTelemetryEnabled() {
            const { extHostTelemetry } = getExtHostServices();
            return extHostTelemetry.getTelemetryConfiguration();
        },
        get onDidChangeTelemetryEnabled() {
            const { extHostTelemetry } = getExtHostServices();
            return extHostTelemetry.onDidChangeTelemetryEnabled;
        },
        createTelemetryLogger(sender) {
            const { extHostTelemetry } = getExtHostServices();
            ExtHostTelemetryLogger.validateSender(sender);
            return extHostTelemetry.instantiateLogger(getExtension(), sender);
        },
        get logLevel() {
            const { extHostLogService } = getExtHostServices();
            return extHostLogService.getLevel();
        },
        get onDidChangeLogLevel() {
            const { extHostLogService } = getExtHostServices();
            return extHostLogService.onDidChangeLogLevel;
        }
    };
}
function create$1(getExtension) {
    return {
        get activeDebugSession() {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.activeDebugSession;
        },
        get activeDebugConsole() {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.activeDebugConsole;
        },
        get breakpoints() {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.breakpoints;
        },
        onDidStartDebugSession(listener, thisArg, disposables) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.onDidStartDebugSession(listener, thisArg, disposables);
        },
        onDidTerminateDebugSession(listener, thisArg, disposables) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.onDidTerminateDebugSession(listener, thisArg, disposables);
        },
        onDidChangeActiveDebugSession(listener, thisArg, disposables) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.onDidChangeActiveDebugSession(listener, thisArg, disposables);
        },
        onDidReceiveDebugSessionCustomEvent(listener, thisArg, disposables) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.onDidReceiveDebugSessionCustomEvent(listener, thisArg, disposables);
        },
        onDidChangeBreakpoints(listener, thisArgs, disposables) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.onDidChangeBreakpoints(listener, thisArgs, disposables);
        },
        registerDebugConfigurationProvider(debugType, provider, triggerKind) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.registerDebugConfigurationProvider(debugType, provider, triggerKind ?? DebugConfigurationProviderTriggerKind$1.Initial);
        },
        registerDebugAdapterDescriptorFactory(debugType, factory) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.registerDebugAdapterDescriptorFactory(getExtension(), debugType, factory);
        },
        registerDebugAdapterTrackerFactory(debugType, factory) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.registerDebugAdapterTrackerFactory(debugType, factory);
        },
        startDebugging(folder, nameOrConfig, parentSessionOrOptions) {
            const { extHostDebugService } = getExtHostServices();
            if ((parentSessionOrOptions == null) || (typeof parentSessionOrOptions === 'object' && 'configuration' in parentSessionOrOptions)) {
                return extHostDebugService.startDebugging(folder, nameOrConfig, { parentSession: parentSessionOrOptions });
            }
            return extHostDebugService.startDebugging(folder, nameOrConfig, parentSessionOrOptions);
        },
        stopDebugging(session) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.stopDebugging(session);
        },
        addBreakpoints(breakpoints) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.addBreakpoints(breakpoints);
        },
        removeBreakpoints(breakpoints) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.removeBreakpoints(breakpoints);
        },
        asDebugSourceUri(source, session) {
            const { extHostDebugService } = getExtHostServices();
            return extHostDebugService.asDebugSourceUri(source, session);
        }
    };
}
function create(getExtension) {
    return {
        getExtension(extensionId, includeFromDifferentExtensionHosts = false) {
            const { extHostExtensionService: extensionService } = getExtHostServices();
            const extensionInfo = extensionService.getExtensionRegistries();
            const extension = getExtension();
            if (!isProposedApiEnabled(getExtension(), 'extensionsAny')) {
                includeFromDifferentExtensionHosts = false;
            }
            const mine = extensionInfo.mine.getExtensionDescription(extensionId);
            if (mine != null) {
                return new Extension(extensionService, extension.identifier, mine, ExtensionKind$1.UI, false);
            }
            if (includeFromDifferentExtensionHosts) {
                const foreign = extensionInfo.all.getExtensionDescription(extensionId);
                if (foreign != null) {
                    return new Extension(extensionService, extension.identifier, foreign, ExtensionKind$1.UI, true);
                }
            }
            return undefined;
        },
        get all() {
            const { extHostExtensionService } = getExtHostServices();
            const extensionInfo = extHostExtensionService.getExtensionRegistries();
            const result = [];
            for (const desc of extensionInfo.mine.getAllExtensionDescriptions()) {
                result.push(new Extension(extHostExtensionService, getExtension().identifier, desc, ExtensionKind$1.UI, false));
            }
            return result;
        },
        get onDidChange() {
            const { extHostExtensionService } = getExtHostServices();
            const extensionInfo = extHostExtensionService.getExtensionRegistries();
            if (isProposedApiEnabled(getExtension(), 'extensionsAny')) {
                return Event.any(extensionInfo.mine.onDidChange, extensionInfo.all.onDidChange);
            }
            return extensionInfo.mine.onDidChange;
        }
    };
}
const unsupported = undefined;
const DEFAULT_EXTENSION = {
    identifier: new ExtensionIdentifier('monaco'),
    isBuiltin: true,
    isUserBuiltin: true,
    isUnderDevelopment: false,
    extensionLocation: ( URI.from({ scheme: 'extension', path: '/' })),
    name: 'monaco',
    publisher: 'microsoft',
    version: '1.0.0',
    engines: {
        vscode: "1.76.0"
    },
    targetPlatform: "web"
};
function getDefaultExtension() {
    return Services.get().extension ?? DEFAULT_EXTENSION;
}
const _workspace = create$4(getDefaultExtension);
const api = {
    version: "1.76.0",
    tasks: unsupported,
    notebooks: unsupported,
    scm: unsupported,
    comments: unsupported,
    authentication: unsupported,
    tests: unsupported,
    extensions: create(getDefaultExtension),
    debug: create$1(getDefaultExtension),
    env: create$2(getDefaultExtension),
    commands: create$5(getDefaultExtension),
    window: create$3(getDefaultExtension, _workspace),
    workspace: _workspace,
    languages: create$6(getDefaultExtension),
    Breakpoint: Breakpoint$1,
    CallHierarchyIncomingCall: CallHierarchyIncomingCall$1,
    CallHierarchyItem: CallHierarchyItem$2,
    CallHierarchyOutgoingCall: CallHierarchyOutgoingCall$1,
    CancellationError: CancellationError$1,
    CancellationTokenSource: CancellationTokenSource$1,
    CodeAction: CodeAction$1,
    CodeActionKind: CodeActionKind$1,
    CodeActionTriggerKind: CodeActionTriggerKind$2,
    CodeLens: CodeLens$1,
    Color: Color$2,
    ColorInformation: ColorInformation$1,
    ColorPresentation: ColorPresentation$2,
    ColorThemeKind: unsupported,
    CommentMode: CommentMode$1,
    CommentThreadCollapsibleState: CommentThreadCollapsibleState$1,
    CompletionItem: CompletionItem$1,
    CompletionItemKind: CompletionItemKind$2,
    CompletionItemTag: CompletionItemTag$2,
    CompletionList: CompletionList$1,
    CompletionTriggerKind: CompletionTriggerKind$2,
    ConfigurationTarget: ConfigurationTarget$1,
    CustomExecution: CustomExecution$1,
    DebugAdapterExecutable: DebugAdapterExecutable$1,
    DebugAdapterInlineImplementation: DebugAdapterInlineImplementation$1,
    DebugAdapterNamedPipeServer: DebugAdapterNamedPipeServer$1,
    DebugAdapterServer: DebugAdapterServer$1,
    DebugConfigurationProviderTriggerKind: DebugConfigurationProviderTriggerKind$1,
    DebugConsoleMode: DebugConsoleMode$1,
    DecorationRangeBehavior: DecorationRangeBehavior$2,
    Diagnostic: Diagnostic$2,
    DiagnosticRelatedInformation: DiagnosticRelatedInformation$2,
    DiagnosticSeverity: DiagnosticSeverity$2,
    DiagnosticTag: DiagnosticTag$2,
    Disposable: Disposable$2,
    DocumentHighlight: DocumentHighlight$2,
    DocumentHighlightKind: DocumentHighlightKind$1,
    DocumentLink: DocumentLink$2,
    DocumentSymbol: DocumentSymbol$2,
    EndOfLine: EndOfLine$2,
    EnvironmentVariableMutatorType: EnvironmentVariableMutatorType$1,
    EvaluatableExpression: EvaluatableExpression$2,
    InlineValueText: InlineValueText$1,
    InlineValueVariableLookup: InlineValueVariableLookup$1,
    InlineValueEvaluatableExpression: InlineValueEvaluatableExpression$1,
    EventEmitter: Emitter$1,
    ExtensionKind: ExtensionKind$1,
    ExtensionMode: ExtensionMode$1,
    FileChangeType: FileChangeType$1,
    FileDecoration: FileDecoration$1,
    FileSystemError: FileSystemError$1,
    FileType: FileType$1,
    FilePermission: FilePermission$1,
    FoldingRange: FoldingRange$2,
    FoldingRangeKind: FoldingRangeKind$3,
    FunctionBreakpoint: FunctionBreakpoint$1,
    Hover: Hover$2,
    IndentAction: IndentAction$1,
    Location: Location$1,
    MarkdownString: MarkdownString$2,
    OverviewRulerLane: OverviewRulerLane$1,
    ParameterInformation: ParameterInformation$2,
    Position: Position$3,
    ProcessExecution: ProcessExecution$1,
    ProgressLocation: ProgressLocation$2,
    QuickInputButtons: QuickInputButtons$1,
    Range: Range$3,
    RelativePattern: RelativePattern$1,
    Selection: Selection$2,
    SelectionRange: SelectionRange$2,
    SemanticTokens: SemanticTokens$1,
    SemanticTokensBuilder: SemanticTokensBuilder$1,
    SemanticTokensEdit: SemanticTokensEdit$1,
    SemanticTokensEdits: SemanticTokensEdits$1,
    SemanticTokensLegend: SemanticTokensLegend$1,
    ShellExecution: ShellExecution$1,
    ShellQuoting: ShellQuoting$1,
    SignatureHelp: SignatureHelp$2,
    SignatureHelpTriggerKind: SignatureHelpTriggerKind$1,
    SignatureInformation: SignatureInformation$2,
    SnippetString: SnippetString$1,
    SourceBreakpoint: SourceBreakpoint$1,
    StatusBarAlignment: unsupported,
    SymbolInformation: SymbolInformation$1,
    SymbolKind: SymbolKind$2,
    SymbolTag: SymbolTag$2,
    Task: unsupported,
    TaskGroup: unsupported,
    TaskPanelKind: unsupported,
    TaskRevealKind: unsupported,
    TaskScope: unsupported,
    TerminalLink: unsupported,
    TerminalLocation: unsupported,
    TerminalProfile: unsupported,
    TextDocumentSaveReason: TextDocumentSaveReason$1,
    TextEdit: TextEdit$2,
    TextEditorCursorStyle: TextEditorCursorStyle$2,
    TextEditorLineNumbersStyle: TextEditorLineNumbersStyle$2,
    TextEditorRevealType: TextEditorRevealType$2,
    TextEditorSelectionChangeKind: TextEditorSelectionChangeKind$1,
    TextDocumentChangeReason: TextDocumentChangeReason$1,
    ThemeColor: ThemeColor$1,
    ThemeIcon: ThemeIcon$1,
    TreeItem: TreeItem$1,
    TreeItemCollapsibleState: TreeItemCollapsibleState$1,
    TypeHierarchyItem: TypeHierarchyItem$2,
    UIKind: UIKind$1,
    Uri: URI,
    ViewColumn: ViewColumn$2,
    WorkspaceEdit: WorkspaceEdit$2,
    InlayHint: InlayHint$1,
    InlayHintLabelPart: InlayHintLabelPart$1,
    InlayHintKind: InlayHintKind$2,
    NotebookRange: unsupported,
    NotebookCellKind: unsupported,
    NotebookCellData: unsupported,
    NotebookData: unsupported,
    NotebookCellStatusBarAlignment: unsupported,
    NotebookCellOutput: unsupported,
    NotebookCellOutputItem: unsupported,
    NotebookCellStatusBarItem: unsupported,
    NotebookControllerAffinity: unsupported,
    LinkedEditingRanges: LinkedEditingRanges$1,
    TestRunRequest: TestRunRequest$1,
    TestMessage: TestMessage$1,
    TestTag: TestTag$1,
    TestRunProfileKind: TestRunProfileKind$1,
    DataTransfer: unsupported,
    DataTransferItem: unsupported,
    LanguageStatusSeverity: LanguageStatusSeverity$1,
    QuickPickItemKind: QuickPickItemKind$1,
    TabInputText: TextTabInput,
    TabInputTextDiff: TextDiffTabInput,
    TabInputCustom: CustomEditorTabInput,
    TabInputNotebook: NotebookEditorTabInput,
    TabInputNotebookDiff: NotebookDiffEditorTabInput,
    TabInputWebview: WebviewEditorTabInput,
    TabInputTerminal: TerminalEditorTabInput,
    InputBoxValidationSeverity: InputBoxValidationSeverity$1,
    InlineCompletionList: InlineSuggestionList,
    InlineCompletionTriggerKind: InlineCompletionTriggerKind$1,
    InlineCompletionItem: InlineSuggestion,
    DocumentDropEdit: DocumentDropEdit$1,
    NotebookEditorRevealType: unsupported,
    SnippetTextEdit: SnippetTextEdit$1,
    NotebookEdit: unsupported,
    LogLevel: LogLevel$1,
    TerminalExitReason: unsupported,
    CommentThreadState: unsupported,
    l10n: unsupported,
    TelemetryTrustedValue: TelemetryTrustedValue$1
};
const { version, tasks, notebooks, scm, comments, authentication, tests, extensions, debug, env, commands, window: window$1, workspace, languages, Breakpoint, CallHierarchyIncomingCall, CallHierarchyItem, CallHierarchyOutgoingCall, CancellationError, CancellationTokenSource, CodeAction, CodeActionKind, CodeActionTriggerKind, CodeLens, Color, ColorInformation, ColorPresentation, ColorThemeKind, CommentMode, CommentThreadCollapsibleState, CompletionItem, CompletionItemKind, CompletionItemTag, CompletionList, CompletionTriggerKind, ConfigurationTarget, CustomExecution, DebugAdapterExecutable, DebugAdapterInlineImplementation, DebugAdapterNamedPipeServer, DebugAdapterServer, DebugConfigurationProviderTriggerKind, DebugConsoleMode, DecorationRangeBehavior, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, Disposable, DocumentHighlight, DocumentHighlightKind, DocumentLink, DocumentSymbol, EndOfLine, EnvironmentVariableMutatorType, EvaluatableExpression, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, EventEmitter, ExtensionKind, ExtensionMode, FileChangeType, FileDecoration, FileSystemError, FileType, FilePermission, FoldingRange, FoldingRangeKind, FunctionBreakpoint, Hover, IndentAction, Location, MarkdownString, OverviewRulerLane, ParameterInformation, Position, ProcessExecution, ProgressLocation, QuickInputButtons, Range, RelativePattern, Selection, SelectionRange, SemanticTokens, SemanticTokensBuilder, SemanticTokensEdit, SemanticTokensEdits, SemanticTokensLegend, ShellExecution, ShellQuoting, SignatureHelp, SignatureHelpTriggerKind, SignatureInformation, SnippetString, SourceBreakpoint, StatusBarAlignment, SymbolInformation, SymbolKind, SymbolTag, Task, TaskGroup, TaskPanelKind, TaskRevealKind, TaskScope, TerminalLink, TerminalLocation, TerminalProfile, TextDocumentSaveReason, TextEdit, TextEditorCursorStyle, TextEditorLineNumbersStyle, TextEditorRevealType, TextEditorSelectionChangeKind, TextDocumentChangeReason, ThemeColor, ThemeIcon, TreeItem, TreeItemCollapsibleState, TypeHierarchyItem, UIKind, Uri, ViewColumn, WorkspaceEdit, InlayHint, InlayHintLabelPart, InlayHintKind, NotebookRange, NotebookCellKind, NotebookCellData, NotebookData, NotebookCellStatusBarAlignment, NotebookCellOutput, NotebookCellOutputItem, NotebookCellStatusBarItem, NotebookControllerAffinity, LinkedEditingRanges, TestRunRequest, TestMessage, TestTag, TestRunProfileKind, DataTransfer, DataTransferItem, LanguageStatusSeverity, QuickPickItemKind, TabInputText, TabInputTextDiff, TabInputCustom, TabInputNotebook, TabInputNotebookDiff, TabInputWebview, TabInputTerminal, InputBoxValidationSeverity, InlineCompletionList, InlineCompletionTriggerKind, InlineCompletionItem, DocumentDropEdit, NotebookEditorRevealType, SnippetTextEdit, NotebookEdit, LogLevel, TerminalExitReason, CommentThreadState, l10n, TelemetryTrustedValue } = api;
var api$1 = Object.freeze({
    __proto__: null,
    Breakpoint: Breakpoint,
    CallHierarchyIncomingCall: CallHierarchyIncomingCall,
    CallHierarchyItem: CallHierarchyItem,
    CallHierarchyOutgoingCall: CallHierarchyOutgoingCall,
    CancellationError: CancellationError,
    CancellationTokenSource: CancellationTokenSource,
    CodeAction: CodeAction,
    CodeActionKind: CodeActionKind,
    CodeActionTriggerKind: CodeActionTriggerKind,
    CodeLens: CodeLens,
    Color: Color,
    ColorInformation: ColorInformation,
    ColorPresentation: ColorPresentation,
    ColorThemeKind: ColorThemeKind,
    CommentMode: CommentMode,
    CommentThreadCollapsibleState: CommentThreadCollapsibleState,
    CommentThreadState: CommentThreadState,
    CompletionItem: CompletionItem,
    CompletionItemKind: CompletionItemKind,
    CompletionItemTag: CompletionItemTag,
    CompletionList: CompletionList,
    CompletionTriggerKind: CompletionTriggerKind,
    ConfigurationTarget: ConfigurationTarget,
    CustomExecution: CustomExecution,
    DEFAULT_EXTENSION: DEFAULT_EXTENSION,
    DataTransfer: DataTransfer,
    DataTransferItem: DataTransferItem,
    DebugAdapterExecutable: DebugAdapterExecutable,
    DebugAdapterInlineImplementation: DebugAdapterInlineImplementation,
    DebugAdapterNamedPipeServer: DebugAdapterNamedPipeServer,
    DebugAdapterServer: DebugAdapterServer,
    DebugConfigurationProviderTriggerKind: DebugConfigurationProviderTriggerKind,
    DebugConsoleMode: DebugConsoleMode,
    DecorationRangeBehavior: DecorationRangeBehavior,
    Diagnostic: Diagnostic,
    DiagnosticRelatedInformation: DiagnosticRelatedInformation,
    DiagnosticSeverity: DiagnosticSeverity,
    DiagnosticTag: DiagnosticTag,
    Disposable: Disposable,
    DocumentDropEdit: DocumentDropEdit,
    DocumentHighlight: DocumentHighlight,
    DocumentHighlightKind: DocumentHighlightKind,
    DocumentLink: DocumentLink,
    DocumentSymbol: DocumentSymbol,
    EndOfLine: EndOfLine,
    EnvironmentVariableMutatorType: EnvironmentVariableMutatorType,
    EvaluatableExpression: EvaluatableExpression,
    EventEmitter: EventEmitter,
    ExtensionKind: ExtensionKind,
    ExtensionMode: ExtensionMode,
    FileChangeType: FileChangeType,
    FileDecoration: FileDecoration,
    FilePermission: FilePermission,
    FileSystemError: FileSystemError,
    FileType: FileType,
    FoldingRange: FoldingRange,
    FoldingRangeKind: FoldingRangeKind,
    FunctionBreakpoint: FunctionBreakpoint,
    Hover: Hover,
    IndentAction: IndentAction,
    InlayHint: InlayHint,
    InlayHintKind: InlayHintKind,
    InlayHintLabelPart: InlayHintLabelPart,
    InlineCompletionItem: InlineCompletionItem,
    InlineCompletionList: InlineCompletionList,
    InlineCompletionTriggerKind: InlineCompletionTriggerKind,
    InlineValueEvaluatableExpression: InlineValueEvaluatableExpression,
    InlineValueText: InlineValueText,
    InlineValueVariableLookup: InlineValueVariableLookup,
    InputBoxValidationSeverity: InputBoxValidationSeverity,
    LanguageStatusSeverity: LanguageStatusSeverity,
    LinkedEditingRanges: LinkedEditingRanges,
    Location: Location,
    LogLevel: LogLevel,
    MarkdownString: MarkdownString,
    NotebookCellData: NotebookCellData,
    NotebookCellKind: NotebookCellKind,
    NotebookCellOutput: NotebookCellOutput,
    NotebookCellOutputItem: NotebookCellOutputItem,
    NotebookCellStatusBarAlignment: NotebookCellStatusBarAlignment,
    NotebookCellStatusBarItem: NotebookCellStatusBarItem,
    NotebookControllerAffinity: NotebookControllerAffinity,
    NotebookData: NotebookData,
    NotebookEdit: NotebookEdit,
    NotebookEditorRevealType: NotebookEditorRevealType,
    NotebookRange: NotebookRange,
    OverviewRulerLane: OverviewRulerLane,
    ParameterInformation: ParameterInformation,
    Position: Position,
    ProcessExecution: ProcessExecution,
    ProgressLocation: ProgressLocation,
    QuickInputButtons: QuickInputButtons,
    QuickPickItemKind: QuickPickItemKind,
    Range: Range,
    RelativePattern: RelativePattern,
    Selection: Selection,
    SelectionRange: SelectionRange,
    SemanticTokens: SemanticTokens,
    SemanticTokensBuilder: SemanticTokensBuilder,
    SemanticTokensEdit: SemanticTokensEdit,
    SemanticTokensEdits: SemanticTokensEdits,
    SemanticTokensLegend: SemanticTokensLegend,
    ShellExecution: ShellExecution,
    ShellQuoting: ShellQuoting,
    SignatureHelp: SignatureHelp,
    SignatureHelpTriggerKind: SignatureHelpTriggerKind,
    SignatureInformation: SignatureInformation,
    SnippetString: SnippetString,
    SnippetTextEdit: SnippetTextEdit,
    SourceBreakpoint: SourceBreakpoint,
    StatusBarAlignment: StatusBarAlignment,
    SymbolInformation: SymbolInformation,
    SymbolKind: SymbolKind,
    SymbolTag: SymbolTag,
    TabInputCustom: TabInputCustom,
    TabInputNotebook: TabInputNotebook,
    TabInputNotebookDiff: TabInputNotebookDiff,
    TabInputTerminal: TabInputTerminal,
    TabInputText: TabInputText,
    TabInputTextDiff: TabInputTextDiff,
    TabInputWebview: TabInputWebview,
    Task: Task,
    TaskGroup: TaskGroup,
    TaskPanelKind: TaskPanelKind,
    TaskRevealKind: TaskRevealKind,
    TaskScope: TaskScope,
    TelemetryTrustedValue: TelemetryTrustedValue,
    TerminalExitReason: TerminalExitReason,
    TerminalLink: TerminalLink,
    TerminalLocation: TerminalLocation,
    TerminalProfile: TerminalProfile,
    TestMessage: TestMessage,
    TestRunProfileKind: TestRunProfileKind,
    TestRunRequest: TestRunRequest,
    TestTag: TestTag,
    TextDocumentChangeReason: TextDocumentChangeReason,
    TextDocumentSaveReason: TextDocumentSaveReason,
    TextEdit: TextEdit,
    TextEditorCursorStyle: TextEditorCursorStyle,
    TextEditorLineNumbersStyle: TextEditorLineNumbersStyle,
    TextEditorRevealType: TextEditorRevealType,
    TextEditorSelectionChangeKind: TextEditorSelectionChangeKind,
    ThemeColor: ThemeColor,
    ThemeIcon: ThemeIcon,
    TreeItem: TreeItem,
    TreeItemCollapsibleState: TreeItemCollapsibleState,
    TypeHierarchyItem: TypeHierarchyItem,
    UIKind: UIKind,
    Uri: Uri,
    ViewColumn: ViewColumn,
    WorkspaceEdit: WorkspaceEdit,
    authentication: authentication,
    commands: commands,
    comments: comments,
    debug: debug,
    env: env,
    extensions: extensions,
    l10n: l10n,
    languages: languages,
    notebooks: notebooks,
    scm: scm,
    tasks: tasks,
    tests: tests,
    version: version,
    window: window$1,
    workspace: workspace
});
export { FileSystemError as $, DebugAdapterNamedPipeServer as A, Breakpoint as B, CallHierarchyIncomingCall as C, DEFAULT_EXTENSION as D, DebugAdapterServer as E, DebugConfigurationProviderTriggerKind as F, DebugConsoleMode as G, DecorationRangeBehavior as H, Diagnostic as I, DiagnosticRelatedInformation as J, DiagnosticSeverity as K, DiagnosticTag as L, Disposable as M, DocumentDropEdit as N, DocumentHighlight as O, DocumentHighlightKind as P, DocumentLink as Q, DocumentSymbol as R, EndOfLine as S, EnvironmentVariableMutatorType as T, EvaluatableExpression as U, EventEmitter as V, ExtensionKind as W, ExtensionMode as X, FileChangeType as Y, FileDecoration as Z, FilePermission as _, CallHierarchyItem as a, TabInputTerminal as a$, FileType as a0, FoldingRange as a1, FoldingRangeKind as a2, FunctionBreakpoint as a3, Hover as a4, IndentAction as a5, InlayHint as a6, InlayHintKind as a7, InlayHintLabelPart as a8, InlineCompletionItem as a9, ProgressLocation as aA, QuickInputButtons as aB, QuickPickItemKind as aC, Range as aD, RelativePattern as aE, Selection as aF, SelectionRange as aG, SemanticTokens as aH, SemanticTokensBuilder as aI, SemanticTokensEdit as aJ, SemanticTokensEdits as aK, SemanticTokensLegend as aL, ShellExecution as aM, ShellQuoting as aN, SignatureHelp as aO, SignatureHelpTriggerKind as aP, SignatureInformation as aQ, SnippetString as aR, SnippetTextEdit as aS, SourceBreakpoint as aT, StatusBarAlignment as aU, SymbolInformation as aV, SymbolKind as aW, SymbolTag as aX, TabInputCustom as aY, TabInputNotebook as aZ, TabInputNotebookDiff as a_, InlineCompletionList as aa, InlineCompletionTriggerKind as ab, InlineValueEvaluatableExpression as ac, InlineValueText as ad, InlineValueVariableLookup as ae, InputBoxValidationSeverity as af, LanguageStatusSeverity as ag, LinkedEditingRanges as ah, Location as ai, LogLevel as aj, MarkdownString as ak, NotebookCellData as al, NotebookCellKind as am, NotebookCellOutput as an, NotebookCellOutputItem as ao, NotebookCellStatusBarAlignment as ap, NotebookCellStatusBarItem as aq, NotebookControllerAffinity as ar, NotebookData as as, NotebookEdit as at, NotebookEditorRevealType as au, NotebookRange as av, OverviewRulerLane as aw, ParameterInformation as ax, Position as ay, ProcessExecution as az, CallHierarchyOutgoingCall as b, TabInputText as b0, TabInputTextDiff as b1, TabInputWebview as b2, Task as b3, TaskGroup as b4, TaskPanelKind as b5, TaskRevealKind as b6, TaskScope as b7, TelemetryTrustedValue as b8, TerminalExitReason as b9, debug as bA, env as bB, extensions as bC, l10n as bD, languages as bE, notebooks as bF, scm as bG, tasks as bH, tests as bI, version as bJ, window$1 as bK, workspace as bL, api$1 as bM, create as bN, create$1 as bO, create$2 as bP, create$5 as bQ, create$3 as bR, create$4 as bS, create$6 as bT, IExtHostExtensionService as bU, TerminalLink as ba, TerminalLocation as bb, TerminalProfile as bc, TestMessage as bd, TestRunProfileKind as be, TestRunRequest as bf, TestTag as bg, TextDocumentChangeReason as bh, TextDocumentSaveReason as bi, TextEdit as bj, TextEditorCursorStyle as bk, TextEditorLineNumbersStyle as bl, TextEditorRevealType as bm, TextEditorSelectionChangeKind as bn, ThemeColor as bo, ThemeIcon as bp, TreeItem as bq, TreeItemCollapsibleState as br, TypeHierarchyItem as bs, UIKind as bt, Uri as bu, ViewColumn as bv, WorkspaceEdit as bw, authentication as bx, commands as by, comments as bz, CancellationError as c, CancellationTokenSource as d, CodeAction as e, CodeActionKind as f, CodeActionTriggerKind as g, CodeLens as h, Color as i, ColorInformation as j, ColorPresentation as k, ColorThemeKind as l, CommentMode as m, CommentThreadCollapsibleState as n, CommentThreadState as o, CompletionItem as p, CompletionItemKind as q, CompletionItemTag as r, CompletionList as s, CompletionTriggerKind as t, ConfigurationTarget as u, CustomExecution as v, DataTransfer as w, DataTransferItem as x, DebugAdapterExecutable as y, DebugAdapterInlineImplementation as z };
