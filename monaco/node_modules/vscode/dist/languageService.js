import { aS as FILES_ASSOCIATIONS_CONFIG, _ as __decorate, a as __param } from './services2.js';
import { bp as IExtensionService } from './missing-services.js';
import { E as ExtensionsRegistry } from './extensionsRegistry.js';
import { parse } from 'monaco-editor/esm/vs/base/common/glob.js';
import { posix, basename } from 'monaco-editor/esm/vs/base/common/path.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { joinPath, DataUri } from 'monaco-editor/esm/vs/base/common/resources.js';
import { Mimes } from 'monaco-editor/esm/vs/base/common/mime.js';
import { PLAINTEXT_LANGUAGE_ID } from 'monaco-editor/esm/vs/editor/common/languages/modesRegistry.js';
import { startsWithUTF8BOM } from 'monaco-editor/esm/vs/base/common/strings.js';
import { LanguageService } from 'monaco-editor/esm/vs/editor/common/services/languageService.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
let registeredAssociations = [];
let nonUserRegisteredAssociations = [];
let userRegisteredAssociations = [];
function registerConfiguredLanguageAssociation(association) {
    _registerLanguageAssociation(association, true, false);
}
function _registerLanguageAssociation(association, userConfigured, warnOnOverwrite) {
    const associationItem = toLanguageAssociationItem(association, userConfigured);
    registeredAssociations.push(associationItem);
    if (!associationItem.userConfigured) {
        nonUserRegisteredAssociations.push(associationItem);
    }
    else {
        userRegisteredAssociations.push(associationItem);
    }
    if (warnOnOverwrite && !associationItem.userConfigured) {
        registeredAssociations.forEach(a => {
            if (a.mime === associationItem.mime || a.userConfigured) {
                return;
            }
            if (associationItem.extension && a.extension === associationItem.extension) {
                console.warn(`Overwriting extension <<${associationItem.extension}>> to now point to mime <<${associationItem.mime}>>`);
            }
            if (associationItem.filename && a.filename === associationItem.filename) {
                console.warn(`Overwriting filename <<${associationItem.filename}>> to now point to mime <<${associationItem.mime}>>`);
            }
            if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {
                console.warn(`Overwriting filepattern <<${associationItem.filepattern}>> to now point to mime <<${associationItem.mime}>>`);
            }
            if (associationItem.firstline && a.firstline === associationItem.firstline) {
                console.warn(`Overwriting firstline <<${associationItem.firstline}>> to now point to mime <<${associationItem.mime}>>`);
            }
        });
    }
}
function toLanguageAssociationItem(association, userConfigured) {
    return {
        id: association.id,
        mime: association.mime,
        filename: association.filename,
        extension: association.extension,
        filepattern: association.filepattern,
        firstline: association.firstline,
        userConfigured: userConfigured,
        filenameLowercase: association.filename ? association.filename.toLowerCase() : undefined,
        extensionLowercase: association.extension ? association.extension.toLowerCase() : undefined,
        filepatternLowercase: association.filepattern ? parse(association.filepattern.toLowerCase()) : undefined,
        filepatternOnPath: association.filepattern ? association.filepattern.indexOf(posix.sep) >= 0 : false
    };
}
function clearConfiguredLanguageAssociations() {
    registeredAssociations = registeredAssociations.filter(a => !a.userConfigured);
    userRegisteredAssociations = [];
}
function getMimeTypes(resource, firstLine) {
    return ( getAssociations(resource, firstLine).map(item => item.mime));
}
function getAssociations(resource, firstLine) {
    let path;
    if (resource) {
        switch (resource.scheme) {
            case Schemas.file:
                path = resource.fsPath;
                break;
            case Schemas.data: {
                const metadata = DataUri.parseMetaData(resource);
                path = metadata.get(DataUri.META_DATA_LABEL);
                break;
            }
            case Schemas.vscodeNotebookCell:
                path = undefined;
                break;
            default:
                path = resource.path;
        }
    }
    if (!path) {
        return [{ id: 'unknown', mime: Mimes.unknown }];
    }
    path = path.toLowerCase();
    const filename = basename(path);
    const configuredLanguage = getAssociationByPath(path, filename, userRegisteredAssociations);
    if (configuredLanguage) {
        return [configuredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];
    }
    const registeredLanguage = getAssociationByPath(path, filename, nonUserRegisteredAssociations);
    if (registeredLanguage) {
        return [registeredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];
    }
    if (firstLine) {
        const firstlineLanguage = getAssociationByFirstline(firstLine);
        if (firstlineLanguage) {
            return [firstlineLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];
        }
    }
    return [{ id: 'unknown', mime: Mimes.unknown }];
}
function getAssociationByPath(path, filename, associations) {
    let filenameMatch = undefined;
    let patternMatch = undefined;
    let extensionMatch = undefined;
    for (let i = associations.length - 1; i >= 0; i--) {
        const association = associations[i];
        if (filename === association.filenameLowercase) {
            filenameMatch = association;
            break;
        }
        if (association.filepattern) {
            if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
                const target = association.filepatternOnPath ? path : filename;
                if (association.filepatternLowercase?.(target)) {
                    patternMatch = association;
                }
            }
        }
        if (association.extension) {
            if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
                if (filename.endsWith(association.extensionLowercase)) {
                    extensionMatch = association;
                }
            }
        }
    }
    if (filenameMatch) {
        return filenameMatch;
    }
    if (patternMatch) {
        return patternMatch;
    }
    if (extensionMatch) {
        return extensionMatch;
    }
    return undefined;
}
function getAssociationByFirstline(firstLine) {
    if (startsWithUTF8BOM(firstLine)) {
        firstLine = firstLine.substr(1);
    }
    if (firstLine.length > 0) {
        for (let i = registeredAssociations.length - 1; i >= 0; i--) {
            const association = registeredAssociations[i];
            if (!association.firstline) {
                continue;
            }
            const matches = firstLine.match(association.firstline);
            if (matches && matches.length > 0) {
                return association;
            }
        }
    }
    return undefined;
}
const languagesExtPoint = ( ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'languages',
    jsonSchema: {
        description: ( localize(
            'vscode.extension.contributes.languages',
            'Contributes language declarations.'
        )),
        type: 'array',
        items: {
            type: 'object',
            defaultSnippets: [{ body: { id: '${1:languageId}', aliases: ['${2:label}'], extensions: ['${3:extension}'], configuration: './language-configuration.json' } }],
            properties: {
                id: {
                    description: ( localize('vscode.extension.contributes.languages.id', 'ID of the language.')),
                    type: 'string'
                },
                aliases: {
                    description: ( localize(
                        'vscode.extension.contributes.languages.aliases',
                        'Name aliases for the language.'
                    )),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                extensions: {
                    description: ( localize(
                        'vscode.extension.contributes.languages.extensions',
                        'File extensions associated to the language.'
                    )),
                    default: ['.foo'],
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenames: {
                    description: ( localize(
                        'vscode.extension.contributes.languages.filenames',
                        'File names associated to the language.'
                    )),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenamePatterns: {
                    description: ( localize(
                        'vscode.extension.contributes.languages.filenamePatterns',
                        'File name glob patterns associated to the language.'
                    )),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                mimetypes: {
                    description: ( localize(
                        'vscode.extension.contributes.languages.mimetypes',
                        'Mime types associated to the language.'
                    )),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                firstLine: {
                    description: ( localize(
                        'vscode.extension.contributes.languages.firstLine',
                        'A regular expression matching the first line of a file of the language.'
                    )),
                    type: 'string'
                },
                configuration: {
                    description: ( localize(
                        'vscode.extension.contributes.languages.configuration',
                        'A relative path to a file containing configuration options for the language.'
                    )),
                    type: 'string',
                    default: './language-configuration.json'
                },
                icon: {
                    type: 'object',
                    description: ( localize(
                        'vscode.extension.contributes.languages.icon',
                        'A icon to use as file icon, if no icon theme provides one for the language.'
                    )),
                    properties: {
                        light: {
                            description: ( localize(
                                'vscode.extension.contributes.languages.icon.light',
                                'Icon path when a light theme is used'
                            )),
                            type: 'string'
                        },
                        dark: {
                            description: ( localize(
                                'vscode.extension.contributes.languages.icon.dark',
                                'Icon path when a dark theme is used'
                            )),
                            type: 'string'
                        }
                    }
                }
            }
        }
    },
    activationEventsGenerator: (languageContributions, result) => {
        for (const languageContribution of languageContributions) {
            if (languageContribution.id) {
                result.push(`onLanguage:${languageContribution.id}`);
            }
        }
    }
}));
let WorkbenchLanguageService = class WorkbenchLanguageService extends LanguageService {
    constructor(extensionService, configurationService, environmentService, logService) {
        super(environmentService.verbose || environmentService.isExtensionDevelopment || !environmentService.isBuilt);
        this.logService = logService;
        this._configurationService = configurationService;
        this._extensionService = extensionService;
        languagesExtPoint.setHandler((extensions) => {
            const allValidLanguages = [];
            for (let i = 0, len = extensions.length; i < len; i++) {
                const extension = extensions[i];
                if (!Array.isArray(extension.value)) {
                    extension.collector.error(( localize(
                        'invalid',
                        "Invalid `contributes.{0}`. Expected an array.",
                        languagesExtPoint.name
                    )));
                    continue;
                }
                for (let j = 0, lenJ = extension.value.length; j < lenJ; j++) {
                    const ext = extension.value[j];
                    if (isValidLanguageExtensionPoint(ext, extension.description, extension.collector)) {
                        let configuration = undefined;
                        if (ext.configuration) {
                            configuration = joinPath(extension.description.extensionLocation, ext.configuration);
                        }
                        allValidLanguages.push({
                            id: ext.id,
                            extensions: ext.extensions,
                            filenames: ext.filenames,
                            filenamePatterns: ext.filenamePatterns,
                            firstLine: ext.firstLine,
                            aliases: ext.aliases,
                            mimetypes: ext.mimetypes,
                            configuration: configuration,
                            icon: ext.icon && {
                                light: joinPath(extension.description.extensionLocation, ext.icon.light),
                                dark: joinPath(extension.description.extensionLocation, ext.icon.dark)
                            }
                        });
                    }
                }
            }
            this._registry.setDynamicLanguages(allValidLanguages);
        });
        this.updateMime();
        this._configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration(FILES_ASSOCIATIONS_CONFIG)) {
                this.updateMime();
            }
        });
        this._extensionService.whenInstalledExtensionsRegistered().then(() => {
            this.updateMime();
        });
        this.onDidEncounterLanguage((languageId) => {
            this._extensionService.activateByEvent(`onLanguage:${languageId}`);
            this._extensionService.activateByEvent(`onLanguage`);
        });
    }
    updateMime() {
        const configuration = this._configurationService.getValue();
        clearConfiguredLanguageAssociations();
        if (configuration.files?.associations) {
            ( Object.keys(configuration.files.associations)).forEach(pattern => {
                const langId = configuration.files.associations[pattern];
                if (typeof langId !== 'string') {
                    this.logService.warn(`Ignoring configured 'files.associations' for '${pattern}' because its type is not a string but '${typeof langId}'`);
                    return;
                }
                const mimeType = this.getMimeType(langId) || `text/x-${langId}`;
                registerConfiguredLanguageAssociation({ id: langId, mime: mimeType, filepattern: pattern });
            });
        }
        this._onDidChange.fire();
    }
};
WorkbenchLanguageService = ( __decorate([
    ( __param(0, IExtensionService)),
    ( __param(1, IConfigurationService)),
    ( __param(2, IEnvironmentService)),
    ( __param(3, ILogService))
], WorkbenchLanguageService));
function isUndefinedOrStringArray(value) {
    if (typeof value === 'undefined') {
        return true;
    }
    if (!Array.isArray(value)) {
        return false;
    }
    return value.every(item => typeof item === 'string');
}
function isValidLanguageExtensionPoint(value, extension, collector) {
    if (!value) {
        collector.error(( localize(
            'invalid.empty',
            "Empty value for `contributes.{0}`",
            languagesExtPoint.name
        )));
        return false;
    }
    if (typeof value.id !== 'string') {
        collector.error(( localize(
            'require.id',
            "property `{0}` is mandatory and must be of type `string`",
            'id'
        )));
        return false;
    }
    if (!isUndefinedOrStringArray(value.extensions)) {
        collector.error(( localize(
            'opt.extensions',
            "property `{0}` can be omitted and must be of type `string[]`",
            'extensions'
        )));
        return false;
    }
    if (!isUndefinedOrStringArray(value.filenames)) {
        collector.error(( localize(
            'opt.filenames',
            "property `{0}` can be omitted and must be of type `string[]`",
            'filenames'
        )));
        return false;
    }
    if (typeof value.firstLine !== 'undefined' && typeof value.firstLine !== 'string') {
        collector.error(( localize(
            'opt.firstLine',
            "property `{0}` can be omitted and must be of type `string`",
            'firstLine'
        )));
        return false;
    }
    if (typeof value.configuration !== 'undefined' && typeof value.configuration !== 'string') {
        collector.error(( localize(
            'opt.configuration',
            "property `{0}` can be omitted and must be of type `string`",
            'configuration'
        )));
        return false;
    }
    if (!isUndefinedOrStringArray(value.aliases)) {
        collector.error(( localize(
            'opt.aliases',
            "property `{0}` can be omitted and must be of type `string[]`",
            'aliases'
        )));
        return false;
    }
    if (!isUndefinedOrStringArray(value.mimetypes)) {
        collector.error(( localize(
            'opt.mimetypes',
            "property `{0}` can be omitted and must be of type `string[]`",
            'mimetypes'
        )));
        return false;
    }
    if (typeof value.icon !== 'undefined') {
        if (typeof value.icon !== 'object' || typeof value.icon.light !== 'string' || typeof value.icon.dark !== 'string') {
            collector.error(( localize(
                'opt.icon',
                "property `{0}` can be omitted and must be of type `object` with properties `{1}` and `{2}` of type `string`",
                'icon',
                'light',
                'dark'
            )));
            return false;
        }
    }
    return true;
}
export { WorkbenchLanguageService as W, getMimeTypes as g, languagesExtPoint as l };
