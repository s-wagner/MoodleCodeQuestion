import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { isMacintosh, isLinux, isWindows, isWeb, isEdge, isFirefox, isChrome, isSafari, OS } from 'monaco-editor/esm/vs/base/common/platform.js';
import { joinPath, basename } from 'monaco-editor/esm/vs/base/common/resources.js';
import { win32, posix } from 'monaco-editor/esm/vs/base/common/path.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { isSingleFolderWorkspaceIdentifier, isWorkspaceIdentifier, IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { TernarySearchTree } from 'monaco-editor/esm/vs/base/common/ternarySearchTree.js';
import { isString, isUndefinedOrNull } from 'monaco-editor/esm/vs/base/common/types.js';
import { VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { RawContextKey as RawContextKey$1 } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { PauseableEmitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api.js';
import { Disposable, MutableDisposable, dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
import { escapeRegExpCharacters, isFalsyOrWhitespace } from 'monaco-editor/esm/vs/base/common/strings.js';
import { hash } from 'monaco-editor/esm/vs/base/common/hash.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import { Promises, RunOnceScheduler, runWhenIdle } from 'monaco-editor/esm/vs/base/common/async.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { illegalArgument, illegalState } from 'monaco-editor/esm/vs/base/common/errors.js';
const Emitter = monaco.Emitter;
function refineServiceDecorator(serviceIdentifier) {
    return serviceIdentifier;
}
const WINDOWS_INVALID_FILE_CHARS = /[\\/:\*\?"<>\|]/g;
const UNIX_INVALID_FILE_CHARS = /[\\/]/g;
const WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])(\.(.*?))?$/i;
function isValidBasename(name, isWindowsOS = isWindows) {
    const invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;
    if (!name || name.length === 0 || /^\s+$/.test(name)) {
        return false;
    }
    invalidFileChars.lastIndex = 0;
    if (invalidFileChars.test(name)) {
        return false;
    }
    if (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {
        return false;
    }
    if (name === '.' || name === '..') {
        return false;
    }
    if (isWindowsOS && name[name.length - 1] === '.') {
        return false;
    }
    if (isWindowsOS && name.length !== name.trim().length) {
        return false;
    }
    if (name.length > 255) {
        return false;
    }
    return true;
}
var NeverShowAgainScope;
( ((function(NeverShowAgainScope) {
    NeverShowAgainScope[NeverShowAgainScope["WORKSPACE"] = 0] = "WORKSPACE";
    NeverShowAgainScope[NeverShowAgainScope["PROFILE"] = 1] = "PROFILE";
    NeverShowAgainScope[NeverShowAgainScope["APPLICATION"] = 2] = "APPLICATION";
})(NeverShowAgainScope || (NeverShowAgainScope = {}))));
var NotificationsFilter;
( ((function(NotificationsFilter) {
    NotificationsFilter[NotificationsFilter["OFF"] = 0] = "OFF";
    NotificationsFilter[NotificationsFilter["SILENT"] = 1] = "SILENT";
    NotificationsFilter[NotificationsFilter["ERROR"] = 2] = "ERROR";
})(NotificationsFilter || (NotificationsFilter = {}))));
class NoOpNotification {
    constructor() {
        this.progress = ( (new NoOpProgress()));
        this.onDidClose = Event.None;
        this.onDidChangeVisibility = Event.None;
    }
    updateSeverity(severity) { }
    updateMessage(message) { }
    updateActions(actions) { }
    close() { }
}
class NoOpProgress {
    infinite() { }
    done() { }
    total(value) { }
    worked(value) { }
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}
class Scanner {
    constructor() {
        this._input = '';
        this._start = 0;
        this._current = 0;
        this._tokens = [];
        this._errorTokens = [];
        this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
    }
    static reportError(token) {
        if (token.type !== 19 ) {
            throw illegalArgument(`expected an error token but got ${JSON.stringify(token)}`);
        }
        switch (token.lexeme) {
            case '=': return `Unexpected token '${token.lexeme}' at offset ${token.offset}. Did you mean '==' or '=~'?`;
            case '&': return `Unexpected token '${token.lexeme}' at offset ${token.offset}. Did you mean '&&'?`;
            case '|': return `Unexpected token '${token.lexeme}' at offset ${token.offset}. Did you mean '||'?`;
            default: {
                const lexeme = token.lexeme;
                if (lexeme && lexeme.length > 1 && lexeme.startsWith(`'`)) {
                    return `Unexpected token '${token.lexeme}' at offset ${token.offset}. Did you forget to close the string?`;
                }
                if (lexeme && lexeme.length > 1 && lexeme.endsWith(`'`)) {
                    return `Unexpected token '${token.lexeme}' at offset ${token.offset}. Did you forget to open the string?`;
                }
                return `Unexpected token '${token.lexeme}' at offset ${token.offset}`;
            }
        }
    }
    static getLexeme(token) {
        switch (token.type) {
            case 0 :
                return '(';
            case 1 :
                return ')';
            case 2 :
                return '!';
            case 3 :
                return '==';
            case 4 :
                return '!=';
            case 5 :
                return '<';
            case 6 :
                return '<=';
            case 7 :
                return '>=';
            case 8 :
                return '>=';
            case 9 :
                return '=~';
            case 10 :
                return token.lexeme;
            case 11 :
                return 'true';
            case 12 :
                return 'false';
            case 13 :
                return 'in';
            case 14 :
                return 'not';
            case 15 :
                return '&&';
            case 16 :
                return '||';
            case 17 :
                return token.lexeme;
            case 18 :
                return token.lexeme;
            case 19 :
                return token.lexeme;
            case 20 :
                return 'EOF';
            default:
                throw illegalState(`unhandled token type: ${JSON.stringify(token)}; have you forgotten to add a case?`);
        }
    }
    get errorTokens() {
        return this._errorTokens;
    }
    reset(value) {
        this._input = value;
        this._start = 0;
        this._current = 0;
        this._tokens = [];
        this._errorTokens = [];
        return this;
    }
    scan() {
        while (!this._isAtEnd()) {
            this._start = this._current;
            const ch = this._advance();
            switch (ch) {
                case 40 :
                    this._addToken(0 );
                    break;
                case 41 :
                    this._addToken(1 );
                    break;
                case 33 :
                    this._addToken(this._match(61 ) ? 4  : 2 );
                    break;
                case 39 :
                    this._quotedString();
                    break;
                case 47 :
                    this._regex();
                    break;
                case 61 :
                    if (this._match(61 )) {
                        this._addToken(3 );
                    }
                    else if (this._match(126 )) {
                        this._addToken(9 );
                    }
                    else {
                        this._error();
                    }
                    break;
                case 60 :
                    this._addToken(this._match(61 ) ? 6  : 5 );
                    break;
                case 62 :
                    this._addToken(this._match(61 ) ? 8  : 7 );
                    break;
                case 38 :
                    if (this._match(38 )) {
                        this._addToken(15 );
                    }
                    else {
                        this._error();
                    }
                    break;
                case 124 :
                    if (this._match(124 )) {
                        this._addToken(16 );
                    }
                    else {
                        this._error();
                    }
                    break;
                case 32 :
                case 13 :
                case 9 :
                case 10 :
                case 160 :
                    break;
                default:
                    this._string();
            }
        }
        this._start = this._current;
        this._addToken(20 );
        return Array.from(this._tokens);
    }
    _match(expected) {
        if (this._isAtEnd()) {
            return false;
        }
        if (this._input.charCodeAt(this._current) !== expected) {
            return false;
        }
        this._current++;
        return true;
    }
    _advance() {
        return this._input.charCodeAt(this._current++);
    }
    _peek() {
        return this._isAtEnd() ? 0  : this._input.charCodeAt(this._current);
    }
    _addToken(type) {
        this._tokens.push({ type, offset: this._start });
    }
    _error() {
        const errToken = { type: 19 , offset: this._start, lexeme: this._input.substring(this._start, this._current) };
        this._errorTokens.push(errToken);
        this._tokens.push(errToken);
    }
    _string() {
        this.stringRe.lastIndex = this._start;
        const match = this.stringRe.exec(this._input);
        if (match) {
            this._current = this._start + match[0].length;
            const lexeme = this._input.substring(this._start, this._current);
            const keyword = Scanner._keywords.get(lexeme);
            if (keyword) {
                this._addToken(keyword);
            }
            else {
                this._tokens.push({ type: 17 , lexeme, offset: this._start });
            }
        }
    }
    _quotedString() {
        while (this._peek() !== 39  && !this._isAtEnd()) {
            this._advance();
        }
        if (this._isAtEnd()) {
            this._error();
            return;
        }
        this._advance();
        this._tokens.push({ type: 18 , lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
    }
    _regex() {
        let p = this._current;
        let inEscape = false;
        let inCharacterClass = false;
        while (true) {
            if (p >= this._input.length) {
                this._current = p;
                this._error();
                return;
            }
            const ch = this._input.charCodeAt(p);
            if (inEscape) {
                inEscape = false;
            }
            else if (ch === 47  && !inCharacterClass) {
                p++;
                break;
            }
            else if (ch === 91 ) {
                inCharacterClass = true;
            }
            else if (ch === 92 ) {
                inEscape = true;
            }
            else if (ch === 93 ) {
                inCharacterClass = false;
            }
            p++;
        }
        while (p < this._input.length && Scanner._regexFlags.has(this._input.charCodeAt(p))) {
            p++;
        }
        this._current = p;
        const lexeme = this._input.substring(this._start, this._current);
        this._tokens.push({ type: 10 , lexeme, offset: this._start });
    }
    _isAtEnd() {
        return this._current >= this._input.length;
    }
}
Scanner._regexFlags = ( (new Set( (['i', 'g', 's', 'm', 'y', 'u'].map(ch => ch.charCodeAt(0))))));
Scanner._keywords = ( (new Map([
    ['not', 14 ],
    ['in', 13 ],
    ['false', 12 ],
    ['true', 11 ],
])));
const CONSTANT_VALUES = ( (new Map()));
CONSTANT_VALUES.set('false', false);
CONSTANT_VALUES.set('true', true);
CONSTANT_VALUES.set('isMac', isMacintosh);
CONSTANT_VALUES.set('isLinux', isLinux);
CONSTANT_VALUES.set('isWindows', isWindows);
CONSTANT_VALUES.set('isWeb', isWeb);
CONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);
CONSTANT_VALUES.set('isEdge', isEdge);
CONSTANT_VALUES.set('isFirefox', isFirefox);
CONSTANT_VALUES.set('isChrome', isChrome);
CONSTANT_VALUES.set('isSafari', isSafari);
const hasOwnProperty = Object.prototype.hasOwnProperty;
var ContextKeyExprType;
( ((function(ContextKeyExprType) {
    ContextKeyExprType[ContextKeyExprType["False"] = 0] = "False";
    ContextKeyExprType[ContextKeyExprType["True"] = 1] = "True";
    ContextKeyExprType[ContextKeyExprType["Defined"] = 2] = "Defined";
    ContextKeyExprType[ContextKeyExprType["Not"] = 3] = "Not";
    ContextKeyExprType[ContextKeyExprType["Equals"] = 4] = "Equals";
    ContextKeyExprType[ContextKeyExprType["NotEquals"] = 5] = "NotEquals";
    ContextKeyExprType[ContextKeyExprType["And"] = 6] = "And";
    ContextKeyExprType[ContextKeyExprType["Regex"] = 7] = "Regex";
    ContextKeyExprType[ContextKeyExprType["NotRegex"] = 8] = "NotRegex";
    ContextKeyExprType[ContextKeyExprType["Or"] = 9] = "Or";
    ContextKeyExprType[ContextKeyExprType["In"] = 10] = "In";
    ContextKeyExprType[ContextKeyExprType["NotIn"] = 11] = "NotIn";
    ContextKeyExprType[ContextKeyExprType["Greater"] = 12] = "Greater";
    ContextKeyExprType[ContextKeyExprType["GreaterEquals"] = 13] = "GreaterEquals";
    ContextKeyExprType[ContextKeyExprType["Smaller"] = 14] = "Smaller";
    ContextKeyExprType[ContextKeyExprType["SmallerEquals"] = 15] = "SmallerEquals";
})(ContextKeyExprType || (ContextKeyExprType = {}))));
class ContextKeyExpr {
    static false() {
        return ContextKeyFalseExpr.INSTANCE;
    }
    static true() {
        return ContextKeyTrueExpr.INSTANCE;
    }
    static has(key) {
        return (
             (ContextKeyDefinedExpr.create(key))
        );
    }
    static equals(key, value) {
        return ContextKeyEqualsExpr.create(key, value);
    }
    static notEquals(key, value) {
        return ContextKeyNotEqualsExpr.create(key, value);
    }
    static regex(key, value) {
        return ContextKeyRegexExpr.create(key, value);
    }
    static in(key, value) {
        return ContextKeyInExpr.create(key, value);
    }
    static notIn(key, value) {
        return ContextKeyNotInExpr.create(key, value);
    }
    static not(key) {
        return (
             (ContextKeyNotExpr.create(key))
        );
    }
    static and(...expr) {
        return ContextKeyAndExpr.create(expr, null, true);
    }
    static or(...expr) {
        return ContextKeyOrExpr.create(expr, null, true);
    }
    static greater(key, value) {
        return ContextKeyGreaterExpr.create(key, value);
    }
    static greaterEquals(key, value) {
        return ContextKeyGreaterEqualsExpr.create(key, value);
    }
    static smaller(key, value) {
        return ContextKeySmallerExpr.create(key, value);
    }
    static smallerEquals(key, value) {
        return ContextKeySmallerEqualsExpr.create(key, value);
    }
    static deserializeOrErrorNew(serialized) {
        if (!serialized) {
            return { type: 'error', lexingErrors: [], parsingErrors: [] };
        }
        const parser = ( (new Parser()));
        const expr = parser.parse(serialized);
        if (expr === undefined) {
            return { type: 'error', lexingErrors: ( (parser.lexingErrors.map(token => Scanner.reportError(token)))), parsingErrors: parser.parsingErrors };
        }
        else {
            return { type: 'ok', expr };
        }
    }
    static deserialize(serialized) {
        if (!serialized) {
            return undefined;
        }
        return this._deserializeOrExpression(serialized);
    }
    static _deserializeOrExpression(serialized) {
        const pieces = serialized.split('||');
        return ContextKeyOrExpr.create(( (pieces.map(p => this._deserializeAndExpression(p)))), null, true);
    }
    static _deserializeAndExpression(serialized) {
        const pieces = serialized.split('&&');
        return ContextKeyAndExpr.create(( (pieces.map(p => this._deserializeOne(p)))), null, true);
    }
    static _deserializeOne(serializedOne) {
        serializedOne = serializedOne.trim();
        if (serializedOne.indexOf('!=') >= 0) {
            const pieces = serializedOne.split('!=');
            return ContextKeyNotEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1]));
        }
        if (serializedOne.indexOf('==') >= 0) {
            const pieces = serializedOne.split('==');
            return ContextKeyEqualsExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1]));
        }
        if (serializedOne.indexOf('=~') >= 0) {
            const pieces = serializedOne.split('=~');
            return ContextKeyRegexExpr.create(pieces[0].trim(), this._deserializeRegexValue(pieces[1]));
        }
        if (serializedOne.indexOf(' not in ') >= 0) {
            const pieces = serializedOne.split(' not in ');
            return ContextKeyNotInExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1]));
        }
        if (serializedOne.indexOf(' in ') >= 0) {
            const pieces = serializedOne.split(' in ');
            return ContextKeyInExpr.create(pieces[0].trim(), this._deserializeValue(pieces[1]));
        }
        if (/^[^<=>]+>=[^<=>]+$/.test(serializedOne)) {
            const pieces = serializedOne.split('>=');
            return ContextKeyGreaterEqualsExpr.create(pieces[0].trim(), pieces[1].trim());
        }
        if (/^[^<=>]+>[^<=>]+$/.test(serializedOne)) {
            const pieces = serializedOne.split('>');
            return ContextKeyGreaterExpr.create(pieces[0].trim(), pieces[1].trim());
        }
        if (/^[^<=>]+<=[^<=>]+$/.test(serializedOne)) {
            const pieces = serializedOne.split('<=');
            return ContextKeySmallerEqualsExpr.create(pieces[0].trim(), pieces[1].trim());
        }
        if (/^[^<=>]+<[^<=>]+$/.test(serializedOne)) {
            const pieces = serializedOne.split('<');
            return ContextKeySmallerExpr.create(pieces[0].trim(), pieces[1].trim());
        }
        if (/^\!\s*/.test(serializedOne)) {
            return (
                 (ContextKeyNotExpr.create(serializedOne.substr(1).trim()))
            );
        }
        return (
             (ContextKeyDefinedExpr.create(serializedOne))
        );
    }
    static _deserializeValue(serializedValue) {
        serializedValue = serializedValue.trim();
        if (serializedValue === 'true') {
            return true;
        }
        if (serializedValue === 'false') {
            return false;
        }
        const m = /^'([^']*)'$/.exec(serializedValue);
        if (m) {
            return m[1].trim();
        }
        return serializedValue;
    }
    static _deserializeRegexValue(serializedValue) {
        if (isFalsyOrWhitespace(serializedValue)) {
            return null;
        }
        const start = serializedValue.indexOf('/');
        const end = serializedValue.lastIndexOf('/');
        if (start === end || start < 0) {
            return null;
        }
        const value = serializedValue.slice(start + 1, end);
        const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';
        try {
            return (
                 (new RegExp(value, caseIgnoreFlag))
            );
        }
        catch (_e) {
            return null;
        }
    }
}
class ParseError extends Error {
}
class Parser {
    constructor() {
        this._scanner = ( (new Scanner()));
        this._tokens = [];
        this._current = 0;
        this._parsingErrors = [];
    }
    get lexingErrors() {
        return this._scanner.errorTokens;
    }
    get parsingErrors() {
        return this._parsingErrors;
    }
    parse(input) {
        if (input === '') {
            this._parsingErrors.push('Expected an expression but got an empty string');
            return undefined;
        }
        this._tokens = this._scanner.reset(input).scan();
        this._current = 0;
        this._parsingErrors = [];
        try {
            const expr = this._expr();
            if (!this._isAtEnd()) {
                throw this._errUnexpected(this._peek());
            }
            return expr;
        }
        catch (e) {
            if (!(e instanceof ParseError)) {
                const token = this._peek();
                this._parsingErrors.push(`Unexpected error: ${e} for token ${Scanner.getLexeme(token)} at offset ${token.offset}.`);
            }
            return undefined;
        }
    }
    _expr() {
        return this._or();
    }
    _or() {
        const expr = [this._and()];
        while (this._matchOne(16 )) {
            const right = this._and();
            expr.push(right);
        }
        return expr.length === 1 ? expr[0] : ( (ContextKeyExpr.or(...expr)));
    }
    _and() {
        const expr = [this._term()];
        while (this._matchOne(15 )) {
            const right = this._term();
            expr.push(right);
        }
        return expr.length === 1 ? expr[0] : ( (ContextKeyExpr.and(...expr)));
    }
    _term() {
        if (this._matchOne(2 )) {
            const expr = this._peek();
            switch (expr.type) {
                case 17 :
                    this._advance();
                    return ContextKeyExpr.not(expr.lexeme);
                case 11 :
                    this._advance();
                    return ContextKeyExpr.false();
                case 12 :
                    this._advance();
                    return ContextKeyExpr.true();
                default:
                    throw this._errExpectedButGot(`KEY, 'true', or 'false'`, expr);
            }
        }
        return this._primary();
    }
    _primary() {
        const peek = this._peek();
        switch (peek.type) {
            case 11 :
                this._advance();
                return ContextKeyExpr.true();
            case 12 :
                this._advance();
                return ContextKeyExpr.false();
            case 0 : {
                this._advance();
                const expr = this._expr();
                this._consume(1 , `')'`);
                return expr;
            }
            case 17 : {
                const key = peek.lexeme;
                this._advance();
                if (this._matchOne(9 )) {
                    const expr = this._peek();
                    switch (expr.type) {
                        case 10 :
                        case 19 : {
                            const lexemeReconstruction = [expr.lexeme];
                            this._advance();
                            let followingToken = this._peek();
                            let parenBalance = 0;
                            for (let i = 0; i < expr.lexeme.length; i++) {
                                if (expr.lexeme.charCodeAt(i) === 40 ) {
                                    parenBalance++;
                                }
                                else if (expr.lexeme.charCodeAt(i) === 41 ) {
                                    parenBalance--;
                                }
                            }
                            while (!this._isAtEnd() && followingToken.type !== 15  && followingToken.type !== 16 ) {
                                switch (followingToken.type) {
                                    case 0 :
                                        parenBalance++;
                                        break;
                                    case 1 :
                                        parenBalance--;
                                        break;
                                    case 10 :
                                    case 18 :
                                        for (let i = 0; i < followingToken.lexeme.length; i++) {
                                            if (followingToken.lexeme.charCodeAt(i) === 40 ) {
                                                parenBalance++;
                                            }
                                            else if (expr.lexeme.charCodeAt(i) === 41 ) {
                                                parenBalance--;
                                            }
                                        }
                                }
                                if (parenBalance < 0) {
                                    break;
                                }
                                lexemeReconstruction.push(Scanner.getLexeme(followingToken));
                                this._advance();
                                followingToken = this._peek();
                            }
                            const regexLexeme = lexemeReconstruction.join('');
                            const closingSlashIndex = regexLexeme.lastIndexOf('/');
                            const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : regexLexeme.substring(closingSlashIndex + 1);
                            const regexp = ( (new RegExp(regexLexeme.substring(1, closingSlashIndex), flags)));
                            return ContextKeyExpr.regex(key, regexp);
                        }
                        case 18 : {
                            const serializedValue = expr.lexeme;
                            this._advance();
                            let regex = null;
                            if (!isFalsyOrWhitespace(serializedValue)) {
                                const start = serializedValue.indexOf('/');
                                const end = serializedValue.lastIndexOf('/');
                                if (start !== end && start >= 0) {
                                    const value = serializedValue.slice(start + 1, end);
                                    const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';
                                    try {
                                        regex = ( (new RegExp(value, caseIgnoreFlag)));
                                    }
                                    catch (_e) { }
                                }
                            }
                            if (regex === null) {
                                throw this._errExpectedButGot('REGEX', expr);
                            }
                            return ContextKeyRegexExpr.create(key, regex);
                        }
                        default:
                            throw this._errExpectedButGot('REGEX', this._peek());
                    }
                }
                if (this._matchOne(14 )) {
                    this._consume(13 , `'in' after 'not'`);
                    const right = this._value();
                    return ContextKeyExpr.notIn(key, right);
                }
                const maybeOp = this._peek().type;
                switch (maybeOp) {
                    case 3 : {
                        this._advance();
                        const right = this._value();
                        switch (right) {
                            case 'true':
                                return ContextKeyExpr.has(key);
                            case 'false':
                                return ContextKeyExpr.not(key);
                            default:
                                return ContextKeyExpr.equals(key, right);
                        }
                    }
                    case 4 : {
                        this._advance();
                        const right = this._value();
                        switch (right) {
                            case 'true':
                                return ContextKeyExpr.not(key);
                            case 'false':
                                return ContextKeyExpr.has(key);
                            default:
                                return (
                                     (ContextKeyExpr.notEquals(key, right))
                                );
                        }
                    }
                    case 5 :
                        this._advance();
                        return ContextKeySmallerExpr.create(key, this._value());
                    case 6 :
                        this._advance();
                        return ContextKeySmallerEqualsExpr.create(key, this._value());
                    case 7 :
                        this._advance();
                        return ContextKeyGreaterExpr.create(key, this._value());
                    case 8 :
                        this._advance();
                        return ContextKeyGreaterEqualsExpr.create(key, this._value());
                    case 13 :
                        this._advance();
                        return ContextKeyExpr.in(key, this._value());
                    default:
                        return ContextKeyExpr.has(key);
                }
            }
            default:
                throw this._errExpectedButGot(`'true', 'false', '(', KEY, KEY '=~' regex, KEY [ ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value ]`, this._peek());
        }
    }
    _value() {
        const token = this._peek();
        switch (token.type) {
            case 17 :
            case 18 :
                this._advance();
                return token.lexeme;
            case 11 :
                this._advance();
                return 'true';
            case 12 :
                this._advance();
                return 'false';
            case 13 :
                this._advance();
                return 'in';
            default:
                return '';
        }
    }
    _previous() {
        return this._tokens[this._current - 1];
    }
    _matchOne(token) {
        if (this._check(token)) {
            this._advance();
            return true;
        }
        return false;
    }
    _advance() {
        if (!this._isAtEnd()) {
            this._current++;
        }
        return this._previous();
    }
    _consume(type, message) {
        if (this._check(type)) {
            return this._advance();
        }
        throw this._errExpectedButGot(message, this._peek());
    }
    _errExpectedButGot(expected, got) {
        return this._error(`Expected ${expected} but got '${Scanner.getLexeme(got)}' at offset ${got.offset}.`);
    }
    _errUnexpected(token) {
        return this._error(`Unexpected '${Scanner.getLexeme(token)}' at offset ${token.offset}.`);
    }
    _error(errMsg) {
        this._parsingErrors.push(errMsg);
        return (
             (new ParseError())
        );
    }
    _check(type) {
        return this._peek().type === type;
    }
    _peek() {
        return this._tokens[this._current];
    }
    _isAtEnd() {
        return this._peek().type === 20 ;
    }
}
function cmp(a, b) {
    return a.cmp(b);
}
class ContextKeyFalseExpr {
    constructor() {
        this.type = 0 ;
    }
    cmp(other) {
        return this.type - other.type;
    }
    equals(other) {
        return (other.type === this.type);
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        return false;
    }
    serialize() {
        return 'false';
    }
    keys() {
        return [];
    }
    map(mapFnc) {
        return this;
    }
    negate() {
        return ContextKeyTrueExpr.INSTANCE;
    }
}
ContextKeyFalseExpr.INSTANCE = ( (new ContextKeyFalseExpr()));
class ContextKeyTrueExpr {
    constructor() {
        this.type = 1 ;
    }
    cmp(other) {
        return this.type - other.type;
    }
    equals(other) {
        return (other.type === this.type);
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        return true;
    }
    serialize() {
        return 'true';
    }
    keys() {
        return [];
    }
    map(mapFnc) {
        return this;
    }
    negate() {
        return ContextKeyFalseExpr.INSTANCE;
    }
}
ContextKeyTrueExpr.INSTANCE = ( (new ContextKeyTrueExpr()));
class ContextKeyDefinedExpr {
    static create(key, negated = null) {
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === 'boolean') {
            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return (
             (new ContextKeyDefinedExpr(key, negated))
        );
    }
    constructor(key, negated) {
        this.key = key;
        this.negated = negated;
        this.type = 2 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp1(this.key, other.key);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key);
        }
        return false;
    }
    substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === 'boolean') {
            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;
        }
        return this;
    }
    evaluate(context) {
        return (!!context.getValue(this.key));
    }
    serialize() {
        return this.key;
    }
    keys() {
        return [this.key];
    }
    map(mapFnc) {
        return mapFnc.mapDefined(this.key);
    }
    negate() {
        if (!this.negated) {
            this.negated = ( (ContextKeyNotExpr.create(this.key, this)));
        }
        return this.negated;
    }
}
class ContextKeyEqualsExpr {
    static create(key, value, negated = null) {
        if (typeof value === 'boolean') {
            return (value ?  (ContextKeyDefinedExpr.create(key, negated)) :  (ContextKeyNotExpr.create(key, negated)));
        }
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === 'boolean') {
            const trueValue = constantValue ? 'true' : 'false';
            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);
        }
        return (
             (new ContextKeyEqualsExpr(key, value, negated))
        );
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 4 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === 'boolean') {
            const trueValue = constantValue ? 'true' : 'false';
            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);
        }
        return this;
    }
    evaluate(context) {
        return (context.getValue(this.key) == this.value);
    }
    serialize() {
        return `${this.key} == '${this.value}'`;
    }
    keys() {
        return [this.key];
    }
    map(mapFnc) {
        return mapFnc.mapEquals(this.key, this.value);
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeyInExpr {
    static create(key, valueKey) {
        return (
             (new ContextKeyInExpr(key, valueKey))
        );
    }
    constructor(key, valueKey) {
        this.key = key;
        this.valueKey = valueKey;
        this.type = 10 ;
        this.negated = null;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.valueKey, other.key, other.valueKey);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.valueKey === other.valueKey);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        const source = context.getValue(this.valueKey);
        const item = context.getValue(this.key);
        if (Array.isArray(source)) {
            return source.includes(item);
        }
        if (typeof item === 'string' && typeof source === 'object' && source !== null) {
            return hasOwnProperty.call(source, item);
        }
        return false;
    }
    serialize() {
        return `${this.key} in '${this.valueKey}'`;
    }
    keys() {
        return [this.key, this.valueKey];
    }
    map(mapFnc) {
        return mapFnc.mapIn(this.key, this.valueKey);
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);
        }
        return this.negated;
    }
}
class ContextKeyNotInExpr {
    static create(key, valueKey) {
        return (
             (new ContextKeyNotInExpr(key, valueKey))
        );
    }
    constructor(key, valueKey) {
        this.key = key;
        this.valueKey = valueKey;
        this.type = 11 ;
        this._negated = ContextKeyInExpr.create(key, valueKey);
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return this._negated.cmp(other._negated);
    }
    equals(other) {
        if (other.type === this.type) {
            return this._negated.equals(other._negated);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        return !this._negated.evaluate(context);
    }
    serialize() {
        return `${this.key} not in '${this.valueKey}'`;
    }
    keys() {
        return (
             (this._negated.keys())
        );
    }
    map(mapFnc) {
        return mapFnc.mapNotIn(this.key, this.valueKey);
    }
    negate() {
        return this._negated;
    }
}
class ContextKeyNotEqualsExpr {
    static create(key, value, negated = null) {
        if (typeof value === 'boolean') {
            if (value) {
                return (
                     (ContextKeyNotExpr.create(key, negated))
                );
            }
            return (
                 (ContextKeyDefinedExpr.create(key, negated))
            );
        }
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === 'boolean') {
            const falseValue = constantValue ? 'true' : 'false';
            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);
        }
        return (
             (new ContextKeyNotEqualsExpr(key, value, negated))
        );
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 5 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === 'boolean') {
            const falseValue = constantValue ? 'true' : 'false';
            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);
        }
        return this;
    }
    evaluate(context) {
        return (context.getValue(this.key) != this.value);
    }
    serialize() {
        return `${this.key} != '${this.value}'`;
    }
    keys() {
        return [this.key];
    }
    map(mapFnc) {
        return mapFnc.mapNotEquals(this.key, this.value);
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeyNotExpr {
    static create(key, negated = null) {
        const constantValue = CONSTANT_VALUES.get(key);
        if (typeof constantValue === 'boolean') {
            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);
        }
        return (
             (new ContextKeyNotExpr(key, negated))
        );
    }
    constructor(key, negated) {
        this.key = key;
        this.negated = negated;
        this.type = 3 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp1(this.key, other.key);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key);
        }
        return false;
    }
    substituteConstants() {
        const constantValue = CONSTANT_VALUES.get(this.key);
        if (typeof constantValue === 'boolean') {
            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);
        }
        return this;
    }
    evaluate(context) {
        return (!context.getValue(this.key));
    }
    serialize() {
        return `!${this.key}`;
    }
    keys() {
        return [this.key];
    }
    map(mapFnc) {
        return mapFnc.mapNot(this.key);
    }
    negate() {
        if (!this.negated) {
            this.negated = ( (ContextKeyDefinedExpr.create(this.key, this)));
        }
        return this.negated;
    }
}
function withFloatOrStr(value, callback) {
    if (typeof value === 'string') {
        const n = parseFloat(value);
        if (!isNaN(n)) {
            value = n;
        }
    }
    if (typeof value === 'string' || typeof value === 'number') {
        return callback(value);
    }
    return ContextKeyFalseExpr.INSTANCE;
}
class ContextKeyGreaterExpr {
    static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => ( (new ContextKeyGreaterExpr(key, value, negated))));
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 12 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        if (typeof this.value === 'string') {
            return false;
        }
        return (parseFloat(context.getValue(this.key)) > this.value);
    }
    serialize() {
        return `${this.key} > ${this.value}`;
    }
    keys() {
        return [this.key];
    }
    map(mapFnc) {
        return mapFnc.mapGreater(this.key, this.value);
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeyGreaterEqualsExpr {
    static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => ( (new ContextKeyGreaterEqualsExpr(key, value, negated))));
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 13 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        if (typeof this.value === 'string') {
            return false;
        }
        return (parseFloat(context.getValue(this.key)) >= this.value);
    }
    serialize() {
        return `${this.key} >= ${this.value}`;
    }
    keys() {
        return [this.key];
    }
    map(mapFnc) {
        return mapFnc.mapGreaterEquals(this.key, this.value);
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeySmallerExpr {
    static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => ( (new ContextKeySmallerExpr(key, value, negated))));
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 14 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        if (typeof this.value === 'string') {
            return false;
        }
        return (parseFloat(context.getValue(this.key)) < this.value);
    }
    serialize() {
        return `${this.key} < ${this.value}`;
    }
    keys() {
        return [this.key];
    }
    map(mapFnc) {
        return mapFnc.mapSmaller(this.key, this.value);
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeySmallerEqualsExpr {
    static create(key, _value, negated = null) {
        return withFloatOrStr(_value, (value) => ( (new ContextKeySmallerEqualsExpr(key, value, negated))));
    }
    constructor(key, value, negated) {
        this.key = key;
        this.value = value;
        this.negated = negated;
        this.type = 15 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return cmp2(this.key, this.value, other.key, other.value);
    }
    equals(other) {
        if (other.type === this.type) {
            return (this.key === other.key && this.value === other.value);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        if (typeof this.value === 'string') {
            return false;
        }
        return (parseFloat(context.getValue(this.key)) <= this.value);
    }
    serialize() {
        return `${this.key} <= ${this.value}`;
    }
    keys() {
        return [this.key];
    }
    map(mapFnc) {
        return mapFnc.mapSmallerEquals(this.key, this.value);
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);
        }
        return this.negated;
    }
}
class ContextKeyRegexExpr {
    static create(key, regexp) {
        return (
             (new ContextKeyRegexExpr(key, regexp))
        );
    }
    constructor(key, regexp) {
        this.key = key;
        this.regexp = regexp;
        this.type = 7 ;
        this.negated = null;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        if (this.key < other.key) {
            return -1;
        }
        if (this.key > other.key) {
            return 1;
        }
        const thisSource = this.regexp ? this.regexp.source : '';
        const otherSource = other.regexp ? other.regexp.source : '';
        if (thisSource < otherSource) {
            return -1;
        }
        if (thisSource > otherSource) {
            return 1;
        }
        return 0;
    }
    equals(other) {
        if (other.type === this.type) {
            const thisSource = this.regexp ? this.regexp.source : '';
            const otherSource = other.regexp ? other.regexp.source : '';
            return (this.key === other.key && thisSource === otherSource);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        const value = context.getValue(this.key);
        return this.regexp ? this.regexp.test(value) : false;
    }
    serialize() {
        const value = this.regexp
            ? `/${this.regexp.source}/${this.regexp.flags}`
            : '/invalid/';
        return `${this.key} =~ ${value}`;
    }
    keys() {
        return [this.key];
    }
    map(mapFnc) {
        return mapFnc.mapRegex(this.key, this.regexp);
    }
    negate() {
        if (!this.negated) {
            this.negated = ContextKeyNotRegexExpr.create(this);
        }
        return this.negated;
    }
}
class ContextKeyNotRegexExpr {
    static create(actual) {
        return (
             (new ContextKeyNotRegexExpr(actual))
        );
    }
    constructor(_actual) {
        this._actual = _actual;
        this.type = 8 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        return this._actual.cmp(other._actual);
    }
    equals(other) {
        if (other.type === this.type) {
            return this._actual.equals(other._actual);
        }
        return false;
    }
    substituteConstants() {
        return this;
    }
    evaluate(context) {
        return !this._actual.evaluate(context);
    }
    serialize() {
        throw new Error('Method not implemented.');
    }
    keys() {
        return (
             (this._actual.keys())
        );
    }
    map(mapFnc) {
        return (
             (new ContextKeyNotRegexExpr( (this._actual.map(mapFnc))))
        );
    }
    negate() {
        return this._actual;
    }
}
function eliminateConstantsInArray(arr) {
    let newArr = null;
    for (let i = 0, len = arr.length; i < len; i++) {
        const newExpr = arr[i].substituteConstants();
        if (arr[i] !== newExpr) {
            if (newArr === null) {
                newArr = [];
                for (let j = 0; j < i; j++) {
                    newArr[j] = arr[j];
                }
            }
        }
        if (newArr !== null) {
            newArr[i] = newExpr;
        }
    }
    if (newArr === null) {
        return arr;
    }
    return newArr;
}
class ContextKeyAndExpr {
    static create(_expr, negated, extraRedundantCheck) {
        return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);
    }
    constructor(expr, negated) {
        this.expr = expr;
        this.negated = negated;
        this.type = 6 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        if (this.expr.length < other.expr.length) {
            return -1;
        }
        if (this.expr.length > other.expr.length) {
            return 1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
            const r = cmp(this.expr[i], other.expr[i]);
            if (r !== 0) {
                return r;
            }
        }
        return 0;
    }
    equals(other) {
        if (other.type === this.type) {
            if (this.expr.length !== other.expr.length) {
                return false;
            }
            for (let i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].equals(other.expr[i])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    substituteConstants() {
        const exprArr = eliminateConstantsInArray(this.expr);
        if (exprArr === this.expr) {
            return this;
        }
        return ContextKeyAndExpr.create(exprArr, this.negated, false);
    }
    evaluate(context) {
        for (let i = 0, len = this.expr.length; i < len; i++) {
            if (!this.expr[i].evaluate(context)) {
                return false;
            }
        }
        return true;
    }
    static _normalizeArr(arr, negated, extraRedundantCheck) {
        const expr = [];
        let hasTrue = false;
        for (const e of arr) {
            if (!e) {
                continue;
            }
            if (e.type === 1 ) {
                hasTrue = true;
                continue;
            }
            if (e.type === 0 ) {
                return ContextKeyFalseExpr.INSTANCE;
            }
            if (e.type === 6 ) {
                expr.push(...e.expr);
                continue;
            }
            expr.push(e);
        }
        if (expr.length === 0 && hasTrue) {
            return ContextKeyTrueExpr.INSTANCE;
        }
        if (expr.length === 0) {
            return undefined;
        }
        if (expr.length === 1) {
            return expr[0];
        }
        expr.sort(cmp);
        for (let i = 1; i < expr.length; i++) {
            if (expr[i - 1].equals(expr[i])) {
                expr.splice(i, 1);
                i--;
            }
        }
        if (expr.length === 1) {
            return expr[0];
        }
        while (expr.length > 1) {
            const lastElement = expr[expr.length - 1];
            if (lastElement.type !== 9 ) {
                break;
            }
            expr.pop();
            const secondToLastElement = expr.pop();
            const isFinished = (expr.length === 0);
            const resultElement = ContextKeyOrExpr.create(( (lastElement.expr.map(
                el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)
            ))), null, isFinished);
            if (resultElement) {
                expr.push(resultElement);
                expr.sort(cmp);
            }
        }
        if (expr.length === 1) {
            return expr[0];
        }
        if (extraRedundantCheck) {
            for (let i = 0; i < expr.length; i++) {
                for (let j = i + 1; j < expr.length; j++) {
                    if (expr[i].negate().equals(expr[j])) {
                        return ContextKeyFalseExpr.INSTANCE;
                    }
                }
            }
            if (expr.length === 1) {
                return expr[0];
            }
        }
        return (
             (new ContextKeyAndExpr(expr, negated))
        );
    }
    serialize() {
        return ( (this.expr.map(e => e.serialize()))).join(' && ');
    }
    keys() {
        const result = [];
        for (const expr of this.expr) {
            result.push(...( (expr.keys())));
        }
        return result;
    }
    map(mapFnc) {
        return (
             (new ContextKeyAndExpr(
                 (this.expr.map(expr => ( (expr.map(mapFnc))))),
                null
            ))
        );
    }
    negate() {
        if (!this.negated) {
            const result = [];
            for (const expr of this.expr) {
                result.push(expr.negate());
            }
            this.negated = ContextKeyOrExpr.create(result, this, true);
        }
        return this.negated;
    }
}
class ContextKeyOrExpr {
    static create(_expr, negated, extraRedundantCheck) {
        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);
    }
    constructor(expr, negated) {
        this.expr = expr;
        this.negated = negated;
        this.type = 9 ;
    }
    cmp(other) {
        if (other.type !== this.type) {
            return this.type - other.type;
        }
        if (this.expr.length < other.expr.length) {
            return -1;
        }
        if (this.expr.length > other.expr.length) {
            return 1;
        }
        for (let i = 0, len = this.expr.length; i < len; i++) {
            const r = cmp(this.expr[i], other.expr[i]);
            if (r !== 0) {
                return r;
            }
        }
        return 0;
    }
    equals(other) {
        if (other.type === this.type) {
            if (this.expr.length !== other.expr.length) {
                return false;
            }
            for (let i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].equals(other.expr[i])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    substituteConstants() {
        const exprArr = eliminateConstantsInArray(this.expr);
        if (exprArr === this.expr) {
            return this;
        }
        return ContextKeyOrExpr.create(exprArr, this.negated, false);
    }
    evaluate(context) {
        for (let i = 0, len = this.expr.length; i < len; i++) {
            if (this.expr[i].evaluate(context)) {
                return true;
            }
        }
        return false;
    }
    static _normalizeArr(arr, negated, extraRedundantCheck) {
        let expr = [];
        let hasFalse = false;
        if (arr) {
            for (let i = 0, len = arr.length; i < len; i++) {
                const e = arr[i];
                if (!e) {
                    continue;
                }
                if (e.type === 0 ) {
                    hasFalse = true;
                    continue;
                }
                if (e.type === 1 ) {
                    return ContextKeyTrueExpr.INSTANCE;
                }
                if (e.type === 9 ) {
                    expr = expr.concat(e.expr);
                    continue;
                }
                expr.push(e);
            }
            if (expr.length === 0 && hasFalse) {
                return ContextKeyFalseExpr.INSTANCE;
            }
            expr.sort(cmp);
        }
        if (expr.length === 0) {
            return undefined;
        }
        if (expr.length === 1) {
            return expr[0];
        }
        for (let i = 1; i < expr.length; i++) {
            if (expr[i - 1].equals(expr[i])) {
                expr.splice(i, 1);
                i--;
            }
        }
        if (expr.length === 1) {
            return expr[0];
        }
        if (extraRedundantCheck) {
            for (let i = 0; i < expr.length; i++) {
                for (let j = i + 1; j < expr.length; j++) {
                    if (expr[i].negate().equals(expr[j])) {
                        return ContextKeyTrueExpr.INSTANCE;
                    }
                }
            }
            if (expr.length === 1) {
                return expr[0];
            }
        }
        return (
             (new ContextKeyOrExpr(expr, negated))
        );
    }
    serialize() {
        return ( (this.expr.map(e => e.serialize()))).join(' || ');
    }
    keys() {
        const result = [];
        for (const expr of this.expr) {
            result.push(...( (expr.keys())));
        }
        return result;
    }
    map(mapFnc) {
        return (
             (new ContextKeyOrExpr(
                 (this.expr.map(expr => ( (expr.map(mapFnc))))),
                null
            ))
        );
    }
    negate() {
        if (!this.negated) {
            const result = [];
            for (const expr of this.expr) {
                result.push(expr.negate());
            }
            while (result.length > 1) {
                const LEFT = result.shift();
                const RIGHT = result.shift();
                const all = [];
                for (const left of getTerminals(LEFT)) {
                    for (const right of getTerminals(RIGHT)) {
                        all.push(ContextKeyAndExpr.create([left, right], null, false));
                    }
                }
                result.unshift(ContextKeyOrExpr.create(all, null, false));
            }
            this.negated = ContextKeyOrExpr.create(result, this, true);
        }
        return this.negated;
    }
}
class RawContextKey extends ContextKeyDefinedExpr {
    static all() {
        return (
             (RawContextKey._info.values())
        );
    }
    constructor(key, defaultValue, metaOrHide) {
        super(key, null);
        this._defaultValue = defaultValue;
        if (typeof metaOrHide === 'object') {
            RawContextKey._info.push({ ...metaOrHide, key });
        }
        else if (metaOrHide !== true) {
            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });
        }
    }
    bindTo(target) {
        return target.createKey(this.key, this._defaultValue);
    }
    getValue(target) {
        return target.getContextKeyValue(this.key);
    }
    toNegated() {
        return this.negate();
    }
    isEqualTo(value) {
        return ContextKeyEqualsExpr.create(this.key, value);
    }
    notEqualsTo(value) {
        return ContextKeyNotEqualsExpr.create(this.key, value);
    }
}
RawContextKey._info = [];
function cmp1(key1, key2) {
    if (key1 < key2) {
        return -1;
    }
    if (key1 > key2) {
        return 1;
    }
    return 0;
}
function cmp2(key1, value1, key2, value2) {
    if (key1 < key2) {
        return -1;
    }
    if (key1 > key2) {
        return 1;
    }
    if (value1 < value2) {
        return -1;
    }
    if (value1 > value2) {
        return 1;
    }
    return 0;
}
function getTerminals(node) {
    if (node.type === 9 ) {
        return node.expr;
    }
    return [node];
}
const mark = (name) => {
    performance.mark(name);
};
const getMarks = () => {
    let timeOrigin = performance.timeOrigin;
    if (typeof timeOrigin !== 'number') {
        timeOrigin = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart;
    }
    const result = [{ name: 'code/timeOrigin', startTime: Math.round(timeOrigin) }];
    for (const entry of performance.getEntriesByType('mark')) {
        result.push({
            name: entry.name,
            startTime: Math.round(timeOrigin + entry.startTime)
        });
    }
    return result;
};
const IFileService = ( (createDecorator('fileService')));
var FileType;
( ((function(FileType) {
    FileType[FileType["Unknown"] = 0] = "Unknown";
    FileType[FileType["File"] = 1] = "File";
    FileType[FileType["Directory"] = 2] = "Directory";
    FileType[FileType["SymbolicLink"] = 64] = "SymbolicLink";
})(FileType || (FileType = {}))));
var FilePermission;
( ((function(FilePermission) {
    FilePermission[FilePermission["Readonly"] = 1] = "Readonly";
})(FilePermission || (FilePermission = {}))));
function hasReadWriteCapability(provider) {
    return !!((provider.capabilities & 2) );
}
function hasFileFolderCopyCapability(provider) {
    return !!((provider.capabilities & 8) );
}
function hasFileCloneCapability(provider) {
    return !!((provider.capabilities & 32768) );
}
function hasOpenReadWriteCloseCapability(provider) {
    return !!((provider.capabilities & 4) );
}
function hasFileReadStreamCapability(provider) {
    return !!((provider.capabilities & 16) );
}
function hasFileAtomicReadCapability(provider) {
    if (!hasReadWriteCapability(provider)) {
        return false;
    }
    return !!((provider.capabilities & 16384) );
}
var FileSystemProviderErrorCode;
( ((function(FileSystemProviderErrorCode) {
    FileSystemProviderErrorCode["FileExists"] = "EntryExists";
    FileSystemProviderErrorCode["FileNotFound"] = "EntryNotFound";
    FileSystemProviderErrorCode["FileNotADirectory"] = "EntryNotADirectory";
    FileSystemProviderErrorCode["FileIsADirectory"] = "EntryIsADirectory";
    FileSystemProviderErrorCode["FileExceedsMemoryLimit"] = "EntryExceedsMemoryLimit";
    FileSystemProviderErrorCode["FileTooLarge"] = "EntryTooLarge";
    FileSystemProviderErrorCode["FileWriteLocked"] = "EntryWriteLocked";
    FileSystemProviderErrorCode["NoPermissions"] = "NoPermissions";
    FileSystemProviderErrorCode["Unavailable"] = "Unavailable";
    FileSystemProviderErrorCode["Unknown"] = "Unknown";
})(FileSystemProviderErrorCode || (FileSystemProviderErrorCode = {}))));
class FileSystemProviderError extends Error {
    static create(error, code) {
        const providerError = ( (new FileSystemProviderError( (error.toString()), code)));
        markAsFileSystemProviderError(providerError, code);
        return providerError;
    }
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
function createFileSystemProviderError(error, code) {
    return FileSystemProviderError.create(error, code);
}
function ensureFileSystemProviderError(error) {
    if (!error) {
        return createFileSystemProviderError(( (localize('unknownError', "Unknown Error"))), FileSystemProviderErrorCode.Unknown);
    }
    return error;
}
function markAsFileSystemProviderError(error, code) {
    error.name = code ? `${code} (FileSystemError)` : `FileSystemError`;
    return error;
}
function toFileSystemProviderErrorCode(error) {
    if (!error) {
        return FileSystemProviderErrorCode.Unknown;
    }
    if (error instanceof FileSystemProviderError) {
        return error.code;
    }
    const match = /^(.+) \(FileSystemError\)$/.exec(error.name);
    if (!match) {
        return FileSystemProviderErrorCode.Unknown;
    }
    switch (match[1]) {
        case FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;
        case FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;
        case FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;
        case FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;
        case FileSystemProviderErrorCode.FileExceedsMemoryLimit: return FileSystemProviderErrorCode.FileExceedsMemoryLimit;
        case FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;
        case FileSystemProviderErrorCode.FileWriteLocked: return FileSystemProviderErrorCode.FileWriteLocked;
        case FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;
        case FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;
    }
    return FileSystemProviderErrorCode.Unknown;
}
function toFileOperationResult(error) {
    if (error instanceof FileOperationError) {
        return error.fileOperationResult;
    }
    switch (toFileSystemProviderErrorCode(error)) {
        case FileSystemProviderErrorCode.FileNotFound:
            return 1 ;
        case FileSystemProviderErrorCode.FileIsADirectory:
            return 0 ;
        case FileSystemProviderErrorCode.FileNotADirectory:
            return 10 ;
        case FileSystemProviderErrorCode.FileWriteLocked:
            return 5 ;
        case FileSystemProviderErrorCode.NoPermissions:
            return 6 ;
        case FileSystemProviderErrorCode.FileExists:
            return 4 ;
        case FileSystemProviderErrorCode.FileExceedsMemoryLimit:
            return 9 ;
        case FileSystemProviderErrorCode.FileTooLarge:
            return 7 ;
        default:
            return 11 ;
    }
}
class FileOperationEvent {
    constructor(resource, operation, target) {
        this.resource = resource;
        this.operation = operation;
        this.target = target;
    }
    isOperation(operation) {
        return this.operation === operation;
    }
}
class FileChangesEvent {
    constructor(changes, ignorePathCasing) {
        this.added = undefined;
        this.updated = undefined;
        this.deleted = undefined;
        this.rawAdded = [];
        this.rawUpdated = [];
        this.rawDeleted = [];
        const entriesByType = ( (new Map()));
        for (const change of changes) {
            const array = entriesByType.get(change.type);
            if (array) {
                array.push([change.resource, change]);
            }
            else {
                entriesByType.set(change.type, [[change.resource, change]]);
            }
            switch (change.type) {
                case 1 :
                    this.rawAdded.push(change.resource);
                    break;
                case 0 :
                    this.rawUpdated.push(change.resource);
                    break;
                case 2 :
                    this.rawDeleted.push(change.resource);
                    break;
            }
        }
        for (const [key, value] of entriesByType) {
            switch (key) {
                case 1 :
                    this.added = TernarySearchTree.forUris(() => ignorePathCasing);
                    this.added.fill(value);
                    break;
                case 0 :
                    this.updated = TernarySearchTree.forUris(() => ignorePathCasing);
                    this.updated.fill(value);
                    break;
                case 2 :
                    this.deleted = TernarySearchTree.forUris(() => ignorePathCasing);
                    this.deleted.fill(value);
                    break;
            }
        }
    }
    contains(resource, ...types) {
        return this.doContains(resource, { includeChildren: false }, ...types);
    }
    affects(resource, ...types) {
        return this.doContains(resource, { includeChildren: true }, ...types);
    }
    doContains(resource, options, ...types) {
        if (!resource) {
            return false;
        }
        const hasTypesFilter = types.length > 0;
        if (!hasTypesFilter || types.includes(1 )) {
            if (this.added?.get(resource)) {
                return true;
            }
            if (options.includeChildren && this.added?.findSuperstr(resource)) {
                return true;
            }
        }
        if (!hasTypesFilter || types.includes(0 )) {
            if (this.updated?.get(resource)) {
                return true;
            }
            if (options.includeChildren && this.updated?.findSuperstr(resource)) {
                return true;
            }
        }
        if (!hasTypesFilter || types.includes(2 )) {
            if (this.deleted?.findSubstr(resource) ) {
                return true;
            }
            if (options.includeChildren && this.deleted?.findSuperstr(resource)) {
                return true;
            }
        }
        return false;
    }
    gotAdded() {
        return !!this.added;
    }
    gotDeleted() {
        return !!this.deleted;
    }
    gotUpdated() {
        return !!this.updated;
    }
}
class FileOperationError extends Error {
    constructor(message, fileOperationResult, options) {
        super(message);
        this.fileOperationResult = fileOperationResult;
        this.options = options;
    }
}
class TooLargeFileOperationError extends FileOperationError {
    constructor(message, fileOperationResult, size, options) {
        super(message, fileOperationResult, options);
        this.fileOperationResult = fileOperationResult;
        this.size = size;
    }
}
class NotModifiedSinceFileOperationError extends FileOperationError {
    constructor(message, stat, options) {
        super(message, 2 , options);
        this.stat = stat;
    }
}
const AutoSaveConfiguration = {
    OFF: 'off',
    AFTER_DELAY: 'afterDelay',
    ON_FOCUS_CHANGE: 'onFocusChange',
    ON_WINDOW_CHANGE: 'onWindowChange'
};
const HotExitConfiguration = {
    OFF: 'off',
    ON_EXIT: 'onExit',
    ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'
};
const FILES_ASSOCIATIONS_CONFIG = 'files.associations';
const ETAG_DISABLED = '';
function etag(stat) {
    if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {
        return undefined;
    }
    return ( (stat.mtime.toString(29))) + ( (stat.size.toString(31)));
}
const IUriIdentityService = ( (createDecorator('IUriIdentityService')));
function isUserDataProfile(thing) {
    const candidate = thing;
    return !!(candidate && typeof candidate === 'object'
        && typeof candidate.id === 'string'
        && typeof candidate.isDefault === 'boolean'
        && typeof candidate.name === 'string'
        && URI.isUri(candidate.location)
        && URI.isUri(candidate.globalStorageHome)
        && URI.isUri(candidate.settingsResource)
        && URI.isUri(candidate.keybindingsResource)
        && URI.isUri(candidate.tasksResource)
        && URI.isUri(candidate.snippetsHome)
        && URI.isUri(candidate.extensionsResource));
}
const IUserDataProfilesService = ( (createDecorator('IUserDataProfilesService')));
function toUserDataProfile(id, name, location, options) {
    return {
        id,
        name,
        location,
        isDefault: false,
        shortName: options?.shortName,
        globalStorageHome: joinPath(location, 'globalStorage'),
        settingsResource: joinPath(location, 'settings.json'),
        keybindingsResource: joinPath(location, 'keybindings.json'),
        tasksResource: joinPath(location, 'tasks.json'),
        snippetsHome: joinPath(location, 'snippets'),
        extensionsResource: joinPath(location, 'extensions.json'),
        useDefaultFlags: options?.useDefaultFlags,
        isTransient: options?.transient
    };
}
let UserDataProfilesService = class UserDataProfilesService extends Disposable {
    get defaultProfile() { return this.profiles[0]; }
    get profiles() { return [...this.profilesObject.profiles, ...this.transientProfilesObject.profiles]; }
    constructor(environmentService, fileService, uriIdentityService, logService) {
        super();
        this.environmentService = environmentService;
        this.fileService = fileService;
        this.uriIdentityService = uriIdentityService;
        this.logService = logService;
        this.enabled = true;
        this._onDidChangeProfiles = this._register(( (new Emitter())));
        this.onDidChangeProfiles = this._onDidChangeProfiles.event;
        this._onWillCreateProfile = this._register(( (new Emitter())));
        this.onWillCreateProfile = this._onWillCreateProfile.event;
        this._onWillRemoveProfile = this._register(( (new Emitter())));
        this.onWillRemoveProfile = this._onWillRemoveProfile.event;
        this._onDidResetWorkspaces = this._register(( (new Emitter())));
        this.onDidResetWorkspaces = this._onDidResetWorkspaces.event;
        this.profileCreationPromises = ( (new Map()));
        this.transientProfilesObject = {
            profiles: [],
            workspaces: ( (new ResourceMap())),
            emptyWindows: ( (new Map()))
        };
        this.profilesHome = joinPath(this.environmentService.userRoamingDataHome, 'profiles');
    }
    init() {
        this._profilesObject = undefined;
    }
    setEnablement(enabled) {
        if (this.enabled !== enabled) {
            this._profilesObject = undefined;
            this.enabled = enabled;
        }
    }
    isEnabled() {
        return this.enabled;
    }
    get profilesObject() {
        if (!this._profilesObject) {
            const profiles = [];
            if (this.enabled) {
                try {
                    for (const storedProfile of this.getStoredProfiles()) {
                        if (!storedProfile.name || !isString(storedProfile.name) || !storedProfile.location) {
                            this.logService.warn('Skipping the invalid stored profile', storedProfile.location || storedProfile.name);
                            continue;
                        }
                        profiles.push(toUserDataProfile(basename(storedProfile.location), storedProfile.name, storedProfile.location, { shortName: storedProfile.shortName, useDefaultFlags: storedProfile.useDefaultFlags }));
                    }
                }
                catch (error) {
                    this.logService.error(error);
                }
            }
            const workspaces = ( (new ResourceMap()));
            const emptyWindows = ( (new Map()));
            const defaultProfile = this.createDefaultProfile();
            profiles.unshift({ ...defaultProfile, extensionsResource: this.getDefaultProfileExtensionsLocation() ?? defaultProfile.extensionsResource, isDefault: true });
            if (profiles.length) {
                try {
                    const profileAssociaitions = this.getStoredProfileAssociations();
                    if (profileAssociaitions.workspaces) {
                        for (const [workspacePath, profileId] of Object.entries(profileAssociaitions.workspaces)) {
                            const workspace = ( (URI.parse(workspacePath)));
                            const profile = profiles.find(p => p.id === profileId);
                            if (profile) {
                                workspaces.set(workspace, profile);
                            }
                        }
                    }
                    if (profileAssociaitions.emptyWindows) {
                        for (const [windowId, profileId] of Object.entries(profileAssociaitions.emptyWindows)) {
                            const profile = profiles.find(p => p.id === profileId);
                            if (profile) {
                                emptyWindows.set(windowId, profile);
                            }
                        }
                    }
                }
                catch (error) {
                    this.logService.error(error);
                }
            }
            this._profilesObject = { profiles, workspaces, emptyWindows };
        }
        return this._profilesObject;
    }
    createDefaultProfile() {
        return toUserDataProfile('__default__profile__', ( (localize('defaultProfile', "Default"))), this.environmentService.userRoamingDataHome);
    }
    async createTransientProfile(workspaceIdentifier) {
        const namePrefix = `Temp`;
        const nameRegEx = ( (new RegExp(`${escapeRegExpCharacters(namePrefix)}\\s(\\d+)`)));
        let nameIndex = 0;
        for (const profile of this.profiles) {
            const matches = nameRegEx.exec(profile.name);
            const index = matches ? parseInt(matches[1]) : 0;
            nameIndex = index > nameIndex ? index : nameIndex;
        }
        const name = `${namePrefix} ${nameIndex + 1}`;
        return this.createProfile(( (hash(generateUuid()).toString(16))), name, { transient: true }, workspaceIdentifier);
    }
    async createNamedProfile(name, options, workspaceIdentifier) {
        return this.createProfile(( (hash(generateUuid()).toString(16))), name, options, workspaceIdentifier);
    }
    async createProfile(id, name, options, workspaceIdentifier) {
        if (!this.enabled) {
            throw new Error(`Profiles are disabled in the current environment.`);
        }
        const profile = await this.doCreateProfile(id, name, options);
        if (workspaceIdentifier) {
            await this.setProfileForWorkspace(workspaceIdentifier, profile);
        }
        return profile;
    }
    async doCreateProfile(id, name, options) {
        if (!isString(name) || !name) {
            throw new Error('Name of the profile is mandatory and must be of type `string`');
        }
        let profileCreationPromise = this.profileCreationPromises.get(name);
        if (!profileCreationPromise) {
            profileCreationPromise = (async () => {
                try {
                    const existing = this.profiles.find(p => p.name === name || p.id === id);
                    if (existing) {
                        return existing;
                    }
                    const profile = toUserDataProfile(id, name, joinPath(this.profilesHome, id), options);
                    await this.fileService.createFolder(profile.location);
                    const joiners = [];
                    this._onWillCreateProfile.fire({
                        profile,
                        join(promise) {
                            joiners.push(promise);
                        }
                    });
                    await Promises.settled(joiners);
                    this.updateProfiles([profile], [], []);
                    return profile;
                }
                finally {
                    this.profileCreationPromises.delete(name);
                }
            })();
            this.profileCreationPromises.set(name, profileCreationPromise);
        }
        return profileCreationPromise;
    }
    async updateProfile(profileToUpdate, options) {
        if (!this.enabled) {
            throw new Error(`Profiles are disabled in the current environment.`);
        }
        let profile = this.profiles.find(p => p.id === profileToUpdate.id);
        if (!profile) {
            throw new Error(`Profile '${profileToUpdate.name}' does not exist`);
        }
        profile = toUserDataProfile(profile.id, options.name ?? profile.name, profile.location, { shortName: options.shortName ?? profile.shortName, transient: options.transient ?? profile.isTransient, useDefaultFlags: options.useDefaultFlags ?? profile.useDefaultFlags });
        this.updateProfiles([], [], [profile]);
        return profile;
    }
    async removeProfile(profileToRemove) {
        if (!this.enabled) {
            throw new Error(`Profiles are disabled in the current environment.`);
        }
        if (profileToRemove.isDefault) {
            throw new Error('Cannot remove default profile');
        }
        const profile = this.profiles.find(p => p.id === profileToRemove.id);
        if (!profile) {
            throw new Error(`Profile '${profileToRemove.name}' does not exist`);
        }
        const joiners = [];
        this._onWillRemoveProfile.fire({
            profile,
            join(promise) {
                joiners.push(promise);
            }
        });
        try {
            await Promise.allSettled(joiners);
        }
        catch (error) {
            this.logService.error(error);
        }
        for (const windowId of [...( (this.profilesObject.emptyWindows.keys()))]) {
            if (profile.id === this.profilesObject.emptyWindows.get(windowId)?.id) {
                this.profilesObject.emptyWindows.delete(windowId);
            }
        }
        for (const workspace of [...( (this.profilesObject.workspaces.keys()))]) {
            if (profile.id === this.profilesObject.workspaces.get(workspace)?.id) {
                this.profilesObject.workspaces.delete(workspace);
            }
        }
        this.updateStoredProfileAssociations();
        this.updateProfiles([], [profile], []);
        try {
            if (this.profiles.length === 1) {
                await this.fileService.del(this.profilesHome, { recursive: true });
            }
            else {
                await this.fileService.del(profile.location, { recursive: true });
            }
        }
        catch (error) {
            this.logService.error(error);
        }
    }
    async setProfileForWorkspace(workspaceIdentifier, profileToSet) {
        if (!this.enabled) {
            throw new Error(`Profiles are disabled in the current environment.`);
        }
        const profile = this.profiles.find(p => p.id === profileToSet.id);
        if (!profile) {
            throw new Error(`Profile '${profileToSet.name}' does not exist`);
        }
        this.updateWorkspaceAssociation(workspaceIdentifier, profile);
    }
    unsetWorkspace(workspaceIdentifier, transient) {
        if (!this.enabled) {
            throw new Error(`Profiles are disabled in the current environment.`);
        }
        this.updateWorkspaceAssociation(workspaceIdentifier, undefined, transient);
    }
    async resetWorkspaces() {
        this.transientProfilesObject.workspaces.clear();
        this.transientProfilesObject.emptyWindows.clear();
        this.profilesObject.workspaces.clear();
        this.profilesObject.emptyWindows.clear();
        this.updateStoredProfileAssociations();
        this._onDidResetWorkspaces.fire();
    }
    async cleanUp() {
        if (!this.enabled) {
            return;
        }
        if (await this.fileService.exists(this.profilesHome)) {
            const stat = await this.fileService.resolve(this.profilesHome);
            await Promise.all(( ((stat.children || [])
                .filter(child => child.isDirectory && this.profiles.every(p => !this.uriIdentityService.extUri.isEqual(p.location, child.resource)))
                .map(child => this.fileService.del(child.resource, { recursive: true })))));
        }
    }
    async cleanUpTransientProfiles() {
        if (!this.enabled) {
            return;
        }
        const unAssociatedTransientProfiles = this.transientProfilesObject.profiles.filter(p => !this.isProfileAssociatedToWorkspace(p));
        await Promise.allSettled(( (unAssociatedTransientProfiles.map(p => this.removeProfile(p)))));
    }
    getProfileForWorkspace(workspaceIdentifier) {
        const workspace = this.getWorkspace(workspaceIdentifier);
        return URI.isUri(workspace) ? this.transientProfilesObject.workspaces.get(workspace) ?? this.profilesObject.workspaces.get(workspace) : this.transientProfilesObject.emptyWindows.get(workspace) ?? this.profilesObject.emptyWindows.get(workspace);
    }
    getWorkspace(workspaceIdentifier) {
        if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
            return workspaceIdentifier.uri;
        }
        if (isWorkspaceIdentifier(workspaceIdentifier)) {
            return workspaceIdentifier.configPath;
        }
        return workspaceIdentifier.id;
    }
    isProfileAssociatedToWorkspace(profile) {
        if ([...( (this.transientProfilesObject.emptyWindows.values()))].some(windowProfile => this.uriIdentityService.extUri.isEqual(windowProfile.location, profile.location))) {
            return true;
        }
        if ([...( (this.transientProfilesObject.workspaces.values()))].some(workspaceProfile => this.uriIdentityService.extUri.isEqual(workspaceProfile.location, profile.location))) {
            return true;
        }
        if ([...( (this.profilesObject.emptyWindows.values()))].some(windowProfile => this.uriIdentityService.extUri.isEqual(windowProfile.location, profile.location))) {
            return true;
        }
        if ([...( (this.profilesObject.workspaces.values()))].some(workspaceProfile => this.uriIdentityService.extUri.isEqual(workspaceProfile.location, profile.location))) {
            return true;
        }
        return false;
    }
    updateProfiles(added, removed, updated) {
        const allProfiles = [...this.profiles, ...added];
        const storedProfiles = [];
        this.transientProfilesObject.profiles = [];
        for (let profile of allProfiles) {
            if (profile.isDefault) {
                continue;
            }
            if (removed.some(p => profile.id === p.id)) {
                continue;
            }
            profile = updated.find(p => profile.id === p.id) ?? profile;
            if (profile.isTransient) {
                this.transientProfilesObject.profiles.push(profile);
            }
            else {
                storedProfiles.push({ location: profile.location, name: profile.name, shortName: profile.shortName, useDefaultFlags: profile.useDefaultFlags });
            }
        }
        this.saveStoredProfiles(storedProfiles);
        this._profilesObject = undefined;
        this.triggerProfilesChanges(added, removed, updated);
    }
    triggerProfilesChanges(added, removed, updated) {
        this._onDidChangeProfiles.fire({ added, removed, updated, all: this.profiles });
    }
    updateWorkspaceAssociation(workspaceIdentifier, newProfile, transient) {
        transient = newProfile?.isTransient ? true : transient;
        if (!transient) {
            this.updateWorkspaceAssociation(workspaceIdentifier, undefined, true);
        }
        const workspace = this.getWorkspace(workspaceIdentifier);
        const profilesObject = transient ? this.transientProfilesObject : this.profilesObject;
        if (URI.isUri(workspace)) {
            profilesObject.workspaces.delete(workspace);
            if (newProfile) {
                profilesObject.workspaces.set(workspace, newProfile);
            }
        }
        else {
            profilesObject.emptyWindows.delete(workspace);
            if (newProfile) {
                profilesObject.emptyWindows.set(workspace, newProfile);
            }
        }
        if (!transient) {
            this.updateStoredProfileAssociations();
        }
    }
    updateStoredProfileAssociations() {
        const workspaces = {};
        for (const [workspace, profile] of this.profilesObject.workspaces.entries()) {
            workspaces[( (workspace.toString()))] = profile.id;
        }
        const emptyWindows = {};
        for (const [windowId, profile] of this.profilesObject.emptyWindows.entries()) {
            emptyWindows[( (windowId.toString()))] = profile.id;
        }
        this.saveStoredProfileAssociations({ workspaces, emptyWindows });
        this._profilesObject = undefined;
    }
    migrateStoredProfileAssociations(storedProfileAssociations) {
        const workspaces = {};
        const defaultProfile = this.createDefaultProfile();
        if (storedProfileAssociations.workspaces) {
            for (const [workspace, location] of Object.entries(storedProfileAssociations.workspaces)) {
                const uri = ( (URI.parse(location)));
                workspaces[workspace] = this.uriIdentityService.extUri.isEqual(uri, defaultProfile.location) ? defaultProfile.id : this.uriIdentityService.extUri.basename(uri);
            }
        }
        const emptyWindows = {};
        if (storedProfileAssociations.emptyWindows) {
            for (const [workspace, location] of Object.entries(storedProfileAssociations.emptyWindows)) {
                const uri = ( (URI.parse(location)));
                emptyWindows[workspace] = this.uriIdentityService.extUri.isEqual(uri, defaultProfile.location) ? defaultProfile.id : this.uriIdentityService.extUri.basename(uri);
            }
        }
        return { workspaces, emptyWindows };
    }
    getStoredProfiles() { return []; }
    saveStoredProfiles(storedProfiles) { throw new Error('not implemented'); }
    getStoredProfileAssociations() { return {}; }
    saveStoredProfileAssociations(storedProfileAssociations) { throw new Error('not implemented'); }
    getDefaultProfileExtensionsLocation() { return undefined; }
};
UserDataProfilesService.PROFILES_KEY = 'userDataProfiles';
UserDataProfilesService.PROFILE_ASSOCIATIONS_KEY = 'profileAssociations';
UserDataProfilesService = ( (__decorate([
    ( (__param(0, IEnvironmentService))),
    ( (__param(1, IFileService))),
    ( (__param(2, IUriIdentityService))),
    ( (__param(3, ILogService)))
], UserDataProfilesService)));
const IS_NEW_KEY = '__$__isNewStorageMarker';
const TARGET_KEY = '__$__targetStorageMarker';
var WillSaveStateReason;
( ((function(WillSaveStateReason) {
    WillSaveStateReason[WillSaveStateReason["NONE"] = 0] = "NONE";
    WillSaveStateReason[WillSaveStateReason["SHUTDOWN"] = 1] = "SHUTDOWN";
})(WillSaveStateReason || (WillSaveStateReason = {}))));
var StorageScope;
( ((function(StorageScope) {
    StorageScope[StorageScope["APPLICATION"] = -1] = "APPLICATION";
    StorageScope[StorageScope["PROFILE"] = 0] = "PROFILE";
    StorageScope[StorageScope["WORKSPACE"] = 1] = "WORKSPACE";
})(StorageScope || (StorageScope = {}))));
var StorageTarget;
( ((function(StorageTarget) {
    StorageTarget[StorageTarget["USER"] = 0] = "USER";
    StorageTarget[StorageTarget["MACHINE"] = 1] = "MACHINE";
})(StorageTarget || (StorageTarget = {}))));
function loadKeyTargets(storage) {
    const keysRaw = storage.get(TARGET_KEY);
    if (keysRaw) {
        try {
            return JSON.parse(keysRaw);
        }
        catch (error) {
        }
    }
    return Object.create(null);
}
class AbstractStorageService extends Disposable {
    constructor(options = { flushInterval: AbstractStorageService.DEFAULT_FLUSH_INTERVAL }) {
        super();
        this.options = options;
        this._onDidChangeValue = this._register(( (new PauseableEmitter())));
        this.onDidChangeValue = this._onDidChangeValue.event;
        this._onDidChangeTarget = this._register(( (new PauseableEmitter())));
        this.onDidChangeTarget = this._onDidChangeTarget.event;
        this._onWillSaveState = this._register(( (new Emitter())));
        this.onWillSaveState = this._onWillSaveState.event;
        this.flushWhenIdleScheduler = this._register(( (new RunOnceScheduler(() => this.doFlushWhenIdle(), this.options.flushInterval))));
        this.runFlushWhenIdle = this._register(( (new MutableDisposable())));
        this._workspaceKeyTargets = undefined;
        this._profileKeyTargets = undefined;
        this._applicationKeyTargets = undefined;
    }
    doFlushWhenIdle() {
        this.runFlushWhenIdle.value = runWhenIdle(() => {
            if (this.shouldFlushWhenIdle()) {
                this.flush();
            }
            this.flushWhenIdleScheduler.schedule();
        });
    }
    shouldFlushWhenIdle() {
        return true;
    }
    stopFlushWhenIdle() {
        dispose([this.runFlushWhenIdle, this.flushWhenIdleScheduler]);
    }
    initialize() {
        if (!this.initializationPromise) {
            this.initializationPromise = (async () => {
                mark('code/willInitStorage');
                try {
                    await this.doInitialize();
                }
                finally {
                    mark('code/didInitStorage');
                }
                this.flushWhenIdleScheduler.schedule();
            })();
        }
        return this.initializationPromise;
    }
    emitDidChangeValue(scope, key) {
        if (key === TARGET_KEY) {
            switch (scope) {
                case -1 :
                    this._applicationKeyTargets = undefined;
                    break;
                case 0 :
                    this._profileKeyTargets = undefined;
                    break;
                case 1 :
                    this._workspaceKeyTargets = undefined;
                    break;
            }
            this._onDidChangeTarget.fire({ scope });
        }
        else {
            this._onDidChangeValue.fire({ scope, key, target: this.getKeyTargets(scope)[key] });
        }
    }
    emitWillSaveState(reason) {
        this._onWillSaveState.fire({ reason });
    }
    get(key, scope, fallbackValue) {
        return this.getStorage(scope)?.get(key, fallbackValue);
    }
    getBoolean(key, scope, fallbackValue) {
        return this.getStorage(scope)?.getBoolean(key, fallbackValue);
    }
    getNumber(key, scope, fallbackValue) {
        return this.getStorage(scope)?.getNumber(key, fallbackValue);
    }
    store(key, value, scope, target) {
        if (isUndefinedOrNull(value)) {
            this.remove(key, scope);
            return;
        }
        this.withPausedEmitters(() => {
            this.updateKeyTarget(key, scope, target);
            this.getStorage(scope)?.set(key, value);
        });
    }
    remove(key, scope) {
        this.withPausedEmitters(() => {
            this.updateKeyTarget(key, scope, undefined);
            this.getStorage(scope)?.delete(key);
        });
    }
    withPausedEmitters(fn) {
        this._onDidChangeValue.pause();
        this._onDidChangeTarget.pause();
        try {
            fn();
        }
        finally {
            this._onDidChangeValue.resume();
            this._onDidChangeTarget.resume();
        }
    }
    keys(scope, target) {
        const keys = [];
        const keyTargets = this.getKeyTargets(scope);
        for (const key of ( (Object.keys(keyTargets)))) {
            const keyTarget = keyTargets[key];
            if (keyTarget === target) {
                keys.push(key);
            }
        }
        return keys;
    }
    updateKeyTarget(key, scope, target) {
        const keyTargets = this.getKeyTargets(scope);
        if (typeof target === 'number') {
            if (keyTargets[key] !== target) {
                keyTargets[key] = target;
                this.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets));
            }
        }
        else {
            if (typeof keyTargets[key] === 'number') {
                delete keyTargets[key];
                this.getStorage(scope)?.set(TARGET_KEY, JSON.stringify(keyTargets));
            }
        }
    }
    get workspaceKeyTargets() {
        if (!this._workspaceKeyTargets) {
            this._workspaceKeyTargets = this.loadKeyTargets(1 );
        }
        return this._workspaceKeyTargets;
    }
    get profileKeyTargets() {
        if (!this._profileKeyTargets) {
            this._profileKeyTargets = this.loadKeyTargets(0 );
        }
        return this._profileKeyTargets;
    }
    get applicationKeyTargets() {
        if (!this._applicationKeyTargets) {
            this._applicationKeyTargets = this.loadKeyTargets(-1 );
        }
        return this._applicationKeyTargets;
    }
    getKeyTargets(scope) {
        switch (scope) {
            case -1 :
                return this.applicationKeyTargets;
            case 0 :
                return this.profileKeyTargets;
            default:
                return this.workspaceKeyTargets;
        }
    }
    loadKeyTargets(scope) {
        const storage = this.getStorage(scope);
        return storage ? loadKeyTargets(storage) : Object.create(null);
    }
    isNew(scope) {
        return this.getBoolean(IS_NEW_KEY, scope) === true;
    }
    async flush(reason = WillSaveStateReason.NONE) {
        this._onWillSaveState.fire({ reason });
        const applicationStorage = this.getStorage(-1 );
        const profileStorage = this.getStorage(0 );
        const workspaceStorage = this.getStorage(1 );
        switch (reason) {
            case WillSaveStateReason.NONE:
                await Promises.settled([
                    applicationStorage?.whenFlushed() ?? Promise.resolve(),
                    profileStorage?.whenFlushed() ?? Promise.resolve(),
                    workspaceStorage?.whenFlushed() ?? Promise.resolve()
                ]);
                break;
            case WillSaveStateReason.SHUTDOWN:
                await Promises.settled([
                    applicationStorage?.flush(0) ?? Promise.resolve(),
                    profileStorage?.flush(0) ?? Promise.resolve(),
                    workspaceStorage?.flush(0) ?? Promise.resolve()
                ]);
                break;
        }
    }
    async log() {
        const applicationItems = this.getStorage(-1 )?.items ?? ( (new Map()));
        const profileItems = this.getStorage(0 )?.items ?? ( (new Map()));
        const workspaceItems = this.getStorage(1 )?.items ?? ( (new Map()));
        return logStorage(applicationItems, profileItems, workspaceItems, this.getLogDetails(-1 ) ?? '', this.getLogDetails(0 ) ?? '', this.getLogDetails(1 ) ?? '');
    }
    async switch(to, preserveData) {
        this.emitWillSaveState(WillSaveStateReason.NONE);
        if (isUserDataProfile(to)) {
            return this.switchToProfile(to, preserveData);
        }
        return this.switchToWorkspace(to, preserveData);
    }
    canSwitchProfile(from, to) {
        if (from.id === to.id) {
            return false;
        }
        if (isProfileUsingDefaultStorage(to) && isProfileUsingDefaultStorage(from)) {
            return false;
        }
        return true;
    }
    switchData(oldStorage, newStorage, scope, preserveData) {
        this.withPausedEmitters(() => {
            if (preserveData) {
                for (const [key, value] of oldStorage) {
                    newStorage.set(key, value);
                }
            }
            else {
                const handledkeys = ( (new Set()));
                for (const [key, oldValue] of oldStorage) {
                    handledkeys.add(key);
                    const newValue = newStorage.get(key);
                    if (newValue !== oldValue) {
                        this.emitDidChangeValue(scope, key);
                    }
                }
                for (const [key] of newStorage.items) {
                    if (!handledkeys.has(key)) {
                        this.emitDidChangeValue(scope, key);
                    }
                }
            }
        });
    }
}
AbstractStorageService.DEFAULT_FLUSH_INTERVAL = 60 * 1000;
function isProfileUsingDefaultStorage(profile) {
    return profile.isDefault || !!profile.useDefaultFlags?.uiState;
}
async function logStorage(application, profile, workspace, applicationPath, profilePath, workspacePath) {
    const safeParse = (value) => {
        try {
            return JSON.parse(value);
        }
        catch (error) {
            return value;
        }
    };
    const applicationItems = ( (new Map()));
    const applicationItemsParsed = ( (new Map()));
    application.forEach((value, key) => {
        applicationItems.set(key, value);
        applicationItemsParsed.set(key, safeParse(value));
    });
    const profileItems = ( (new Map()));
    const profileItemsParsed = ( (new Map()));
    profile.forEach((value, key) => {
        profileItems.set(key, value);
        profileItemsParsed.set(key, safeParse(value));
    });
    const workspaceItems = ( (new Map()));
    const workspaceItemsParsed = ( (new Map()));
    workspace.forEach((value, key) => {
        workspaceItems.set(key, value);
        workspaceItemsParsed.set(key, safeParse(value));
    });
    if (applicationPath !== profilePath) {
        console.group(`Storage: Application (path: ${applicationPath})`);
    }
    else {
        console.group(`Storage: Application & Profile (path: ${applicationPath}, default profile)`);
    }
    const applicationValues = [];
    applicationItems.forEach((value, key) => {
        applicationValues.push({ key, value });
    });
    console.table(applicationValues);
    console.groupEnd();
    console.log(applicationItemsParsed);
    if (applicationPath !== profilePath) {
        console.group(`Storage: Profile (path: ${profilePath}, profile specific)`);
        const profileValues = [];
        profileItems.forEach((value, key) => {
            profileValues.push({ key, value });
        });
        console.table(profileValues);
        console.groupEnd();
        console.log(profileItemsParsed);
    }
    console.group(`Storage: Workspace (path: ${workspacePath})`);
    const workspaceValues = [];
    workspaceItems.forEach((value, key) => {
        workspaceValues.push({ key, value });
    });
    console.table(workspaceValues);
    console.groupEnd();
    console.log(workspaceItemsParsed);
}
const IProductService = ( (createDecorator('productService')));
const productSchemaId = 'vscode://schemas/vscode-product';
const IEditorGroupsService = ( (createDecorator('editorGroupsService')));
function isEditorGroup(obj) {
    const group = obj;
    return !!group && typeof group.id === 'number' && Array.isArray(group.editors);
}
function preferredSideBySideGroupDirection(configurationService) {
    const openSideBySideDirection = configurationService.getValue('workbench.editor.openSideBySideDirection');
    if (openSideBySideDirection === 'down') {
        return 1 ;
    }
    return 3 ;
}
const IEditorService = ( (createDecorator('editorService')));
const ACTIVE_GROUP = -1;
const SIDE_GROUP = -2;
function isPreferredGroup(obj) {
    const candidate = obj;
    return typeof obj === 'number' || isEditorGroup(candidate);
}
const IWorkbenchEnvironmentService = refineServiceDecorator(IEnvironmentService);
const IHostService = ( (createDecorator('hostService')));
const ILanguageStatusService = ( (createDecorator('ILanguageStatusService')));
const IPaneCompositePartService = ( (createDecorator('paneCompositePartService')));
function isVirtualResource(resource) {
    return resource.scheme !== Schemas.file && resource.scheme !== Schemas.vscodeRemote;
}
function getVirtualWorkspaceLocation(workspace) {
    if (workspace.folders.length) {
        return workspace.folders.every(f => isVirtualResource(f.uri)) ? workspace.folders[0].uri : undefined;
    }
    else if (workspace.configuration && isVirtualResource(workspace.configuration)) {
        return workspace.configuration;
    }
    return undefined;
}
function getVirtualWorkspaceScheme(workspace) {
    return getVirtualWorkspaceLocation(workspace)?.scheme;
}
const IRemoteAgentService = ( (createDecorator('remoteAgentService')));
const IPathService = ( (createDecorator('pathService')));
let AbstractPathService = class AbstractPathService {
    constructor(localUserHome, remoteAgentService, environmentService, contextService) {
        this.localUserHome = localUserHome;
        this.remoteAgentService = remoteAgentService;
        this.environmentService = environmentService;
        this.contextService = contextService;
        this.resolveOS = (async () => {
            const env = await this.remoteAgentService.getEnvironment();
            return env?.os || OS;
        })();
        this.resolveUserHome = (async () => {
            const env = await this.remoteAgentService.getEnvironment();
            const userHome = this.maybeUnresolvedUserHome = env?.userHome ?? localUserHome;
            return userHome;
        })();
    }
    hasValidBasename(resource, arg2, basename) {
        if (typeof arg2 === 'string' || typeof arg2 === 'undefined') {
            return this.resolveOS.then(os => this.doHasValidBasename(resource, os, arg2));
        }
        return this.doHasValidBasename(resource, arg2, basename);
    }
    doHasValidBasename(resource, os, name) {
        if (resource.scheme === Schemas.file || resource.scheme === Schemas.vscodeRemote) {
            return isValidBasename(name ?? basename(resource), os === 1 );
        }
        return true;
    }
    get defaultUriScheme() {
        return AbstractPathService.findDefaultUriScheme(this.environmentService, this.contextService);
    }
    static findDefaultUriScheme(environmentService, contextService) {
        if (environmentService.remoteAuthority) {
            return Schemas.vscodeRemote;
        }
        const virtualWorkspace = getVirtualWorkspaceScheme(contextService.getWorkspace());
        if (virtualWorkspace) {
            return virtualWorkspace;
        }
        const firstFolder = contextService.getWorkspace().folders[0];
        if (firstFolder) {
            return firstFolder.uri.scheme;
        }
        const configuration = contextService.getWorkspace().configuration;
        if (configuration) {
            return configuration.scheme;
        }
        return Schemas.file;
    }
    userHome(options) {
        return options?.preferLocal ? this.localUserHome : this.resolveUserHome;
    }
    get resolvedUserHome() {
        return this.maybeUnresolvedUserHome;
    }
    get path() {
        return this.resolveOS.then(os => {
            return os === 1  ?
                win32 :
                posix;
        });
    }
    async fileURI(_path) {
        let authority = '';
        const os = await this.resolveOS;
        if (os === 1 ) {
            _path = _path.replace(/\\/g, '/');
        }
        if (_path[0] === '/' && _path[1] === '/') {
            const idx = _path.indexOf('/', 2);
            if (idx === -1) {
                authority = _path.substring(2);
                _path = '/';
            }
            else {
                authority = _path.substring(2, idx);
                _path = _path.substring(idx) || '/';
            }
        }
        return (
             (URI.from({
                scheme: Schemas.file,
                authority,
                path: _path,
                query: '',
                fragment: ''
            }))
        );
    }
};
AbstractPathService = ( (__decorate([
    ( (__param(1, IRemoteAgentService))),
    ( (__param(2, IWorkbenchEnvironmentService))),
    ( (__param(3, IWorkspaceContextService)))
], AbstractPathService)));
const ITextFileService = ( (createDecorator('textFileService')));
class TextFileOperationError extends FileOperationError {
    static isTextFileOperationError(obj) {
        return obj instanceof Error && !isUndefinedOrNull(obj.textFileOperationResult);
    }
    constructor(message, textFileOperationResult, options) {
        super(message, 11 );
        this.textFileOperationResult = textFileOperationResult;
        this.options = options;
    }
}
function stringToSnapshot(value) {
    let done = false;
    return {
        read() {
            if (!done) {
                done = true;
                return value;
            }
            return null;
        }
    };
}
function toBufferOrReadable(value) {
    if (typeof value === 'undefined') {
        return undefined;
    }
    if (typeof value === 'string') {
        return VSBuffer.fromString(value);
    }
    return {
        read: () => {
            const chunk = value.read();
            if (typeof chunk === 'string') {
                return VSBuffer.fromString(chunk);
            }
            return null;
        }
    };
}
const IWorkingCopyFileService = ( (createDecorator('workingCopyFileService')));
const ISnippetsService = ( (createDecorator('snippetService')));
const VIEWLET_ID = 'workbench.view.debug';
const VARIABLES_VIEW_ID = 'workbench.debug.variablesView';
const CALLSTACK_VIEW_ID = 'workbench.debug.callStackView';
const BREAKPOINTS_VIEW_ID = 'workbench.debug.breakPointsView';
const REPL_VIEW_ID = 'workbench.panel.repl.view';
const CONTEXT_DEBUG_TYPE = ( (new RawContextKey$1(
    'debugType',
    undefined,
    { type: 'string', description: ( (localize(
        'debugType',
        "Debug type of the active debug session. For example 'python'."
    ))) }
)));
const CONTEXT_DEBUG_CONFIGURATION_TYPE = ( (new RawContextKey$1(
    'debugConfigurationType',
    undefined,
    { type: 'string', description: ( (localize(
        'debugConfigurationType',
        "Debug type of the selected launch configuration. For example 'python'."
    ))) }
)));
const CONTEXT_DEBUG_STATE = ( (new RawContextKey$1(
    'debugState',
    'inactive',
    { type: 'string', description: ( (localize(
        'debugState',
        "State that the focused debug session is in. One of the following: 'inactive', 'initializing', 'stopped' or 'running'."
    ))) }
)));
const CONTEXT_DEBUG_UX_KEY = 'debugUx';
const CONTEXT_DEBUG_UX = ( (new RawContextKey$1(
    CONTEXT_DEBUG_UX_KEY,
    'default',
    { type: 'string', description: ( (localize(
        'debugUX',
        "Debug UX state. When there are no debug configurations it is 'simple', otherwise 'default'. Used to decide when to show welcome views in the debug viewlet."
    ))) }
)));
const CONTEXT_HAS_DEBUGGED = ( (new RawContextKey$1(
    'hasDebugged',
    false,
    { type: 'boolean', description: ( (localize(
        'hasDebugged',
        "True when a debug session has been started at least once, false otherwise."
    ))) }
)));
const CONTEXT_IN_DEBUG_MODE = ( (new RawContextKey$1(
    'inDebugMode',
    false,
    { type: 'boolean', description: ( (localize('inDebugMode', "True when debugging, false otherwise."))) }
)));
const CONTEXT_BREAKPOINT_WIDGET_VISIBLE = ( (new RawContextKey$1(
    'breakpointWidgetVisible',
    false,
    { type: 'boolean', description: ( (localize(
        'breakpointWidgetVisibile',
        "True when breakpoint editor zone widget is visible, false otherwise."
    ))) }
)));
const CONTEXT_IN_BREAKPOINT_WIDGET = ( (new RawContextKey$1(
    'inBreakpointWidget',
    false,
    { type: 'boolean', description: ( (localize(
        'inBreakpointWidget',
        "True when focus is in the breakpoint editor zone widget, false otherwise."
    ))) }
)));
const CONTEXT_BREAKPOINTS_FOCUSED = ( (new RawContextKey$1(
    'breakpointsFocused',
    true,
    { type: 'boolean', description: ( (localize(
        'breakpointsFocused',
        "True when the BREAKPOINTS view is focused, false otherwise."
    ))) }
)));
const CONTEXT_WATCH_EXPRESSIONS_FOCUSED = ( (new RawContextKey$1(
    'watchExpressionsFocused',
    true,
    { type: 'boolean', description: ( (localize(
        'watchExpressionsFocused',
        "True when the WATCH view is focused, false otherwsie."
    ))) }
)));
const CONTEXT_VARIABLES_FOCUSED = ( (new RawContextKey$1(
    'variablesFocused',
    true,
    { type: 'boolean', description: ( (localize(
        'variablesFocused',
        "True when the VARIABLES views is focused, false otherwsie"
    ))) }
)));
const CONTEXT_EXPRESSION_SELECTED = ( (new RawContextKey$1(
    'expressionSelected',
    false,
    { type: 'boolean', description: ( (localize(
        'expressionSelected',
        "True when an expression input box is open in either the WATCH or the VARIABLES view, false otherwise."
    ))) }
)));
const CONTEXT_BREAKPOINT_INPUT_FOCUSED = ( (new RawContextKey$1(
    'breakpointInputFocused',
    false,
    { type: 'boolean', description: ( (localize(
        'breakpointInputFocused',
        "True when the input box has focus in the BREAKPOINTS view."
    ))) }
)));
const CONTEXT_CAN_VIEW_MEMORY = ( (new RawContextKey$1(
    'canViewMemory',
    undefined,
    { type: 'boolean', description: ( (localize(
        'canViewMemory',
        "Indicates whether the item in the view has an associated memory refrence."
    ))) }
)));
const CONTEXT_BREAKPOINT_ITEM_TYPE = ( (new RawContextKey$1(
    'breakpointItemType',
    undefined,
    { type: 'string', description: ( (localize(
        'breakpointItemType',
        "Represents the item type of the focused element in the BREAKPOINTS view. For example: 'breakpoint', 'exceptionBreakppint', 'functionBreakpoint', 'dataBreakpoint'"
    ))) }
)));
const CONTEXT_BREAKPOINT_SUPPORTS_CONDITION = ( (new RawContextKey$1(
    'breakpointSupportsCondition',
    false,
    { type: 'boolean', description: ( (localize(
        'breakpointSupportsCondition',
        "True when the focused breakpoint supports conditions."
    ))) }
)));
const CONTEXT_LOADED_SCRIPTS_SUPPORTED = ( (new RawContextKey$1(
    'loadedScriptsSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'loadedScriptsSupported',
        "True when the focused sessions supports the LOADED SCRIPTS view"
    ))) }
)));
const CONTEXT_FOCUSED_SESSION_IS_ATTACH = ( (new RawContextKey$1(
    'focusedSessionIsAttach',
    false,
    { type: 'boolean', description: ( (localize('focusedSessionIsAttach', "True when the focused session is 'attach'."))) }
)));
const CONTEXT_STEP_BACK_SUPPORTED = ( (new RawContextKey$1(
    'stepBackSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'stepBackSupported',
        "True when the focused session supports 'stepBack' requests."
    ))) }
)));
const CONTEXT_RESTART_FRAME_SUPPORTED = ( (new RawContextKey$1(
    'restartFrameSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'restartFrameSupported',
        "True when the focused session supports 'restartFrame' requests."
    ))) }
)));
const CONTEXT_JUMP_TO_CURSOR_SUPPORTED = ( (new RawContextKey$1(
    'jumpToCursorSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'jumpToCursorSupported',
        "True when the focused session supports 'jumpToCursor' request."
    ))) }
)));
const CONTEXT_STEP_INTO_TARGETS_SUPPORTED = ( (new RawContextKey$1(
    'stepIntoTargetsSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'stepIntoTargetsSupported',
        "True when the focused session supports 'stepIntoTargets' request."
    ))) }
)));
const CONTEXT_BREAKPOINTS_EXIST = ( (new RawContextKey$1(
    'breakpointsExist',
    false,
    { type: 'boolean', description: ( (localize('breakpointsExist', "True when at least one breakpoint exists."))) }
)));
const CONTEXT_DEBUGGERS_AVAILABLE = ( (new RawContextKey$1(
    'debuggersAvailable',
    false,
    { type: 'boolean', description: ( (localize(
        'debuggersAvailable',
        "True when there is at least one debug extensions active."
    ))) }
)));
const CONTEXT_DEBUG_EXTENSION_AVAILABLE = ( (new RawContextKey$1(
    'debugExtensionAvailable',
    true,
    { type: 'boolean', description: ( (localize(
        'debugExtensionsAvailable',
        "True when there is at least one debug extension installed and enabled."
    ))) }
)));
const CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT = ( (new RawContextKey$1(
    'debugProtocolVariableMenuContext',
    undefined,
    { type: 'string', description: ( (localize(
        'debugProtocolVariableMenuContext',
        "Represents the context the debug adapter sets on the focused variable in the VARIABLES view."
    ))) }
)));
const CONTEXT_SET_VARIABLE_SUPPORTED = ( (new RawContextKey$1(
    'debugSetVariableSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'debugSetVariableSupported',
        "True when the focused session supports 'setVariable' request."
    ))) }
)));
const CONTEXT_SET_EXPRESSION_SUPPORTED = ( (new RawContextKey$1(
    'debugSetExpressionSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'debugSetExpressionSupported',
        "True when the focused session supports 'setExpression' request."
    ))) }
)));
const CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED = ( (new RawContextKey$1(
    'terminateDebuggeeSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'terminateDebuggeeSupported',
        "True when the focused session supports the terminate debuggee capability."
    ))) }
)));
const CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED = ( (new RawContextKey$1(
    'suspendDebuggeeSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'suspendDebuggeeSupported',
        "True when the focused session supports the suspend debuggee capability."
    ))) }
)));
const CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT = ( (new RawContextKey$1(
    'variableEvaluateNamePresent',
    false,
    { type: 'boolean', description: ( (localize(
        'variableEvaluateNamePresent',
        "True when the focused variable has an 'evalauteName' field set."
    ))) }
)));
const CONTEXT_VARIABLE_IS_READONLY = ( (new RawContextKey$1(
    'variableIsReadonly',
    false,
    { type: 'boolean', description: ( (localize('variableIsReadonly', "True when the focused variable is readonly."))) }
)));
const CONTEXT_EXCEPTION_WIDGET_VISIBLE = ( (new RawContextKey$1(
    'exceptionWidgetVisible',
    false,
    { type: 'boolean', description: ( (localize('exceptionWidgetVisible', "True when the exception widget is visible."))) }
)));
const CONTEXT_MULTI_SESSION_DEBUG = ( (new RawContextKey$1(
    'multiSessionDebug',
    false,
    { type: 'boolean', description: ( (localize(
        'multiSessionDebug',
        "True when there is more than 1 active debug session."
    ))) }
)));
const CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED = ( (new RawContextKey$1(
    'disassembleRequestSupported',
    false,
    { type: 'boolean', description: ( (localize(
        'disassembleRequestSupported',
        "True when the focused sessions supports disassemble request."
    ))) }
)));
const CONTEXT_DISASSEMBLY_VIEW_FOCUS = ( (new RawContextKey$1(
    'disassemblyViewFocus',
    false,
    { type: 'boolean', description: ( (localize('disassemblyViewFocus', "True when the Disassembly View is focused."))) }
)));
const CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE = ( (new RawContextKey$1(
    'focusedStackFrameHasInstructionReference',
    false,
    { type: 'boolean', description: ( (localize(
        'focusedStackFrameHasInstructionReference',
        "True when the focused stack frame has instruction pointer reference."
    ))) }
)));
const debuggerDisabledMessage = (debugType) => ( (localize(
    'debuggerDisabled',
    "Configured debug type '{0}' is installed but not supported in this environment.",
    debugType
)));
const EDITOR_CONTRIBUTION_ID = 'editor.contrib.debug';
const BREAKPOINT_EDITOR_CONTRIBUTION_ID = 'editor.contrib.breakpoint';
const DEBUG_SCHEME = 'debug';
const INTERNAL_CONSOLE_OPTIONS_SCHEMA = {
    enum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart'],
    default: 'openOnFirstSessionStart',
    description: ( (localize(
        'internalConsoleOptions',
        "Controls when the internal Debug Console should open."
    )))
};
function getStateLabel(state) {
    switch (state) {
        case 1 : return 'initializing';
        case 2 : return 'stopped';
        case 3 : return 'running';
        default: return 'inactive';
    }
}
const DEBUG_MEMORY_SCHEME = 'vscode-debug-memory';
var DebugConfigurationProviderTriggerKind;
( ((function(DebugConfigurationProviderTriggerKind) {
    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Initial"] = 1] = "Initial";
    DebugConfigurationProviderTriggerKind[DebugConfigurationProviderTriggerKind["Dynamic"] = 2] = "Dynamic";
})(
    DebugConfigurationProviderTriggerKind || (DebugConfigurationProviderTriggerKind = {})
)));
var DebuggerString;
( ((function(DebuggerString) {
    DebuggerString["UnverifiedBreakpoints"] = "unverifiedBreakpoints";
})(DebuggerString || (DebuggerString = {}))));
const IDebugService = ( (createDecorator('debugService')));
let services;
var Services;
( (function(Services) {
    Services.get = () => {
        return services ?? {};
    };
    function install(_services) {
        if (services != null) {
            console.warn('Services have been overridden');
        }
        services = _services;
        return {
            dispose: () => {
                if (services === _services) {
                    services = undefined;
                }
            }
        };
    }
    Services.install = install;
})(Services || (Services = {})));
export { TooLargeFileOperationError as $, ACTIVE_GROUP as A, StorageTarget as B, ContextKeyExprType as C, DebugConfigurationProviderTriggerKind as D, Emitter as E, FileSystemProviderErrorCode as F, NeverShowAgainScope as G, isPreferredGroup as H, IEditorService as I, IUserDataProfilesService as J, toBufferOrReadable as K, stringToSnapshot as L, FileChangesEvent as M, NotificationsFilter as N, hasOpenReadWriteCloseCapability as O, hasReadWriteCapability as P, hasFileReadStreamCapability as Q, ensureFileSystemProviderError as R, Services as S, TextFileOperationError as T, etag as U, FileOperationEvent as V, toFileOperationResult as W, ETAG_DISABLED as X, hasFileAtomicReadCapability as Y, NotModifiedSinceFileOperationError as Z, __decorate as _, __param as a, NoOpNotification as a$, hasFileFolderCopyCapability as a0, hasFileCloneCapability as a1, createFileSystemProviderError as a2, FileSystemProviderError as a3, BREAKPOINTS_VIEW_ID as a4, CONTEXT_DEBUGGERS_AVAILABLE as a5, CONTEXT_BREAKPOINT_ITEM_TYPE as a6, CONTEXT_BREAKPOINTS_EXIST as a7, CONTEXT_IN_DEBUG_MODE as a8, CONTEXT_BREAKPOINT_SUPPORTS_CONDITION as a9, CONTEXT_STEP_BACK_SUPPORTED as aA, CONTEXT_MULTI_SESSION_DEBUG as aB, CONTEXT_BREAKPOINT_WIDGET_VISIBLE as aC, CONTEXT_IN_BREAKPOINT_WIDGET as aD, CONTEXT_EXCEPTION_WIDGET_VISIBLE as aE, CONTEXT_DEBUG_EXTENSION_AVAILABLE as aF, CONTEXT_DEBUG_CONFIGURATION_TYPE as aG, CONTEXT_LOADED_SCRIPTS_SUPPORTED as aH, CONTEXT_RESTART_FRAME_SUPPORTED as aI, CONTEXT_SET_VARIABLE_SUPPORTED as aJ, CONTEXT_SET_EXPRESSION_SUPPORTED as aK, CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED as aL, CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE as aM, CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT as aN, CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT as aO, CONTEXT_CAN_VIEW_MEMORY as aP, CONTEXT_VARIABLE_IS_READONLY as aQ, DebuggerString as aR, FILES_ASSOCIATIONS_CONFIG as aS, productSchemaId as aT, AutoSaveConfiguration as aU, IRemoteAgentService as aV, AbstractPathService as aW, HotExitConfiguration as aX, markAsFileSystemProviderError as aY, RawContextKey as aZ, ContextKeyExpr as a_, BREAKPOINT_EDITOR_CONTRIBUTION_ID as aa, CONTEXT_DISASSEMBLY_VIEW_FOCUS as ab, CONTEXT_JUMP_TO_CURSOR_SUPPORTED as ac, CONTEXT_DEBUG_STATE as ad, CONTEXT_STEP_INTO_TARGETS_SUPPORTED as ae, CONTEXT_FOCUSED_SESSION_IS_ATTACH as af, REPL_VIEW_ID as ag, CONTEXT_BREAKPOINTS_FOCUSED as ah, CONTEXT_WATCH_EXPRESSIONS_FOCUSED as ai, CONTEXT_VARIABLES_FOCUSED as aj, CONTEXT_EXPRESSION_SELECTED as ak, CONTEXT_BREAKPOINT_INPUT_FOCUSED as al, VIEWLET_ID as am, CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED as an, CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED as ao, VARIABLES_VIEW_ID as ap, EDITOR_CONTRIBUTION_ID as aq, INTERNAL_CONSOLE_OPTIONS_SCHEMA as ar, DEBUG_MEMORY_SCHEME as as, DEBUG_SCHEME as at, CALLSTACK_VIEW_ID as au, CONTEXT_DEBUG_TYPE as av, CONTEXT_HAS_DEBUGGED as aw, CONTEXT_DEBUG_UX as ax, getStateLabel as ay, debuggerDisabledMessage as az, __classPrivateFieldSet as b, __classPrivateFieldGet as c, IEditorGroupsService as d, IProductService as e, FileType as f, getMarks as g, FilePermission as h, SIDE_GROUP as i, IUriIdentityService as j, IPaneCompositePartService as k, ITextFileService as l, mark as m, IFileService as n, IWorkbenchEnvironmentService as o, preferredSideBySideGroupDirection as p, IWorkingCopyFileService as q, IPathService as r, ILanguageStatusService as s, IHostService as t, IDebugService as u, FileOperationError as v, refineServiceDecorator as w, toFileSystemProviderErrorCode as x, ISnippetsService as y, StorageScope as z };
