import * as monaco from 'monaco-editor';
import * as vscode from 'vscode';

/**
 * An object that performs a cleanup operation when `.dispose()` is called.
 *
 * Some examples of how disposables are used:
 *
 * - An event listener that removes itself when `.dispose()` is called.
 * - A resource such as a file system watcher that cleans up the resource when `.dispose()` is called.
 * - The return value from registering a provider. When `.dispose()` is called, the provider is unregistered.
 */
interface IDisposable {
    dispose(): void;
}
/**
 * Manages a collection of disposable values.
 *
 * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an
 * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a
 * store that has already been disposed of.
 */
declare class DisposableStore implements IDisposable {
    static DISABLE_DISPOSED_WARNING: boolean;
    private readonly _toDispose;
    private _isDisposed;
    constructor();
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose(): void;
    /**
     * @return `true` if this object has been disposed of.
     */
    get isDisposed(): boolean;
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear(): void;
    /**
     * Add a new {@link IDisposable disposable} to the collection.
     */
    add<T extends IDisposable>(o: T): T;
}
/**
 * Abstract base class for a {@link IDisposable disposable} object.
 *
 * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.
 */
declare abstract class Disposable implements IDisposable {
    /**
     * A disposable that does nothing when it is disposed of.
     *
     * TODO: This should not be a static property.
     */
    static readonly None: Readonly<IDisposable>;
    protected readonly _store: DisposableStore;
    constructor();
    dispose(): void;
    /**
     * Adds `o` to the collection of disposables managed by this object.
     */
    protected _register<T extends IDisposable>(o: T): T;
}

/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 * ```txt
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 * ```
 */
declare class URI implements UriComponents {
    static isUri(thing: any): thing is URI;
    /**
     * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.
     * The part before the first colon.
     */
    readonly scheme: string;
    /**
     * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.
     * The part between the first double slashes and the next slash.
     */
    readonly authority: string;
    /**
     * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly path: string;
    /**
     * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly query: string;
    /**
     * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.
     */
    readonly fragment: string;
    /**
     * @internal
     */
    protected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);
    /**
     * @internal
     */
    protected constructor(components: UriComponents);
    /**
     * Returns a string representing the corresponding file system path of this URI.
     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
     * platform specific path separator.
     *
     * * Will *not* validate the path for invalid characters and semantics.
     * * Will *not* look at the scheme of this URI.
     * * The result shall *not* be used for display purposes but for accessing a file on disk.
     *
     *
     * The *difference* to `URI#path` is the use of the platform specific separator and the handling
     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
     *
     * ```ts
        const u = URI.parse('file://server/c$/folder/file.txt')
        u.authority === 'server'
        u.path === '/shares/c$/file.txt'
        u.fsPath === '\\server\c$\folder\file.txt'
    ```
     *
     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
     * with URIs that represent files on disk (`file` scheme).
     */
    get fsPath(): string;
    with(change: {
        scheme?: string;
        authority?: string | null;
        path?: string | null;
        query?: string | null;
        fragment?: string | null;
    }): URI;
    /**
     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    static parse(value: string, _strict?: boolean): URI;
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    static file(path: string): URI;
    static from(components: {
        scheme: string;
        authority?: string;
        path?: string;
        query?: string;
        fragment?: string;
    }): URI;
    /**
     * Join a URI path with path fragments and normalizes the resulting path.
     *
     * @param uri The input URI.
     * @param pathFragment The path fragment to add to the URI path.
     * @returns The resulting URI.
     */
    static joinPath(uri: URI, ...pathFragment: string[]): URI;
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    toString(skipEncoding?: boolean): string;
    toJSON(): UriComponents;
    static revive(data: UriComponents | URI): URI;
    static revive(data: UriComponents | URI | undefined): URI | undefined;
    static revive(data: UriComponents | URI | null): URI | null;
    static revive(data: UriComponents | URI | undefined | null): URI | undefined | null;
}
interface UriComponents {
    scheme: string;
    authority: string;
    path: string;
    query: string;
    fragment: string;
}

interface CancellationToken {
    /**
     * A flag signalling is cancellation has been requested.
     */
    readonly isCancellationRequested: boolean;
    /**
     * An event which fires when cancellation is requested. This event
     * only ever fires `once` as cancellation can only happen once. Listeners
     * that are registered after cancellation will be called (next event loop run),
     * but also only once.
     *
     * @event
     */
    readonly onCancellationRequested: (listener: (e: any) => any, thisArgs?: any, disposables?: IDisposable[]) => IDisposable;
}
declare namespace CancellationToken {
    function isCancellationToken(thing: unknown): thing is CancellationToken;
    const None: Readonly<CancellationToken>;
    const Cancelled: Readonly<CancellationToken>;
}

interface IObservable<T, TChange = void> {
    readonly TChange: TChange;
    /**
     * Reads the current value.
     *
     * Must not be called from {@link IObserver.handleChange}.
     */
    get(): T;
    /**
     * Adds an observer.
     */
    addObserver(observer: IObserver): void;
    removeObserver(observer: IObserver): void;
    /**
     * Subscribes the reader to this observable and returns the current value of this observable.
     */
    read(reader: IReader): T;
    map<TNew>(fn: (value: T) => TNew): IObservable<TNew>;
    readonly debugName: string;
}
interface IReader {
    /**
     * Reports an observable that was read.
     *
     * Is called by {@link IObservable.read}.
     */
    subscribeTo<T>(observable: IObservable<T, any>): void;
}
interface IObserver {
    /**
     * Indicates that an update operation is about to begin.
     *
     * During an update, invariants might not hold for subscribed observables and
     * change events might be delayed.
     * However, all changes must be reported before all update operations are over.
     */
    beginUpdate<T>(observable: IObservable<T>): void;
    /**
     * Is called by a subscribed observable immediately after it notices a change.
     *
     * When {@link IObservable.get} returns and no change has been reported,
     * there has been no change for that observable.
     *
     * Implementations must not call into other observables!
     * The change should be processed when {@link IObserver.endUpdate} is called.
     */
    handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;
    /**
     * Indicates that an update operation has completed.
     */
    endUpdate<T>(observable: IObservable<T>): void;
}

/**
 * Can be passed into the Delayed to defer using a microtask
 * */
declare const MicrotaskDelay: unique symbol;

/**
 * An event with zero or one parameters that can be subscribed to. The event is a function itself.
 */
type Event<T> = vscode.Event<T>
declare namespace Event {
    const None: Event<any>;
    /**
     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared
     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a
     * result of merging events and to try prevent race conditions that could arise when using related deferred and
     * non-deferred events.
     *
     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work
     * (eg. latency of keypress to text rendered).
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function defer(event: Event<unknown>, disposable?: DisposableStore): Event<void>;
    /**
     * Given an event, returns another event which only fires once.
     *
     * @param event The event source for the new event.
     */
    function once<T>(event: Event<T>): Event<T>;
    /**
     * Maps an event of one type into an event of another type using a mapping function, similar to how
     * `Array.prototype.map` works.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The event source for the new event.
     * @param map The mapping function.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function map<I, O>(event: Event<I>, map: (i: I) => O, disposable?: DisposableStore): Event<O>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function forEach<I>(event: Event<I>, each: (i: I) => void, disposable?: DisposableStore): Event<I>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function filter<T, U>(event: Event<T | U>, filter: (e: T | U) => e is T, disposable?: DisposableStore): Event<T>;
    function filter<T>(event: Event<T>, filter: (e: T) => boolean, disposable?: DisposableStore): Event<T>;
    function filter<T, R>(event: Event<T | R>, filter: (e: T | R) => e is R, disposable?: DisposableStore): Event<R>;
    /**
     * Given an event, returns the same event but typed as `Event<void>`.
     */
    function signal<T>(event: Event<T>): Event<void>;
    /**
     * Given a collection of events, returns a single event which emits
     * whenever any of the provided events emit.
     */
    function any<T>(...events: Event<T>[]): Event<T>;
    function any(...events: Event<any>[]): Event<void>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function reduce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, initial?: O, disposable?: DisposableStore): Event<O>;
    /**
     * Given an event, creates a new emitter that event that will debounce events based on {@link delay} and give an
     * array event object of all events that fired.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @param event The original event to debounce.
     * @param merge A function that reduces all events into a single event.
     * @param delay The number of milliseconds to debounce.
     * @param leading Whether to fire a leading event without debouncing.
     * @param flushOnListenerRemove Whether to fire all debounced events when a listener is removed. If this is not
     * specified, some events could go missing. Use this if it's important that all events are processed, even if the
     * listener gets disposed before the debounced event fires.
     * @param leakWarningThreshold See {@link EmitterOptions.leakWarningThreshold}.
     * @param disposable A disposable store to register the debounce emitter to.
     */
    function debounce<T>(event: Event<T>, merge: (last: T | undefined, event: T) => T, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<T>;
    function debounce<I, O>(event: Event<I>, merge: (last: O | undefined, event: I) => O, delay?: number | typeof MicrotaskDelay, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number, disposable?: DisposableStore): Event<O>;
    /**
     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function accumulate<T>(event: Event<T>, delay?: number, disposable?: DisposableStore): Event<T[]>;
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function latch<T>(event: Event<T>, equals?: (a: T, b: T) => boolean, disposable?: DisposableStore): Event<T>;
    /**
     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.
     *
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     *
     * @example
     * ```
     * const event = new EventEmitter<number | undefined>().event;
     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);
     * ```
     *
     * @param event The event source for the new event.
     * @param isT A function that determines what event is of the first type.
     * @param disposable A disposable store to add the new EventEmitter to.
     */
    function split<T, U>(event: Event<T | U>, isT: (e: T | U) => e is T, disposable?: DisposableStore): [Event<T>, Event<U>];
    /**
     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
     * event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
     * returned event causes this utility to leak a listener on the original event.
     */
    function buffer<T>(event: Event<T>, flushAfterTimeout?: boolean, _buffer?: T[]): Event<T>;
    interface IChainableEvent<T> extends IDisposable {
        event: Event<T>;
        map<O>(fn: (i: T) => O): IChainableEvent<O>;
        forEach(fn: (i: T) => void): IChainableEvent<T>;
        filter(fn: (e: T) => boolean): IChainableEvent<T>;
        filter<R>(fn: (e: T | R) => e is R): IChainableEvent<R>;
        reduce<R>(merge: (last: R | undefined, event: T) => R, initial?: R): IChainableEvent<R>;
        latch(): IChainableEvent<T>;
        debounce(merge: (last: T | undefined, event: T) => T, delay?: number, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number): IChainableEvent<T>;
        debounce<R>(merge: (last: R | undefined, event: T) => R, delay?: number, leading?: boolean, flushOnListenerRemove?: boolean, leakWarningThreshold?: number): IChainableEvent<R>;
        on(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[] | DisposableStore): IDisposable;
        once(listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
    }
    function chain<T>(event: Event<T>): IChainableEvent<T>;
    interface NodeEventEmitter {
        on(event: string | symbol, listener: Function): unknown;
        removeListener(event: string | symbol, listener: Function): unknown;
    }
    function fromNodeEventEmitter<T>(emitter: NodeEventEmitter, eventName: string, map?: (...args: any[]) => T): Event<T>;
    interface DOMEventEmitter {
        addEventListener(event: string | symbol, listener: Function): void;
        removeEventListener(event: string | symbol, listener: Function): void;
    }
    function fromDOMEventEmitter<T>(emitter: DOMEventEmitter, eventName: string, map?: (...args: any[]) => T): Event<T>;
    function toPromise<T>(event: Event<T>): Promise<T>;
    function runAndSubscribe<T>(event: Event<T>, handler: (e: T | undefined) => any): IDisposable;
    function runAndSubscribeWithStore<T>(event: Event<T>, handler: (e: T | undefined, disposableStore: DisposableStore) => any): IDisposable;
    function fromObservable<T>(obs: IObservable<T, any>, store?: DisposableStore): Event<T>;
}

interface ServicesAccessor {
    get<T>(id: ServiceIdentifier<T>): T;
}
/**
 * Identifies a service of type `T`.
 */
interface ServiceIdentifier<T> {
    (...args: any[]): void;
    type: T;
}

declare const enum ContextKeyExprType {
    False = 0,
    True = 1,
    Defined = 2,
    Not = 3,
    Equals = 4,
    NotEquals = 5,
    And = 6,
    Regex = 7,
    NotRegex = 8,
    Or = 9,
    In = 10,
    NotIn = 11,
    Greater = 12,
    GreaterEquals = 13,
    Smaller = 14,
    SmallerEquals = 15
}
interface IContextKeyExprMapper {
    mapDefined(key: string): ContextKeyExpression;
    mapNot(key: string): ContextKeyExpression;
    mapEquals(key: string, value: any): ContextKeyExpression;
    mapNotEquals(key: string, value: any): ContextKeyExpression;
    mapGreater(key: string, value: any): ContextKeyExpression;
    mapGreaterEquals(key: string, value: any): ContextKeyExpression;
    mapSmaller(key: string, value: any): ContextKeyExpression;
    mapSmallerEquals(key: string, value: any): ContextKeyExpression;
    mapRegex(key: string, regexp: RegExp | null): ContextKeyRegexExpr;
    mapIn(key: string, valueKey: string): ContextKeyInExpr;
    mapNotIn(key: string, valueKey: string): ContextKeyNotInExpr;
}
interface IContextKeyExpression {
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
type ContextKeyExpression = (ContextKeyFalseExpr | ContextKeyTrueExpr | ContextKeyDefinedExpr | ContextKeyNotExpr | ContextKeyEqualsExpr | ContextKeyNotEqualsExpr | ContextKeyRegexExpr | ContextKeyNotRegexExpr | ContextKeyAndExpr | ContextKeyOrExpr | ContextKeyInExpr | ContextKeyNotInExpr | ContextKeyGreaterExpr | ContextKeyGreaterEqualsExpr | ContextKeySmallerExpr | ContextKeySmallerEqualsExpr);
declare class ContextKeyFalseExpr implements IContextKeyExpression {
    static INSTANCE: ContextKeyFalseExpr;
    readonly type = ContextKeyExprType.False;
    protected constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyTrueExpr implements IContextKeyExpression {
    static INSTANCE: ContextKeyTrueExpr;
    readonly type = ContextKeyExprType.True;
    protected constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyDefinedExpr implements IContextKeyExpression {
    readonly key: string;
    private negated;
    static create(key: string, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Defined;
    protected constructor(key: string, negated: ContextKeyExpression | null);
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyEqualsExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Equals;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyInExpr implements IContextKeyExpression {
    private readonly key;
    private readonly valueKey;
    static create(key: string, valueKey: string): ContextKeyInExpr;
    readonly type = ContextKeyExprType.In;
    private negated;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyInExpr;
    negate(): ContextKeyExpression;
}
declare class ContextKeyNotInExpr implements IContextKeyExpression {
    private readonly key;
    private readonly valueKey;
    static create(key: string, valueKey: string): ContextKeyNotInExpr;
    readonly type = ContextKeyExprType.NotIn;
    private readonly _negated;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyNotEqualsExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.NotEquals;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyNotExpr implements IContextKeyExpression {
    private readonly key;
    private negated;
    static create(key: string, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Not;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyGreaterExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, _value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Greater;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyGreaterEqualsExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, _value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.GreaterEquals;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeySmallerExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, _value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.Smaller;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeySmallerEqualsExpr implements IContextKeyExpression {
    private readonly key;
    private readonly value;
    private negated;
    static create(key: string, _value: any, negated?: ContextKeyExpression | null): ContextKeyExpression;
    readonly type = ContextKeyExprType.SmallerEquals;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyRegexExpr implements IContextKeyExpression {
    private readonly key;
    private readonly regexp;
    static create(key: string, regexp: RegExp | null): ContextKeyRegexExpr;
    readonly type = ContextKeyExprType.Regex;
    private negated;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyRegexExpr;
    negate(): ContextKeyExpression;
}
declare class ContextKeyNotRegexExpr implements IContextKeyExpression {
    private readonly _actual;
    static create(actual: ContextKeyRegexExpr): ContextKeyExpression;
    readonly type = ContextKeyExprType.NotRegex;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyAndExpr implements IContextKeyExpression {
    readonly expr: ContextKeyExpression[];
    private negated;
    static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined;
    readonly type = ContextKeyExprType.And;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    private static _normalizeArr;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
declare class ContextKeyOrExpr implements IContextKeyExpression {
    readonly expr: ContextKeyExpression[];
    private negated;
    static create(_expr: ReadonlyArray<ContextKeyExpression | null | undefined>, negated: ContextKeyExpression | null, extraRedundantCheck: boolean): ContextKeyExpression | undefined;
    readonly type = ContextKeyExprType.Or;
    private constructor();
    cmp(other: ContextKeyExpression): number;
    equals(other: ContextKeyExpression): boolean;
    substituteConstants(): ContextKeyExpression | undefined;
    evaluate(context: IContext): boolean;
    private static _normalizeArr;
    serialize(): string;
    keys(): string[];
    map(mapFnc: IContextKeyExprMapper): ContextKeyExpression;
    negate(): ContextKeyExpression;
}
type ContextKeyValue = null | undefined | boolean | number | string | Array<null | undefined | boolean | number | string> | Record<string, null | undefined | boolean | number | string>;
interface IContext {
    getValue<T extends ContextKeyValue = ContextKeyValue>(key: string): T | undefined;
}
interface IContextKey<T extends ContextKeyValue = ContextKeyValue> {
    set(value: T): void;
    reset(): void;
    get(): T | undefined;
}
interface IContextKeyServiceTarget {
    parentElement: IContextKeyServiceTarget | null;
    setAttribute(attr: string, value: string): void;
    removeAttribute(attr: string): void;
    hasAttribute(attr: string): boolean;
    getAttribute(attr: string): string | null;
}
interface IReadableSet<T> {
    has(value: T): boolean;
}
interface IContextKeyChangeEvent {
    affectsSome(keys: IReadableSet<string>): boolean;
    allKeysContainedIn(keys: IReadableSet<string>): boolean;
}
declare const IContextKeyService: ServiceIdentifier<IContextKeyService>;
interface IContextKeyService {
    readonly _serviceBrand: undefined;
    dispose(): void;
    onDidChangeContext: Event<IContextKeyChangeEvent>;
    bufferChangeEvents(callback: Function): void;
    createKey<T extends ContextKeyValue>(key: string, defaultValue: T | undefined): IContextKey<T>;
    contextMatchesRules(rules: ContextKeyExpression | undefined): boolean;
    getContextKeyValue<T>(key: string): T | undefined;
    createScoped(target: IContextKeyServiceTarget): IContextKeyService;
    createOverlay(overlay: Iterable<[string, any]>): IContextKeyService;
    getContext(target: IContextKeyServiceTarget | null): IContext;
    updateParent(parentContextKeyService: IContextKeyService): void;
}

type JSONSchemaType = 'string' | 'number' | 'integer' | 'boolean' | 'null' | 'array' | 'object';
interface IJSONSchema {
    id?: string;
    $id?: string;
    $schema?: string;
    type?: JSONSchemaType | JSONSchemaType[];
    title?: string;
    default?: any;
    definitions?: IJSONSchemaMap;
    description?: string;
    properties?: IJSONSchemaMap;
    patternProperties?: IJSONSchemaMap;
    additionalProperties?: boolean | IJSONSchema;
    minProperties?: number;
    maxProperties?: number;
    dependencies?: IJSONSchemaMap | {
        [prop: string]: string[];
    };
    items?: IJSONSchema | IJSONSchema[];
    minItems?: number;
    maxItems?: number;
    uniqueItems?: boolean;
    additionalItems?: boolean | IJSONSchema;
    pattern?: string;
    minLength?: number;
    maxLength?: number;
    minimum?: number;
    maximum?: number;
    exclusiveMinimum?: boolean | number;
    exclusiveMaximum?: boolean | number;
    multipleOf?: number;
    required?: string[];
    $ref?: string;
    anyOf?: IJSONSchema[];
    allOf?: IJSONSchema[];
    oneOf?: IJSONSchema[];
    not?: IJSONSchema;
    enum?: any[];
    format?: string;
    const?: any;
    contains?: IJSONSchema;
    propertyNames?: IJSONSchema;
    examples?: any[];
    $comment?: string;
    if?: IJSONSchema;
    then?: IJSONSchema;
    else?: IJSONSchema;
    unevaluatedProperties?: boolean | IJSONSchema;
    unevaluatedItems?: boolean | IJSONSchema;
    minContains?: number;
    maxContains?: number;
    deprecated?: boolean;
    dependentRequired?: {
        [prop: string]: string[];
    };
    dependentSchemas?: IJSONSchemaMap;
    $defs?: {
        [name: string]: IJSONSchema;
    };
    $anchor?: string;
    $recursiveRef?: string;
    $recursiveAnchor?: string;
    $vocabulary?: any;
    prefixItems?: IJSONSchema[];
    $dynamicRef?: string;
    $dynamicAnchor?: string;
    defaultSnippets?: IJSONSchemaSnippet[];
    errorMessage?: string;
    patternErrorMessage?: string;
    deprecationMessage?: string;
    markdownDeprecationMessage?: string;
    enumDescriptions?: string[];
    markdownEnumDescriptions?: string[];
    markdownDescription?: string;
    doNotSuggest?: boolean;
    suggestSortText?: string;
    allowComments?: boolean;
    allowTrailingCommas?: boolean;
}
interface IJSONSchemaMap {
    [name: string]: IJSONSchema;
}
interface IJSONSchemaSnippet {
    label?: string;
    description?: string;
    body?: any;
    bodyText?: string;
}

/**
 * A position in the editor. This interface is suitable for serialization.
 */
interface IPosition {
    /**
     * line number (starts at 1)
     */
    readonly lineNumber: number;
    /**
     * column (the first character in a line is between column 1 and column 2)
     */
    readonly column: number;
}
/**
 * A position in the editor.
 */
declare class Position {
    /**
     * line number (starts at 1)
     */
    readonly lineNumber: number;
    /**
     * column (the first character in a line is between column 1 and column 2)
     */
    readonly column: number;
    constructor(lineNumber: number, column: number);
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    with(newLineNumber?: number, newColumn?: number): Position;
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    delta(deltaLineNumber?: number, deltaColumn?: number): Position;
    /**
     * Test if this position equals other position
     */
    equals(other: IPosition): boolean;
    /**
     * Test if position `a` equals position `b`
     */
    static equals(a: IPosition | null, b: IPosition | null): boolean;
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    isBefore(other: IPosition): boolean;
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    static isBefore(a: IPosition, b: IPosition): boolean;
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    isBeforeOrEqual(other: IPosition): boolean;
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    static isBeforeOrEqual(a: IPosition, b: IPosition): boolean;
    /**
     * A function that compares positions, useful for sorting
     */
    static compare(a: IPosition, b: IPosition): number;
    /**
     * Clone this position.
     */
    clone(): Position;
    /**
     * Convert to a human-readable representation.
     */
    toString(): string;
    /**
     * Create a `Position` from an `IPosition`.
     */
    static lift(pos: IPosition): Position;
    /**
     * Test if `obj` is an `IPosition`.
     */
    static isIPosition(obj: any): obj is IPosition;
}

/**
 * A range in the editor. This interface is suitable for serialization.
 */
interface IRange {
    /**
     * Line number on which the range starts (starts at 1).
     */
    readonly startLineNumber: number;
    /**
     * Column on which the range starts in line `startLineNumber` (starts at 1).
     */
    readonly startColumn: number;
    /**
     * Line number on which the range ends.
     */
    readonly endLineNumber: number;
    /**
     * Column on which the range ends in line `endLineNumber`.
     */
    readonly endColumn: number;
}
/**
 * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
 */
declare class Range {
    /**
     * Line number on which the range starts (starts at 1).
     */
    readonly startLineNumber: number;
    /**
     * Column on which the range starts in line `startLineNumber` (starts at 1).
     */
    readonly startColumn: number;
    /**
     * Line number on which the range ends.
     */
    readonly endLineNumber: number;
    /**
     * Column on which the range ends in line `endLineNumber`.
     */
    readonly endColumn: number;
    constructor(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number);
    /**
     * Test if this range is empty.
     */
    isEmpty(): boolean;
    /**
     * Test if `range` is empty.
     */
    static isEmpty(range: IRange): boolean;
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    containsPosition(position: IPosition): boolean;
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    static containsPosition(range: IRange, position: IPosition): boolean;
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return false.
     * @internal
     */
    static strictContainsPosition(range: IRange, position: IPosition): boolean;
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    containsRange(range: IRange): boolean;
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    static containsRange(range: IRange, otherRange: IRange): boolean;
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    strictContainsRange(range: IRange): boolean;
    /**
     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    static strictContainsRange(range: IRange, otherRange: IRange): boolean;
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    plusRange(range: IRange): Range;
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    static plusRange(a: IRange, b: IRange): Range;
    /**
     * A intersection of the two ranges.
     */
    intersectRanges(range: IRange): Range | null;
    /**
     * A intersection of the two ranges.
     */
    static intersectRanges(a: IRange, b: IRange): Range | null;
    /**
     * Test if this range equals other.
     */
    equalsRange(other: IRange | null | undefined): boolean;
    /**
     * Test if range `a` equals `b`.
     */
    static equalsRange(a: IRange | null | undefined, b: IRange | null | undefined): boolean;
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    getEndPosition(): Position;
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    static getEndPosition(range: IRange): Position;
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    getStartPosition(): Position;
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    static getStartPosition(range: IRange): Position;
    /**
     * Transform to a user presentable string representation.
     */
    toString(): string;
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    setEndPosition(endLineNumber: number, endColumn: number): Range;
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    setStartPosition(startLineNumber: number, startColumn: number): Range;
    /**
     * Create a new empty range using this range's start position.
     */
    collapseToStart(): Range;
    /**
     * Create a new empty range using this range's start position.
     */
    static collapseToStart(range: IRange): Range;
    /**
     * Create a new empty range using this range's end position.
     */
    collapseToEnd(): Range;
    /**
     * Create a new empty range using this range's end position.
     */
    static collapseToEnd(range: IRange): Range;
    /**
     * Moves the range by the given amount of lines.
     */
    delta(lineCount: number): Range;
    static fromPositions(start: IPosition, end?: IPosition): Range;
    /**
     * Create a `Range` from an `IRange`.
     */
    static lift(range: undefined | null): null;
    static lift(range: IRange): Range;
    static lift(range: IRange | undefined | null): Range | null;
    /**
     * Test if `obj` is an `IRange`.
     */
    static isIRange(obj: any): obj is IRange;
    /**
     * Test if the two ranges are touching in any way.
     */
    static areIntersectingOrTouching(a: IRange, b: IRange): boolean;
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    static areIntersecting(a: IRange, b: IRange): boolean;
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    static compareRangesUsingStarts(a: IRange | null | undefined, b: IRange | null | undefined): number;
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    static compareRangesUsingEnds(a: IRange, b: IRange): number;
    /**
     * Test if the range spans multiple lines.
     */
    static spansMultipleLines(range: IRange): boolean;
    toJSON(): IRange;
}

interface MarkdownStringTrustedOptions {
    readonly enabledCommands: readonly string[];
}
interface IMarkdownString {
    readonly value: string;
    readonly isTrusted?: boolean | MarkdownStringTrustedOptions;
    readonly supportThemeIcons?: boolean;
    readonly supportHtml?: boolean;
    readonly baseUri?: UriComponents;
    uris?: {
        [href: string]: UriComponents;
    };
}

/**
 * A single edit operation, that acts as a simple replace.
 * i.e. Replace text at `range` with `text` in model.
 */
interface ISingleEditOperation {
    /**
     * The range to replace. This can be empty to emulate a simple insert.
     */
    range: IRange;
    /**
     * The text to replace with. This can be null to emulate a simple delete.
     */
    text: string | null;
    /**
     * This indicates that this operation has "insert" semantics.
     * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
     */
    forceMoveMarkers?: boolean;
}

/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
interface ISelection {
    /**
     * The line number on which the selection has started.
     */
    readonly selectionStartLineNumber: number;
    /**
     * The column on `selectionStartLineNumber` where the selection has started.
     */
    readonly selectionStartColumn: number;
    /**
     * The line number on which the selection has ended.
     */
    readonly positionLineNumber: number;
    /**
     * The column on `positionLineNumber` where the selection has ended.
     */
    readonly positionColumn: number;
}
/**
 * The direction of a selection.
 */
declare const enum SelectionDirection {
    /**
     * The selection starts above where it ends.
     */
    LTR = 0,
    /**
     * The selection starts below where it ends.
     */
    RTL = 1
}
/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
declare class Selection extends Range {
    /**
     * The line number on which the selection has started.
     */
    readonly selectionStartLineNumber: number;
    /**
     * The column on `selectionStartLineNumber` where the selection has started.
     */
    readonly selectionStartColumn: number;
    /**
     * The line number on which the selection has ended.
     */
    readonly positionLineNumber: number;
    /**
     * The column on `positionLineNumber` where the selection has ended.
     */
    readonly positionColumn: number;
    constructor(selectionStartLineNumber: number, selectionStartColumn: number, positionLineNumber: number, positionColumn: number);
    /**
     * Transform to a human-readable representation.
     */
    toString(): string;
    /**
     * Test if equals other selection.
     */
    equalsSelection(other: ISelection): boolean;
    /**
     * Test if the two selections are equal.
     */
    static selectionsEqual(a: ISelection, b: ISelection): boolean;
    /**
     * Get directions (LTR or RTL).
     */
    getDirection(): SelectionDirection;
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    setEndPosition(endLineNumber: number, endColumn: number): Selection;
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    getPosition(): Position;
    /**
     * Get the position at the start of the selection.
    */
    getSelectionStart(): Position;
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    setStartPosition(startLineNumber: number, startColumn: number): Selection;
    /**
     * Create a `Selection` from one or two positions
     */
    static fromPositions(start: IPosition, end?: IPosition): Selection;
    /**
     * Creates a `Selection` from a range, given a direction.
     */
    static fromRange(range: Range, direction: SelectionDirection): Selection;
    /**
     * Create a `Selection` from an `ISelection`.
     */
    static liftSelection(sel: ISelection): Selection;
    /**
     * `a` equals `b`.
     */
    static selectionsArrEqual(a: ISelection[], b: ISelection[]): boolean;
    /**
     * Test if `obj` is an `ISelection`.
     */
    static isISelection(obj: any): obj is ISelection;
    /**
     * Create with a direction.
     */
    static createWithDirection(startLineNumber: number, startColumn: number, endLineNumber: number, endColumn: number, direction: SelectionDirection): Selection;
}

interface ThemeColor {
    id: string;
}
declare namespace ThemeColor {
    function isThemeColor(obj: any): obj is ThemeColor;
}
interface ThemeIcon {
    readonly id: string;
    readonly color?: ThemeColor;
}
declare namespace ThemeIcon {
    const iconNameSegment = "[A-Za-z0-9]+";
    const iconNameExpression = "[A-Za-z0-9-]+";
    const iconModifierExpression = "~[A-Za-z]+";
    const iconNameCharacter = "[A-Za-z0-9~-]";
    function asClassNameArray(icon: ThemeIcon): string[];
    function asClassName(icon: ThemeIcon): string;
    function asCSSSelector(icon: ThemeIcon): string;
    function isThemeIcon(obj: any): obj is ThemeIcon;
    function fromString(str: string): ThemeIcon | undefined;
    function fromId(id: string): ThemeIcon;
    function modify(icon: ThemeIcon, modifier: 'disabled' | 'spin' | undefined): ThemeIcon;
    function getModifier(icon: ThemeIcon): string | undefined;
    function isEqual(ti1: ThemeIcon, ti2: ThemeIcon): boolean;
}

declare class RGBA {
    _rgbaBrand: void;
    /**
     * Red: integer in [0-255]
     */
    readonly r: number;
    /**
     * Green: integer in [0-255]
     */
    readonly g: number;
    /**
     * Blue: integer in [0-255]
     */
    readonly b: number;
    /**
     * Alpha: float in [0-1]
     */
    readonly a: number;
    constructor(r: number, g: number, b: number, a?: number);
    static equals(a: RGBA, b: RGBA): boolean;
}
declare class HSLA {
    _hslaBrand: void;
    /**
     * Hue: integer in [0, 360]
     */
    readonly h: number;
    /**
     * Saturation: float in [0, 1]
     */
    readonly s: number;
    /**
     * Luminosity: float in [0, 1]
     */
    readonly l: number;
    /**
     * Alpha: float in [0, 1]
     */
    readonly a: number;
    constructor(h: number, s: number, l: number, a: number);
    static equals(a: HSLA, b: HSLA): boolean;
    /**
     * Converts an RGB color value to HSL. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes r, g, and b are contained in the set [0, 255] and
     * returns h in the set [0, 360], s, and l in the set [0, 1].
     */
    static fromRGBA(rgba: RGBA): HSLA;
    private static _hue2rgb;
    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     */
    static toRGBA(hsla: HSLA): RGBA;
}
declare class HSVA {
    _hsvaBrand: void;
    /**
     * Hue: integer in [0, 360]
     */
    readonly h: number;
    /**
     * Saturation: float in [0, 1]
     */
    readonly s: number;
    /**
     * Value: float in [0, 1]
     */
    readonly v: number;
    /**
     * Alpha: float in [0, 1]
     */
    readonly a: number;
    constructor(h: number, s: number, v: number, a: number);
    static equals(a: HSVA, b: HSVA): boolean;
    static fromRGBA(rgba: RGBA): HSVA;
    static toRGBA(hsva: HSVA): RGBA;
}
declare class Color {
    static fromHex(hex: string): Color;
    static equals(a: Color | null, b: Color | null): boolean;
    readonly rgba: RGBA;
    private _hsla?;
    get hsla(): HSLA;
    private _hsva?;
    get hsva(): HSVA;
    constructor(arg: RGBA | HSLA | HSVA);
    equals(other: Color | null): boolean;
    /**
     * http://www.w3.org/TR/WCAG20/#relativeluminancedef
     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
     */
    getRelativeLuminance(): number;
    private static _relativeLuminanceForComponent;
    /**
     * http://www.w3.org/TR/WCAG20/#contrast-ratiodef
     * Returns the contrast ration number in the set [1, 21].
     */
    getContrastRatio(another: Color): number;
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if darker color otherwise 'false'
     */
    isDarker(): boolean;
    /**
     *	http://24ways.org/2010/calculating-color-contrast
     *  Return 'true' if lighter color otherwise 'false'
     */
    isLighter(): boolean;
    isLighterThan(another: Color): boolean;
    isDarkerThan(another: Color): boolean;
    lighten(factor: number): Color;
    darken(factor: number): Color;
    transparent(factor: number): Color;
    isTransparent(): boolean;
    isOpaque(): boolean;
    opposite(): Color;
    blend(c: Color): Color;
    makeOpaque(opaqueBackground: Color): Color;
    flatten(...backgrounds: Color[]): Color;
    private static _flatten;
    private _toString?;
    toString(): string;
    static getLighterColor(of: Color, relative: Color, factor?: number): Color;
    static getDarkerColor(of: Color, relative: Color, factor?: number): Color;
    static readonly white: Color;
    static readonly black: Color;
    static readonly red: Color;
    static readonly blue: Color;
    static readonly green: Color;
    static readonly cyan: Color;
    static readonly lightgrey: Color;
    static readonly transparent: Color;
}
declare namespace Color {
    namespace Format {
        namespace CSS {
            function formatRGB(color: Color): string;
            function formatRGBA(color: Color): string;
            function formatHSL(color: Color): string;
            function formatHSLA(color: Color): string;
            /**
             * Formats the color as #RRGGBB
             */
            function formatHex(color: Color): string;
            /**
             * Formats the color as #RRGGBBAA
             * If 'compact' is set, colors without transparancy will be printed as #RRGGBB
             */
            function formatHexA(color: Color, compact?: boolean): string;
            /**
             * The default format will use HEX if opaque and RGBA otherwise.
             */
            function format(color: Color): string;
            /**
             * Converts an Hex color value to a Color.
             * returns r, g, and b are contained in the set [0, 255]
             * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).
             */
            function parseHex(hex: string): Color | null;
        }
    }
}

interface IDataTransferFile {
    readonly name: string;
    readonly uri?: URI;
    data(): Promise<Uint8Array>;
}
interface IDataTransferItem {
    readonly id: string;
    asString(): Thenable<string>;
    asFile(): IDataTransferFile | undefined;
    value: any;
}
declare class VSDataTransfer {
    private readonly _entries;
    get size(): number;
    has(mimeType: string): boolean;
    get(mimeType: string): IDataTransferItem | undefined;
    append(mimeType: string, value: IDataTransferItem): void;
    replace(mimeType: string, value: IDataTransferItem): void;
    delete(mimeType: string): void;
    entries(): Iterable<[string, IDataTransferItem]>;
    values(): Iterable<IDataTransferItem>;
    forEach(f: (value: IDataTransferItem, key: string) => void): void;
    private toKey;
}

/**
 * Open ended enum at runtime
 */
declare const enum LanguageId {
    Null = 0,
    PlainText = 1
}
/**
 * Open ended enum at runtime
 */
declare const enum ColorId {
    None = 0,
    DefaultForeground = 1,
    DefaultBackground = 2
}
/**
 * A standard token type.
 */
declare const enum StandardTokenType {
    Other = 0,
    Comment = 1,
    String = 2,
    RegEx = 3
}
/**
 */
interface ITokenPresentation {
    foreground: ColorId;
    italic: boolean;
    bold: boolean;
    underline: boolean;
    strikethrough: boolean;
}

declare enum Severity$1 {
    Ignore = 0,
    Info = 1,
    Warning = 2,
    Error = 3
}
declare namespace Severity$1 {
    /**
     * Parses 'error', 'warning', 'warn', 'info' in call casings
     * and falls back to ignore.
     */
    function fromValue(value: string): Severity$1;
    function toString(severity: Severity$1): string;
}

/**
 * **!Do not construct directly!**
 *
 * **!Only static methods because it gets serialized!**
 *
 * This represents the "canonical" version for an extension identifier. Extension ids
 * have to be case-insensitive (due to the marketplace), but we must ensure case
 * preservation because the extension API is already public at this time.
 *
 * For example, given an extension with the publisher `"Hello"` and the name `"World"`,
 * its canonical extension identifier is `"Hello.World"`. This extension could be
 * referenced in some other extension's dependencies using the string `"hello.world"`.
 *
 * To make matters more complicated, an extension can optionally have an UUID. When two
 * extensions have the same UUID, they are considered equal even if their identifier is different.
 */
declare class ExtensionIdentifier {
    readonly value: string;
    private readonly _lower;
    constructor(value: string);
    static equals(a: ExtensionIdentifier | string | null | undefined, b: ExtensionIdentifier | string | null | undefined): boolean;
    /**
     * Gives the value by which to index (for equality).
     */
    static toKey(id: ExtensionIdentifier | string): string;
}

/**
 *
 */
interface IRelatedInformation {
    resource: URI;
    message: string;
    startLineNumber: number;
    startColumn: number;
    endLineNumber: number;
    endColumn: number;
}
declare const enum MarkerTag {
    Unnecessary = 1,
    Deprecated = 2
}
declare enum MarkerSeverity {
    Hint = 1,
    Info = 2,
    Warning = 4,
    Error = 8
}
declare namespace MarkerSeverity {
    function compare(a: MarkerSeverity, b: MarkerSeverity): number;
    function toString(a: MarkerSeverity): string;
    function fromSeverity(severity: Severity$1): MarkerSeverity;
    function toSeverity(severity: MarkerSeverity): Severity$1;
}
/**
 * A structure defining a problem/warning/etc.
 */
interface IMarkerData {
    code?: string | {
        value: string;
        target: URI;
    };
    severity: MarkerSeverity;
    message: string;
    source?: string;
    startLineNumber: number;
    startColumn: number;
    endLineNumber: number;
    endColumn: number;
    modelVersionId?: number;
    relatedInformation?: IRelatedInformation[];
    tags?: MarkerTag[];
}
declare namespace IMarkerData {
    function makeKey(markerData: IMarkerData): string;
    function makeKeyOptionalMessage(markerData: IMarkerData, useMessage: boolean): string;
}

/**
 * @internal
 */
interface ILanguageIdCodec {
    encodeLanguageId(languageId: string): LanguageId;
    decodeLanguageId(languageId: LanguageId): string;
}
/**
 * A provider result represents the values a provider, like the {@link HoverProvider},
 * may return. For once this is the actual result type `T`, like `Hover`, or a thenable that resolves
 * to that type `T`. In addition, `null` and `undefined` can be returned - either directly or from a
 * thenable.
 */
type ProviderResult<T> = T | undefined | null | Thenable<T | undefined | null>;
/**
 * A hover represents additional information for a symbol or word. Hovers are
 * rendered in a tooltip-like widget.
 */
interface Hover {
    /**
     * The contents of this hover.
     */
    contents: IMarkdownString[];
    /**
     * The range to which this hover applies. When missing, the
     * editor will use the range at the current position or the
     * current position itself.
     */
    range?: IRange;
}
/**
 * The hover provider interface defines the contract between extensions and
 * the [hover](https://code.visualstudio.com/docs/editor/intellisense)-feature.
 */
interface HoverProvider {
    /**
     * Provide a hover for the given position and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideHover(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Hover>;
}
/**
 * An evaluatable expression represents additional information for an expression in a document. Evaluatable expressions are
 * evaluated by a debugger or runtime and their result is rendered in a tooltip-like widget.
 * @internal
 */
interface EvaluatableExpression {
    /**
     * The range to which this expression applies.
     */
    range: IRange;
    /**
     * This expression overrides the expression extracted from the range.
     */
    expression?: string;
}
/**
 * The evaluatable expression provider interface defines the contract between extensions and
 * the debug hover.
 * @internal
 */
interface EvaluatableExpressionProvider {
    /**
     * Provide a hover for the given position and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideEvaluatableExpression(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<EvaluatableExpression>;
}
/**
 * A value-object that contains contextual information when requesting inline values from a InlineValuesProvider.
 * @internal
 */
interface InlineValueContext {
    frameId: number;
    stoppedLocation: Range;
}
/**
 * Provide inline value as text.
 * @internal
 */
interface InlineValueText {
    type: 'text';
    range: IRange;
    text: string;
}
/**
 * Provide inline value through a variable lookup.
 * @internal
 */
interface InlineValueVariableLookup {
    type: 'variable';
    range: IRange;
    variableName?: string;
    caseSensitiveLookup: boolean;
}
/**
 * Provide inline value through an expression evaluation.
 * @internal
 */
interface InlineValueExpression {
    type: 'expression';
    range: IRange;
    expression?: string;
}
/**
 * Inline value information can be provided by different means:
 * - directly as a text value (class InlineValueText).
 * - as a name to use for a variable lookup (class InlineValueVariableLookup)
 * - as an evaluatable expression (class InlineValueEvaluatableExpression)
 * The InlineValue types combines all inline value types into one type.
 * @internal
 */
type InlineValue = InlineValueText | InlineValueVariableLookup | InlineValueExpression;
/**
 * The inline values provider interface defines the contract between extensions and
 * the debugger's inline values feature.
 * @internal
 */
interface InlineValuesProvider {
    /**
     */
    onDidChangeInlineValues?: Event<void> | undefined;
    /**
     * Provide the "inline values" for the given range and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideInlineValues(model: ITextModel, viewPort: Range, context: InlineValueContext, token: CancellationToken): ProviderResult<InlineValue[]>;
}
declare const enum CompletionItemKind {
    Method = 0,
    Function = 1,
    Constructor = 2,
    Field = 3,
    Variable = 4,
    Class = 5,
    Struct = 6,
    Interface = 7,
    Module = 8,
    Property = 9,
    Event = 10,
    Operator = 11,
    Unit = 12,
    Value = 13,
    Constant = 14,
    Enum = 15,
    EnumMember = 16,
    Keyword = 17,
    Text = 18,
    Color = 19,
    File = 20,
    Reference = 21,
    Customcolor = 22,
    Folder = 23,
    TypeParameter = 24,
    User = 25,
    Issue = 26,
    Snippet = 27
}
interface CompletionItemLabel {
    label: string;
    detail?: string;
    description?: string;
}
declare const enum CompletionItemTag {
    Deprecated = 1
}
declare const enum CompletionItemInsertTextRule {
    None = 0,
    /**
     * Adjust whitespace/indentation of multiline insert texts to
     * match the current line indentation.
     */
    KeepWhitespace = 1,
    /**
     * `insertText` is a snippet.
     */
    InsertAsSnippet = 4
}
interface CompletionItemRanges {
    insert: IRange;
    replace: IRange;
}
/**
 * A completion item represents a text snippet that is
 * proposed to complete text that is being typed.
 */
interface CompletionItem {
    /**
     * The label of this completion item. By default
     * this is also the text that is inserted when selecting
     * this completion.
     */
    label: string | CompletionItemLabel;
    /**
     * The kind of this completion item. Based on the kind
     * an icon is chosen by the editor.
     */
    kind: CompletionItemKind;
    /**
     * A modifier to the `kind` which affect how the item
     * is rendered, e.g. Deprecated is rendered with a strikeout
     */
    tags?: ReadonlyArray<CompletionItemTag>;
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string;
    /**
     * A human-readable string that represents a doc-comment.
     */
    documentation?: string | IMarkdownString;
    /**
     * A string that should be used when comparing this item
     * with other items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    sortText?: string;
    /**
     * A string that should be used when filtering a set of
     * completion items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    filterText?: string;
    /**
     * Select this item when showing. *Note* that only one completion item can be selected and
     * that the editor decides which item that is. The rule is that the *first* item of those
     * that match best is selected.
     */
    preselect?: boolean;
    /**
     * A string or snippet that should be inserted in a document when selecting
     * this completion.
     */
    insertText: string;
    /**
     * Additional rules (as bitmask) that should be applied when inserting
     * this completion.
     */
    insertTextRules?: CompletionItemInsertTextRule;
    /**
     * A range of text that should be replaced by this completion item.
     *
     * Defaults to a range from the start of the {@link TextDocument.getWordRangeAtPosition current word} to the
     * current position.
     *
     * *Note:* The range must be a {@link Range.isSingleLine single line} and it must
     * {@link Range.contains contain} the position at which completion has been {@link CompletionItemProvider.provideCompletionItems requested}.
     */
    range: IRange | CompletionItemRanges;
    /**
     * An optional set of characters that when pressed while this completion is active will accept it first and
     * then type that character. *Note* that all commit characters should have `length=1` and that superfluous
     * characters will be ignored.
     */
    commitCharacters?: string[];
    /**
     * An optional array of additional text edits that are applied when
     * selecting this completion. Edits must not overlap with the main edit
     * nor with themselves.
     */
    additionalTextEdits?: ISingleEditOperation[];
    /**
     * A command that should be run upon acceptance of this item.
     */
    command?: Command;
    /**
     * @internal
     */
    extensionId?: ExtensionIdentifier;
    /**
     * @internal
     */
    _id?: [number, number];
}
interface CompletionList {
    suggestions: CompletionItem[];
    incomplete?: boolean;
    dispose?(): void;
    /**
     * @internal
     */
    duration?: number;
}
/**
 * How a suggest provider was triggered.
 */
declare const enum CompletionTriggerKind {
    Invoke = 0,
    TriggerCharacter = 1,
    TriggerForIncompleteCompletions = 2
}
/**
 * Contains additional information about the context in which
 * {@link CompletionItemProvider.provideCompletionItems completion provider} is triggered.
 */
interface CompletionContext {
    /**
     * How the completion was triggered.
     */
    triggerKind: CompletionTriggerKind;
    /**
     * Character that triggered the completion item provider.
     *
     * `undefined` if provider was not triggered by a character.
     */
    triggerCharacter?: string;
}
/**
 * The completion item provider interface defines the contract between extensions and
 * the [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense).
 *
 * When computing *complete* completion items is expensive, providers can optionally implement
 * the `resolveCompletionItem`-function. In that case it is enough to return completion
 * items with a {@link CompletionItem.label label} from the
 * {@link CompletionItemProvider.provideCompletionItems provideCompletionItems}-function. Subsequently,
 * when a completion item is shown in the UI and gains focus this provider is asked to resolve
 * the item, like adding {@link CompletionItem.documentation doc-comment} or {@link CompletionItem.detail details}.
 */
interface CompletionItemProvider {
    /**
     * @internal
     */
    _debugDisplayName?: string;
    triggerCharacters?: string[];
    /**
     * Provide completion items for the given position and document.
     */
    provideCompletionItems(model: ITextModel, position: Position, context: CompletionContext, token: CancellationToken): ProviderResult<CompletionList>;
    /**
     * Given a completion item fill in more data, like {@link CompletionItem.documentation doc-comment}
     * or {@link CompletionItem.detail details}.
     *
     * The editor will only resolve a completion item once.
     */
    resolveCompletionItem?(item: CompletionItem, token: CancellationToken): ProviderResult<CompletionItem>;
}
/**
 * How an {@link InlineCompletionsProvider inline completion provider} was triggered.
 */
declare enum InlineCompletionTriggerKind {
    /**
     * Completion was triggered automatically while editing.
     * It is sufficient to return a single completion item in this case.
     */
    Automatic = 0,
    /**
     * Completion was triggered explicitly by a user gesture.
     * Return multiple completion items to enable cycling through them.
     */
    Explicit = 1
}
interface InlineCompletionContext {
    /**
     * How the completion was triggered.
     */
    readonly triggerKind: InlineCompletionTriggerKind;
    readonly selectedSuggestionInfo: SelectedSuggestionInfo | undefined;
}
interface SelectedSuggestionInfo {
    range: IRange;
    text: string;
    isSnippetText: boolean;
    completionKind: CompletionItemKind;
}
interface InlineCompletion {
    /**
     * The text to insert.
     * If the text contains a line break, the range must end at the end of a line.
     * If existing text should be replaced, the existing text must be a prefix of the text to insert.
     *
     * The text can also be a snippet. In that case, a preview with default parameters is shown.
     * When accepting the suggestion, the full snippet is inserted.
    */
    readonly insertText: string | {
        snippet: string;
    };
    /**
     * A text that is used to decide if this inline completion should be shown.
     * An inline completion is shown if the text to replace is a subword of the filter text.
     */
    readonly filterText?: string;
    /**
     * An optional array of additional text edits that are applied when
     * selecting this completion. Edits must not overlap with the main edit
     * nor with themselves.
     */
    readonly additionalTextEdits?: ISingleEditOperation[];
    /**
     * The range to replace.
     * Must begin and end on the same line.
    */
    readonly range?: IRange;
    readonly command?: Command;
    /**
     * If set to `true`, unopened closing brackets are removed and unclosed opening brackets are closed.
     * Defaults to `false`.
    */
    readonly completeBracketPairs?: boolean;
}
interface InlineCompletions<TItem extends InlineCompletion = InlineCompletion> {
    readonly items: readonly TItem[];
    /**
     * A list of commands associated with the inline completions of this list.
     */
    readonly commands?: Command[];
}
interface InlineCompletionsProvider<T extends InlineCompletions = InlineCompletions> {
    provideInlineCompletions(model: ITextModel, position: Position, context: InlineCompletionContext, token: CancellationToken): ProviderResult<T>;
    /**
     * Will be called when an item is shown.
    */
    handleItemDidShow?(completions: T, item: T['items'][number]): void;
    /**
     * Will be called when an item is partially accepted.
     */
    handlePartialAccept?(completions: T, item: T['items'][number], acceptedCharacters: number): void;
    /**
     * Will be called when a completions list is no longer in use and can be garbage-collected.
    */
    freeInlineCompletions(completions: T): void;
}
interface CodeAction {
    title: string;
    command?: Command;
    edit?: WorkspaceEdit;
    diagnostics?: IMarkerData[];
    kind?: string;
    isPreferred?: boolean;
    disabled?: string;
}
declare const enum CodeActionTriggerType {
    Invoke = 1,
    Auto = 2
}
/**
 * @internal
 */
interface CodeActionContext {
    only?: string;
    trigger: CodeActionTriggerType;
}
interface CodeActionList extends IDisposable {
    readonly actions: ReadonlyArray<CodeAction>;
}
/**
 * The code action interface defines the contract between extensions and
 * the [light bulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature.
 * @internal
 */
interface CodeActionProvider {
    displayName?: string;
    /**
     * Provide commands for the given document and range.
     */
    provideCodeActions(model: ITextModel, range: Range | Selection, context: CodeActionContext, token: CancellationToken): ProviderResult<CodeActionList>;
    /**
     * Given a code action fill in the edit. Will only invoked when missing.
     */
    resolveCodeAction?(codeAction: CodeAction, token: CancellationToken): ProviderResult<CodeAction>;
    /**
     * Optional list of CodeActionKinds that this provider returns.
     */
    readonly providedCodeActionKinds?: ReadonlyArray<string>;
    readonly documentation?: ReadonlyArray<{
        readonly kind: string;
        readonly command: Command;
    }>;
    /**
     * @internal
     */
    _getAdditionalMenuItems?(context: CodeActionContext, actions: readonly CodeAction[]): Command[];
}
/**
 * @internal
 */
interface DocumentPasteEdit {
    insertText: string | {
        snippet: string;
    };
    additionalEdit?: WorkspaceEdit;
}
/**
 * @internal
 */
interface DocumentPasteEditProvider {
    readonly pasteMimeTypes: readonly string[];
    prepareDocumentPaste?(model: ITextModel, ranges: readonly IRange[], dataTransfer: VSDataTransfer, token: CancellationToken): Promise<undefined | VSDataTransfer>;
    provideDocumentPasteEdits(model: ITextModel, ranges: readonly IRange[], dataTransfer: VSDataTransfer, token: CancellationToken): Promise<DocumentPasteEdit | undefined>;
}
/**
 * Represents a parameter of a callable-signature. A parameter can
 * have a label and a doc-comment.
 */
interface ParameterInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string | [number, number];
    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | IMarkdownString;
}
/**
 * Represents the signature of something callable. A signature
 * can have a label, like a function-name, a doc-comment, and
 * a set of parameters.
 */
interface SignatureInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string;
    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | IMarkdownString;
    /**
     * The parameters of this signature.
     */
    parameters: ParameterInformation[];
    /**
     * Index of the active parameter.
     *
     * If provided, this is used in place of `SignatureHelp.activeSignature`.
     */
    activeParameter?: number;
}
/**
 * Signature help represents the signature of something
 * callable. There can be multiple signatures but only one
 * active and only one active parameter.
 */
interface SignatureHelp {
    /**
     * One or more signatures.
     */
    signatures: SignatureInformation[];
    /**
     * The active signature.
     */
    activeSignature: number;
    /**
     * The active parameter of the active signature.
     */
    activeParameter: number;
}
interface SignatureHelpResult extends IDisposable {
    value: SignatureHelp;
}
declare enum SignatureHelpTriggerKind {
    Invoke = 1,
    TriggerCharacter = 2,
    ContentChange = 3
}
interface SignatureHelpContext {
    readonly triggerKind: SignatureHelpTriggerKind;
    readonly triggerCharacter?: string;
    readonly isRetrigger: boolean;
    readonly activeSignatureHelp?: SignatureHelp;
}
/**
 * The signature help provider interface defines the contract between extensions and
 * the [parameter hints](https://code.visualstudio.com/docs/editor/intellisense)-feature.
 */
interface SignatureHelpProvider {
    readonly signatureHelpTriggerCharacters?: ReadonlyArray<string>;
    readonly signatureHelpRetriggerCharacters?: ReadonlyArray<string>;
    /**
     * Provide help for the signature at the given position and document.
     */
    provideSignatureHelp(model: ITextModel, position: Position, token: CancellationToken, context: SignatureHelpContext): ProviderResult<SignatureHelpResult>;
}
/**
 * A document highlight kind.
 */
declare enum DocumentHighlightKind {
    /**
     * A textual occurrence.
     */
    Text = 0,
    /**
     * Read-access of a symbol, like reading a variable.
     */
    Read = 1,
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    Write = 2
}
/**
 * A document highlight is a range inside a text document which deserves
 * special attention. Usually a document highlight is visualized by changing
 * the background color of its range.
 */
interface DocumentHighlight {
    /**
     * The range this highlight applies to.
     */
    range: IRange;
    /**
     * The highlight kind, default is {@link DocumentHighlightKind.Text text}.
     */
    kind?: DocumentHighlightKind;
}
/**
 * The document highlight provider interface defines the contract between extensions and
 * the word-highlight-feature.
 */
interface DocumentHighlightProvider {
    /**
     * Provide a set of document highlights, like all occurrences of a variable or
     * all exit-points of a function.
     */
    provideDocumentHighlights(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<DocumentHighlight[]>;
}
/**
 * The linked editing range provider interface defines the contract between extensions and
 * the linked editing feature.
 */
interface LinkedEditingRangeProvider {
    /**
     * Provide a list of ranges that can be edited together.
     */
    provideLinkedEditingRanges(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<LinkedEditingRanges>;
}
/**
 * Represents a list of ranges that can be edited together along with a word pattern to describe valid contents.
 */
interface LinkedEditingRanges {
    /**
     * A list of ranges that can be edited together. The ranges must have
     * identical length and text content. The ranges cannot overlap
     */
    ranges: IRange[];
    /**
     * An optional word pattern that describes valid contents for the given ranges.
     * If no pattern is provided, the language configuration's word pattern will be used.
     */
    wordPattern?: RegExp;
}
/**
 * Value-object that contains additional information when
 * requesting references.
 */
interface ReferenceContext {
    /**
     * Include the declaration of the current symbol.
     */
    includeDeclaration: boolean;
}
/**
 * The reference provider interface defines the contract between extensions and
 * the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.
 */
interface ReferenceProvider {
    /**
     * Provide a set of project-wide references for the given position and document.
     */
    provideReferences(model: ITextModel, position: Position, context: ReferenceContext, token: CancellationToken): ProviderResult<Location[]>;
}
/**
 * Represents a location inside a resource, such as a line
 * inside a text file.
 */
interface Location {
    /**
     * The resource identifier of this location.
     */
    uri: URI;
    /**
     * The document range of this locations.
     */
    range: IRange;
}
interface LocationLink {
    /**
     * A range to select where this link originates from.
     */
    originSelectionRange?: IRange;
    /**
     * The target uri this link points to.
     */
    uri: URI;
    /**
     * The full range this link points to.
     */
    range: IRange;
    /**
     * A range to select this link points to. Must be contained
     * in `LocationLink.range`.
     */
    targetSelectionRange?: IRange;
}
type Definition = Location | Location[] | LocationLink[];
/**
 * The definition provider interface defines the contract between extensions and
 * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
 * and peek definition features.
 */
interface DefinitionProvider {
    /**
     * Provide the definition of the symbol at the given position and document.
     */
    provideDefinition(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * The definition provider interface defines the contract between extensions and
 * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
 * and peek definition features.
 */
interface DeclarationProvider {
    /**
     * Provide the declaration of the symbol at the given position and document.
     */
    provideDeclaration(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * The implementation provider interface defines the contract between extensions and
 * the go to implementation feature.
 */
interface ImplementationProvider {
    /**
     * Provide the implementation of the symbol at the given position and document.
     */
    provideImplementation(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * The type definition provider interface defines the contract between extensions and
 * the go to type definition feature.
 */
interface TypeDefinitionProvider {
    /**
     * Provide the type definition of the symbol at the given position and document.
     */
    provideTypeDefinition(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * A symbol kind.
 */
declare const enum SymbolKind {
    File = 0,
    Module = 1,
    Namespace = 2,
    Package = 3,
    Class = 4,
    Method = 5,
    Property = 6,
    Field = 7,
    Constructor = 8,
    Enum = 9,
    Interface = 10,
    Function = 11,
    Variable = 12,
    Constant = 13,
    String = 14,
    Number = 15,
    Boolean = 16,
    Array = 17,
    Object = 18,
    Key = 19,
    Null = 20,
    EnumMember = 21,
    Struct = 22,
    Event = 23,
    Operator = 24,
    TypeParameter = 25
}
declare const enum SymbolTag {
    Deprecated = 1
}
interface DocumentSymbol {
    name: string;
    detail: string;
    kind: SymbolKind;
    tags: ReadonlyArray<SymbolTag>;
    containerName?: string;
    range: IRange;
    selectionRange: IRange;
    children?: DocumentSymbol[];
}
/**
 * The document symbol provider interface defines the contract between extensions and
 * the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.
 */
interface DocumentSymbolProvider {
    displayName?: string;
    /**
     * Provide symbol information for the given document.
     */
    provideDocumentSymbols(model: ITextModel, token: CancellationToken): ProviderResult<DocumentSymbol[]>;
}
interface TextEdit {
    range: IRange;
    text: string;
    eol?: EndOfLineSequence;
}
/**
 * Interface used to format a model
 */
interface FormattingOptions {
    /**
     * Size of a tab in spaces.
     */
    tabSize: number;
    /**
     * Prefer spaces over tabs.
     */
    insertSpaces: boolean;
}
/**
 * The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.
 */
interface DocumentFormattingEditProvider {
    /**
     * @internal
     */
    readonly extensionId?: ExtensionIdentifier;
    readonly displayName?: string;
    /**
     * Provide formatting edits for a whole document.
     */
    provideDocumentFormattingEdits(model: ITextModel, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
}
/**
 * The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.
 */
interface DocumentRangeFormattingEditProvider {
    /**
     * @internal
     */
    readonly extensionId?: ExtensionIdentifier;
    readonly displayName?: string;
    /**
     * Provide formatting edits for a range in a document.
     *
     * The given range is a hint and providers can decide to format a smaller
     * or larger range. Often this is done by adjusting the start and end
     * of the range to full syntax nodes.
     */
    provideDocumentRangeFormattingEdits(model: ITextModel, range: Range, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
}
/**
 * The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.
 */
interface OnTypeFormattingEditProvider {
    /**
     * @internal
     */
    readonly extensionId?: ExtensionIdentifier;
    autoFormatTriggerCharacters: string[];
    /**
     * Provide formatting edits after a character has been typed.
     *
     * The given position and character should hint to the provider
     * what range the position to expand to, like find the matching `{`
     * when `}` has been entered.
     */
    provideOnTypeFormattingEdits(model: ITextModel, position: Position, ch: string, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
}
/**
 * A link inside the editor.
 */
interface ILink {
    range: IRange;
    url?: URI | string;
    tooltip?: string;
}
interface ILinksList {
    links: ILink[];
    dispose?(): void;
}
/**
 * A provider of links.
 */
interface LinkProvider {
    provideLinks(model: ITextModel, token: CancellationToken): ProviderResult<ILinksList>;
    resolveLink?: (link: ILink, token: CancellationToken) => ProviderResult<ILink>;
}
/**
 * A color in RGBA format.
 */
interface IColor {
    /**
     * The red component in the range [0-1].
     */
    readonly red: number;
    /**
     * The green component in the range [0-1].
     */
    readonly green: number;
    /**
     * The blue component in the range [0-1].
     */
    readonly blue: number;
    /**
     * The alpha component in the range [0-1].
     */
    readonly alpha: number;
}
/**
 * String representations for a color
 */
interface IColorPresentation {
    /**
     * The label of this color presentation. It will be shown on the color
     * picker header. By default this is also the text that is inserted when selecting
     * this color presentation.
     */
    label: string;
    /**
     * An {@link TextEdit edit} which is applied to a document when selecting
     * this presentation for the color.
     */
    textEdit?: TextEdit;
    /**
     * An optional array of additional {@link TextEdit text edits} that are applied when
     * selecting this color presentation.
     */
    additionalTextEdits?: TextEdit[];
}
/**
 * A color range is a range in a text model which represents a color.
 */
interface IColorInformation {
    /**
     * The range within the model.
     */
    range: IRange;
    /**
     * The color represented in this range.
     */
    color: IColor;
}
/**
 * A provider of colors for editor models.
 */
interface DocumentColorProvider {
    /**
     * Provides the color ranges for a specific model.
     */
    provideDocumentColors(model: ITextModel, token: CancellationToken): ProviderResult<IColorInformation[]>;
    /**
     * Provide the string representations for a color.
     */
    provideColorPresentations(model: ITextModel, colorInfo: IColorInformation, token: CancellationToken): ProviderResult<IColorPresentation[]>;
}
interface SelectionRange {
    range: IRange;
}
interface SelectionRangeProvider {
    /**
     * Provide ranges that should be selected from the given position.
     */
    provideSelectionRanges(model: ITextModel, positions: Position[], token: CancellationToken): ProviderResult<SelectionRange[][]>;
}
interface FoldingContext {
}
/**
 * A provider of folding ranges for editor models.
 */
interface FoldingRangeProvider {
    /**
     * @internal
     */
    readonly id?: string;
    /**
     * An optional event to signal that the folding ranges from this provider have changed.
     */
    onDidChange?: Event<this>;
    /**
     * Provides the folding ranges for a specific model.
     */
    provideFoldingRanges(model: ITextModel, context: FoldingContext, token: CancellationToken): ProviderResult<FoldingRange[]>;
}
interface FoldingRange {
    /**
     * The one-based start line of the range to fold. The folded area starts after the line's last character.
     */
    start: number;
    /**
     * The one-based end line of the range to fold. The folded area ends with the line's last character.
     */
    end: number;
    /**
     * Describes the {@link FoldingRangeKind Kind} of the folding range such as {@link FoldingRangeKind.Comment Comment} or
     * {@link FoldingRangeKind.Region Region}. The kind is used to categorize folding ranges and used by commands
     * like 'Fold all comments'. See
     * {@link FoldingRangeKind} for an enumeration of standardized kinds.
     */
    kind?: FoldingRangeKind;
}
declare class FoldingRangeKind {
    value: string;
    /**
     * Kind for folding range representing a comment. The value of the kind is 'comment'.
     */
    static readonly Comment: FoldingRangeKind;
    /**
     * Kind for folding range representing a import. The value of the kind is 'imports'.
     */
    static readonly Imports: FoldingRangeKind;
    /**
     * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
     * The value of the kind is 'region'.
     */
    static readonly Region: FoldingRangeKind;
    /**
     * Returns a {@link FoldingRangeKind} for the given value.
     *
     * @param value of the kind.
     */
    static fromValue(value: string): FoldingRangeKind;
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value: string);
}
interface WorkspaceEditMetadata {
    needsConfirmation: boolean;
    label: string;
    description?: string;
    /**
     * @internal
     */
    iconPath?: ThemeIcon | URI | {
        light: URI;
        dark: URI;
    };
}
interface WorkspaceFileEditOptions {
    overwrite?: boolean;
    ignoreIfNotExists?: boolean;
    ignoreIfExists?: boolean;
    recursive?: boolean;
    copy?: boolean;
    folder?: boolean;
    skipTrashBin?: boolean;
    maxSize?: number;
    contentsBase64?: string;
}
interface IWorkspaceFileEdit {
    oldResource?: URI;
    newResource?: URI;
    options?: WorkspaceFileEditOptions;
    metadata?: WorkspaceEditMetadata;
}
interface IWorkspaceTextEdit {
    resource: URI;
    textEdit: TextEdit & {
        insertAsSnippet?: boolean;
    };
    versionId: number | undefined;
    metadata?: WorkspaceEditMetadata;
}
interface WorkspaceEdit {
    edits: Array<IWorkspaceTextEdit | IWorkspaceFileEdit>;
}
interface Rejection {
    rejectReason?: string;
}
interface RenameLocation {
    range: IRange;
    text: string;
}
interface RenameProvider {
    provideRenameEdits(model: ITextModel, position: Position, newName: string, token: CancellationToken): ProviderResult<WorkspaceEdit & Rejection>;
    resolveRenameLocation?(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<RenameLocation & Rejection>;
}
interface Command {
    id: string;
    title: string;
    tooltip?: string;
    arguments?: any[];
}
/**
 * @internal
 */
declare namespace Command {
    /**
     * @internal
     */
    function is(obj: any): obj is Command;
}
interface CodeLens {
    range: IRange;
    id?: string;
    command?: Command;
}
interface CodeLensList {
    lenses: CodeLens[];
    dispose(): void;
}
interface CodeLensProvider {
    onDidChange?: Event<this>;
    provideCodeLenses(model: ITextModel, token: CancellationToken): ProviderResult<CodeLensList>;
    resolveCodeLens?(model: ITextModel, codeLens: CodeLens, token: CancellationToken): ProviderResult<CodeLens>;
}
declare enum InlayHintKind {
    Type = 1,
    Parameter = 2
}
interface InlayHintLabelPart {
    label: string;
    tooltip?: string | IMarkdownString;
    command?: Command;
    location?: Location;
}
interface InlayHint {
    label: string | InlayHintLabelPart[];
    tooltip?: string | IMarkdownString;
    textEdits?: TextEdit[];
    position: IPosition;
    kind?: InlayHintKind;
    paddingLeft?: boolean;
    paddingRight?: boolean;
}
interface InlayHintList {
    hints: InlayHint[];
    dispose(): void;
}
interface InlayHintsProvider {
    displayName?: string;
    onDidChangeInlayHints?: Event<void>;
    provideInlayHints(model: ITextModel, range: Range, token: CancellationToken): ProviderResult<InlayHintList>;
    resolveInlayHint?(hint: InlayHint, token: CancellationToken): ProviderResult<InlayHint>;
}
interface SemanticTokensLegend {
    readonly tokenTypes: string[];
    readonly tokenModifiers: string[];
}
interface SemanticTokens {
    readonly resultId?: string;
    readonly data: Uint32Array;
}
interface SemanticTokensEdit {
    readonly start: number;
    readonly deleteCount: number;
    readonly data?: Uint32Array;
}
interface SemanticTokensEdits {
    readonly resultId?: string;
    readonly edits: SemanticTokensEdit[];
}
interface DocumentSemanticTokensProvider {
    onDidChange?: Event<void>;
    getLegend(): SemanticTokensLegend;
    provideDocumentSemanticTokens(model: ITextModel, lastResultId: string | null, token: CancellationToken): ProviderResult<SemanticTokens | SemanticTokensEdits>;
    releaseDocumentSemanticTokens(resultId: string | undefined): void;
}
interface DocumentRangeSemanticTokensProvider {
    getLegend(): SemanticTokensLegend;
    provideDocumentRangeSemanticTokens(model: ITextModel, range: Range, token: CancellationToken): ProviderResult<SemanticTokens>;
}
/**
 * @internal
 */
interface DocumentOnDropEdit {
    insertText: string | {
        snippet: string;
    };
    additionalEdit?: WorkspaceEdit;
}
/**
 * @internal
 */
interface DocumentOnDropEditProvider {
    provideDocumentOnDropEdits(model: ITextModel, position: IPosition, dataTransfer: VSDataTransfer, token: CancellationToken): ProviderResult<DocumentOnDropEdit>;
}

interface IViewLineTokens {
    equals(other: IViewLineTokens): boolean;
    getCount(): number;
    getForeground(tokenIndex: number): ColorId;
    getEndOffset(tokenIndex: number): number;
    getClassName(tokenIndex: number): string;
    getInlineStyle(tokenIndex: number, colorMap: string[]): string;
    getPresentation(tokenIndex: number): ITokenPresentation;
    findTokenIndexAtOffset(offset: number): number;
    getLineContent(): string;
    getMetadata(tokenIndex: number): number;
    getLanguageId(tokenIndex: number): string;
}
declare class LineTokens implements IViewLineTokens {
    _lineTokensBrand: void;
    private readonly _tokens;
    private readonly _tokensCount;
    private readonly _text;
    private readonly _languageIdCodec;
    static defaultTokenMetadata: number;
    static createEmpty(lineContent: string, decoder: ILanguageIdCodec): LineTokens;
    constructor(tokens: Uint32Array, text: string, decoder: ILanguageIdCodec);
    equals(other: IViewLineTokens): boolean;
    slicedEquals(other: LineTokens, sliceFromTokenIndex: number, sliceTokenCount: number): boolean;
    getLineContent(): string;
    getCount(): number;
    getStartOffset(tokenIndex: number): number;
    getMetadata(tokenIndex: number): number;
    getLanguageId(tokenIndex: number): string;
    getStandardTokenType(tokenIndex: number): StandardTokenType;
    getForeground(tokenIndex: number): ColorId;
    getClassName(tokenIndex: number): string;
    getInlineStyle(tokenIndex: number, colorMap: string[]): string;
    getPresentation(tokenIndex: number): ITokenPresentation;
    getEndOffset(tokenIndex: number): number;
    /**
     * Find the token containing offset `offset`.
     * @param offset The search offset
     * @return The index of the token containing the offset.
     */
    findTokenIndexAtOffset(offset: number): number;
    inflate(): IViewLineTokens;
    sliceAndInflate(startOffset: number, endOffset: number, deltaOffset: number): IViewLineTokens;
    static convertToEndOffset(tokens: Uint32Array, lineTextLength: number): void;
    static findIndexInTokensArray(tokens: Uint32Array, desiredIndex: number): number;
    /**
     * @pure
     * @param insertTokens Must be sorted by offset.
    */
    withInserted(insertTokens: {
        offset: number;
        text: string;
        tokenMetadata: number;
    }[]): LineTokens;
}

declare class ScopedLineTokens {
    _scopedLineTokensBrand: void;
    readonly languageId: string;
    private readonly _actual;
    private readonly _firstTokenIndex;
    private readonly _lastTokenIndex;
    readonly firstCharOffset: number;
    private readonly _lastCharOffset;
    constructor(actual: LineTokens, languageId: string, firstTokenIndex: number, lastTokenIndex: number, firstCharOffset: number, lastCharOffset: number);
    getLineContent(): string;
    getActualLineContentBefore(offset: number): string;
    getTokenCount(): number;
    findTokenIndexAtOffset(offset: number): number;
    getStandardTokenType(tokenIndex: number): StandardTokenType;
}

/**
 * Describes how comments for a language work.
 */
interface CommentRule {
    /**
     * The line comment token, like `// this is a comment`
     */
    lineComment?: string | null;
    /**
     * The block comment character pair, like `/* block comment *&#47;`
     */
    blockComment?: CharacterPair | null;
}
/**
 * The language configuration interface defines the contract between extensions and
 * various editor features, like automatic bracket insertion, automatic indentation etc.
 */
interface LanguageConfiguration {
    /**
     * The language's comment settings.
     */
    comments?: CommentRule;
    /**
     * The language's brackets.
     * This configuration implicitly affects pressing Enter around these brackets.
     */
    brackets?: CharacterPair[];
    /**
     * The language's word definition.
     * If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
     * to provide a word definition that uses exclusion of known separators.
     * e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
     *   /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
     */
    wordPattern?: RegExp;
    /**
     * The language's indentation settings.
     */
    indentationRules?: IndentationRule;
    /**
     * The language's rules to be evaluated when pressing Enter.
     */
    onEnterRules?: OnEnterRule[];
    /**
     * The language's auto closing pairs. The 'close' character is automatically inserted with the
     * 'open' character is typed. If not set, the configured brackets will be used.
     */
    autoClosingPairs?: IAutoClosingPairConditional[];
    /**
     * The language's surrounding pairs. When the 'open' character is typed on a selection, the
     * selected string is surrounded by the open and close characters. If not set, the autoclosing pairs
     * settings will be used.
     */
    surroundingPairs?: IAutoClosingPair[];
    /**
     * Defines a list of bracket pairs that are colorized depending on their nesting level.
     * If not set, the configured brackets will be used.
    */
    colorizedBracketPairs?: CharacterPair[];
    /**
     * Defines what characters must be after the cursor for bracket or quote autoclosing to occur when using the \'languageDefined\' autoclosing setting.
     *
     * This is typically the set of characters which can not start an expression, such as whitespace, closing brackets, non-unary operators, etc.
     */
    autoCloseBefore?: string;
    /**
     * The language's folding rules.
     */
    folding?: FoldingRules;
    /**
     * **Deprecated** Do not use.
     *
     * @deprecated Will be replaced by a better API soon.
     */
    __electricCharacterSupport?: {
        docComment?: IDocComment;
    };
}
/**
 * Describes indentation rules for a language.
 */
interface IndentationRule {
    /**
     * If a line matches this pattern, then all the lines after it should be unindented once (until another rule matches).
     */
    decreaseIndentPattern: RegExp;
    /**
     * If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).
     */
    increaseIndentPattern: RegExp;
    /**
     * If a line matches this pattern, then **only the next line** after it should be indented once.
     */
    indentNextLinePattern?: RegExp | null;
    /**
     * If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.
     */
    unIndentedLinePattern?: RegExp | null;
}
/**
 * Describes language specific folding markers such as '#region' and '#endregion'.
 * The start and end regexes will be tested against the contents of all lines and must be designed efficiently:
 * - the regex should start with '^'
 * - regexp flags (i, g) are ignored
 */
interface FoldingMarkers {
    start: RegExp;
    end: RegExp;
}
/**
 * Describes folding rules for a language.
 */
interface FoldingRules {
    /**
     * Used by the indentation based strategy to decide whether empty lines belong to the previous or the next block.
     * A language adheres to the off-side rule if blocks in that language are expressed by their indentation.
     * See [wikipedia](https://en.wikipedia.org/wiki/Off-side_rule) for more information.
     * If not set, `false` is used and empty lines belong to the previous block.
     */
    offSide?: boolean;
    /**
     * Region markers used by the language.
     */
    markers?: FoldingMarkers;
}
/**
 * Describes a rule to be evaluated when pressing Enter.
 */
interface OnEnterRule {
    /**
     * This rule will only execute if the text before the cursor matches this regular expression.
     */
    beforeText: RegExp;
    /**
     * This rule will only execute if the text after the cursor matches this regular expression.
     */
    afterText?: RegExp;
    /**
     * This rule will only execute if the text above the this line matches this regular expression.
     */
    previousLineText?: RegExp;
    /**
     * The action to execute.
     */
    action: EnterAction;
}
/**
 * Definition of documentation comments (e.g. Javadoc/JSdoc)
 */
interface IDocComment {
    /**
     * The string that starts a doc comment (e.g. '/**')
     */
    open: string;
    /**
     * The string that appears on the last line and closes the doc comment (e.g. ' * /').
     */
    close?: string;
}
/**
 * A tuple of two characters, like a pair of
 * opening and closing brackets.
 */
type CharacterPair = [string, string];
interface IAutoClosingPair {
    open: string;
    close: string;
}
interface IAutoClosingPairConditional extends IAutoClosingPair {
    notIn?: string[];
}
/**
 * Describes what to do with the indentation when pressing Enter.
 */
declare enum IndentAction {
    /**
     * Insert new line and copy the previous line's indentation.
     */
    None = 0,
    /**
     * Insert new line and indent once (relative to the previous line's indentation).
     */
    Indent = 1,
    /**
     * Insert two new lines:
     *  - the first one indented which will hold the cursor
     *  - the second one at the same indentation level
     */
    IndentOutdent = 2,
    /**
     * Insert new line and outdent once (relative to the previous line's indentation).
     */
    Outdent = 3
}
/**
 * Describes what to do when pressing Enter.
 */
interface EnterAction {
    /**
     * Describe what to do with the indentation.
     */
    indentAction: IndentAction;
    /**
     * Describes text to be appended after the new line and after the indentation.
     */
    appendText?: string;
    /**
     * Describes the number of characters to remove from the new line's indentation.
     */
    removeText?: number;
}
/**
 * @internal
 */
declare class StandardAutoClosingPairConditional {
    readonly open: string;
    readonly close: string;
    private readonly _inString;
    private readonly _inComment;
    private readonly _inRegEx;
    private _neutralCharacter;
    private _neutralCharacterSearched;
    constructor(source: IAutoClosingPairConditional);
    isOK(standardToken: StandardTokenType): boolean;
    shouldAutoClose(context: ScopedLineTokens, column: number): boolean;
    private _findNeutralCharacterInRange;
    /**
     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
     */
    findNeutralCharacter(): string | null;
}
/**
 * @internal
 */
declare class AutoClosingPairs {
    /** Key is first character of open */
    readonly autoClosingPairsOpenByStart: Map<string, StandardAutoClosingPairConditional[]>;
    /** Key is last character of open */
    readonly autoClosingPairsOpenByEnd: Map<string, StandardAutoClosingPairConditional[]>;
    /** Key is first character of close */
    readonly autoClosingPairsCloseByStart: Map<string, StandardAutoClosingPairConditional[]>;
    /** Key is last character of close */
    readonly autoClosingPairsCloseByEnd: Map<string, StandardAutoClosingPairConditional[]>;
    /** Key is close. Only has pairs that are a single character */
    readonly autoClosingPairsCloseSingleChar: Map<string, StandardAutoClosingPairConditional[]>;
    constructor(autoClosingPairs: StandardAutoClosingPairConditional[]);
}

/**
 * Captures all bracket related configurations for a single language.
 * Immutable.
*/
declare class LanguageBracketsConfiguration {
    readonly languageId: string;
    private readonly _openingBrackets;
    private readonly _closingBrackets;
    constructor(languageId: string, config: LanguageConfiguration);
    /**
     * No two brackets have the same bracket text.
    */
    get openingBrackets(): readonly OpeningBracketKind[];
    /**
     * No two brackets have the same bracket text.
    */
    get closingBrackets(): readonly ClosingBracketKind[];
    getOpeningBracketInfo(bracketText: string): OpeningBracketKind | undefined;
    getClosingBracketInfo(bracketText: string): ClosingBracketKind | undefined;
    getBracketInfo(bracketText: string): BracketKind | undefined;
}
type BracketKind = OpeningBracketKind | ClosingBracketKind;
declare class BracketKindBase {
    protected readonly config: LanguageBracketsConfiguration;
    readonly bracketText: string;
    constructor(config: LanguageBracketsConfiguration, bracketText: string);
    get languageId(): string;
}
declare class OpeningBracketKind extends BracketKindBase {
    readonly openedBrackets: ReadonlySet<ClosingBracketKind>;
    readonly isOpeningBracket = true;
    constructor(config: LanguageBracketsConfiguration, bracketText: string, openedBrackets: ReadonlySet<ClosingBracketKind>);
}
declare class ClosingBracketKind extends BracketKindBase {
    /**
     * Non empty array of all opening brackets this bracket closes.
    */
    readonly openingBrackets: ReadonlySet<OpeningBracketKind>;
    private readonly openingColorizedBrackets;
    readonly isOpeningBracket = false;
    constructor(config: LanguageBracketsConfiguration, bracketText: string, 
    /**
     * Non empty array of all opening brackets this bracket closes.
    */
    openingBrackets: ReadonlySet<OpeningBracketKind>, openingColorizedBrackets: ReadonlySet<OpeningBracketKind>);
    /**
     * Checks if this bracket closes the given other bracket.
     * If the bracket infos come from different configurations, this method will return false.
    */
    closes(other: OpeningBracketKind): boolean;
    closesColorized(other: OpeningBracketKind): boolean;
    getOpeningBrackets(): readonly OpeningBracketKind[];
}

declare class CharacterPairSupport {
    static readonly DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ";:.,=}])> \n\t";
    static readonly DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = "'\"`;:.,=}])> \n\t";
    static readonly DEFAULT_AUTOCLOSE_BEFORE_WHITESPACE = " \n\t";
    private readonly _autoClosingPairs;
    private readonly _surroundingPairs;
    private readonly _autoCloseBeforeForQuotes;
    private readonly _autoCloseBeforeForBrackets;
    constructor(config: LanguageConfiguration);
    getAutoClosingPairs(): StandardAutoClosingPairConditional[];
    getAutoCloseBeforeSet(forQuotes: boolean): string;
    getSurroundingPairs(): IAutoClosingPair[];
}

/**
 * Represents a grouping of colliding bracket pairs.
 *
 * Most of the times this contains a single bracket pair,
 * but sometimes this contains multiple bracket pairs in cases
 * where the same string appears as a closing bracket for multiple
 * bracket pairs, or the same string appears an opening bracket for
 * multiple bracket pairs.
 *
 * e.g. of a group containing a single pair:
 *   open: ['{'], close: ['}']
 *
 * e.g. of a group containing multiple pairs:
 *   open: ['if', 'for'], close: ['end', 'end']
 */
declare class RichEditBracket {
    _richEditBracketBrand: void;
    readonly languageId: string;
    /**
     * A 0-based consecutive unique identifier for this bracket pair.
     * If a language has 5 bracket pairs, out of which 2 are grouped together,
     * it is expected that the `index` goes from 0 to 4.
     */
    readonly index: number;
    /**
     * The open sequence for each bracket pair contained in this group.
     *
     * The open sequence at a specific index corresponds to the
     * closing sequence at the same index.
     *
     * [ open[i], closed[i] ] represent a bracket pair.
     */
    readonly open: string[];
    /**
     * The close sequence for each bracket pair contained in this group.
     *
     * The close sequence at a specific index corresponds to the
     * opening sequence at the same index.
     *
     * [ open[i], closed[i] ] represent a bracket pair.
     */
    readonly close: string[];
    /**
     * A regular expression that is useful to search for this bracket pair group in a string.
     *
     * This regular expression is built in a way that it is aware of the other bracket
     * pairs defined for the language, so it might match brackets from other groups.
     *
     * See the fine details in `getRegexForBracketPair`.
     */
    readonly forwardRegex: RegExp;
    /**
     * A regular expression that is useful to search for this bracket pair group in a string backwards.
     *
     * This regular expression is built in a way that it is aware of the other bracket
     * pairs defined for the language, so it might match brackets from other groups.
     *
     * See the fine defails in `getReversedRegexForBracketPair`.
     */
    readonly reversedRegex: RegExp;
    private readonly _openSet;
    private readonly _closeSet;
    constructor(languageId: string, index: number, open: string[], close: string[], forwardRegex: RegExp, reversedRegex: RegExp);
    /**
     * Check if the provided `text` is an open bracket in this group.
     */
    isOpen(text: string): boolean;
    /**
     * Check if the provided `text` is a close bracket in this group.
     */
    isClose(text: string): boolean;
    private static _toSet;
}
declare class RichEditBrackets {
    _richEditBracketsBrand: void;
    /**
     * All groups of brackets defined for this language.
     */
    readonly brackets: RichEditBracket[];
    /**
     * A regular expression that is useful to search for all bracket pairs in a string.
     *
     * See the fine details in `getRegexForBrackets`.
     */
    readonly forwardRegex: RegExp;
    /**
     * A regular expression that is useful to search for all bracket pairs in a string backwards.
     *
     * See the fine details in `getReversedRegexForBrackets`.
     */
    readonly reversedRegex: RegExp;
    /**
     * The length (i.e. str.length) for the longest bracket pair.
     */
    readonly maxBracketLength: number;
    /**
     * A map useful for decoding a regex match and finding which bracket group was matched.
     */
    readonly textIsBracket: {
        [text: string]: RichEditBracket;
    };
    /**
     * A set useful for decoding if a regex match is the open bracket of a bracket pair.
     */
    readonly textIsOpenBracket: {
        [text: string]: boolean;
    };
    constructor(languageId: string, _brackets: readonly CharacterPair[]);
}

/**
 * Interface used to support electric characters
 * @internal
 */
interface IElectricAction {
    matchOpenBracket: string;
}
declare class BracketElectricCharacterSupport {
    private readonly _richEditBrackets;
    constructor(richEditBrackets: RichEditBrackets | null);
    getElectricCharacters(): string[];
    onElectricCharacter(character: string, context: ScopedLineTokens, column: number): IElectricAction | null;
}

declare class IndentRulesSupport {
    private readonly _indentationRules;
    constructor(indentationRules: IndentationRule);
    shouldIncrease(text: string): boolean;
    shouldDecrease(text: string): boolean;
    shouldIndentNextLine(text: string): boolean;
    shouldIgnore(text: string): boolean;
    getIndentMetadata(text: string): number;
}

/**
 * Interface used to support insertion of mode specific comments.
 */
interface ICommentsConfiguration {
    lineCommentToken?: string;
    blockCommentStartToken?: string;
    blockCommentEndToken?: string;
}
declare class LanguageConfigurationServiceChangeEvent {
    readonly languageId: string | undefined;
    constructor(languageId: string | undefined);
    affects(languageId: string): boolean;
}
interface ILanguageConfigurationService {
    readonly _serviceBrand: undefined;
    onDidChange: Event<LanguageConfigurationServiceChangeEvent>;
    /**
     * @param priority Use a higher number for higher priority
     */
    register(languageId: string, configuration: LanguageConfiguration, priority?: number): IDisposable;
    getLanguageConfiguration(languageId: string): ResolvedLanguageConfiguration;
}
declare const ILanguageConfigurationService: ServiceIdentifier<ILanguageConfigurationService>;
/**
 * Immutable.
*/
declare class ResolvedLanguageConfiguration {
    readonly languageId: string;
    readonly underlyingConfig: LanguageConfiguration;
    private _brackets;
    private _electricCharacter;
    private readonly _onEnterSupport;
    readonly comments: ICommentsConfiguration | null;
    readonly characterPair: CharacterPairSupport;
    readonly wordDefinition: RegExp;
    readonly indentRulesSupport: IndentRulesSupport | null;
    readonly indentationRules: IndentationRule | undefined;
    readonly foldingRules: FoldingRules;
    readonly bracketsNew: LanguageBracketsConfiguration;
    constructor(languageId: string, underlyingConfig: LanguageConfiguration);
    getWordDefinition(): RegExp;
    get brackets(): RichEditBrackets | null;
    get electricCharacter(): BracketElectricCharacterSupport | null;
    onEnter(autoIndent: EditorAutoIndentStrategy, previousLineText: string, beforeEnterText: string, afterEnterText: string): EnterAction | null;
    getAutoClosingPairs(): AutoClosingPairs;
    getAutoCloseBeforeSet(forQuotes: boolean): string;
    getSurroundingPairs(): IAutoClosingPair[];
    private static _handleComments;
}

/**
 * Vertical Lane in the overview ruler of the editor.
 */
declare enum OverviewRulerLane {
    Left = 1,
    Center = 2,
    Right = 4,
    Full = 7
}
/**
 * Position in the minimap to render the decoration.
 */
declare enum MinimapPosition {
    Inline = 1,
    Gutter = 2
}
interface IDecorationOptions {
    /**
     * CSS color to render.
     * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
     */
    color: string | ThemeColor | undefined;
    /**
     * CSS color to render.
     * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
     */
    darkColor?: string | ThemeColor;
}
/**
 * Options for rendering a model decoration in the overview ruler.
 */
interface IModelDecorationOverviewRulerOptions extends IDecorationOptions {
    /**
     * The position in the overview ruler.
     */
    position: OverviewRulerLane;
}
/**
 * Options for rendering a model decoration in the overview ruler.
 */
interface IModelDecorationMinimapOptions extends IDecorationOptions {
    /**
     * The position in the overview ruler.
     */
    position: MinimapPosition;
}
/**
 * Options for a model decoration.
 */
interface IModelDecorationOptions {
    /**
     * A debug description that can be used for inspecting model decorations.
     * @internal
     */
    description: string;
    /**
     * Customize the growing behavior of the decoration when typing at the edges of the decoration.
     * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
     */
    stickiness?: TrackedRangeStickiness;
    /**
     * CSS class name describing the decoration.
     */
    className?: string | null;
    blockClassName?: string | null;
    /**
     * Indicates if this block should be rendered after the last line.
     * In this case, the range must be empty and set to the last line.
     */
    blockIsAfterEnd?: boolean | null;
    /**
     * Message to be rendered when hovering over the glyph margin decoration.
     */
    glyphMarginHoverMessage?: IMarkdownString | IMarkdownString[] | null;
    /**
     * Array of MarkdownString to render as the decoration message.
     */
    hoverMessage?: IMarkdownString | IMarkdownString[] | null;
    /**
     * Should the decoration expand to encompass a whole line.
     */
    isWholeLine?: boolean;
    /**
     * Always render the decoration (even when the range it encompasses is collapsed).
     */
    showIfCollapsed?: boolean;
    /**
     * Collapse the decoration if its entire range is being replaced via an edit.
     * @internal
     */
    collapseOnReplaceEdit?: boolean;
    /**
     * Specifies the stack order of a decoration.
     * A decoration with greater stack order is always in front of a decoration with
     * a lower stack order when the decorations are on the same line.
     */
    zIndex?: number;
    /**
     * If set, render this decoration in the overview ruler.
     */
    overviewRuler?: IModelDecorationOverviewRulerOptions | null;
    /**
     * If set, render this decoration in the minimap.
     */
    minimap?: IModelDecorationMinimapOptions | null;
    /**
     * If set, the decoration will be rendered in the glyph margin with this CSS class name.
     */
    glyphMarginClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the lines decorations with this CSS class name.
     */
    linesDecorationsClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.
     */
    firstLineDecorationClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
     */
    marginClassName?: string | null;
    /**
     * If set, the decoration will be rendered inline with the text with this CSS class name.
     * Please use this only for CSS rules that must impact the text. For example, use `className`
     * to have a background color decoration.
     */
    inlineClassName?: string | null;
    /**
     * If there is an `inlineClassName` which affects letter spacing.
     */
    inlineClassNameAffectsLetterSpacing?: boolean;
    /**
     * If set, the decoration will be rendered before the text with this CSS class name.
     */
    beforeContentClassName?: string | null;
    /**
     * If set, the decoration will be rendered after the text with this CSS class name.
     */
    afterContentClassName?: string | null;
    /**
     * If set, text will be injected in the view after the range.
     */
    after?: InjectedTextOptions | null;
    /**
     * If set, text will be injected in the view before the range.
     */
    before?: InjectedTextOptions | null;
    /**
     * If set, this decoration will not be rendered for comment tokens.
     * @internal
    */
    hideInCommentTokens?: boolean | null;
    /**
     * If set, this decoration will not be rendered for string tokens.
     * @internal
    */
    hideInStringTokens?: boolean | null;
}
/**
 * Configures text that is injected into the view without changing the underlying document.
*/
interface InjectedTextOptions {
    /**
     * Sets the text to inject. Must be a single line.
     */
    readonly content: string;
    /**
     * If set, the decoration will be rendered inline with the text with this CSS class name.
     */
    readonly inlineClassName?: string | null;
    /**
     * If there is an `inlineClassName` which affects letter spacing.
     */
    readonly inlineClassNameAffectsLetterSpacing?: boolean;
    /**
     * This field allows to attach data to this injected text.
     * The data can be read when injected texts at a given position are queried.
     */
    readonly attachedData?: unknown;
    /**
     * Configures cursor stops around injected text.
     * Defaults to {@link InjectedTextCursorStops.Both}.
    */
    readonly cursorStops?: InjectedTextCursorStops | null;
}
declare enum InjectedTextCursorStops {
    Both = 0,
    Right = 1,
    Left = 2,
    None = 3
}
/**
 * New model decorations.
 */
interface IModelDeltaDecoration {
    /**
     * Range that this decoration covers.
     */
    range: IRange;
    /**
     * Options associated with this decoration.
     */
    options: IModelDecorationOptions;
}
/**
 * An accessor that can add, change or remove model decorations.
 * @internal
 */
interface IModelDecorationsChangeAccessor {
    /**
     * Add a new decoration.
     * @param range Range that this decoration covers.
     * @param options Options associated with this decoration.
     * @return An unique identifier associated with this decoration.
     */
    addDecoration(range: IRange, options: IModelDecorationOptions): string;
    /**
     * Change the range that an existing decoration covers.
     * @param id The unique identifier associated with the decoration.
     * @param newRange The new range that this decoration covers.
     */
    changeDecoration(id: string, newRange: IRange): void;
    /**
     * Change the options associated with an existing decoration.
     * @param id The unique identifier associated with the decoration.
     * @param newOptions The new options associated with this decoration.
     */
    changeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;
    /**
     * Remove an existing decoration.
     * @param id The unique identifier associated with the decoration.
     */
    removeDecoration(id: string): void;
    /**
     * Perform a minimum amount of operations, in order to transform the decorations
     * identified by `oldDecorations` to the decorations described by `newDecorations`
     * and returns the new identifiers associated with the resulting decorations.
     *
     * @param oldDecorations Array containing previous decorations identifiers.
     * @param newDecorations Array describing what decorations should result after the call.
     * @return An array containing the new decorations identifiers.
     */
    deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
}
/**
 * End of line character preference.
 */
declare const enum EndOfLineSequence {
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 0,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 1
}
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
 */
declare const enum TrackedRangeStickiness {
    AlwaysGrowsWhenTypingAtEdges = 0,
    NeverGrowsWhenTypingAtEdges = 1,
    GrowsOnlyWhenTypingBefore = 2,
    GrowsOnlyWhenTypingAfter = 3
}
/**
 * A model.
 */
type ITextModel = monaco.editor.ITextModel

/**
 * Configuration options for auto indentation in the editor
 */
declare const enum EditorAutoIndentStrategy {
    None = 0,
    Keep = 1,
    Brackets = 2,
    Advanced = 3,
    Full = 4
}

/**
 * An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.
 */
interface IEditorContribution {
    /**
     * Dispose this contribution.
     */
    dispose(): void;
    /**
     * Store view state.
     */
    saveViewState?(): any;
    /**
     * Restore view state.
     */
    restoreViewState?(state: any): void;
}

type ColorIdentifier = string;
declare const enum ColorTransformType {
    Darken = 0,
    Lighten = 1,
    Transparent = 2,
    Opaque = 3,
    OneOf = 4,
    LessProminent = 5,
    IfDefinedThenElse = 6
}
type ColorTransform = {
    op: ColorTransformType.Darken;
    value: ColorValue;
    factor: number;
} | {
    op: ColorTransformType.Lighten;
    value: ColorValue;
    factor: number;
} | {
    op: ColorTransformType.Transparent;
    value: ColorValue;
    factor: number;
} | {
    op: ColorTransformType.Opaque;
    value: ColorValue;
    background: ColorValue;
} | {
    op: ColorTransformType.OneOf;
    values: readonly ColorValue[];
} | {
    op: ColorTransformType.LessProminent;
    value: ColorValue;
    background: ColorValue;
    factor: number;
    transparency: number;
} | {
    op: ColorTransformType.IfDefinedThenElse;
    if: ColorIdentifier;
    then: ColorValue;
    else: ColorValue;
};
interface ColorDefaults {
    light: ColorValue | null;
    dark: ColorValue | null;
    hcDark: ColorValue | null;
    hcLight: ColorValue | null;
}
/**
 * A Color Value is either a color literal, a reference to an other color or a derived color
 */
type ColorValue = Color | string | ColorIdentifier | ColorTransform;
declare function registerColor(id: string, defaults: ColorDefaults | null, description: string, needsTransparency?: boolean, deprecationMessage?: string): ColorIdentifier;

/**
 * A rich code editor.
 */
type ICodeEditor = monaco.editor.ICodeEditor

interface IAction {
    readonly id: string;
    label: string;
    tooltip: string;
    class: string | undefined;
    enabled: boolean;
    checked?: boolean;
    run(event?: unknown): unknown;
}

type TypeConstraint = string | Function;

type ICommandsMap = Map<string, ICommand>;
interface ICommandHandler {
    (accessor: ServicesAccessor, ...args: any[]): void;
}
interface ICommand {
    id: string;
    handler: ICommandHandler;
    description?: ICommandHandlerDescription | null;
}
interface ICommandHandlerDescription {
    readonly description: string;
    readonly args: ReadonlyArray<{
        readonly name: string;
        readonly isOptional?: boolean;
        readonly description?: string;
        readonly constraint?: TypeConstraint;
        readonly schema?: IJSONSchema;
    }>;
    readonly returns?: string;
}
interface ICommandRegistry {
    onDidRegisterCommand: Event<string>;
    registerCommand(id: string, command: ICommandHandler): IDisposable;
    registerCommand(command: ICommand): IDisposable;
    registerCommandAlias(oldId: string, newId: string): IDisposable;
    getCommand(id: string): ICommand | undefined;
    getCommands(): ICommandsMap;
}
declare const CommandsRegistry: ICommandRegistry;

type Severity = Severity$1;
type NotificationMessage = string | Error;
interface INotificationProperties {
    /**
     * Sticky notifications are not automatically removed after a certain timeout. By
     * default, notifications with primary actions and severity error are always sticky.
     */
    readonly sticky?: boolean;
    /**
     * Silent notifications are not shown to the user unless the notification center
     * is opened. The status bar will still indicate all number of notifications to
     * catch some attention.
     */
    readonly silent?: boolean;
    /**
     * Adds an action to never show the notification again. The choice will be persisted
     * such as future requests will not cause the notification to show again.
     */
    readonly neverShowAgain?: INeverShowAgainOptions;
}
declare enum NeverShowAgainScope {
    /**
     * Will never show this notification on the current workspace again.
     */
    WORKSPACE = 0,
    /**
     * Will never show this notification on any workspace of the same
     * profile again.
     */
    PROFILE = 1,
    /**
     * Will never show this notification on any workspace across all
     * profiles again.
     */
    APPLICATION = 2
}
interface INeverShowAgainOptions {
    /**
     * The id is used to persist the selection of not showing the notification again.
     */
    readonly id: string;
    /**
     * By default the action will show up as primary action. Setting this to true will
     * make it a secondary action instead.
     */
    readonly isSecondary?: boolean;
    /**
     * Whether to persist the choice in the current workspace or for all workspaces. By
     * default it will be persisted for all workspaces across all profiles
     * (= `NeverShowAgainScope.APPLICATION`).
     */
    readonly scope?: NeverShowAgainScope;
}
interface INotification extends INotificationProperties {
    /**
     * The id of the notification. If provided, will be used to compare
     * notifications with others to decide whether a notification is
     * duplicate or not.
     */
    readonly id?: string;
    /**
     * The severity of the notification. Either `Info`, `Warning` or `Error`.
     */
    readonly severity: Severity;
    /**
     * The message of the notification. This can either be a `string` or `Error`. Messages
     * can optionally include links in the format: `[text](link)`
     */
    readonly message: NotificationMessage;
    /**
     * The source of the notification appears as additional information.
     */
    readonly source?: string | {
        label: string;
        id: string;
    };
    /**
     * Actions to show as part of the notification. Primary actions show up as
     * buttons as part of the message and will close the notification once clicked.
     *
     * Secondary actions are meant to provide additional configuration or context
     * for the notification and will show up less prominent. A notification does not
     * close automatically when invoking a secondary action.
     *
     * **Note:** If your intent is to show a message with actions to the user, consider
     * the `INotificationService.prompt()` method instead which are optimized for
     * this usecase and much easier to use!
     */
    actions?: INotificationActions;
    /**
     * The initial set of progress properties for the notification. To update progress
     * later on, access the `INotificationHandle.progress` property.
     */
    readonly progress?: INotificationProgressProperties;
}
interface INotificationActions {
    /**
     * Primary actions show up as buttons as part of the message and will close
     * the notification once clicked.
     *
     * Pass `ActionWithMenuAction` for an action that has additional menu actions.
     */
    readonly primary?: readonly IAction[];
    /**
     * Secondary actions are meant to provide additional configuration or context
     * for the notification and will show up less prominent. A notification does not
     * close automatically when invoking a secondary action.
     */
    readonly secondary?: readonly IAction[];
}
interface INotificationProgressProperties {
    /**
     * Causes the progress bar to spin infinitley.
     */
    readonly infinite?: boolean;
    /**
     * Indicate the total amount of work.
     */
    readonly total?: number;
    /**
     * Indicate that a specific chunk of work is done.
     */
    readonly worked?: number;
}
interface INotificationProgress {
    /**
     * Causes the progress bar to spin infinitley.
     */
    infinite(): void;
    /**
     * Indicate the total amount of work.
     */
    total(value: number): void;
    /**
     * Indicate that a specific chunk of work is done.
     */
    worked(value: number): void;
    /**
     * Indicate that the long running operation is done.
     */
    done(): void;
}
interface INotificationHandle {
    /**
     * Will be fired once the notification is closed.
     */
    readonly onDidClose: Event<void>;
    /**
     * Will be fired whenever the visibility of the notification changes.
     * A notification can either be visible as toast or inside the notification
     * center if it is visible.
     */
    readonly onDidChangeVisibility: Event<boolean>;
    /**
     * Allows to indicate progress on the notification even after the
     * notification is already visible.
     */
    readonly progress: INotificationProgress;
    /**
     * Allows to update the severity of the notification.
     */
    updateSeverity(severity: Severity): void;
    /**
     * Allows to update the message of the notification even after the
     * notification is already visible.
     */
    updateMessage(message: NotificationMessage): void;
    /**
     * Allows to update the actions of the notification even after the
     * notification is already visible.
     */
    updateActions(actions?: INotificationActions): void;
    /**
     * Hide the notification and remove it from the notification center.
     */
    close(): void;
}
interface IBasePromptChoice {
    /**
     * Label to show for the choice to the user.
     */
    readonly label: string;
    /**
     * Whether to keep the notification open after the choice was selected
     * by the user. By default, will close the notification upon click.
     */
    readonly keepOpen?: boolean;
    /**
     * Triggered when the user selects the choice.
     */
    run: () => void;
}
interface IPromptChoice extends IBasePromptChoice {
    /**
     * Primary choices show up as buttons in the notification below the message.
     * Secondary choices show up under the gear icon in the header of the notification.
     */
    readonly isSecondary?: boolean;
}
interface IPromptChoiceWithMenu extends IPromptChoice {
    /**
     * Additional choices those will be shown in the dropdown menu for this choice.
     */
    readonly menu: IBasePromptChoice[];
    /**
     * Menu is not supported on secondary choices
     */
    readonly isSecondary: false | undefined;
}
interface IPromptOptions extends INotificationProperties {
    /**
     * Will be called if the user closed the notification without picking
     * any of the provided choices.
     */
    onCancel?: () => void;
}
interface IStatusMessageOptions {
    /**
     * An optional timeout after which the status message should show. By default
     * the status message will show immediately.
     */
    readonly showAfter?: number;
    /**
     * An optional timeout after which the status message is to be hidden. By default
     * the status message will not hide until another status message is displayed.
     */
    readonly hideAfter?: number;
}
declare const INotificationService: ServiceIdentifier<INotificationService>;
/**
 * A service to bring up notifications and non-modal prompts.
 *
 * Note: use the `IDialogService` for a modal way to ask the user for input.
 */
interface INotificationService {
    readonly _serviceBrand: undefined;
    /**
     * The DND mode can be enabled or disabled
     * and will result in all info and warning
     * notifications to be silent.
     */
    doNotDisturbMode: boolean;
    /**
     * Emitted when a new notification is added.
     */
    readonly onDidAddNotification: Event<INotification>;
    /**
     * Emitted when a notification is removed.
     */
    readonly onDidRemoveNotification: Event<INotification>;
    /**
     * Emitted when a do not disturb mode has changed.
     */
    readonly onDidChangeDoNotDisturbMode: Event<void>;
    /**
     * Show the provided notification to the user. The returned `INotificationHandle`
     * can be used to control the notification afterwards.
     *
     * **Note:** If your intent is to show a message with actions to the user, consider
     * the `INotificationService.prompt()` method instead which are optimized for
     * this usecase and much easier to use!
     *
     * @returns a handle on the notification to e.g. hide it or update message, buttons, etc.
     */
    notify(notification: INotification): INotificationHandle;
    /**
     * A convenient way of reporting infos. Use the `INotificationService.notify`
     * method if you need more control over the notification.
     */
    info(message: NotificationMessage | NotificationMessage[]): void;
    /**
     * A convenient way of reporting warnings. Use the `INotificationService.notify`
     * method if you need more control over the notification.
     */
    warn(message: NotificationMessage | NotificationMessage[]): void;
    /**
     * A convenient way of reporting errors. Use the `INotificationService.notify`
     * method if you need more control over the notification.
     */
    error(message: NotificationMessage | NotificationMessage[]): void;
    /**
     * Shows a prompt in the notification area with the provided choices. The prompt
     * is non-modal. If you want to show a modal dialog instead, use `IDialogService`.
     *
     * @param severity the severity of the notification. Either `Info`, `Warning` or `Error`.
     * @param message the message to show as status.
     * @param choices options to be chosen from.
     * @param options provides some optional configuration options.
     *
     * @returns a handle on the notification to e.g. hide it or update message, buttons, etc.
     */
    prompt(severity: Severity, message: string, choices: (IPromptChoice | IPromptChoiceWithMenu)[], options?: IPromptOptions): INotificationHandle;
    /**
     * Shows a status message in the status area with the provided text.
     *
     * @param message the message to show as status
     * @param options provides some optional configuration options
     *
     * @returns a disposable to hide the status message
     */
    status(message: NotificationMessage, options?: IStatusMessageOptions): IDisposable;
}

interface IRelativePattern {
    /**
     * A base file path to which this pattern will be matched against relatively.
     */
    readonly base: string;
    /**
     * A file glob pattern like `*.{ts,js}` that will be matched on file paths
     * relative to the base path.
     *
     * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,
     * the file glob pattern will match on `index.js`.
     */
    readonly pattern: string;
}

interface LanguageFilter {
    readonly language?: string;
    readonly scheme?: string;
    readonly pattern?: string | IRelativePattern;
    readonly notebookType?: string;
    /**
     * This provider is implemented in the UI thread.
     */
    readonly hasAccessToAllModels?: boolean;
    readonly exclusive?: boolean;
}
type LanguageSelector = string | LanguageFilter | ReadonlyArray<string | LanguageFilter>;

interface NotebookInfo {
    readonly uri: URI;
    readonly type: string;
}
interface NotebookInfoResolver {
    (uri: URI): NotebookInfo | undefined;
}
declare class LanguageFeatureRegistry<T> {
    private readonly _notebookInfoResolver?;
    private _clock;
    private readonly _entries;
    private readonly _onDidChange;
    readonly onDidChange: Event<number>;
    constructor(_notebookInfoResolver?: NotebookInfoResolver | undefined);
    register(selector: LanguageSelector, provider: T): IDisposable;
    has(model: ITextModel): boolean;
    all(model: ITextModel): T[];
    ordered(model: ITextModel): T[];
    orderedGroups(model: ITextModel): T[][];
    private _orderedForEach;
    private _lastCandidate;
    private _updateScores;
    private static _compareByScoreAndTime;
}

declare const ILanguageFeaturesService: ServiceIdentifier<ILanguageFeaturesService>;
interface ILanguageFeaturesService {
    readonly _serviceBrand: undefined;
    readonly referenceProvider: LanguageFeatureRegistry<ReferenceProvider>;
    readonly definitionProvider: LanguageFeatureRegistry<DefinitionProvider>;
    readonly typeDefinitionProvider: LanguageFeatureRegistry<TypeDefinitionProvider>;
    readonly declarationProvider: LanguageFeatureRegistry<DeclarationProvider>;
    readonly implementationProvider: LanguageFeatureRegistry<ImplementationProvider>;
    readonly codeActionProvider: LanguageFeatureRegistry<CodeActionProvider>;
    readonly documentPasteEditProvider: LanguageFeatureRegistry<DocumentPasteEditProvider>;
    readonly renameProvider: LanguageFeatureRegistry<RenameProvider>;
    readonly documentFormattingEditProvider: LanguageFeatureRegistry<DocumentFormattingEditProvider>;
    readonly documentRangeFormattingEditProvider: LanguageFeatureRegistry<DocumentRangeFormattingEditProvider>;
    readonly onTypeFormattingEditProvider: LanguageFeatureRegistry<OnTypeFormattingEditProvider>;
    readonly documentSymbolProvider: LanguageFeatureRegistry<DocumentSymbolProvider>;
    readonly inlayHintsProvider: LanguageFeatureRegistry<InlayHintsProvider>;
    readonly colorProvider: LanguageFeatureRegistry<DocumentColorProvider>;
    readonly codeLensProvider: LanguageFeatureRegistry<CodeLensProvider>;
    readonly signatureHelpProvider: LanguageFeatureRegistry<SignatureHelpProvider>;
    readonly hoverProvider: LanguageFeatureRegistry<HoverProvider>;
    readonly documentHighlightProvider: LanguageFeatureRegistry<DocumentHighlightProvider>;
    readonly documentRangeSemanticTokensProvider: LanguageFeatureRegistry<DocumentRangeSemanticTokensProvider>;
    readonly documentSemanticTokensProvider: LanguageFeatureRegistry<DocumentSemanticTokensProvider>;
    readonly selectionRangeProvider: LanguageFeatureRegistry<SelectionRangeProvider>;
    readonly foldingRangeProvider: LanguageFeatureRegistry<FoldingRangeProvider>;
    readonly linkProvider: LanguageFeatureRegistry<LinkProvider>;
    readonly inlineCompletionsProvider: LanguageFeatureRegistry<InlineCompletionsProvider>;
    readonly completionProvider: LanguageFeatureRegistry<CompletionItemProvider>;
    readonly linkedEditingRangeProvider: LanguageFeatureRegistry<LinkedEditingRangeProvider>;
    readonly inlineValuesProvider: LanguageFeatureRegistry<InlineValuesProvider>;
    readonly evaluatableExpressionProvider: LanguageFeatureRegistry<EvaluatableExpressionProvider>;
    readonly documentOnDropEditProvider: LanguageFeatureRegistry<DocumentOnDropEditProvider>;
    setNotebookTypeResolver(resolver: NotebookInfoResolver | undefined): void;
}

/**
 * The options to create an editor.
 */
type IStandaloneEditorConstructionOptions = monaco.editor.IStandaloneEditorConstructionOptions
/**
 * The options to create a diff editor.
 */
type IStandaloneDiffEditorConstructionOptions = monaco.editor.IStandaloneDiffEditorConstructionOptions
type IStandaloneCodeEditor = monaco.editor.IStandaloneCodeEditor
type IStandaloneDiffEditor = monaco.editor.IStandaloneDiffEditor

declare const ILanguageFeatureDebounceService: ServiceIdentifier<ILanguageFeatureDebounceService>;
interface ILanguageFeatureDebounceService {
    readonly _serviceBrand: undefined;
    for(feature: LanguageFeatureRegistry<object>, debugName: string, config?: {
        min?: number;
        max?: number;
        salt?: string;
    }): IFeatureDebounceInformation;
}
interface IFeatureDebounceInformation {
    get(model: ITextModel): number;
    update(model: ITextModel, value: number): number;
    default(): number;
}

type IEditorOverrideServices = monaco.editor.IEditorOverrideServices

/**
 * Create a new editor under `domElement`.
 * `domElement` should be empty (not contain other dom nodes).
 * The editor will read the size of `domElement`.
 */
declare function create(domElement: HTMLElement, options?: IStandaloneEditorConstructionOptions, override?: IEditorOverrideServices): IStandaloneCodeEditor;
/**
 * Create a new diff editor under `domElement`.
 * `domElement` should be empty (not contain other dom nodes).
 * The editor will read the size of `domElement`.
 */
declare function createDiffEditor(domElement: HTMLElement, options?: IStandaloneDiffEditorConstructionOptions, override?: IEditorOverrideServices): IStandaloneDiffEditor;

interface ErrorListenerCallback {
    (error: any): void;
}
interface ErrorListenerUnbind {
    (): void;
}
declare class ErrorHandler {
    private unexpectedErrorHandler;
    private listeners;
    constructor();
    addListener(listener: ErrorListenerCallback): ErrorListenerUnbind;
    private emit;
    private _removeListener;
    setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void;
    getUnexpectedErrorHandler(): (e: any) => void;
    onUnexpectedError(e: any): void;
    onUnexpectedExternalError(e: any): void;
}
declare const errorHandler: ErrorHandler;

interface ILineRange {
    startLineNumber: number;
    endLineNumber: number;
}
declare const enum FoldSource {
    provider = 0,
    userDefined = 1,
    recovered = 2
}
interface FoldRange {
    startLineNumber: number;
    endLineNumber: number;
    type: string | undefined;
    isCollapsed: boolean;
    source: FoldSource;
}
declare class FoldingRegions {
    private readonly _startIndexes;
    private readonly _endIndexes;
    private readonly _collapseStates;
    private readonly _userDefinedStates;
    private readonly _recoveredStates;
    private _parentsComputed;
    private readonly _types;
    constructor(startIndexes: Uint32Array, endIndexes: Uint32Array, types?: Array<string | undefined>);
    private ensureParentIndices;
    get length(): number;
    getStartLineNumber(index: number): number;
    getEndLineNumber(index: number): number;
    getType(index: number): string | undefined;
    hasTypes(): boolean;
    isCollapsed(index: number): boolean;
    setCollapsed(index: number, newState: boolean): void;
    private isUserDefined;
    private setUserDefined;
    private isRecovered;
    private setRecovered;
    getSource(index: number): FoldSource;
    setSource(index: number, source: FoldSource): void;
    setCollapsedAllOfType(type: string, newState: boolean): boolean;
    toRegion(index: number): FoldingRegion;
    getParentIndex(index: number): number;
    contains(index: number, line: number): boolean;
    private findIndex;
    findRange(line: number): number;
    toString(): string;
    toFoldRange(index: number): FoldRange;
    static fromFoldRanges(ranges: FoldRange[]): FoldingRegions;
    /**
     * Two inputs, each a FoldingRegions or a FoldRange[], are merged.
     * Each input must be pre-sorted on startLineNumber.
     * The first list is assumed to always include all regions currently defined by range providers.
     * The second list only contains the previously collapsed and all manual ranges.
     * If the line position matches, the range of the new range is taken, and the range is no longer manual
     * When an entry in one list overlaps an entry in the other, the second list's entry "wins" and
     * overlapping entries in the first list are discarded.
     * Invalid entries are discarded. An entry is invalid if:
     * 		the start and end line numbers aren't a valid range of line numbers,
     * 		it is out of sequence or has the same start line as a preceding entry,
     * 		it overlaps a preceding entry and is not fully contained by that entry.
     */
    static sanitizeAndMerge(rangesA: FoldingRegions | FoldRange[], rangesB: FoldingRegions | FoldRange[], maxLineNumber: number | undefined): FoldRange[];
}
declare class FoldingRegion {
    private readonly ranges;
    private index;
    constructor(ranges: FoldingRegions, index: number);
    get startLineNumber(): number;
    get endLineNumber(): number;
    get regionIndex(): number;
    get parentIndex(): number;
    get isCollapsed(): boolean;
    containedBy(range: ILineRange): boolean;
    containsLine(lineNumber: number): boolean;
    hidesLine(lineNumber: number): boolean;
}

interface IDecorationProvider {
    getDecorationOption(isCollapsed: boolean, isHidden: boolean, isManual: boolean): IModelDecorationOptions;
    changeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T): T | null;
    removeDecorations(decorationIds: string[]): void;
}
interface FoldingModelChangeEvent {
    model: FoldingModel;
    collapseStateChanged?: FoldingRegion[];
}
interface ILineMemento extends ILineRange {
    checksum?: number;
    isCollapsed?: boolean;
    source?: FoldSource;
}
type CollapseMemento = ILineMemento[];
declare class FoldingModel {
    private readonly _textModel;
    private readonly _decorationProvider;
    private _regions;
    private _editorDecorationIds;
    private readonly _updateEventEmitter;
    readonly onDidChange: Event<FoldingModelChangeEvent>;
    get regions(): FoldingRegions;
    get textModel(): ITextModel;
    get decorationProvider(): IDecorationProvider;
    constructor(textModel: ITextModel, decorationProvider: IDecorationProvider);
    toggleCollapseState(toggledRegions: FoldingRegion[]): void;
    removeManualRanges(ranges: ILineRange[]): void;
    update(newRegions: FoldingRegions, blockedLineNumers?: number[]): void;
    updatePost(newRegions: FoldingRegions): void;
    private _currentFoldedOrManualRanges;
    /**
     * Collapse state memento, for persistence only
     */
    getMemento(): CollapseMemento | undefined;
    /**
     * Apply persisted state, for persistence only
     */
    applyMemento(state: CollapseMemento): void;
    private _getLinesChecksum;
    dispose(): void;
    getAllRegionsAtLine(lineNumber: number, filter?: (r: FoldingRegion, level: number) => boolean): FoldingRegion[];
    getRegionAtLine(lineNumber: number): FoldingRegion | null;
    getRegionsInside(region: FoldingRegion | null, filter?: RegionFilter | RegionFilterWithLevel): FoldingRegion[];
}
type RegionFilter = (r: FoldingRegion) => boolean;
type RegionFilterWithLevel = (r: FoldingRegion, level: number) => boolean;
/**
 * Folds all regions for which the lines start with a given regex
 * @param foldingModel the folding model
 */
declare function setCollapseStateForMatchingLines(foldingModel: FoldingModel, regExp: RegExp, doCollapse: boolean): void;

interface FoldingStateMemento {
    collapsedRegions?: CollapseMemento;
    lineCount?: number;
    provider?: string;
    foldedImports?: boolean;
}
interface FoldingLimitReporter {
    readonly limit: number;
    update(computed: number, limited: number | false): void;
}
type FoldingRangeProviderSelector = (provider: FoldingRangeProvider[], document: ITextModel) => FoldingRangeProvider[] | undefined;
declare class FoldingController extends Disposable implements IEditorContribution {
    private readonly contextKeyService;
    private readonly languageConfigurationService;
    private readonly languageFeaturesService;
    static readonly ID = "editor.contrib.folding";
    static get(editor: ICodeEditor): FoldingController | null;
    private static _foldingRangeSelector;
    static getFoldingRangeProviders(languageFeaturesService: ILanguageFeaturesService, model: ITextModel): FoldingRangeProvider[];
    static setFoldingRangeProviderSelector(foldingRangeSelector: FoldingRangeProviderSelector): IDisposable;
    private readonly editor;
    private _isEnabled;
    private _useFoldingProviders;
    private _unfoldOnClickAfterEndOfLine;
    private _restoringViewState;
    private _foldingImportsByDefault;
    private _currentModelHasFoldedImports;
    private readonly foldingDecorationProvider;
    private foldingModel;
    private hiddenRangeModel;
    private rangeProvider;
    private foldingRegionPromise;
    private foldingModelPromise;
    private updateScheduler;
    private readonly updateDebounceInfo;
    private foldingEnabled;
    private cursorChangedScheduler;
    private readonly localToDispose;
    private mouseDownInfo;
    readonly _foldingLimitReporter: RangesLimitReporter;
    constructor(editor: ICodeEditor, contextKeyService: IContextKeyService, languageConfigurationService: ILanguageConfigurationService, notificationService: INotificationService, languageFeatureDebounceService: ILanguageFeatureDebounceService, languageFeaturesService: ILanguageFeaturesService);
    get limitReporter(): RangesLimitReporter;
    /**
     * Store view state.
     */
    saveViewState(): FoldingStateMemento | undefined;
    /**
     * Restore view state.
     */
    restoreViewState(state: FoldingStateMemento): void;
    private onModelChanged;
    private onFoldingStrategyChanged;
    private getRangeProvider;
    getFoldingModel(): Promise<FoldingModel | null> | null;
    private onDidChangeModelContent;
    triggerFoldingModelChanged(): void;
    private onHiddenRangesChanges;
    private onCursorPositionChanged;
    private revealCursor;
    private onEditorMouseDown;
    private onEditorMouseUp;
    reveal(position: IPosition): void;
}
declare class RangesLimitReporter implements FoldingLimitReporter {
    private readonly editor;
    constructor(editor: ICodeEditor);
    get limit(): number;
    private _onDidChange;
    readonly onDidChange: Event<void>;
    private _computed;
    private _limited;
    get computed(): number;
    get limited(): number | false;
    update(computed: number, limited: number | false): void;
}

interface IRegistry {
    /**
     * Adds the extension functions and properties defined by data to the
     * platform. The provided id must be unique.
     * @param id a unique identifier
     * @param data a contribution
     */
    add(id: string, data: any): void;
    /**
     * Returns true iff there is an extension with the provided id.
     * @param id an extension identifier
     */
    knows(id: string): boolean;
    /**
     * Returns the extension functions and properties defined by the specified key or null.
     * @param id an extension identifier
     */
    as<T>(id: string): T;
}
declare const Registry: IRegistry;

interface ISchemaContributions {
    schemas: {
        [id: string]: IJSONSchema;
    };
}
interface IJSONContributionRegistry {
    readonly onDidChangeSchema: Event<string>;
    /**
     * Register a schema to the registry.
     */
    registerSchema(uri: string, unresolvedSchemaContent: IJSONSchema): void;
    /**
     * Notifies all listeners that the content of the given schema has changed.
     * @param uri The id of the schema
     */
    notifySchemaChanged(uri: string): void;
    /**
     * Get all schemas
     */
    getSchemaContributions(): ISchemaContributions;
}

declare const createConfiguredEditor: typeof create;
declare const createConfiguredDiffEditor: typeof createDiffEditor;
declare const Extensions: {
    Configuration: string;
    JSONContribution: string;
};
type FileMatch = Partial<Record<string, string[]>>;
declare function getJsonSchemas(fileMatchs?: FileMatch): monaco.languages.json.DiagnosticsOptions['schemas'];
declare const onDidChangeJsonSchema: Event<string>;

export { CommandsRegistry, ContextKeyExprType, DisposableStore, Extensions, FoldingController, FoldingModel, IJSONContributionRegistry, IJSONSchema, Registry, createConfiguredDiffEditor, createConfiguredEditor, errorHandler, getJsonSchemas, onDidChangeJsonSchema, registerColor, setCollapseStateForMatchingLines };
