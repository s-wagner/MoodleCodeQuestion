import { _ as __decorate, E as Emitter, a as __param, T as TextFileOperationError, K as toBufferOrReadable, l as ITextFileService, I as IEditorService, n as IFileService, q as IWorkingCopyFileService, j as IUriIdentityService, o as IWorkbenchEnvironmentService, r as IPathService, e as IProductService, L as stringToSnapshot, m as mark, M as FileChangesEvent, v as FileOperationError, O as hasOpenReadWriteCloseCapability, P as hasReadWriteCapability, Q as hasFileReadStreamCapability, x as toFileSystemProviderErrorCode, F as FileSystemProviderErrorCode, R as ensureFileSystemProviderError, f as FileType, h as FilePermission, U as etag, V as FileOperationEvent, W as toFileOperationResult, X as ETAG_DISABLED, Y as hasFileAtomicReadCapability, Z as NotModifiedSinceFileOperationError, $ as TooLargeFileOperationError, a0 as hasFileFolderCopyCapability, a1 as hasFileCloneCapability, a2 as createFileSystemProviderError, a3 as FileSystemProviderError } from './services2.js';
import { z as bufferToReadable, B as bufferToStream, C as consumeStream, D as insert, E as isReadableStream, F as peekStream, G as peekReadable, H as streamToBuffer, J as transform, K as isReadableBufferedStream, L as listenStream, M as bufferedStreamToBuffer, O as readableToBuffer, Q as newWriteableBufferStream, T as newWriteableStream } from './polyfill.js';
import { b$ as SaveSourceRegistry, c0 as IWorkingCopyBackupService, I as IWorkingCopyService, bP as ILanguageDetectionService, c1 as IUntitledTextEditorService, bL as ILifecycleService, c2 as IFileDialogService, c3 as IFilesConfigurationService, c4 as IElevatedFileService, c5 as IDecorationsService, u as unsupported, D as Disposable$1 } from './missing-services.js';
import { C as CancellationTokenSource } from './cancellation.js';
import { VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { onUnexpectedError, canceled, ErrorNoTelemetry } from 'monaco-editor/esm/vs/base/common/errors.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { R as ResourceQueue } from './async.js';
import { Disposable, dispose, toDisposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Promises, raceCancellation } from 'monaco-editor/esm/vs/base/common/async.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
import { isEqual, basename, dirname, joinPath, extname as extname$1, isAbsolutePath, extUri, extUriIgnorePathCase } from 'monaco-editor/esm/vs/base/common/resources.js';
import { TernarySearchTree } from 'monaco-editor/esm/vs/base/common/ternarySearchTree.js';
import { firstOrDefault, coalesce } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { hash } from 'monaco-editor/esm/vs/base/common/hash.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { I as IExtensionResourceLoaderService, A as AbstractExtensionResourceLoaderService } from './extensionResourceLoader.js';
import { B as BaseTextEditorModel, N as NO_TYPE_ID, U as UTF8, c as createTextBufferFactoryFromStream, t as toEncodeReadable, a as toDecodeStream, b as UTF16be, d as UTF16le, e as UTF8_with_bom, f as encodingExists, T as TextFileEditorModel } from './textFileEditorModel.js';
import { withNullAsUndefined, assertIsDefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { getCharContainingOffset } from 'monaco-editor/esm/vs/base/common/strings.js';
import { ensureValidWordDefinition } from 'monaco-editor/esm/vs/editor/common/core/wordHelper.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ITextResourceConfigurationService } from 'monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { IAccessibilityService } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
import { IProgressService } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { createTextBufferFactoryFromSnapshot } from 'monaco-editor/esm/vs/editor/common/model/textModel.js';
import { PLAINTEXT_LANGUAGE_ID, PLAINTEXT_EXTENSION } from 'monaco-editor/esm/vs/editor/common/languages/modesRegistry.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { listErrorForeground } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { t as toLocalResource } from './resources.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { extname } from 'monaco-editor/esm/vs/base/common/path.js';
import { IDialogService } from 'monaco-editor/esm/vs/platform/dialogs/common/dialogs.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { WORKSPACE_EXTENSION, IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { registerSingleton } from 'monaco-editor/esm/vs/platform/instantiation/common/extensions.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
let UntitledTextEditorModel = class UntitledTextEditorModel extends BaseTextEditorModel {
    get name() {
        if (this.configuredLabelFormat === 'content' && !this.hasAssociatedFilePath && this.cachedModelFirstLineWords) {
            return this.cachedModelFirstLineWords;
        }
        return this.labelService.getUriBasenameLabel(this.resource);
    }
    constructor(resource, hasAssociatedFilePath, initialValue, preferredLanguageId, preferredEncoding, languageService, modelService, workingCopyBackupService, textResourceConfigurationService, workingCopyService, textFileService, labelService, editorService, languageDetectionService, accessibilityService) {
        super(modelService, languageService, languageDetectionService, accessibilityService);
        this.resource = resource;
        this.hasAssociatedFilePath = hasAssociatedFilePath;
        this.initialValue = initialValue;
        this.preferredLanguageId = preferredLanguageId;
        this.preferredEncoding = preferredEncoding;
        this.workingCopyBackupService = workingCopyBackupService;
        this.textResourceConfigurationService = textResourceConfigurationService;
        this.workingCopyService = workingCopyService;
        this.textFileService = textFileService;
        this.labelService = labelService;
        this.editorService = editorService;
        this._onDidChangeContent = this._register(( (new Emitter())));
        this.onDidChangeContent = this._onDidChangeContent.event;
        this._onDidChangeName = this._register(( (new Emitter())));
        this.onDidChangeName = this._onDidChangeName.event;
        this._onDidChangeDirty = this._register(( (new Emitter())));
        this.onDidChangeDirty = this._onDidChangeDirty.event;
        this._onDidChangeEncoding = this._register(( (new Emitter())));
        this.onDidChangeEncoding = this._onDidChangeEncoding.event;
        this._onDidSave = this._register(( (new Emitter())));
        this.onDidSave = this._onDidSave.event;
        this._onDidRevert = this._register(( (new Emitter())));
        this.onDidRevert = this._onDidRevert.event;
        this.typeId = NO_TYPE_ID;
        this.capabilities = 2 ;
        this.configuredLabelFormat = 'content';
        this.cachedModelFirstLineWords = undefined;
        this.dirty = this.hasAssociatedFilePath || !!this.initialValue;
        this._register(this.workingCopyService.registerWorkingCopy(this));
        if (preferredLanguageId) {
            this.setLanguageId(preferredLanguageId);
        }
        this.onConfigurationChange(undefined, false);
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.textResourceConfigurationService.onDidChangeConfiguration(e => this.onConfigurationChange(e, true)));
    }
    onConfigurationChange(e, fromEvent) {
        if (!e || e.affectsConfiguration(this.resource, 'files.encoding')) {
            const configuredEncoding = this.textResourceConfigurationService.getValue(this.resource, 'files.encoding');
            if (this.configuredEncoding !== configuredEncoding && typeof configuredEncoding === 'string') {
                this.configuredEncoding = configuredEncoding;
                if (fromEvent && !this.preferredEncoding) {
                    this._onDidChangeEncoding.fire();
                }
            }
        }
        if (!e || e.affectsConfiguration(this.resource, 'workbench.editor.untitled.labelFormat')) {
            const configuredLabelFormat = this.textResourceConfigurationService.getValue(this.resource, 'workbench.editor.untitled.labelFormat');
            if (this.configuredLabelFormat !== configuredLabelFormat && (configuredLabelFormat === 'content' || configuredLabelFormat === 'name')) {
                this.configuredLabelFormat = configuredLabelFormat;
                if (fromEvent) {
                    this._onDidChangeName.fire();
                }
            }
        }
    }
    setLanguageId(languageId, source) {
        const actualLanguage = languageId === UntitledTextEditorModel.ACTIVE_EDITOR_LANGUAGE_ID
            ? this.editorService.activeTextEditorLanguageId
            : languageId;
        this.preferredLanguageId = actualLanguage;
        if (actualLanguage) {
            super.setLanguageId(actualLanguage, source);
        }
    }
    getLanguageId() {
        if (this.textEditorModel) {
            return this.textEditorModel.getLanguageId();
        }
        return this.preferredLanguageId;
    }
    getEncoding() {
        return this.preferredEncoding || this.configuredEncoding;
    }
    async setEncoding(encoding) {
        const oldEncoding = this.getEncoding();
        this.preferredEncoding = encoding;
        if (oldEncoding !== this.preferredEncoding) {
            this._onDidChangeEncoding.fire();
        }
    }
    isDirty() {
        return this.dirty;
    }
    setDirty(dirty) {
        if (this.dirty === dirty) {
            return;
        }
        this.dirty = dirty;
        this._onDidChangeDirty.fire();
    }
    async save(options) {
        const target = await this.textFileService.save(this.resource, options);
        if (target) {
            this._onDidSave.fire({ reason: options?.reason, source: options?.source });
        }
        return !!target;
    }
    async revert() {
        this.setDirty(false);
        this._onDidRevert.fire();
        this.dispose();
    }
    async backup(token) {
        let content = undefined;
        if (this.isResolved()) {
            content = await this.textFileService.getEncodedReadable(this.resource, withNullAsUndefined(this.createSnapshot()), { encoding: UTF8 });
        }
        else if (typeof this.initialValue === 'string') {
            content = bufferToReadable(VSBuffer.fromString(this.initialValue));
        }
        return { content };
    }
    async resolve() {
        let createdUntitledModel = false;
        let hasBackup = false;
        if (!this.textEditorModel) {
            let untitledContents;
            const backup = await this.workingCopyBackupService.resolve(this);
            if (backup) {
                untitledContents = backup.value;
                hasBackup = true;
            }
            else {
                untitledContents = bufferToStream(VSBuffer.fromString(this.initialValue || ''));
            }
            const untitledContentsFactory = await createTextBufferFactoryFromStream(await this.textFileService.getDecodedStream(this.resource, untitledContents, { encoding: UTF8 }));
            this.createTextEditorModel(untitledContentsFactory, this.resource, this.preferredLanguageId);
            createdUntitledModel = true;
        }
        else {
            this.updateTextEditorModel(undefined, this.preferredLanguageId);
        }
        const textEditorModel = assertIsDefined(this.textEditorModel);
        this.installModelListeners(textEditorModel);
        if (createdUntitledModel) {
            if (hasBackup || this.initialValue) {
                this.updateNameFromFirstLine(textEditorModel);
            }
            this.setDirty(this.hasAssociatedFilePath || !!hasBackup || !!this.initialValue);
            if (hasBackup || this.initialValue) {
                this._onDidChangeContent.fire();
            }
        }
        return super.resolve();
    }
    installModelListeners(model) {
        this._register(model.onDidChangeContent(e => this.onModelContentChanged(model, e)));
        this._register(model.onDidChangeLanguage(() => this.onConfigurationChange(undefined, true)));
        super.installModelListeners(model);
    }
    onModelContentChanged(textEditorModel, e) {
        if (!this.hasAssociatedFilePath && textEditorModel.getLineCount() === 1 && textEditorModel.getLineContent(1) === '') {
            this.setDirty(false);
        }
        else {
            this.setDirty(true);
        }
        if (e.changes.some(change => (change.range.startLineNumber === 1 || change.range.endLineNumber === 1) && change.range.startColumn <= UntitledTextEditorModel.FIRST_LINE_NAME_CANDIDATE_MAX_LENGTH)) {
            this.updateNameFromFirstLine(textEditorModel);
        }
        this._onDidChangeContent.fire();
        this.autoDetectLanguage();
    }
    updateNameFromFirstLine(textEditorModel) {
        if (this.hasAssociatedFilePath) {
            return;
        }
        let modelFirstWordsCandidate = undefined;
        let firstLineText = textEditorModel
            .getValueInRange({
            startLineNumber: 1,
            endLineNumber: 1,
            startColumn: 1,
            endColumn: UntitledTextEditorModel.FIRST_LINE_NAME_CANDIDATE_MAX_LENGTH + 1
        })
            .trim().replace(/\s+/g, ' ');
        firstLineText = firstLineText.substr(0, getCharContainingOffset(
        firstLineText, UntitledTextEditorModel.FIRST_LINE_NAME_MAX_LENGTH)[0]);
        if (firstLineText && ensureValidWordDefinition().exec(firstLineText)) {
            modelFirstWordsCandidate = firstLineText;
        }
        if (modelFirstWordsCandidate !== this.cachedModelFirstLineWords) {
            this.cachedModelFirstLineWords = modelFirstWordsCandidate;
            this._onDidChangeName.fire();
        }
    }
    isReadonly() {
        return false;
    }
};
UntitledTextEditorModel.FIRST_LINE_NAME_MAX_LENGTH = 40;
UntitledTextEditorModel.FIRST_LINE_NAME_CANDIDATE_MAX_LENGTH = UntitledTextEditorModel.FIRST_LINE_NAME_MAX_LENGTH * 10;
UntitledTextEditorModel.ACTIVE_EDITOR_LANGUAGE_ID = '${activeEditorLanguage}';
UntitledTextEditorModel = ( (__decorate([
    ( (__param(5, ILanguageService))),
    ( (__param(6, IModelService))),
    ( (__param(7, IWorkingCopyBackupService))),
    ( (__param(8, ITextResourceConfigurationService))),
    ( (__param(9, IWorkingCopyService))),
    ( (__param(10, ITextFileService))),
    ( (__param(11, ILabelService))),
    ( (__param(12, IEditorService))),
    ( (__param(13, ILanguageDetectionService))),
    ( (__param(14, IAccessibilityService)))
], UntitledTextEditorModel)));
async function readFileIntoStream(provider, resource, target, transformer, options, token) {
    let error = undefined;
    try {
        await doReadFileIntoStream(provider, resource, target, transformer, options, token);
    }
    catch (err) {
        error = err;
    }
    finally {
        if (error && options.errorTransformer) {
            error = options.errorTransformer(error);
        }
        if (typeof error !== 'undefined') {
            target.error(error);
        }
        target.end();
    }
}
async function doReadFileIntoStream(provider, resource, target, transformer, options, token) {
    throwIfCancelled(token);
    const handle = await provider.open(resource, { create: false });
    try {
        throwIfCancelled(token);
        let totalBytesRead = 0;
        let bytesRead = 0;
        let allowedRemainingBytes = (options && typeof options.length === 'number') ? options.length : undefined;
        let buffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));
        let posInFile = options && typeof options.position === 'number' ? options.position : 0;
        let posInBuffer = 0;
        do {
            bytesRead = await provider.read(handle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);
            posInFile += bytesRead;
            posInBuffer += bytesRead;
            totalBytesRead += bytesRead;
            if (typeof allowedRemainingBytes === 'number') {
                allowedRemainingBytes -= bytesRead;
            }
            if (posInBuffer === buffer.byteLength) {
                await target.write(transformer(buffer));
                buffer = VSBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));
                posInBuffer = 0;
            }
        } while (bytesRead > 0 && (typeof allowedRemainingBytes !== 'number' || allowedRemainingBytes > 0) && throwIfCancelled(token) && throwIfTooLarge(totalBytesRead, options));
        if (posInBuffer > 0) {
            let lastChunkLength = posInBuffer;
            if (typeof allowedRemainingBytes === 'number') {
                lastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);
            }
            target.write(transformer(buffer.slice(0, lastChunkLength)));
        }
    }
    catch (error) {
        throw ensureFileSystemProviderError(error);
    }
    finally {
        await provider.close(handle);
    }
}
function throwIfCancelled(token) {
    if (token.isCancellationRequested) {
        throw canceled();
    }
    return true;
}
function throwIfTooLarge(totalBytesRead, options) {
    if (options?.limits) {
        if (typeof options.limits.memory === 'number' && totalBytesRead > options.limits.memory) {
            throw createFileSystemProviderError(localize('fileTooLargeForHeapError', "To open a file of this size, you need to restart and allow to use more memory"), FileSystemProviderErrorCode.FileExceedsMemoryLimit);
        }
        if (typeof options.limits.size === 'number' && totalBytesRead > options.limits.size) {
            throw createFileSystemProviderError(localize('fileTooLargeError', "File is too large to open"), FileSystemProviderErrorCode.FileTooLarge);
        }
    }
    return true;
}
let FileService = class FileService extends Disposable {
    constructor(logService) {
        super();
        this.logService = logService;
        this.BUFFER_SIZE = 256 * 1024;
        this._onDidChangeFileSystemProviderRegistrations = this._register(( (new Emitter())));
        this.onDidChangeFileSystemProviderRegistrations = this._onDidChangeFileSystemProviderRegistrations.event;
        this._onWillActivateFileSystemProvider = this._register(( (new Emitter())));
        this.onWillActivateFileSystemProvider = this._onWillActivateFileSystemProvider.event;
        this._onDidChangeFileSystemProviderCapabilities = this._register(( (new Emitter())));
        this.onDidChangeFileSystemProviderCapabilities = this._onDidChangeFileSystemProviderCapabilities.event;
        this.provider = ( (new Map()));
        this._onDidRunOperation = this._register(( (new Emitter())));
        this.onDidRunOperation = this._onDidRunOperation.event;
        this._onDidFilesChange = this._register(( (new Emitter())));
        this.onDidFilesChange = this._onDidFilesChange.event;
        this._onDidWatchError = this._register(( (new Emitter())));
        this.onDidWatchError = this._onDidWatchError.event;
        this.activeWatchers = ( (new Map()));
        this.writeQueue = this._register(( (new ResourceQueue())));
    }
    registerProvider(scheme, provider) {
        if (this.provider.has(scheme)) {
            throw new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);
        }
        mark(`code/registerFilesystem/${scheme}`);
        const providerDisposables = ( (new DisposableStore()));
        this.provider.set(scheme, provider);
        this._onDidChangeFileSystemProviderRegistrations.fire({ added: true, scheme, provider });
        providerDisposables.add(provider.onDidChangeFile(changes => this._onDidFilesChange.fire(( (new FileChangesEvent(changes, !this.isPathCaseSensitive(provider)))))));
        if (typeof provider.onDidWatchError === 'function') {
            providerDisposables.add(provider.onDidWatchError(error => this._onDidWatchError.fire(( (new Error(error))))));
        }
        providerDisposables.add(provider.onDidChangeCapabilities(() => this._onDidChangeFileSystemProviderCapabilities.fire({ provider, scheme })));
        return toDisposable(() => {
            this._onDidChangeFileSystemProviderRegistrations.fire({ added: false, scheme, provider });
            this.provider.delete(scheme);
            dispose(providerDisposables);
        });
    }
    getProvider(scheme) {
        return this.provider.get(scheme);
    }
    async activateProvider(scheme) {
        const joiners = [];
        this._onWillActivateFileSystemProvider.fire({
            scheme,
            join(promise) {
                joiners.push(promise);
            },
        });
        if (this.provider.has(scheme)) {
            return;
        }
        await Promises.settled(joiners);
    }
    async canHandleResource(resource) {
        await this.activateProvider(resource.scheme);
        return this.hasProvider(resource);
    }
    hasProvider(resource) {
        return this.provider.has(resource.scheme);
    }
    hasCapability(resource, capability) {
        const provider = this.provider.get(resource.scheme);
        return !!(provider && (provider.capabilities & capability));
    }
    listCapabilities() {
        return (
             (Iterable.map(
                this.provider,
                ([scheme, provider]) => ({ scheme, capabilities: provider.capabilities })
            ))
        );
    }
    async withProvider(resource) {
        if (!isAbsolutePath(resource)) {
            throw new FileOperationError(localize('invalidPath', "Unable to resolve filesystem provider with relative file path '{0}'", this.resourceForError(resource)), 8 );
        }
        await this.activateProvider(resource.scheme);
        const provider = this.provider.get(resource.scheme);
        if (!provider) {
            const error = ( (new ErrorNoTelemetry()));
            error.message = ( (localize(
                'noProviderFound',
                "ENOPRO: No file system provider found for resource '{0}'",
                 (resource.toString())
            )));
            throw error;
        }
        return provider;
    }
    async withReadProvider(resource) {
        const provider = await this.withProvider(resource);
        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider) || hasFileReadStreamCapability(provider)) {
            return provider;
        }
        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);
    }
    async withWriteProvider(resource) {
        const provider = await this.withProvider(resource);
        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {
            return provider;
        }
        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);
    }
    async resolve(resource, options) {
        try {
            return await this.doResolveFile(resource, options);
        }
        catch (error) {
            if (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {
                throw new FileOperationError(localize('fileNotFoundError', "Unable to resolve nonexistent file '{0}'", this.resourceForError(resource)), 1 );
            }
            throw ensureFileSystemProviderError(error);
        }
    }
    async doResolveFile(resource, options) {
        const provider = await this.withProvider(resource);
        const isPathCaseSensitive = this.isPathCaseSensitive(provider);
        const resolveTo = options?.resolveTo;
        const resolveSingleChildDescendants = options?.resolveSingleChildDescendants;
        const resolveMetadata = options?.resolveMetadata;
        const stat = await provider.stat(resource);
        let trie;
        return this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {
            if (!trie) {
                trie = TernarySearchTree.forUris(() => !isPathCaseSensitive);
                trie.set(resource, true);
                if (resolveTo) {
                    trie.fill(true, resolveTo);
                }
            }
            if (trie.get(stat.resource) || trie.findSuperstr(stat.resource.with({ query: null, fragment: null } ))) {
                return true;
            }
            if (stat.isDirectory && resolveSingleChildDescendants) {
                return siblings === 1;
            }
            return false;
        });
    }
    async toFileStat(provider, resource, stat, siblings, resolveMetadata, recurse) {
        const { providerExtUri } = this.getExtUri(provider);
        const fileStat = {
            resource,
            name: providerExtUri.basename(resource),
            isFile: (stat.type & FileType.File) !== 0,
            isDirectory: (stat.type & FileType.Directory) !== 0,
            isSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,
            mtime: stat.mtime,
            ctime: stat.ctime,
            size: stat.size,
            readonly: Boolean((stat.permissions ?? 0) & FilePermission.Readonly) || Boolean(provider.capabilities & 2048 ),
            etag: etag({ mtime: stat.mtime, size: stat.size }),
            children: undefined
        };
        if (fileStat.isDirectory && recurse(fileStat, siblings)) {
            try {
                const entries = await provider.readdir(resource);
                const resolvedEntries = await Promises.settled(( (entries.map(async ([name, type]) => {
                    try {
                        const childResource = providerExtUri.joinPath(resource, name);
                        const childStat = resolveMetadata ? await provider.stat(childResource) : { type };
                        return await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);
                    }
                    catch (error) {
                        this.logService.trace(error);
                        return null;
                    }
                }))));
                fileStat.children = coalesce(resolvedEntries);
            }
            catch (error) {
                this.logService.trace(error);
                fileStat.children = [];
            }
            return fileStat;
        }
        return fileStat;
    }
    async resolveAll(toResolve) {
        return Promises.settled(( (toResolve.map(async (entry) => {
            try {
                return { stat: await this.doResolveFile(entry.resource, entry.options), success: true };
            }
            catch (error) {
                this.logService.trace(error);
                return { stat: undefined, success: false };
            }
        }))));
    }
    async stat(resource) {
        const provider = await this.withProvider(resource);
        const stat = await provider.stat(resource);
        return this.toFileStat(provider, resource, stat, undefined, true, () => false );
    }
    async exists(resource) {
        const provider = await this.withProvider(resource);
        try {
            const stat = await provider.stat(resource);
            return !!stat;
        }
        catch (error) {
            return false;
        }
    }
    async canCreateFile(resource, options) {
        try {
            await this.doValidateCreateFile(resource, options);
        }
        catch (error) {
            return error;
        }
        return true;
    }
    async doValidateCreateFile(resource, options) {
        if (!options?.overwrite && (await this.exists(resource))) {
            throw new FileOperationError(localize('fileExists', "Unable to create file '{0}' that already exists when overwrite flag is not set", this.resourceForError(resource)), 3 , options);
        }
    }
    async createFile(resource, bufferOrReadableOrStream = VSBuffer.fromString(''), options) {
        await this.doValidateCreateFile(resource, options);
        const fileStat = await this.writeFile(resource, bufferOrReadableOrStream);
        this._onDidRunOperation.fire(( (new FileOperationEvent(resource, 0 , fileStat))));
        return fileStat;
    }
    async writeFile(resource, bufferOrReadableOrStream, options) {
        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);
        const { providerExtUri } = this.getExtUri(provider);
        try {
            const stat = await this.validateWriteFile(provider, resource, options);
            if (!stat) {
                await this.mkdirp(provider, providerExtUri.dirname(resource));
            }
            let bufferOrReadableOrStreamOrBufferedStream;
            if (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof VSBuffer)) {
                if (isReadableStream(bufferOrReadableOrStream)) {
                    const bufferedStream = await peekStream(bufferOrReadableOrStream, 3);
                    if (bufferedStream.ended) {
                        bufferOrReadableOrStreamOrBufferedStream = VSBuffer.concat(bufferedStream.buffer);
                    }
                    else {
                        bufferOrReadableOrStreamOrBufferedStream = bufferedStream;
                    }
                }
                else {
                    bufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => VSBuffer.concat(data), 3);
                }
            }
            else {
                bufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;
            }
            if (!hasOpenReadWriteCloseCapability(provider) || (hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer)) {
                await this.doWriteUnbuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream);
            }
            else {
                await this.doWriteBuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer ? bufferToReadable(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);
            }
            this._onDidRunOperation.fire(( (new FileOperationEvent(resource, 4 ))));
        }
        catch (error) {
            throw new FileOperationError(localize('err.write', "Unable to write file '{0}' ({1})", this.resourceForError(resource), ensureFileSystemProviderError(error).toString()), toFileOperationResult(error), options);
        }
        return this.resolve(resource, { resolveMetadata: true });
    }
    async validateWriteFile(provider, resource, options) {
        const unlock = !!options?.unlock;
        if (unlock && !((provider.capabilities & 8192) )) {
            throw new Error(localize('writeFailedUnlockUnsupported', "Unable to unlock file '{0}' because provider does not support it.", this.resourceForError(resource)));
        }
        let stat = undefined;
        try {
            stat = await provider.stat(resource);
        }
        catch (error) {
            return undefined;
        }
        if ((stat.type & FileType.Directory) !== 0) {
            throw new FileOperationError(localize('fileIsDirectoryWriteError', "Unable to write file '{0}' that is actually a directory", this.resourceForError(resource)), 0 , options);
        }
        this.throwIfFileIsReadonly(resource, stat);
        if (typeof options?.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&
            typeof stat.mtime === 'number' && typeof stat.size === 'number' &&
            options.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime , size: stat.size })) {
            throw new FileOperationError(localize('fileModifiedError', "File Modified Since"), 3 , options);
        }
        return stat;
    }
    async readFile(resource, options, token) {
        const provider = await this.withReadProvider(resource);
        if (options?.atomic) {
            return this.doReadFileAtomic(provider, resource, options, token);
        }
        return this.doReadFile(provider, resource, options, token);
    }
    async doReadFileAtomic(provider, resource, options, token) {
        return (
             (new Promise((resolve, reject) => {
                this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {
                    try {
                        const content = await this.doReadFile(provider, resource, options, token);
                        resolve(content);
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            }))
        );
    }
    async doReadFile(provider, resource, options, token) {
        const stream = await this.doReadFileStream(provider, resource, {
            ...options,
            preferUnbuffered: true
        }, token);
        return {
            ...stream,
            value: await streamToBuffer(stream.value)
        };
    }
    async readFileStream(resource, options, token) {
        const provider = await this.withReadProvider(resource);
        return this.doReadFileStream(provider, resource, options, token);
    }
    async doReadFileStream(provider, resource, options, token) {
        const cancellableSource = ( (new CancellationTokenSource(token)));
        const statPromise = this.validateReadFile(resource, options).then(stat => stat, error => {
            cancellableSource.cancel();
            throw error;
        });
        let fileStream = undefined;
        try {
            if (typeof options?.etag === 'string' && options.etag !== ETAG_DISABLED) {
                await statPromise;
            }
            if ((options?.atomic && hasFileAtomicReadCapability(provider)) ||
                !(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) ||
                (hasReadWriteCapability(provider) && options?.preferUnbuffered)
            ) {
                fileStream = this.readFileUnbuffered(provider, resource, options);
            }
            else if (hasFileReadStreamCapability(provider)) {
                fileStream = this.readFileStreamed(provider, resource, cancellableSource.token, options);
            }
            else {
                fileStream = this.readFileBuffered(provider, resource, cancellableSource.token, options);
            }
            const fileStat = await statPromise;
            return {
                ...fileStat,
                value: fileStream
            };
        }
        catch (error) {
            if (fileStream) {
                await consumeStream(fileStream);
            }
            throw this.restoreReadError(error, resource, options);
        }
    }
    restoreReadError(error, resource, options) {
        const message = ( (localize(
            'err.read',
            "Unable to read file '{0}' ({1})",
            this.resourceForError(resource),
             (ensureFileSystemProviderError(error).toString())
        )));
        if (error instanceof NotModifiedSinceFileOperationError) {
            return (
                 (new NotModifiedSinceFileOperationError(message, error.stat, options))
            );
        }
        if (error instanceof TooLargeFileOperationError) {
            return (
                 (new TooLargeFileOperationError(message, error.fileOperationResult, error.size, error.options))
            );
        }
        return (
             (new FileOperationError(message, toFileOperationResult(error), options))
        );
    }
    readFileStreamed(provider, resource, token, options = Object.create(null)) {
        const fileStream = provider.readFileStream(resource, options, token);
        return transform(fileStream, {
            data: data => data instanceof VSBuffer ? data : VSBuffer.wrap(data),
            error: error => this.restoreReadError(error, resource, options)
        }, data => VSBuffer.concat(data));
    }
    readFileBuffered(provider, resource, token, options = Object.create(null)) {
        const stream = newWriteableBufferStream();
        readFileIntoStream(provider, resource, stream, data => data, {
            ...options,
            bufferSize: this.BUFFER_SIZE,
            errorTransformer: error => this.restoreReadError(error, resource, options)
        }, token);
        return stream;
    }
    readFileUnbuffered(provider, resource, options) {
        const stream = newWriteableStream(data => VSBuffer.concat(data));
        (async () => {
            try {
                let buffer;
                if (options?.atomic && hasFileAtomicReadCapability(provider)) {
                    buffer = await provider.readFile(resource, { atomic: true });
                }
                else {
                    buffer = await provider.readFile(resource);
                }
                if (typeof options?.position === 'number') {
                    buffer = buffer.slice(options.position);
                }
                if (typeof options?.length === 'number') {
                    buffer = buffer.slice(0, options.length);
                }
                this.validateReadFileLimits(resource, buffer.byteLength, options);
                stream.end(VSBuffer.wrap(buffer));
            }
            catch (err) {
                stream.error(err);
                stream.end();
            }
        })();
        return stream;
    }
    async validateReadFile(resource, options) {
        const stat = await this.resolve(resource, { resolveMetadata: true });
        if (stat.isDirectory) {
            throw new FileOperationError(localize('fileIsDirectoryReadError', "Unable to read file '{0}' that is actually a directory", this.resourceForError(resource)), 0 , options);
        }
        if (typeof options?.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {
            throw new NotModifiedSinceFileOperationError(localize('fileNotModifiedError', "File not modified since"), stat, options);
        }
        this.validateReadFileLimits(resource, stat.size, options);
        return stat;
    }
    validateReadFileLimits(resource, size, options) {
        if (options?.limits) {
            let tooLargeErrorResult = undefined;
            if (typeof options.limits.memory === 'number' && size > options.limits.memory) {
                tooLargeErrorResult = 9 ;
            }
            if (typeof options.limits.size === 'number' && size > options.limits.size) {
                tooLargeErrorResult = 7 ;
            }
            if (typeof tooLargeErrorResult === 'number') {
                throw new TooLargeFileOperationError(localize('fileTooLargeError', "Unable to read file '{0}' that is too large to open", this.resourceForError(resource)), tooLargeErrorResult, size, options);
            }
        }
    }
    async canMove(source, target, overwrite) {
        return this.doCanMoveCopy(source, target, 'move', overwrite);
    }
    async canCopy(source, target, overwrite) {
        return this.doCanMoveCopy(source, target, 'copy', overwrite);
    }
    async doCanMoveCopy(source, target, mode, overwrite) {
        if (( (source.toString())) !== ( (target.toString()))) {
            try {
                const sourceProvider = mode === 'move' ? this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source) : await this.withReadProvider(source);
                const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);
                await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);
            }
            catch (error) {
                return error;
            }
        }
        return true;
    }
    async move(source, target, overwrite) {
        const sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);
        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);
        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);
        const fileStat = await this.resolve(target, { resolveMetadata: true });
        this._onDidRunOperation.fire(( (new FileOperationEvent(
            source,
            mode === 'move' ? 2  : 3 ,
            fileStat
        ))));
        return fileStat;
    }
    async copy(source, target, overwrite) {
        const sourceProvider = await this.withReadProvider(source);
        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);
        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);
        const fileStat = await this.resolve(target, { resolveMetadata: true });
        this._onDidRunOperation.fire(( (new FileOperationEvent(
            source,
            mode === 'copy' ? 3  : 2 ,
            fileStat
        ))));
        return fileStat;
    }
    async doMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite) {
        if (( (source.toString())) === ( (target.toString()))) {
            return mode;
        }
        const { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);
        if (exists && !isSameResourceWithDifferentPathCase && overwrite) {
            await this.del(target, { recursive: true });
        }
        await this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));
        if (mode === 'copy') {
            if (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {
                await sourceProvider.copy(source, target, { overwrite });
            }
            else {
                const sourceFile = await this.resolve(source);
                if (sourceFile.isDirectory) {
                    await this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);
                }
                else {
                    await this.doCopyFile(sourceProvider, source, targetProvider, target);
                }
            }
            return mode;
        }
        else {
            if (sourceProvider === targetProvider) {
                await sourceProvider.rename(source, target, { overwrite });
                return mode;
            }
            else {
                await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);
                await this.del(source, { recursive: true });
                return 'copy';
            }
        }
    }
    async doCopyFile(sourceProvider, source, targetProvider, target) {
        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {
            return this.doPipeBuffered(sourceProvider, source, targetProvider, target);
        }
        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {
            return this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);
        }
        if (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {
            return this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);
        }
        if (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {
            return this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);
        }
    }
    async doCopyFolder(sourceProvider, sourceFolder, targetProvider, targetFolder) {
        await targetProvider.mkdir(targetFolder);
        if (Array.isArray(sourceFolder.children)) {
            await Promises.settled(( (sourceFolder.children.map(async (sourceChild) => {
                const targetChild = this.getExtUri(targetProvider).providerExtUri.joinPath(targetFolder, sourceChild.name);
                if (sourceChild.isDirectory) {
                    return this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);
                }
                else {
                    return this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);
                }
            }))));
        }
    }
    async doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite) {
        let isSameResourceWithDifferentPathCase = false;
        if (sourceProvider === targetProvider) {
            const { providerExtUri, isPathCaseSensitive } = this.getExtUri(sourceProvider);
            if (!isPathCaseSensitive) {
                isSameResourceWithDifferentPathCase = providerExtUri.isEqual(source, target);
            }
            if (isSameResourceWithDifferentPathCase && mode === 'copy') {
                throw new Error(localize('unableToMoveCopyError1', "Unable to copy when source '{0}' is same as target '{1}' with different path case on a case insensitive file system", this.resourceForError(source), this.resourceForError(target)));
            }
            if (!isSameResourceWithDifferentPathCase && providerExtUri.isEqualOrParent(target, source)) {
                throw new Error(localize('unableToMoveCopyError2', "Unable to move/copy when source '{0}' is parent of target '{1}'.", this.resourceForError(source), this.resourceForError(target)));
            }
        }
        const exists = await this.exists(target);
        if (exists && !isSameResourceWithDifferentPathCase) {
            if (!overwrite) {
                throw new FileOperationError(localize('unableToMoveCopyError3', "Unable to move/copy '{0}' because target '{1}' already exists at destination.", this.resourceForError(source), this.resourceForError(target)), 4 );
            }
            if (sourceProvider === targetProvider) {
                const { providerExtUri } = this.getExtUri(sourceProvider);
                if (providerExtUri.isEqualOrParent(source, target)) {
                    throw new Error(localize('unableToMoveCopyError4', "Unable to move/copy '{0}' into '{1}' since a file would replace the folder it is contained in.", this.resourceForError(source), this.resourceForError(target)));
                }
            }
        }
        return { exists, isSameResourceWithDifferentPathCase };
    }
    getExtUri(provider) {
        const isPathCaseSensitive = this.isPathCaseSensitive(provider);
        return {
            providerExtUri: isPathCaseSensitive ? extUri : extUriIgnorePathCase,
            isPathCaseSensitive
        };
    }
    isPathCaseSensitive(provider) {
        return !!((provider.capabilities & 1024) );
    }
    async createFolder(resource) {
        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);
        await this.mkdirp(provider, resource);
        const fileStat = await this.resolve(resource, { resolveMetadata: true });
        this._onDidRunOperation.fire(( (new FileOperationEvent(resource, 0 , fileStat))));
        return fileStat;
    }
    async mkdirp(provider, directory) {
        const directoriesToCreate = [];
        const { providerExtUri } = this.getExtUri(provider);
        while (!providerExtUri.isEqual(directory, providerExtUri.dirname(directory))) {
            try {
                const stat = await provider.stat(directory);
                if ((stat.type & FileType.Directory) === 0) {
                    throw new Error(localize('mkdirExistsError', "Unable to create folder '{0}' that already exists but is not a directory", this.resourceForError(directory)));
                }
                break;
            }
            catch (error) {
                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {
                    throw error;
                }
                directoriesToCreate.push(providerExtUri.basename(directory));
                directory = providerExtUri.dirname(directory);
            }
        }
        for (let i = directoriesToCreate.length - 1; i >= 0; i--) {
            directory = providerExtUri.joinPath(directory, directoriesToCreate[i]);
            try {
                await provider.mkdir(directory);
            }
            catch (error) {
                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {
                    throw error;
                }
            }
        }
    }
    async canDelete(resource, options) {
        try {
            await this.doValidateDelete(resource, options);
        }
        catch (error) {
            return error;
        }
        return true;
    }
    async doValidateDelete(resource, options) {
        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);
        const useTrash = !!options?.useTrash;
        if (useTrash && !((provider.capabilities & 4096) )) {
            throw new Error(localize('deleteFailedTrashUnsupported', "Unable to delete file '{0}' via trash because provider does not support it.", this.resourceForError(resource)));
        }
        let stat = undefined;
        try {
            stat = await provider.stat(resource);
        }
        catch (error) {
        }
        if (stat) {
            this.throwIfFileIsReadonly(resource, stat);
        }
        else {
            throw new FileOperationError(localize('deleteFailedNotFound', "Unable to delete nonexistent file '{0}'", this.resourceForError(resource)), 1 );
        }
        const recursive = !!options?.recursive;
        if (!recursive) {
            const stat = await this.resolve(resource);
            if (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {
                throw new Error(localize('deleteFailedNonEmptyFolder', "Unable to delete non-empty folder '{0}'.", this.resourceForError(resource)));
            }
        }
        return provider;
    }
    async del(resource, options) {
        const provider = await this.doValidateDelete(resource, options);
        const useTrash = !!options?.useTrash;
        const recursive = !!options?.recursive;
        await provider.delete(resource, { recursive, useTrash });
        this._onDidRunOperation.fire(( (new FileOperationEvent(resource, 1 ))));
    }
    async cloneFile(source, target) {
        const sourceProvider = await this.withProvider(source);
        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);
        if (sourceProvider === targetProvider && this.getExtUri(sourceProvider).providerExtUri.isEqual(source, target)) {
            return;
        }
        if (sourceProvider === targetProvider && hasFileCloneCapability(sourceProvider)) {
            return sourceProvider.cloneFile(source, target);
        }
        await this.mkdirp(targetProvider, this.getExtUri(targetProvider).providerExtUri.dirname(target));
        const sourceWriteQueue = this.writeQueue.queueFor(source, this.getExtUri(sourceProvider).providerExtUri);
        if (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {
            return sourceWriteQueue.queue(() => sourceProvider.copy(source, target, { overwrite: true }));
        }
        return sourceWriteQueue.queue(() => this.doCopyFile(sourceProvider, source, targetProvider, target));
    }
    watch(resource, options = { recursive: false, excludes: [] }) {
        const disposables = ( (new DisposableStore()));
        let watchDisposed = false;
        let disposeWatch = () => { watchDisposed = true; };
        disposables.add(toDisposable(() => disposeWatch()));
        (async () => {
            try {
                const disposable = await this.doWatch(resource, options);
                if (watchDisposed) {
                    dispose(disposable);
                }
                else {
                    disposeWatch = () => dispose(disposable);
                }
            }
            catch (error) {
                this.logService.error(error);
            }
        })();
        return disposables;
    }
    async doWatch(resource, options) {
        const provider = await this.withProvider(resource);
        const watchHash = hash([this.getExtUri(provider).providerExtUri.getComparisonKey(resource), options]);
        let watcher = this.activeWatchers.get(watchHash);
        if (!watcher) {
            watcher = {
                count: 0,
                disposable: provider.watch(resource, options)
            };
            this.activeWatchers.set(watchHash, watcher);
        }
        watcher.count += 1;
        return toDisposable(() => {
            if (watcher) {
                watcher.count--;
                if (watcher.count === 0) {
                    dispose(watcher.disposable);
                    this.activeWatchers.delete(watchHash);
                }
            }
        });
    }
    dispose() {
        super.dispose();
        for (const [, watcher] of this.activeWatchers) {
            dispose(watcher.disposable);
        }
        this.activeWatchers.clear();
    }
    async doWriteBuffered(provider, resource, options, readableOrStreamOrBufferedStream) {
        return this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(async () => {
            const handle = await provider.open(resource, { create: true, unlock: options?.unlock ?? false });
            try {
                if (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {
                    await this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);
                }
                else {
                    await this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);
                }
            }
            catch (error) {
                throw ensureFileSystemProviderError(error);
            }
            finally {
                await provider.close(handle);
            }
        });
    }
    async doWriteStreamBufferedQueued(provider, handle, streamOrBufferedStream) {
        let posInFile = 0;
        let stream;
        if (isReadableBufferedStream(streamOrBufferedStream)) {
            if (streamOrBufferedStream.buffer.length > 0) {
                const chunk = VSBuffer.concat(streamOrBufferedStream.buffer);
                await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);
                posInFile += chunk.byteLength;
            }
            if (streamOrBufferedStream.ended) {
                return;
            }
            stream = streamOrBufferedStream.stream;
        }
        else {
            stream = streamOrBufferedStream;
        }
        return (
             (new Promise((resolve, reject) => {
                listenStream(stream, {
                    onData: async (chunk) => {
                        stream.pause();
                        try {
                            await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);
                        }
                        catch (error) {
                            return reject(error);
                        }
                        posInFile += chunk.byteLength;
                        setTimeout(() => stream.resume());
                    },
                    onError: error => reject(error),
                    onEnd: () => resolve()
                });
            }))
        );
    }
    async doWriteReadableBufferedQueued(provider, handle, readable) {
        let posInFile = 0;
        let chunk;
        while ((chunk = readable.read()) !== null) {
            await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);
            posInFile += chunk.byteLength;
        }
    }
    async doWriteBuffer(provider, handle, buffer, length, posInFile, posInBuffer) {
        let totalBytesWritten = 0;
        while (totalBytesWritten < length) {
            const bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);
            totalBytesWritten += bytesWritten;
        }
    }
    async doWriteUnbuffered(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream) {
        return this.writeQueue.queueFor(resource, this.getExtUri(provider).providerExtUri).queue(() => this.doWriteUnbufferedQueued(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream));
    }
    async doWriteUnbufferedQueued(provider, resource, options, bufferOrReadableOrStreamOrBufferedStream) {
        let buffer;
        if (bufferOrReadableOrStreamOrBufferedStream instanceof VSBuffer) {
            buffer = bufferOrReadableOrStreamOrBufferedStream;
        }
        else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {
            buffer = await streamToBuffer(bufferOrReadableOrStreamOrBufferedStream);
        }
        else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {
            buffer = await bufferedStreamToBuffer(bufferOrReadableOrStreamOrBufferedStream);
        }
        else {
            buffer = readableToBuffer(bufferOrReadableOrStreamOrBufferedStream);
        }
        await provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true, unlock: options?.unlock ?? false });
    }
    async doPipeBuffered(sourceProvider, source, targetProvider, target) {
        return this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));
    }
    async doPipeBufferedQueued(sourceProvider, source, targetProvider, target) {
        let sourceHandle = undefined;
        let targetHandle = undefined;
        try {
            sourceHandle = await sourceProvider.open(source, { create: false });
            targetHandle = await targetProvider.open(target, { create: true, unlock: false });
            const buffer = VSBuffer.alloc(this.BUFFER_SIZE);
            let posInFile = 0;
            let posInBuffer = 0;
            let bytesRead = 0;
            do {
                bytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);
                await this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);
                posInFile += bytesRead;
                posInBuffer += bytesRead;
                if (posInBuffer === buffer.byteLength) {
                    posInBuffer = 0;
                }
            } while (bytesRead > 0);
        }
        catch (error) {
            throw ensureFileSystemProviderError(error);
        }
        finally {
            await Promises.settled([
                typeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),
                typeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),
            ]);
        }
    }
    async doPipeUnbuffered(sourceProvider, source, targetProvider, target) {
        return this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));
    }
    async doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target) {
        return targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true, unlock: false });
    }
    async doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target) {
        return this.writeQueue.queueFor(target, this.getExtUri(targetProvider).providerExtUri).queue(() => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));
    }
    async doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target) {
        const targetHandle = await targetProvider.open(target, { create: true, unlock: false });
        try {
            const buffer = await sourceProvider.readFile(source);
            await this.doWriteBuffer(targetProvider, targetHandle, VSBuffer.wrap(buffer), buffer.byteLength, 0, 0);
        }
        catch (error) {
            throw ensureFileSystemProviderError(error);
        }
        finally {
            await targetProvider.close(targetHandle);
        }
    }
    async doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target) {
        const buffer = await streamToBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));
        await this.doWriteUnbuffered(targetProvider, target, undefined, buffer);
    }
    throwIfFileSystemIsReadonly(provider, resource) {
        if (provider.capabilities & 2048 ) {
            throw new FileOperationError(localize('err.readonly', "Unable to modify readonly file '{0}'", this.resourceForError(resource)), 6 );
        }
        return provider;
    }
    throwIfFileIsReadonly(resource, stat) {
        if ((stat.permissions ?? 0) & FilePermission.Readonly) {
            throw new FileOperationError(localize('err.readonly', "Unable to modify readonly file '{0}'", this.resourceForError(resource)), 6 );
        }
    }
    resourceForError(resource) {
        if (resource.scheme === Schemas.file) {
            return resource.fsPath;
        }
        return (
             (resource.toString(true))
        );
    }
};
FileService = ( (__decorate([
    ( (__param(0, ILogService)))
], FileService)));
let File$1 = class File {
    constructor(name) {
        this.type = FileType.File;
        this.ctime = Date.now();
        this.mtime = Date.now();
        this.size = 0;
        this.name = name;
    }
};
class Directory {
    constructor(name) {
        this.type = FileType.Directory;
        this.ctime = Date.now();
        this.mtime = Date.now();
        this.size = 0;
        this.name = name;
        this.entries = ( (new Map()));
    }
}
class InMemoryFileSystemProvider extends Disposable {
    constructor() {
        super(...arguments);
        this._onDidChangeCapabilities = this._register(( (new Emitter())));
        this.onDidChangeCapabilities = this._onDidChangeCapabilities.event;
        this._capabilities = 2  | 1024 ;
        this.root = ( (new Directory('')));
        this._onDidChangeFile = this._register(( (new Emitter())));
        this.onDidChangeFile = this._onDidChangeFile.event;
        this._bufferedChanges = [];
    }
    get capabilities() { return this._capabilities; }
    setReadOnly(readonly) {
        const isReadonly = !!((this._capabilities & 2048) );
        if (readonly !== isReadonly) {
            this._capabilities = readonly ? 2048  | 1024  | 2
                : 2  | 1024 ;
            this._onDidChangeCapabilities.fire();
        }
    }
    async stat(resource) {
        return this._lookup(resource, false);
    }
    async readdir(resource) {
        const entry = this._lookupAsDirectory(resource, false);
        const result = [];
        entry.entries.forEach((child, name) => result.push([name, child.type]));
        return result;
    }
    async readFile(resource) {
        const data = this._lookupAsFile(resource, false).data;
        if (data) {
            return data;
        }
        throw createFileSystemProviderError('file not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async writeFile(resource, content, opts) {
        const basename$1 = basename(resource);
        const parent = this._lookupParentDirectory(resource);
        let entry = parent.entries.get(basename$1);
        if (entry instanceof Directory) {
            throw createFileSystemProviderError('file is directory', FileSystemProviderErrorCode.FileIsADirectory);
        }
        if (!entry && !opts.create) {
            throw createFileSystemProviderError('file not found', FileSystemProviderErrorCode.FileNotFound);
        }
        if (entry && opts.create && !opts.overwrite) {
            throw createFileSystemProviderError('file exists already', FileSystemProviderErrorCode.FileExists);
        }
        if (!entry) {
            entry = ( (new File$1(basename$1)));
            parent.entries.set(basename$1, entry);
            this._fireSoon({ type: 1 , resource });
        }
        entry.mtime = Date.now();
        entry.size = content.byteLength;
        entry.data = content;
        this._fireSoon({ type: 0 , resource });
    }
    async rename(from, to, opts) {
        if (!opts.overwrite && this._lookup(to, true)) {
            throw createFileSystemProviderError('file exists already', FileSystemProviderErrorCode.FileExists);
        }
        const entry = this._lookup(from, false);
        const oldParent = this._lookupParentDirectory(from);
        const newParent = this._lookupParentDirectory(to);
        const newName = basename(to);
        oldParent.entries.delete(entry.name);
        entry.name = newName;
        newParent.entries.set(newName, entry);
        this._fireSoon({ type: 2 , resource: from }, { type: 1 , resource: to });
    }
    async delete(resource, opts) {
        const dirname$1 = dirname(resource);
        const basename$1 = basename(resource);
        const parent = this._lookupAsDirectory(dirname$1, false);
        if (parent.entries.has(basename$1)) {
            parent.entries.delete(basename$1);
            parent.mtime = Date.now();
            parent.size -= 1;
            this._fireSoon({ type: 0 , resource: dirname$1 }, { resource, type: 2  });
        }
    }
    async mkdir(resource) {
        if (this._lookup(resource, true)) {
            throw createFileSystemProviderError('file exists already', FileSystemProviderErrorCode.FileExists);
        }
        const basename$1 = basename(resource);
        const dirname$1 = dirname(resource);
        const parent = this._lookupAsDirectory(dirname$1, false);
        const entry = ( (new Directory(basename$1)));
        parent.entries.set(entry.name, entry);
        parent.mtime = Date.now();
        parent.size += 1;
        this._fireSoon({ type: 0 , resource: dirname$1 }, { type: 1 , resource });
    }
    _lookup(uri, silent) {
        const parts = uri.path.split('/');
        let entry = this.root;
        for (const part of parts) {
            if (!part) {
                continue;
            }
            let child;
            if (entry instanceof Directory) {
                child = entry.entries.get(part);
            }
            if (!child) {
                if (!silent) {
                    throw createFileSystemProviderError('file not found', FileSystemProviderErrorCode.FileNotFound);
                }
                else {
                    return undefined;
                }
            }
            entry = child;
        }
        return entry;
    }
    _lookupAsDirectory(uri, silent) {
        const entry = this._lookup(uri, silent);
        if (entry instanceof Directory) {
            return entry;
        }
        throw createFileSystemProviderError('file not a directory', FileSystemProviderErrorCode.FileNotADirectory);
    }
    _lookupAsFile(uri, silent) {
        const entry = this._lookup(uri, silent);
        if (entry instanceof File$1) {
            return entry;
        }
        throw createFileSystemProviderError('file is a directory', FileSystemProviderErrorCode.FileIsADirectory);
    }
    _lookupParentDirectory(uri) {
        const dirname$1 = dirname(uri);
        return this._lookupAsDirectory(dirname$1, false);
    }
    watch(resource, opts) {
        return Disposable.None;
    }
    _fireSoon(...changes) {
        this._bufferedChanges.push(...changes);
        if (this._fireSoonHandle) {
            clearTimeout(this._fireSoonHandle);
        }
        this._fireSoonHandle = setTimeout(() => {
            this._onDidChangeFile.fire(this._bufferedChanges);
            this._bufferedChanges.length = 0;
        }, 5);
    }
}
let TextFileSaveParticipant = class TextFileSaveParticipant extends Disposable {
    constructor(progressService, logService) {
        super();
        this.progressService = progressService;
        this.logService = logService;
        this.saveParticipants = [];
    }
    addSaveParticipant(participant) {
        const remove = insert(this.saveParticipants, participant);
        return toDisposable(() => remove());
    }
    participate(model, context, token) {
        const cts = ( (new CancellationTokenSource(token)));
        return this.progressService.withProgress({
            title: ( (localize('saveParticipants', "Saving '{0}'", model.name))),
            location: 15 ,
            cancellable: true,
            delay: model.isDirty() ? 3000 : 5000
        }, async (progress) => {
            model.textEditorModel?.pushStackElement();
            for (const saveParticipant of this.saveParticipants) {
                if (cts.token.isCancellationRequested || !model.textEditorModel ) {
                    break;
                }
                try {
                    const promise = saveParticipant.participate(model, context, progress, cts.token);
                    await raceCancellation(promise, cts.token);
                }
                catch (err) {
                    this.logService.error(err);
                }
            }
            model.textEditorModel?.pushStackElement();
        }, () => {
            cts.dispose(true);
        });
    }
    dispose() {
        this.saveParticipants.splice(0, this.saveParticipants.length);
    }
};
TextFileSaveParticipant = ( (__decorate([
    ( (__param(0, IProgressService))),
    ( (__param(1, ILogService)))
], TextFileSaveParticipant)));
let TextFileEditorModelManager = class TextFileEditorModelManager extends Disposable {
    get models() {
        return [...( (this.mapResourceToModel.values()))];
    }
    constructor(instantiationService, fileService, notificationService, workingCopyFileService, uriIdentityService) {
        super();
        this.instantiationService = instantiationService;
        this.fileService = fileService;
        this.notificationService = notificationService;
        this.workingCopyFileService = workingCopyFileService;
        this.uriIdentityService = uriIdentityService;
        this._onDidCreate = this._register(( (new Emitter())));
        this.onDidCreate = this._onDidCreate.event;
        this._onDidResolve = this._register(( (new Emitter())));
        this.onDidResolve = this._onDidResolve.event;
        this._onDidRemove = this._register(( (new Emitter())));
        this.onDidRemove = this._onDidRemove.event;
        this._onDidChangeDirty = this._register(( (new Emitter())));
        this.onDidChangeDirty = this._onDidChangeDirty.event;
        this._onDidChangeReadonly = this._register(( (new Emitter())));
        this.onDidChangeReadonly = this._onDidChangeReadonly.event;
        this._onDidChangeOrphaned = this._register(( (new Emitter())));
        this.onDidChangeOrphaned = this._onDidChangeOrphaned.event;
        this._onDidSaveError = this._register(( (new Emitter())));
        this.onDidSaveError = this._onDidSaveError.event;
        this._onDidSave = this._register(( (new Emitter())));
        this.onDidSave = this._onDidSave.event;
        this._onDidRevert = this._register(( (new Emitter())));
        this.onDidRevert = this._onDidRevert.event;
        this._onDidChangeEncoding = this._register(( (new Emitter())));
        this.onDidChangeEncoding = this._onDidChangeEncoding.event;
        this.mapResourceToModel = ( (new ResourceMap()));
        this.mapResourceToModelListeners = ( (new ResourceMap()));
        this.mapResourceToDisposeListener = ( (new ResourceMap()));
        this.mapResourceToPendingModelResolvers = ( (new ResourceMap()));
        this.modelResolveQueue = this._register(( (new ResourceQueue())));
        this.saveErrorHandler = (() => {
            const notificationService = this.notificationService;
            return {
                onSaveError(error, model) {
                    notificationService.error(( (localize(
                        { key: 'genericSaveError', comment: ['{0} is the resource that failed to save and {1} the error message'] },
                        "Failed to save '{0}': {1}",
                        model.name,
                        toErrorMessage(error, false)
                    ))));
                }
            };
        })();
        this.mapCorrelationIdToModelsToRestore = ( (new Map()));
        this.saveParticipants = this._register(this.instantiationService.createInstance(TextFileSaveParticipant));
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.fileService.onDidFilesChange(e => this.onDidFilesChange(e)));
        this._register(this.fileService.onDidChangeFileSystemProviderCapabilities(e => this.onDidChangeFileSystemProviderCapabilities(e)));
        this._register(this.fileService.onDidChangeFileSystemProviderRegistrations(e => this.onDidChangeFileSystemProviderRegistrations(e)));
        this._register(this.workingCopyFileService.onWillRunWorkingCopyFileOperation(e => this.onWillRunWorkingCopyFileOperation(e)));
        this._register(this.workingCopyFileService.onDidFailWorkingCopyFileOperation(e => this.onDidFailWorkingCopyFileOperation(e)));
        this._register(this.workingCopyFileService.onDidRunWorkingCopyFileOperation(e => this.onDidRunWorkingCopyFileOperation(e)));
    }
    onDidFilesChange(e) {
        for (const model of this.models) {
            if (model.isDirty()) {
                continue;
            }
            if (e.contains(model.resource, 0 , 1 )) {
                this.queueModelReload(model);
            }
        }
    }
    onDidChangeFileSystemProviderCapabilities(e) {
        this.queueModelReloads(e.scheme);
    }
    onDidChangeFileSystemProviderRegistrations(e) {
        if (!e.added) {
            return;
        }
        this.queueModelReloads(e.scheme);
    }
    queueModelReloads(scheme) {
        for (const model of this.models) {
            if (model.isDirty()) {
                continue;
            }
            if (scheme === model.resource.scheme) {
                this.queueModelReload(model);
            }
        }
    }
    queueModelReload(model) {
        const queue = this.modelResolveQueue.queueFor(model.resource);
        if (queue.size <= 1) {
            queue.queue(async () => {
                try {
                    await this.reload(model);
                }
                catch (error) {
                    onUnexpectedError(error);
                }
            });
        }
    }
    onWillRunWorkingCopyFileOperation(e) {
        if (e.operation === 2  || e.operation === 3 ) {
            const modelsToRestore = [];
            for (const { source, target } of e.files) {
                if (source) {
                    if (this.uriIdentityService.extUri.isEqual(source, target)) {
                        continue;
                    }
                    const sourceModels = [];
                    for (const model of this.models) {
                        if (this.uriIdentityService.extUri.isEqualOrParent(model.resource, source)) {
                            sourceModels.push(model);
                        }
                    }
                    for (const sourceModel of sourceModels) {
                        const sourceModelResource = sourceModel.resource;
                        let targetModelResource;
                        if (this.uriIdentityService.extUri.isEqual(sourceModelResource, source)) {
                            targetModelResource = target;
                        }
                        else {
                            targetModelResource = joinPath(target, sourceModelResource.path.substr(source.path.length + 1));
                        }
                        modelsToRestore.push({
                            source: sourceModelResource,
                            target: targetModelResource,
                            languageId: sourceModel.getLanguageId(),
                            encoding: sourceModel.getEncoding(),
                            snapshot: sourceModel.isDirty() ? sourceModel.createSnapshot() : undefined
                        });
                    }
                }
            }
            this.mapCorrelationIdToModelsToRestore.set(e.correlationId, modelsToRestore);
        }
    }
    onDidFailWorkingCopyFileOperation(e) {
        if (((e.operation === 2  || e.operation === 3) )) {
            const modelsToRestore = this.mapCorrelationIdToModelsToRestore.get(e.correlationId);
            if (modelsToRestore) {
                this.mapCorrelationIdToModelsToRestore.delete(e.correlationId);
                modelsToRestore.forEach(model => {
                    if (model.snapshot) {
                        this.get(model.source)?.setDirty(true);
                    }
                });
            }
        }
    }
    onDidRunWorkingCopyFileOperation(e) {
        switch (e.operation) {
            case 0 :
                e.waitUntil((async () => {
                    for (const { target } of e.files) {
                        const model = this.get(target);
                        if (model && !model.isDisposed()) {
                            await model.revert();
                        }
                    }
                })());
                break;
            case 2 :
            case 3 :
                e.waitUntil((async () => {
                    const modelsToRestore = this.mapCorrelationIdToModelsToRestore.get(e.correlationId);
                    if (modelsToRestore) {
                        this.mapCorrelationIdToModelsToRestore.delete(e.correlationId);
                        await Promises.settled(( (modelsToRestore.map(async (modelToRestore) => {
                            const restoredModel = await this.resolve(modelToRestore.target, {
                                reload: { async: false },
                                contents: modelToRestore.snapshot ? createTextBufferFactoryFromSnapshot(modelToRestore.snapshot) : undefined,
                                encoding: modelToRestore.encoding
                            });
                            if (modelToRestore.languageId &&
                                modelToRestore.languageId !== PLAINTEXT_LANGUAGE_ID &&
                                restoredModel.getLanguageId() === PLAINTEXT_LANGUAGE_ID &&
                                extname$1(modelToRestore.target) !== PLAINTEXT_EXTENSION) {
                                restoredModel.updateTextEditorModel(undefined, modelToRestore.languageId);
                            }
                        }))));
                    }
                })());
                break;
        }
    }
    get(resource) {
        return this.mapResourceToModel.get(resource);
    }
    has(resource) {
        return this.mapResourceToModel.has(resource);
    }
    async reload(model) {
        await this.joinPendingResolves(model.resource);
        if (model.isDirty() || model.isDisposed() || !this.has(model.resource)) {
            return;
        }
        await this.doResolve(model, { reload: { async: false } });
    }
    async resolve(resource, options) {
        const pendingResolve = this.joinPendingResolves(resource);
        if (pendingResolve) {
            await pendingResolve;
        }
        return this.doResolve(resource, options);
    }
    async doResolve(resourceOrModel, options) {
        let model;
        let resource;
        if (URI.isUri(resourceOrModel)) {
            resource = resourceOrModel;
            model = this.get(resource);
        }
        else {
            resource = resourceOrModel.resource;
            model = resourceOrModel;
        }
        let modelResolve;
        let didCreateModel = false;
        if (model) {
            if (options?.contents) {
                modelResolve = model.resolve(options);
            }
            else if (options?.reload) {
                if (options.reload.async) {
                    modelResolve = Promise.resolve();
                    (async () => {
                        try {
                            await model.resolve(options);
                        }
                        catch (error) {
                            onUnexpectedError(error);
                        }
                    })();
                }
                else {
                    modelResolve = model.resolve(options);
                }
            }
            else {
                modelResolve = Promise.resolve();
            }
        }
        else {
            didCreateModel = true;
            const newModel = model = this.instantiationService.createInstance(TextFileEditorModel, resource, options ? options.encoding : undefined, options ? options.languageId : undefined);
            modelResolve = model.resolve(options);
            this.registerModel(newModel);
        }
        this.mapResourceToPendingModelResolvers.set(resource, modelResolve);
        this.add(resource, model);
        if (didCreateModel) {
            this._onDidCreate.fire(model);
            if (model.isDirty()) {
                this._onDidChangeDirty.fire(model);
            }
        }
        try {
            await modelResolve;
        }
        catch (error) {
            if (didCreateModel) {
                model.dispose();
            }
            throw error;
        }
        finally {
            this.mapResourceToPendingModelResolvers.delete(resource);
        }
        if (options?.languageId) {
            model.setLanguageId(options.languageId);
        }
        if (didCreateModel && model.isDirty()) {
            this._onDidChangeDirty.fire(model);
        }
        return model;
    }
    joinPendingResolves(resource) {
        const pendingModelResolve = this.mapResourceToPendingModelResolvers.get(resource);
        if (!pendingModelResolve) {
            return;
        }
        return this.doJoinPendingResolves(resource);
    }
    async doJoinPendingResolves(resource) {
        let currentModelCopyResolve;
        while (this.mapResourceToPendingModelResolvers.has(resource)) {
            const nextPendingModelResolve = this.mapResourceToPendingModelResolvers.get(resource);
            if (nextPendingModelResolve === currentModelCopyResolve) {
                return;
            }
            currentModelCopyResolve = nextPendingModelResolve;
            try {
                await nextPendingModelResolve;
            }
            catch (error) {
            }
        }
    }
    registerModel(model) {
        const modelListeners = ( (new DisposableStore()));
        modelListeners.add(model.onDidResolve(reason => this._onDidResolve.fire({ model, reason })));
        modelListeners.add(model.onDidChangeDirty(() => this._onDidChangeDirty.fire(model)));
        modelListeners.add(model.onDidChangeReadonly(() => this._onDidChangeReadonly.fire(model)));
        modelListeners.add(model.onDidChangeOrphaned(() => this._onDidChangeOrphaned.fire(model)));
        modelListeners.add(model.onDidSaveError(() => this._onDidSaveError.fire(model)));
        modelListeners.add(model.onDidSave(e => this._onDidSave.fire({ model, ...e })));
        modelListeners.add(model.onDidRevert(() => this._onDidRevert.fire(model)));
        modelListeners.add(model.onDidChangeEncoding(() => this._onDidChangeEncoding.fire(model)));
        this.mapResourceToModelListeners.set(model.resource, modelListeners);
    }
    add(resource, model) {
        const knownModel = this.mapResourceToModel.get(resource);
        if (knownModel === model) {
            return;
        }
        const disposeListener = this.mapResourceToDisposeListener.get(resource);
        disposeListener?.dispose();
        this.mapResourceToModel.set(resource, model);
        this.mapResourceToDisposeListener.set(resource, model.onWillDispose(() => this.remove(resource)));
    }
    remove(resource) {
        const removed = this.mapResourceToModel.delete(resource);
        const disposeListener = this.mapResourceToDisposeListener.get(resource);
        if (disposeListener) {
            dispose(disposeListener);
            this.mapResourceToDisposeListener.delete(resource);
        }
        const modelListener = this.mapResourceToModelListeners.get(resource);
        if (modelListener) {
            dispose(modelListener);
            this.mapResourceToModelListeners.delete(resource);
        }
        if (removed) {
            this._onDidRemove.fire(resource);
        }
    }
    addSaveParticipant(participant) {
        return this.saveParticipants.addSaveParticipant(participant);
    }
    runSaveParticipants(model, context, token) {
        return this.saveParticipants.participate(model, context, token);
    }
    canDispose(model) {
        if (model.isDisposed() ||
            (!this.mapResourceToPendingModelResolvers.has(model.resource) && !model.isDirty())) {
            return true;
        }
        return this.doCanDispose(model);
    }
    async doCanDispose(model) {
        const pendingResolve = this.joinPendingResolves(model.resource);
        if (pendingResolve) {
            await pendingResolve;
            return this.canDispose(model);
        }
        if (model.isDirty()) {
            await Event.toPromise(model.onDidChangeDirty);
            return this.canDispose(model);
        }
        return true;
    }
    dispose() {
        super.dispose();
        this.mapResourceToModel.clear();
        this.mapResourceToPendingModelResolvers.clear();
        dispose(( (this.mapResourceToDisposeListener.values())));
        this.mapResourceToDisposeListener.clear();
        dispose(( (this.mapResourceToModelListeners.values())));
        this.mapResourceToModelListeners.clear();
    }
};
TextFileEditorModelManager = ( (__decorate([
    ( (__param(0, IInstantiationService))),
    ( (__param(1, IFileService))),
    ( (__param(2, INotificationService))),
    ( (__param(3, IWorkingCopyFileService))),
    ( (__param(4, IUriIdentityService)))
], TextFileEditorModelManager)));
let AbstractTextFileService = class AbstractTextFileService extends Disposable {
    constructor(fileService, untitledTextEditorService, lifecycleService, instantiationService, modelService, environmentService, dialogService, fileDialogService, textResourceConfigurationService, filesConfigurationService, codeEditorService, pathService, workingCopyFileService, uriIdentityService, languageService, logService, elevatedFileService, decorationsService) {
        super();
        this.fileService = fileService;
        this.untitledTextEditorService = untitledTextEditorService;
        this.lifecycleService = lifecycleService;
        this.instantiationService = instantiationService;
        this.modelService = modelService;
        this.environmentService = environmentService;
        this.dialogService = dialogService;
        this.fileDialogService = fileDialogService;
        this.textResourceConfigurationService = textResourceConfigurationService;
        this.filesConfigurationService = filesConfigurationService;
        this.codeEditorService = codeEditorService;
        this.pathService = pathService;
        this.workingCopyFileService = workingCopyFileService;
        this.uriIdentityService = uriIdentityService;
        this.languageService = languageService;
        this.logService = logService;
        this.elevatedFileService = elevatedFileService;
        this.decorationsService = decorationsService;
        this.files = this._register(this.instantiationService.createInstance(TextFileEditorModelManager));
        this.untitled = this.untitledTextEditorService;
        this.provideDecorations();
    }
    provideDecorations() {
        this.decorationsService.registerDecorationsProvider(new (class extends Disposable {
            constructor(files) {
                super();
                this.files = files;
                this.label = ( (localize('textFileModelDecorations', "Text File Model Decorations")));
                this._onDidChange = this._register(( (new Emitter())));
                this.onDidChange = this._onDidChange.event;
                this.registerListeners();
            }
            registerListeners() {
                this._register(this.files.onDidResolve(({ model }) => {
                    if (model.isReadonly() || model.hasState(4 )) {
                        this._onDidChange.fire([model.resource]);
                    }
                }));
                this._register(this.files.onDidRemove(modelUri => this._onDidChange.fire([modelUri])));
                this._register(this.files.onDidChangeReadonly(model => this._onDidChange.fire([model.resource])));
                this._register(this.files.onDidChangeOrphaned(model => this._onDidChange.fire([model.resource])));
            }
            provideDecorations(uri) {
                const model = this.files.get(uri);
                if (!model || model.isDisposed()) {
                    return undefined;
                }
                const isReadonly = model.isReadonly();
                const isOrphaned = model.hasState(4 );
                if (isReadonly && isOrphaned) {
                    return {
                        color: listErrorForeground,
                        letter: Codicon.lockSmall,
                        strikethrough: true,
                        tooltip: ( (localize('readonlyAndDeleted', "Deleted, Read Only"))),
                    };
                }
                else if (isReadonly) {
                    return {
                        letter: Codicon.lockSmall,
                        tooltip: ( (localize('readonly', "Read Only"))),
                    };
                }
                else if (isOrphaned) {
                    return {
                        color: listErrorForeground,
                        strikethrough: true,
                        tooltip: ( (localize('deleted', "Deleted"))),
                    };
                }
                return undefined;
            }
        })(this.files));
    }
    get encoding() {
        if (!this._encoding) {
            this._encoding = this._register(this.instantiationService.createInstance(EncodingOracle));
        }
        return this._encoding;
    }
    async read(resource, options) {
        const [bufferStream, decoder] = await this.doRead(resource, {
            ...options,
            preferUnbuffered: true
        });
        return {
            ...bufferStream,
            encoding: decoder.detected.encoding || UTF8,
            value: await consumeStream(decoder.stream, strings => strings.join(''))
        };
    }
    async readStream(resource, options) {
        const [bufferStream, decoder] = await this.doRead(resource, options);
        return {
            ...bufferStream,
            encoding: decoder.detected.encoding || UTF8,
            value: await createTextBufferFactoryFromStream(decoder.stream)
        };
    }
    async doRead(resource, options) {
        const cts = ( (new CancellationTokenSource()));
        let bufferStream;
        if (options?.preferUnbuffered) {
            const content = await this.fileService.readFile(resource, options, cts.token);
            bufferStream = {
                ...content,
                value: bufferToStream(content.value)
            };
        }
        else {
            bufferStream = await this.fileService.readFileStream(resource, options, cts.token);
        }
        try {
            const decoder = await this.doGetDecodedStream(resource, bufferStream.value, options);
            return [bufferStream, decoder];
        }
        catch (error) {
            cts.dispose(true);
            if (error.decodeStreamErrorKind === 1 ) {
                throw new TextFileOperationError(localize('fileBinaryError', "File seems to be binary and cannot be opened as text"), 0 , options);
            }
            else {
                throw error;
            }
        }
    }
    async create(operations, undoInfo) {
        const operationsWithContents = await Promise.all(( (operations.map(async (operation) => {
            const contents = await this.getEncodedReadable(operation.resource, operation.value);
            return {
                resource: operation.resource,
                contents,
                overwrite: operation.options?.overwrite
            };
        }))));
        return this.workingCopyFileService.create(operationsWithContents, CancellationToken.None, undoInfo);
    }
    async write(resource, value, options) {
        const readable = await this.getEncodedReadable(resource, value, options);
        if (options?.writeElevated && this.elevatedFileService.isSupported(resource)) {
            return this.elevatedFileService.writeFileElevated(resource, readable, options);
        }
        return this.fileService.writeFile(resource, readable, options);
    }
    async getEncodedReadable(resource, value, options) {
        const { encoding, addBOM } = await this.encoding.getWriteEncoding(resource, options);
        if (encoding === UTF8 && !addBOM) {
            return typeof value === 'undefined'
                ? undefined
                : toBufferOrReadable(value);
        }
        value = value || '';
        const snapshot = typeof value === 'string' ? stringToSnapshot(value) : value;
        return toEncodeReadable(snapshot, encoding, { addBOM });
    }
    async getDecodedStream(resource, value, options) {
        return (await this.doGetDecodedStream(resource, value, options)).stream;
    }
    doGetDecodedStream(resource, stream, options) {
        return toDecodeStream(stream, {
            acceptTextOnly: options?.acceptTextOnly ?? false,
            guessEncoding: options?.autoGuessEncoding || this.textResourceConfigurationService.getValue(resource, 'files.autoGuessEncoding'),
            overwriteEncoding: async (detectedEncoding) => {
                const { encoding } = await this.encoding.getPreferredReadEncoding(resource, options, withNullAsUndefined(detectedEncoding));
                return encoding;
            }
        });
    }
    async save(resource, options) {
        if (resource.scheme === Schemas.untitled) {
            const model = this.untitled.get(resource);
            if (model) {
                let targetUri;
                if (model.hasAssociatedFilePath) {
                    targetUri = await this.suggestSavePath(resource);
                }
                else {
                    targetUri = await this.fileDialogService.pickFileToSave(await this.suggestSavePath(resource), options?.availableFileSystems);
                }
                if (targetUri) {
                    return this.saveAs(resource, targetUri, options);
                }
            }
        }
        else {
            const model = this.files.get(resource);
            if (model) {
                return (await model.save(options)) ? resource : undefined;
            }
        }
        return undefined;
    }
    async saveAs(source, target, options) {
        if (!target) {
            target = await this.fileDialogService.pickFileToSave(await this.suggestSavePath(options?.suggestedTarget ?? source), options?.availableFileSystems);
        }
        if (!target) {
            return;
        }
        if (isEqual(source, target)) {
            return this.save(source, { ...options, force: true  });
        }
        if (this.fileService.hasProvider(source) && this.uriIdentityService.extUri.isEqual(source, target) && (await this.fileService.exists(source))) {
            await this.workingCopyFileService.move([{ file: { source, target } }], CancellationToken.None);
            const success = await this.save(source, options);
            if (!success) {
                await this.save(target, options);
            }
            return target;
        }
        return this.doSaveAs(source, target, options);
    }
    async doSaveAs(source, target, options) {
        let success = false;
        const textFileModel = this.files.get(source);
        if (textFileModel?.isResolved()) {
            success = await this.doSaveAsTextFile(textFileModel, source, target, options);
        }
        else if (this.fileService.hasProvider(source)) {
            await this.fileService.copy(source, target, true);
            success = true;
        }
        else {
            const textModel = this.modelService.getModel(source);
            if (textModel) {
                success = await this.doSaveAsTextFile(textModel, source, target, options);
            }
        }
        if (!success) {
            return undefined;
        }
        try {
            await this.revert(source);
        }
        catch (error) {
            this.logService.error(error);
        }
        return target;
    }
    async doSaveAsTextFile(sourceModel, source, target, options) {
        let sourceModelEncoding = undefined;
        const sourceModelWithEncodingSupport = sourceModel;
        if (typeof sourceModelWithEncodingSupport.getEncoding === 'function') {
            sourceModelEncoding = sourceModelWithEncodingSupport.getEncoding();
        }
        let targetExists = false;
        let targetModel = this.files.get(target);
        if (targetModel?.isResolved()) {
            targetExists = true;
        }
        else {
            targetExists = await this.fileService.exists(target);
            if (!targetExists) {
                await this.create([{ resource: target, value: '' }]);
            }
            try {
                targetModel = await this.files.resolve(target, { encoding: sourceModelEncoding });
            }
            catch (error) {
                if (targetExists) {
                    if (error.textFileOperationResult === 0  ||
                        error.fileOperationResult === 7 ) {
                        await this.fileService.del(target);
                        return this.doSaveAsTextFile(sourceModel, source, target, options);
                    }
                }
                throw error;
            }
        }
        let write;
        if (sourceModel instanceof UntitledTextEditorModel && sourceModel.hasAssociatedFilePath && targetExists && this.uriIdentityService.extUri.isEqual(target, toLocalResource(sourceModel.resource, this.environmentService.remoteAuthority, this.pathService.defaultUriScheme))) {
            write = await this.confirmOverwrite(target);
        }
        else {
            write = true;
        }
        if (!write) {
            return false;
        }
        let sourceTextModel = undefined;
        if (sourceModel instanceof BaseTextEditorModel) {
            if (sourceModel.isResolved()) {
                sourceTextModel = sourceModel.textEditorModel;
            }
        }
        else {
            sourceTextModel = sourceModel;
        }
        let targetTextModel = undefined;
        if (targetModel.isResolved()) {
            targetTextModel = targetModel.textEditorModel;
        }
        if (sourceTextModel && targetTextModel) {
            targetModel.updatePreferredEncoding(sourceModelEncoding);
            this.modelService.updateModel(targetTextModel, createTextBufferFactoryFromSnapshot(sourceTextModel.createSnapshot()));
            const sourceLanguageId = sourceTextModel.getLanguageId();
            const targetLanguageId = targetTextModel.getLanguageId();
            if (sourceLanguageId !== PLAINTEXT_LANGUAGE_ID && targetLanguageId === PLAINTEXT_LANGUAGE_ID) {
                targetTextModel.setMode(sourceLanguageId);
            }
            const sourceTransientProperties = this.codeEditorService.getTransientModelProperties(sourceTextModel);
            if (sourceTransientProperties) {
                for (const [key, value] of sourceTransientProperties) {
                    this.codeEditorService.setTransientModelProperty(targetTextModel, key, value);
                }
            }
        }
        if (!options?.source) {
            options = {
                ...options,
                source: targetExists ? AbstractTextFileService.TEXTFILE_SAVE_REPLACE_SOURCE : AbstractTextFileService.TEXTFILE_SAVE_CREATE_SOURCE
            };
        }
        return targetModel.save(options);
    }
    async confirmOverwrite(resource) {
        const { confirmed } = await this.dialogService.confirm({
            type: 'warning',
            message: ( (localize(
                'confirmOverwrite',
                "'{0}' already exists. Do you want to replace it?",
                basename(resource)
            ))),
            detail: ( (localize(
                'irreversible',
                "A file or folder with the name '{0}' already exists in the folder '{1}'. Replacing it will overwrite its current contents.",
                basename(resource),
                basename(dirname(resource))
            ))),
            primaryButton: ( (localize(
                { key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] },
                "&&Replace"
            ))),
        });
        return confirmed;
    }
    async suggestSavePath(resource) {
        if (this.fileService.hasProvider(resource)) {
            return resource;
        }
        const remoteAuthority = this.environmentService.remoteAuthority;
        const defaultFilePath = await this.fileDialogService.defaultFilePath();
        let suggestedFilename = undefined;
        if (resource.scheme === Schemas.untitled) {
            const model = this.untitled.get(resource);
            if (model) {
                if (model.hasAssociatedFilePath) {
                    return toLocalResource(resource, remoteAuthority, this.pathService.defaultUriScheme);
                }
                let nameCandidate;
                if (await this.pathService.hasValidBasename(joinPath(defaultFilePath, model.name), model.name)) {
                    nameCandidate = model.name;
                }
                else {
                    nameCandidate = basename(resource);
                }
                const languageId = model.getLanguageId();
                if (languageId && languageId !== PLAINTEXT_LANGUAGE_ID) {
                    suggestedFilename = this.suggestFilename(languageId, nameCandidate);
                }
                else {
                    suggestedFilename = nameCandidate;
                }
            }
        }
        if (!suggestedFilename) {
            suggestedFilename = basename(resource);
        }
        return joinPath(defaultFilePath, suggestedFilename);
    }
    suggestFilename(languageId, untitledName) {
        const languageName = this.languageService.getLanguageName(languageId);
        if (!languageName) {
            return untitledName;
        }
        const untitledExtension = extname(untitledName);
        const extensions = this.languageService.getExtensions(languageId);
        if (extensions.includes(untitledExtension)) {
            return untitledName;
        }
        const primaryExtension = firstOrDefault(extensions);
        if (primaryExtension) {
            if (untitledExtension) {
                return `${untitledName.substring(0, untitledName.indexOf(untitledExtension))}${primaryExtension}`;
            }
            return `${untitledName}${primaryExtension}`;
        }
        const filenames = this.languageService.getFilenames(languageId);
        if (filenames.includes(untitledName)) {
            return untitledName;
        }
        return firstOrDefault(filenames) ?? untitledName;
    }
    async revert(resource, options) {
        if (resource.scheme === Schemas.untitled) {
            const model = this.untitled.get(resource);
            if (model) {
                return model.revert(options);
            }
        }
        else {
            const model = this.files.get(resource);
            if (model && (model.isDirty() || options?.force)) {
                return model.revert(options);
            }
        }
    }
    isDirty(resource) {
        const model = resource.scheme === Schemas.untitled ? this.untitled.get(resource) : this.files.get(resource);
        if (model) {
            return model.isDirty();
        }
        return false;
    }
};
AbstractTextFileService.TEXTFILE_SAVE_CREATE_SOURCE = SaveSourceRegistry.registerSource('textFileCreate.source', ( (localize('textFileCreate.source', "File Created"))));
AbstractTextFileService.TEXTFILE_SAVE_REPLACE_SOURCE = SaveSourceRegistry.registerSource('textFileOverwrite.source', ( (localize('textFileOverwrite.source', "File Replaced"))));
AbstractTextFileService = ( (__decorate([
    ( (__param(0, IFileService))),
    ( (__param(1, IUntitledTextEditorService))),
    ( (__param(2, ILifecycleService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IModelService))),
    ( (__param(5, IWorkbenchEnvironmentService))),
    ( (__param(6, IDialogService))),
    ( (__param(7, IFileDialogService))),
    ( (__param(8, ITextResourceConfigurationService))),
    ( (__param(9, IFilesConfigurationService))),
    ( (__param(10, ICodeEditorService))),
    ( (__param(11, IPathService))),
    ( (__param(12, IWorkingCopyFileService))),
    ( (__param(13, IUriIdentityService))),
    ( (__param(14, ILanguageService))),
    ( (__param(15, ILogService))),
    ( (__param(16, IElevatedFileService))),
    ( (__param(17, IDecorationsService)))
], AbstractTextFileService)));
let EncodingOracle = class EncodingOracle extends Disposable {
    get encodingOverrides() { return this._encodingOverrides; }
    set encodingOverrides(value) { this._encodingOverrides = value; }
    constructor(textResourceConfigurationService, environmentService, contextService, uriIdentityService) {
        super();
        this.textResourceConfigurationService = textResourceConfigurationService;
        this.environmentService = environmentService;
        this.contextService = contextService;
        this.uriIdentityService = uriIdentityService;
        this._encodingOverrides = this.getDefaultEncodingOverrides();
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.contextService.onDidChangeWorkspaceFolders(() => this.encodingOverrides = this.getDefaultEncodingOverrides()));
    }
    getDefaultEncodingOverrides() {
        const defaultEncodingOverrides = [];
        defaultEncodingOverrides.push({ parent: this.environmentService.userRoamingDataHome, encoding: UTF8 });
        defaultEncodingOverrides.push({ extension: WORKSPACE_EXTENSION, encoding: UTF8 });
        defaultEncodingOverrides.push({ parent: this.environmentService.untitledWorkspacesHome, encoding: UTF8 });
        this.contextService.getWorkspace().folders.forEach(folder => {
            defaultEncodingOverrides.push({ parent: joinPath(folder.uri, '.vscode'), encoding: UTF8 });
        });
        return defaultEncodingOverrides;
    }
    async getWriteEncoding(resource, options) {
        const { encoding, hasBOM } = await this.getPreferredWriteEncoding(resource, options ? options.encoding : undefined);
        return { encoding, addBOM: hasBOM };
    }
    async getPreferredWriteEncoding(resource, preferredEncoding) {
        const resourceEncoding = await this.getEncodingForResource(resource, preferredEncoding);
        return {
            encoding: resourceEncoding,
            hasBOM: resourceEncoding === UTF16be || resourceEncoding === UTF16le || resourceEncoding === UTF8_with_bom
        };
    }
    async getPreferredReadEncoding(resource, options, detectedEncoding) {
        let preferredEncoding;
        if (options?.encoding) {
            if (detectedEncoding === UTF8_with_bom && options.encoding === UTF8) {
                preferredEncoding = UTF8_with_bom;
            }
            else {
                preferredEncoding = options.encoding;
            }
        }
        else if (typeof detectedEncoding === 'string') {
            preferredEncoding = detectedEncoding;
        }
        else if (this.textResourceConfigurationService.getValue(resource, 'files.encoding') === UTF8_with_bom) {
            preferredEncoding = UTF8;
        }
        const encoding = await this.getEncodingForResource(resource, preferredEncoding);
        return {
            encoding,
            hasBOM: encoding === UTF16be || encoding === UTF16le || encoding === UTF8_with_bom
        };
    }
    async getEncodingForResource(resource, preferredEncoding) {
        let fileEncoding;
        const override = this.getEncodingOverride(resource);
        if (override) {
            fileEncoding = override;
        }
        else if (preferredEncoding) {
            fileEncoding = preferredEncoding;
        }
        else {
            fileEncoding = this.textResourceConfigurationService.getValue(resource, 'files.encoding');
        }
        if (fileEncoding !== UTF8) {
            if (!fileEncoding || !(await encodingExists(fileEncoding))) {
                fileEncoding = UTF8;
            }
        }
        return fileEncoding;
    }
    getEncodingOverride(resource) {
        if (this.encodingOverrides?.length) {
            for (const override of this.encodingOverrides) {
                if (override.parent && this.uriIdentityService.extUri.isEqualOrParent(resource, override.parent)) {
                    return override.encoding;
                }
                if (override.extension && extname$1(resource) === `.${override.extension}`) {
                    return override.encoding;
                }
            }
        }
        return undefined;
    }
};
EncodingOracle = ( (__decorate([
    ( (__param(0, ITextResourceConfigurationService))),
    ( (__param(1, IWorkbenchEnvironmentService))),
    ( (__param(2, IWorkspaceContextService))),
    ( (__param(3, IUriIdentityService)))
], EncodingOracle)));
let BrowserTextFileService = class BrowserTextFileService extends AbstractTextFileService {
    constructor(fileService, untitledTextEditorService, lifecycleService, instantiationService, modelService, environmentService, dialogService, fileDialogService, textResourceConfigurationService, filesConfigurationService, codeEditorService, pathService, workingCopyFileService, uriIdentityService, languageService, elevatedFileService, logService, decorationsService) {
        super(fileService, untitledTextEditorService, lifecycleService, instantiationService, modelService, environmentService, dialogService, fileDialogService, textResourceConfigurationService, filesConfigurationService, codeEditorService, pathService, workingCopyFileService, uriIdentityService, languageService, logService, elevatedFileService, decorationsService);
        this.registerListeners();
    }
    registerListeners() {
        this.lifecycleService.onBeforeShutdown(event => event.veto(this.onBeforeShutdown(), 'veto.textFiles'));
    }
    onBeforeShutdown() {
        if (this.files.models.some(model => model.hasState(2 ))) {
            return true;
        }
        return false;
    }
};
BrowserTextFileService = ( (__decorate([
    ( (__param(0, IFileService))),
    ( (__param(1, IUntitledTextEditorService))),
    ( (__param(2, ILifecycleService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IModelService))),
    ( (__param(5, IWorkbenchEnvironmentService))),
    ( (__param(6, IDialogService))),
    ( (__param(7, IFileDialogService))),
    ( (__param(8, ITextResourceConfigurationService))),
    ( (__param(9, IFilesConfigurationService))),
    ( (__param(10, ICodeEditorService))),
    ( (__param(11, IPathService))),
    ( (__param(12, IWorkingCopyFileService))),
    ( (__param(13, IUriIdentityService))),
    ( (__param(14, ILanguageService))),
    ( (__param(15, IElevatedFileService))),
    ( (__param(16, ILogService))),
    ( (__param(17, IDecorationsService)))
], BrowserTextFileService)));
let SimpleExtensionResourceLoaderService = class SimpleExtensionResourceLoaderService extends AbstractExtensionResourceLoaderService {
    constructor(fileService, storageService, productService, environmentService, configurationService) {
        super(fileService, storageService, productService, environmentService, configurationService);
    }
    async readExtensionResource(uri) {
        const result = await this._fileService.readFile(uri);
        return ( result.value.toString());
    }
};
SimpleExtensionResourceLoaderService = ( __decorate([
    ( __param(0, IFileService)),
    ( __param(1, IStorageService)),
    ( __param(2, IProductService)),
    ( __param(3, IEnvironmentService)),
    ( __param(4, IConfigurationService))
], SimpleExtensionResourceLoaderService));
registerSingleton(IExtensionResourceLoaderService, SimpleExtensionResourceLoaderService, 0 );
class File {
    constructor(getContent) {
        this.getContent = getContent;
        this.ctime = Date.now();
        this.mtime = Date.now();
        this.size = 0;
        this.type = FileType.File;
    }
}
const encoder = new TextEncoder();
class ExtensionFileSystemProviderWithFileReadWriteCapability {
    constructor() {
        this.capabilities = 2  | 1024 ;
        this.onDidChangeFile = Event.None;
        this.onDidChangeCapabilities = Event.None;
        this.onDidWatchError = Event.None;
        this.writeFile = unsupported;
        this.mkdir = unsupported;
        this.readdir = unsupported;
        this.delete = unsupported;
        this.rename = unsupported;
        this.files = new Map();
    }
    async stat(resource) {
        const file = this.files.get(( resource.toString()));
        if (file != null) {
            return file;
        }
        throw FileSystemProviderError.create('file not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async readFile(resource) {
        const file = this.files.get(( resource.toString()));
        if (file != null) {
            return encoder.encode(await file.getContent());
        }
        throw FileSystemProviderError.create('file not found', FileSystemProviderErrorCode.FileNotFound);
    }
    watch() {
        return {
            dispose() { }
        };
    }
    registerFile(resource, getContent) {
        this.files.set(( resource.toString()), new File(getContent));
        return new Disposable$1(() => {
            this.files.delete(( resource.toString()));
        });
    }
}
const extensionFileSystemProvider = new ExtensionFileSystemProviderWithFileReadWriteCapability();
let MemoryFileService = class MemoryFileService extends FileService {
    constructor(logService) {
        super(logService);
        this.registerProvider('user', new InMemoryFileSystemProvider());
        this.registerProvider('extension', extensionFileSystemProvider);
    }
};
MemoryFileService = ( __decorate([
    ( __param(0, ILogService))
], MemoryFileService));
function registerExtensionFile(extensionLocation, path, getContent) {
    return extensionFileSystemProvider.registerFile(joinPath(extensionLocation, path), getContent);
}
function getServiceOverride() {
    return {
        [( IFileService.toString())]: new SyncDescriptor(MemoryFileService),
        [( IExtensionResourceLoaderService.toString())]: new SyncDescriptor(SimpleExtensionResourceLoaderService),
        [( ITextFileService.toString())]: new SyncDescriptor(BrowserTextFileService)
    };
}
export { getServiceOverride as g, registerExtensionFile as r };
