import { _ as __decorate, aU as AutoSaveConfiguration, I as IEditorService, k as IPaneCompositePartService, j as IUriIdentityService, E as Emitter, l as ITextFileService, n as IFileService, d as IEditorGroupsService, o as IWorkbenchEnvironmentService, q as IWorkingCopyFileService, r as IPathService, S as Services, e as IProductService, s as ILanguageStatusService, t as IHostService, J as IUserDataProfilesService, y as ISnippetsService, u as IDebugService, aV as IRemoteAgentService, b as __classPrivateFieldSet, c as __classPrivateFieldGet, w as refineServiceDecorator, aW as AbstractPathService, a as __param, aX as HotExitConfiguration, F as FileSystemProviderErrorCode, aY as markAsFileSystemProviderError } from './services2.js';
import { I as IPolicyService, f as flatten, a0 as uniqueFilter, R as Range$1, $ as isStringArray, m as mapArrayOrNot } from './polyfill.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { compare, nextCharLength, compareIgnoreCase } from 'monaco-editor/esm/vs/base/common/strings.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { ExtensionIdentifier } from 'monaco-editor/esm/vs/platform/extensions/common/extensions.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import { Disposable as Disposable$1, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { addMatchMediaChangeListener } from 'monaco-editor/esm/vs/base/browser/browser.js';
import { registerIcon } from 'monaco-editor/esm/vs/platform/theme/common/iconRegistry.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { Promises, DeferredPromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { ThemeIcon as ThemeIcon$1 } from 'monaco-editor/esm/vs/base/common/themables.js';
import { Keybinding, KeyCodeChord } from 'monaco-editor/esm/vs/base/common/keybindings.js';
import { USLayoutResolvedKeybinding } from 'monaco-editor/esm/vs/platform/keybinding/common/usLayoutResolvedKeybinding.js';
import { firstOrDefault, coalesce, coalesceInPlace, equals as equals$1 } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { ExtUri, dirname } from 'monaco-editor/esm/vs/base/common/resources.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { equals, cloneAndChange, mixin, deepClone } from 'monaco-editor/esm/vs/base/common/objects.js';
import { Lazy } from 'monaco-editor/esm/vs/base/common/lazy.js';
import { LRUCachedFunction } from 'monaco-editor/esm/vs/base/common/cache.js';
import { match } from 'monaco-editor/esm/vs/base/common/glob.js';
import { isEqualOrParent } from 'monaco-editor/esm/vs/base/common/extpath.js';
import { relative } from 'monaco-editor/esm/vs/base/common/path.js';
import { illegalArgument, CancellationError, isCancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { isNumber, isObject, isString } from 'monaco-editor/esm/vs/base/common/types.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { isWeb, OS } from 'monaco-editor/esm/vs/base/common/platform.js';
import { IContextKeyService, RawContextKey } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import { MarkdownString as MarkdownString$1 } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { Mimes } from 'monaco-editor/esm/vs/base/common/mime.js';
import Severity from 'monaco-editor/esm/vs/base/common/severity.js';
import { registerSingleton } from 'monaco-editor/esm/vs/platform/instantiation/common/extensions.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { IProgressService } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { LanguageFeatureRegistry } from 'monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js';
import { trackFocus } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { DomEmitter } from 'monaco-editor/esm/vs/base/browser/event.js';
var _a$1;
const _format2Regexp = /{([^}]+)}/g;
function format2(template, values) {
    return template.replace(_format2Regexp, (match, group) => (values[group] ?? match));
}
function count(value, character) {
    let result = 0;
    const ch = character.charCodeAt(0);
    for (let i = value.length - 1; i >= 0; i--) {
        if (value.charCodeAt(i) === ch) {
            result++;
        }
    }
    return result;
}
function replaceAsync(str, search, replacer) {
    const parts = [];
    let last = 0;
    for (const match of str.matchAll(search)) {
        parts.push(str.slice(last, match.index));
        if (match.index === undefined) {
            throw new Error('match.index should be defined');
        }
        last = match.index + match[0].length;
        parts.push(replacer(match[0], ...match.slice(1), match.index, str, match.groups));
    }
    parts.push(str.slice(last));
    return Promise.all(parts).then(p => p.join(''));
}
function getNLines(str, n = 1) {
    if (n === 0) {
        return '';
    }
    let idx = -1;
    do {
        idx = str.indexOf('\n', idx + 1);
        n--;
    } while (n > 0 && idx >= 0);
    if (idx === -1) {
        return str;
    }
    if (str[idx - 1] === '\r') {
        idx--;
    }
    return str.substr(0, idx);
}
class AmbiguousCharacters {
    static getInstance(locales) {
        return AmbiguousCharacters.cache.get(Array.from(locales));
    }
    static getLocales() {
        return AmbiguousCharacters._locales.value;
    }
    constructor(confusableDictionary) {
        this.confusableDictionary = confusableDictionary;
    }
    isAmbiguous(codePoint) {
        return this.confusableDictionary.has(codePoint);
    }
    getPrimaryConfusable(codePoint) {
        return this.confusableDictionary.get(codePoint);
    }
    getConfusableCodePoints() {
        return (
             (new Set( (this.confusableDictionary.keys())))
        );
    }
}
_a$1 = AmbiguousCharacters;
AmbiguousCharacters.ambiguousCharacterData = ( (new Lazy(() => {
    return JSON.parse('{\"_common\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],\"_default\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"cs\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"de\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"es\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"fr\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"it\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ja\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\"ko\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pl\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pt-BR\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"qps-ploc\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ru\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"tr\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"zh-hans\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\"zh-hant\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');
})));
AmbiguousCharacters.cache = ( (new LRUCachedFunction((locales) => {
    function arrayToMap(arr) {
        const result = ( (new Map()));
        for (let i = 0; i < arr.length; i += 2) {
            result.set(arr[i], arr[i + 1]);
        }
        return result;
    }
    function mergeMaps(map1, map2) {
        const result = ( (new Map(map1)));
        for (const [key, value] of map2) {
            result.set(key, value);
        }
        return result;
    }
    function intersectMaps(map1, map2) {
        if (!map1) {
            return map2;
        }
        const result = ( (new Map()));
        for (const [key, value] of map1) {
            if (map2.has(key)) {
                result.set(key, value);
            }
        }
        return result;
    }
    const data = _a$1.ambiguousCharacterData.value;
    let filteredLocales = locales.filter((l) => !l.startsWith('_') && l in data);
    if (filteredLocales.length === 0) {
        filteredLocales = ['_default'];
    }
    let languageSpecificMap = undefined;
    for (const locale of filteredLocales) {
        const map = arrayToMap(data[locale]);
        languageSpecificMap = intersectMaps(languageSpecificMap, map);
    }
    const commonMap = arrayToMap(data['_common']);
    const map = mergeMaps(commonMap, languageSpecificMap);
    return (
         (new AmbiguousCharacters(map))
    );
})));
AmbiguousCharacters._locales = ( (new Lazy(
    () => ( (Object.keys(AmbiguousCharacters.ambiguousCharacterData.value))).filter((k) => !k.startsWith('_'))
)));
var DialogKind;
( ((function(DialogKind) {
    DialogKind[DialogKind["Confirmation"] = 1] = "Confirmation";
    DialogKind[DialogKind["Prompt"] = 2] = "Prompt";
    DialogKind[DialogKind["Input"] = 3] = "Input";
})(DialogKind || (DialogKind = {}))));
class AbstractDialogHandler {
    getConfirmationButtons(dialog) {
        return this.getButtons(dialog, DialogKind.Confirmation);
    }
    getPromptButtons(dialog) {
        return this.getButtons(dialog, DialogKind.Prompt);
    }
    getInputButtons(dialog) {
        return this.getButtons(dialog, DialogKind.Input);
    }
    getButtons(dialog, kind) {
        const buttons = [];
        switch (kind) {
            case DialogKind.Confirmation: {
                const confirmationDialog = dialog;
                if (confirmationDialog.primaryButton) {
                    buttons.push(confirmationDialog.primaryButton);
                }
                else {
                    buttons.push(( (localize({ key: 'yesButton', comment: ['&& denotes a mnemonic'] }, "&&Yes"))));
                }
                if (confirmationDialog.cancelButton) {
                    buttons.push(confirmationDialog.cancelButton);
                }
                else {
                    buttons.push(( (localize('cancelButton', "Cancel"))));
                }
                break;
            }
            case DialogKind.Prompt: {
                const promptDialog = dialog;
                if (Array.isArray(promptDialog.buttons) && promptDialog.buttons.length > 0) {
                    buttons.push(...( (promptDialog.buttons.map(button => button.label))));
                }
                if (promptDialog.cancelButton) {
                    if (promptDialog.cancelButton === true) {
                        buttons.push(( (localize('cancelButton', "Cancel"))));
                    }
                    else if (typeof promptDialog.cancelButton === 'string') {
                        buttons.push(promptDialog.cancelButton);
                    }
                    else {
                        if (promptDialog.cancelButton.label) {
                            buttons.push(promptDialog.cancelButton.label);
                        }
                        else {
                            buttons.push(( (localize('cancelButton', "Cancel"))));
                        }
                    }
                }
                if (buttons.length === 0) {
                    buttons.push(( (localize({ key: 'okButton', comment: ['&& denotes a mnemonic'] }, "&&OK"))));
                }
                break;
            }
            case DialogKind.Input: {
                const inputDialog = dialog;
                if (inputDialog.primaryButton) {
                    buttons.push(inputDialog.primaryButton);
                }
                else {
                    buttons.push(( (localize({ key: 'okButton', comment: ['&& denotes a mnemonic'] }, "&&OK"))));
                }
                if (inputDialog.cancelButton) {
                    buttons.push(inputDialog.cancelButton);
                }
                else {
                    buttons.push(( (localize('cancelButton', "Cancel"))));
                }
                break;
            }
        }
        return buttons;
    }
    getDialogType(type) {
        if (typeof type === 'string') {
            return type;
        }
        if (typeof type === 'number') {
            return (type === Severity.Info) ? 'info' : (type === Severity.Error) ? 'error' : (type === Severity.Warning) ? 'warning' : 'none';
        }
        return undefined;
    }
    async getPromptResult(prompt, buttonIndex, checkboxChecked) {
        const promptButtons = [...(prompt.buttons ?? [])];
        if (prompt.cancelButton && typeof prompt.cancelButton !== 'string' && typeof prompt.cancelButton !== 'boolean') {
            promptButtons.push(prompt.cancelButton);
        }
        const result = await promptButtons[buttonIndex]?.run({ checkboxChecked });
        return { result, checkboxChecked };
    }
}
const IFileDialogService = ( (createDecorator('fileDialogService')));
const ICustomEndpointTelemetryService = ( (createDecorator('customEndpointTelemetryService')));
const TELEMETRY_SETTING_ID = 'telemetry.telemetryLevel';
const TELEMETRY_CRASH_REPORTER_SETTING_ID = 'telemetry.enableCrashReporter';
const TELEMETRY_OLD_SETTING_ID = 'telemetry.enableTelemetry';
const ILoggerService = ( (createDecorator('loggerService')));
function isLogLevel(thing) {
    return isNumber(thing);
}
var LogLevel;
( ((function(LogLevel) {
    LogLevel[LogLevel["Off"] = 0] = "Off";
    LogLevel[LogLevel["Trace"] = 1] = "Trace";
    LogLevel[LogLevel["Debug"] = 2] = "Debug";
    LogLevel[LogLevel["Info"] = 3] = "Info";
    LogLevel[LogLevel["Warning"] = 4] = "Warning";
    LogLevel[LogLevel["Error"] = 5] = "Error";
})(LogLevel || (LogLevel = {}))));
class AbstractLoggerService extends Disposable$1 {
    constructor(logLevel, loggerResources) {
        super();
        this.logLevel = logLevel;
        this._loggers = ( (new ResourceMap()));
        this._loggerResources = ( (new ResourceMap()));
        this._onDidChangeLoggers = this._register(( (new Emitter())));
        this.onDidChangeLoggers = this._onDidChangeLoggers.event;
        this._onDidChangeLogLevel = this._register(( (new Emitter())));
        this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        if (loggerResources) {
            for (const loggerResource of loggerResources) {
                this._loggerResources.set(loggerResource.resource, loggerResource);
            }
        }
    }
    getLogger(resource) {
        return this._loggers.get(resource);
    }
    createLogger(resource, options) {
        let logger = this._loggers.get(resource);
        const logLevel = options?.logLevel === 'always' ? LogLevel.Trace : options?.logLevel;
        if (!logger) {
            logger = this.doCreateLogger(resource, logLevel ?? this.getLogLevel(resource) ?? this.logLevel, options);
            this._loggers.set(resource, logger);
        }
        this.registerLogger({ resource, id: options?.id ?? ( (resource.toString())), logLevel, name: options?.name, hidden: options?.hidden, extensionId: options?.extensionId });
        return logger;
    }
    setLogLevel(arg1, arg2) {
        if (URI.isUri(arg1)) {
            const resource = arg1;
            const logLevel = arg2;
            const loggerResource = this._loggerResources.get(resource);
            if (loggerResource && logLevel !== loggerResource.logLevel) {
                loggerResource.logLevel = logLevel === this.logLevel ? undefined : logLevel;
                this._loggers.get(resource)?.setLevel(logLevel);
                this._loggerResources.set(loggerResource.resource, loggerResource);
                this._onDidChangeLogLevel.fire([resource, logLevel]);
            }
        }
        else {
            this.logLevel = arg1;
            for (const [resource, logger] of this._loggers.entries()) {
                if (this._loggerResources.get(resource)?.logLevel === undefined) {
                    logger.setLevel(this.logLevel);
                }
            }
            this._onDidChangeLogLevel.fire(this.logLevel);
        }
    }
    setVisibility(resource, visibility) {
        const loggerResource = this._loggerResources.get(resource);
        if (loggerResource && visibility !== !loggerResource.hidden) {
            loggerResource.hidden = !visibility;
            this._loggerResources.set(loggerResource.resource, loggerResource);
            this._onDidChangeVisibility.fire([resource, visibility]);
        }
    }
    getLogLevel(resource) {
        let logLevel;
        if (resource) {
            logLevel = this._loggerResources.get(resource)?.logLevel;
        }
        return logLevel ?? this.logLevel;
    }
    registerLogger(resource) {
        const existing = this._loggerResources.get(resource.resource);
        if (existing) {
            if (existing.hidden !== resource.hidden) {
                this.setVisibility(resource.resource, !resource.hidden);
            }
        }
        else {
            this._loggerResources.set(resource.resource, resource);
            this._onDidChangeLoggers.fire({ added: [resource], removed: [] });
        }
    }
    deregisterLogger(resource) {
        const existing = this._loggerResources.get(resource);
        if (existing) {
            this._loggerResources.delete(resource);
            const logger = this._loggers.get(resource);
            if (logger) {
                this._loggers.delete(resource);
                logger.dispose();
            }
            this._onDidChangeLoggers.fire({ added: [], removed: [existing] });
        }
    }
    getRegisteredLoggers() {
        return (
             (this._loggerResources.values())
        );
    }
    getRegisteredLogger(resource) {
        return this._loggerResources.get(resource);
    }
    dispose() {
        this._loggers.forEach(logger => logger.dispose());
        this._loggers.clear();
        this._loggerResources.clear();
        super.dispose();
    }
}
class NullLogger {
    constructor() {
        this.onDidChangeLogLevel = ( (new Emitter())).event;
    }
    setLevel(level) { }
    getLevel() { return LogLevel.Info; }
    trace(message, ...args) { }
    debug(message, ...args) { }
    info(message, ...args) { }
    warn(message, ...args) { }
    error(message, ...args) { }
    critical(message, ...args) { }
    dispose() { }
    flush() { }
}
class NullLoggerService extends AbstractLoggerService {
    constructor() { super(LogLevel.Info); }
    doCreateLogger(resource, logLevel, options) {
        return (
             (new NullLogger())
        );
    }
}
const IWorkspaceTrustRequestService = ( (createDecorator('workspaceTrustRequestService')));
const _simplePattern = /^(.+)\/(.+?)(;.+)?$/;
function normalizeMimeType(mimeType, strict) {
    const match = _simplePattern.exec(mimeType);
    if (!match) {
        return strict
            ? undefined
            : mimeType;
    }
    return `${match[1].toLowerCase()}/${match[2].toLowerCase()}${match[3] ?? ''}`;
}
function isResourceEditorInput(editor) {
    if (isEditorInput(editor)) {
        return false;
    }
    const candidate = editor;
    return URI.isUri(candidate?.resource);
}
function isResourceDiffEditorInput(editor) {
    if (isEditorInput(editor)) {
        return false;
    }
    const candidate = editor;
    return candidate?.original !== undefined && candidate.modified !== undefined;
}
function isResourceSideBySideEditorInput(editor) {
    if (isEditorInput(editor)) {
        return false;
    }
    if (isResourceDiffEditorInput(editor)) {
        return false;
    }
    const candidate = editor;
    return candidate?.primary !== undefined && candidate.secondary !== undefined;
}
function isResourceMergeEditorInput(editor) {
    if (isEditorInput(editor)) {
        return false;
    }
    const candidate = editor;
    return URI.isUri(candidate?.base?.resource) && URI.isUri(candidate?.input1?.resource) && URI.isUri(candidate?.input2?.resource) && URI.isUri(candidate?.result?.resource);
}
class SaveSourceFactory {
    constructor() {
        this.mapIdToSaveSource = ( (new Map()));
    }
    registerSource(id, label) {
        let sourceDescriptor = this.mapIdToSaveSource.get(id);
        if (!sourceDescriptor) {
            sourceDescriptor = { source: id, label };
            this.mapIdToSaveSource.set(id, sourceDescriptor);
        }
        return sourceDescriptor.source;
    }
    getSourceLabel(source) {
        return this.mapIdToSaveSource.get(source)?.label ?? source;
    }
}
const SaveSourceRegistry = ( (new SaveSourceFactory()));
class AbstractEditorInput extends Disposable$1 {
}
function isEditorInput(editor) {
    return editor instanceof AbstractEditorInput;
}
function isEditorInputWithPreferredResource(editor) {
    const candidate = editor;
    return URI.isUri(candidate?.preferredResource);
}
function isSideBySideEditorInput(editor) {
    const candidate = editor;
    return isEditorInput(candidate?.primary) && isEditorInput(candidate?.secondary);
}
function isDiffEditorInput(editor) {
    const candidate = editor;
    return isEditorInput(candidate?.modified) && isEditorInput(candidate?.original);
}
var SideBySideEditor;
( ((function(SideBySideEditor) {
    SideBySideEditor[SideBySideEditor["PRIMARY"] = 1] = "PRIMARY";
    SideBySideEditor[SideBySideEditor["SECONDARY"] = 2] = "SECONDARY";
    SideBySideEditor[SideBySideEditor["BOTH"] = 3] = "BOTH";
    SideBySideEditor[SideBySideEditor["ANY"] = 4] = "ANY";
})(SideBySideEditor || (SideBySideEditor = {}))));
class EditorResourceAccessorImpl {
    getOriginalUri(editor, options) {
        if (!editor) {
            return undefined;
        }
        if (isResourceMergeEditorInput(editor)) {
            return EditorResourceAccessor.getOriginalUri(editor.result, options);
        }
        if (options?.supportSideBySide) {
            const { primary, secondary } = this.getSideEditors(editor);
            if (primary && secondary) {
                if (options?.supportSideBySide === SideBySideEditor.BOTH) {
                    return {
                        primary: this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }),
                        secondary: this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme })
                    };
                }
                else if (options?.supportSideBySide === SideBySideEditor.ANY) {
                    return this.getOriginalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getOriginalUri(secondary, { filterByScheme: options.filterByScheme });
                }
                editor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;
            }
        }
        if (isResourceDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {
            return undefined;
        }
        const originalResource = isEditorInputWithPreferredResource(editor) ? editor.preferredResource : editor.resource;
        if (!originalResource || !options || !options.filterByScheme) {
            return originalResource;
        }
        return this.filterUri(originalResource, options.filterByScheme);
    }
    getSideEditors(editor) {
        if (isSideBySideEditorInput(editor) || isResourceSideBySideEditorInput(editor)) {
            return { primary: editor.primary, secondary: editor.secondary };
        }
        if (isDiffEditorInput(editor) || isResourceDiffEditorInput(editor)) {
            return { primary: editor.modified, secondary: editor.original };
        }
        return { primary: undefined, secondary: undefined };
    }
    getCanonicalUri(editor, options) {
        if (!editor) {
            return undefined;
        }
        if (isResourceMergeEditorInput(editor)) {
            return EditorResourceAccessor.getCanonicalUri(editor.result, options);
        }
        if (options?.supportSideBySide) {
            const { primary, secondary } = this.getSideEditors(editor);
            if (primary && secondary) {
                if (options?.supportSideBySide === SideBySideEditor.BOTH) {
                    return {
                        primary: this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }),
                        secondary: this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme })
                    };
                }
                else if (options?.supportSideBySide === SideBySideEditor.ANY) {
                    return this.getCanonicalUri(primary, { filterByScheme: options.filterByScheme }) ?? this.getCanonicalUri(secondary, { filterByScheme: options.filterByScheme });
                }
                editor = options.supportSideBySide === SideBySideEditor.PRIMARY ? primary : secondary;
            }
        }
        if (isResourceDiffEditorInput(editor) || isResourceSideBySideEditorInput(editor) || isResourceMergeEditorInput(editor)) {
            return undefined;
        }
        const canonicalResource = editor.resource;
        if (!canonicalResource || !options || !options.filterByScheme) {
            return canonicalResource;
        }
        return this.filterUri(canonicalResource, options.filterByScheme);
    }
    filterUri(resource, filter) {
        if (Array.isArray(filter)) {
            if (filter.some(scheme => resource.scheme === scheme)) {
                return resource;
            }
        }
        else {
            if (filter === resource.scheme) {
                return resource;
            }
        }
        return undefined;
    }
}
const EditorResourceAccessor = ( (new EditorResourceAccessorImpl()));
function isTextEditorViewState(candidate) {
    const viewState = candidate;
    if (!viewState) {
        return false;
    }
    const diffEditorViewState = viewState;
    if (diffEditorViewState.modified) {
        return isTextEditorViewState(diffEditorViewState.modified);
    }
    const codeEditorViewState = viewState;
    return !!(codeEditorViewState.contributionsState && codeEditorViewState.viewState && Array.isArray(codeEditorViewState.cursorState));
}
const IWorkingCopyService = ( (createDecorator('workingCopyService')));
var RemoteAuthorityResolverErrorCode;
( ((function(RemoteAuthorityResolverErrorCode) {
    RemoteAuthorityResolverErrorCode["Unknown"] = "Unknown";
    RemoteAuthorityResolverErrorCode["NotAvailable"] = "NotAvailable";
    RemoteAuthorityResolverErrorCode["TemporarilyNotAvailable"] = "TemporarilyNotAvailable";
    RemoteAuthorityResolverErrorCode["NoResolverFound"] = "NoResolverFound";
})(
    RemoteAuthorityResolverErrorCode || (RemoteAuthorityResolverErrorCode = {})
)));
function getRemoteAuthorityPrefix(remoteAuthority) {
    const plusIndex = remoteAuthority.indexOf('+');
    if (plusIndex === -1) {
        return remoteAuthority;
    }
    return remoteAuthority.substring(0, plusIndex);
}
var CellKind;
( ((function(CellKind) {
    CellKind[CellKind["Markup"] = 1] = "Markup";
    CellKind[CellKind["Code"] = 2] = "Code";
})(CellKind || (CellKind = {}))));
function isTextStreamMime(mimeType) {
    return ['application/vnd.code.notebook.stdout', 'application/vnd.code.notebook.stderr'].includes(mimeType);
}
function getRemoteAuthority(uri) {
    return uri.scheme === Schemas.vscodeRemote ? uri.authority : undefined;
}
function getRemoteName(authority) {
    if (!authority) {
        return undefined;
    }
    const pos = authority.indexOf('+');
    if (pos < 0) {
        return authority;
    }
    return authority.substr(0, pos);
}
function getRemoteServerRootPath(product) {
    return `/${product.quality ?? 'oss'}-${product.commit ?? 'dev'}`;
}
class TelemetryTrustedValue {
    constructor(value) {
        this.value = value;
    }
}
class NullEndpointTelemetryService {
    async publicLog(_endpoint, _eventName, _data) {
    }
    async publicLogError(_endpoint, _errorEventName, _data) {
    }
}
const extensionTelemetryLogChannelId = 'extensionTelemetryLog';
function supportsTelemetry(productService, environmentService) {
    if (!environmentService.isBuilt && !environmentService.disableTelemetry) {
        return true;
    }
    return !(environmentService.disableTelemetry || !productService.enableTelemetry || environmentService.extensionTestsLocationURI);
}
function getTelemetryLevel(configurationService) {
    const newConfig = configurationService.getValue(TELEMETRY_SETTING_ID);
    const crashReporterConfig = configurationService.getValue(TELEMETRY_CRASH_REPORTER_SETTING_ID);
    const oldConfig = configurationService.getValue(TELEMETRY_OLD_SETTING_ID);
    if (oldConfig === false || crashReporterConfig === false) {
        return 0 ;
    }
    switch (newConfig ?? "all" ) {
        case "all" :
            return 3 ;
        case "error" :
            return 2 ;
        case "crash" :
            return 1 ;
        case "off" :
            return 0 ;
    }
}
const telemetryAllowedAuthorities = ( (new Set(
    ['ssh-remote', 'dev-container', 'attached-container', 'wsl', 'tunnel', 'codespaces', 'amlext']
)));
function cleanRemoteAuthority(remoteAuthority) {
    if (!remoteAuthority) {
        return 'none';
    }
    const remoteName = getRemoteName(remoteAuthority);
    return telemetryAllowedAuthorities.has(remoteName) ? remoteName : 'other';
}
function anonymizeFilePaths(stack, cleanupPatterns) {
    if (!stack || (!stack.includes('/') && !stack.includes('\\'))) {
        return stack;
    }
    let updatedStack = stack;
    const cleanUpIndexes = [];
    for (const regexp of cleanupPatterns) {
        while (true) {
            const result = regexp.exec(stack);
            if (!result) {
                break;
            }
            cleanUpIndexes.push([result.index, regexp.lastIndex]);
        }
    }
    const nodeModulesRegex = /^[\\\/]?(node_modules|node_modules\.asar)[\\\/]/;
    const fileRegex = /(file:\/\/)?([a-zA-Z]:(\\\\|\\|\/)|(\\\\|\\|\/))?([\w-\._]+(\\\\|\\|\/))+[\w-\._]*/g;
    let lastIndex = 0;
    updatedStack = '';
    while (true) {
        const result = fileRegex.exec(stack);
        if (!result) {
            break;
        }
        const overlappingRange = cleanUpIndexes.some(([start, end]) => result.index < end && start < fileRegex.lastIndex);
        if (!nodeModulesRegex.test(result[0]) && !overlappingRange) {
            updatedStack += stack.substring(lastIndex, result.index) + '<REDACTED: user-file-path>';
            lastIndex = fileRegex.lastIndex;
        }
    }
    if (lastIndex < stack.length) {
        updatedStack += stack.substr(lastIndex);
    }
    return updatedStack;
}
function removePropertiesWithPossibleUserInfo(property) {
    if (!property) {
        return property;
    }
    const value = property.toLowerCase();
    const userDataRegexes = [
        { label: 'Google API Key', regex: /AIza[A-Za-z0-9_\\\-]{35}/ },
        { label: 'Slack Token', regex: /xox[pbar]\-[A-Za-z0-9]/ },
        { label: 'Generic Secret', regex: /(key|token|sig|secret|signature|password|passwd|pwd|android:value)[^a-zA-Z0-9]/ },
        { label: 'Email', regex: /@[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+/ }
    ];
    for (const secretRegex of userDataRegexes) {
        if (secretRegex.regex.test(value)) {
            return `<REDACTED: ${secretRegex.label}>`;
        }
    }
    return property;
}
function cleanData(data, cleanUpPatterns) {
    return cloneAndChange(data, value => {
        if (value instanceof TelemetryTrustedValue) {
            return value.value;
        }
        if (typeof value === 'string') {
            let updatedProperty = value.replaceAll('%20', ' ');
            updatedProperty = anonymizeFilePaths(updatedProperty, cleanUpPatterns);
            for (const regexp of cleanUpPatterns) {
                updatedProperty = updatedProperty.replace(regexp, '');
            }
            updatedProperty = removePropertiesWithPossibleUserInfo(updatedProperty);
            return updatedProperty;
        }
        return undefined;
    });
}
function areSameExtensions(a, b) {
    if (a.uuid && b.uuid) {
        return a.uuid === b.uuid;
    }
    if (a.id === b.id) {
        return true;
    }
    return compareIgnoreCase(a.id, b.id) === 0;
}
function getExtensionId(publisher, name) {
    return `${publisher}.${name}`;
}
const IExtensionService = ( (createDecorator('extensionService')));
class MissingExtensionDependency {
    constructor(dependency) {
        this.dependency = dependency;
    }
}
function extensionIdentifiersArrayToSet(extensionIds) {
    const result = ( (new Set()));
    for (const extensionId of extensionIds) {
        result.add(ExtensionIdentifier.toKey(extensionId));
    }
    return result;
}
function isProposedApiEnabled(extension, proposal) {
    if (!extension.enabledApiProposals) {
        return false;
    }
    return extension.enabledApiProposals.includes(proposal);
}
function checkProposedApiEnabled(extension, proposal) {
    if (!isProposedApiEnabled(extension, proposal)) {
        throw new Error(`Extension '${extension.identifier.value}' CANNOT use API proposal: ${proposal}.\nIts package.json#enabledApiProposals-property declares: ${extension.enabledApiProposals?.join(', ') ?? '[]'} but NOT ${proposal}.\n The missing proposal MUST be added and you must start in extension development mode or use the following command line switch: --enable-proposed-api ${extension.identifier.value}`);
    }
}
function toExtensionDescription(extension, isUnderDevelopment) {
    return {
        identifier: ( (new ExtensionIdentifier(getExtensionId(extension.manifest.publisher, extension.manifest.name)))),
        isBuiltin: extension.type === 0 ,
        isUserBuiltin: extension.type === 1  && extension.isBuiltin,
        isUnderDevelopment: !!isUnderDevelopment,
        extensionLocation: extension.location,
        ...extension.manifest,
        uuid: extension.identifier.uuid,
        targetPlatform: extension.targetPlatform,
        browserNlsBundleUris: extension.browserNlsBundleUris
    };
}
class NullExtensionService {
    constructor() {
        this.onDidRegisterExtensions = Event.None;
        this.onDidChangeExtensionsStatus = Event.None;
        this.onDidChangeExtensions = Event.None;
        this.onWillActivateByEvent = Event.None;
        this.onDidChangeResponsiveChange = Event.None;
        this.extensions = [];
    }
    activateByEvent(_activationEvent) { return Promise.resolve(undefined); }
    activationEventIsDone(_activationEvent) { return false; }
    whenInstalledExtensionsRegistered() { return Promise.resolve(true); }
    getExtension() { return Promise.resolve(undefined); }
    readExtensionPointContributions(_extPoint) { return Promise.resolve(Object.create(null)); }
    getExtensionsStatus() { return Object.create(null); }
    getInspectPort(_extensionHostId, _tryEnableInspector) { return Promise.resolve(0); }
    getInspectPorts(_extensionHostKind, _tryEnableInspector) { return Promise.resolve([]); }
    stopExtensionHosts() { }
    async restartExtensionHost() { }
    async startExtensionHosts() { }
    async setRemoteEnvironment(_env) { }
    canAddExtension() { return false; }
    canRemoveExtension() { return false; }
}
var _Disposable_callOnDispose, _MarkdownString_delegate, _DataTransfer_items, _a, _NotebookCellOutputItem_encoder;
var Disposable_1, Position_1, Range_1, Selection_1, TextEdit_1, NotebookEdit_1, SnippetString_1, Location_1, SymbolInformation_1, DocumentSymbol_1, CodeActionKind_1, MarkdownString_1, TaskGroup_1, Task_1, TreeItem_1, FileSystemError_1, TestMessage_1;
function es5ClassCompat(target) {
    const interceptFunctions = {
        apply: function () {
            const args = arguments.length === 1 ? [] : arguments[1];
            return Reflect.construct(target, args, arguments[0].constructor);
        },
        call: function () {
            if (arguments.length === 0) {
                return Reflect.construct(target, []);
            }
            else {
                const [thisArg, ...restArgs] = arguments;
                return Reflect.construct(target, restArgs, thisArg.constructor);
            }
        }
    };
    return Object.assign(target, interceptFunctions);
}
let Disposable = Disposable_1 = class Disposable {
    static from(...inDisposables) {
        let disposables = inDisposables;
        return (
             (new Disposable_1(function () {
                if (disposables) {
                    for (const disposable of disposables) {
                        if (disposable && typeof disposable.dispose === 'function') {
                            disposable.dispose();
                        }
                    }
                    disposables = undefined;
                }
            }))
        );
    }
    constructor(callOnDispose) {
        _Disposable_callOnDispose.set(this, void 0);
        __classPrivateFieldSet(this, _Disposable_callOnDispose, callOnDispose, "f");
    }
    dispose() {
        if (typeof __classPrivateFieldGet(this, _Disposable_callOnDispose, "f") === 'function') {
            __classPrivateFieldGet(this, _Disposable_callOnDispose, "f").call(this);
            __classPrivateFieldSet(this, _Disposable_callOnDispose, undefined, "f");
        }
    }
};
_Disposable_callOnDispose = ( (new WeakMap()));
Disposable = Disposable_1 = ( (__decorate([
    es5ClassCompat
], Disposable)));
let Position = Position_1 = class Position {
    static Min(...positions) {
        if (positions.length === 0) {
            throw new TypeError();
        }
        let result = positions[0];
        for (let i = 1; i < positions.length; i++) {
            const p = positions[i];
            if (p.isBefore(result)) {
                result = p;
            }
        }
        return result;
    }
    static Max(...positions) {
        if (positions.length === 0) {
            throw new TypeError();
        }
        let result = positions[0];
        for (let i = 1; i < positions.length; i++) {
            const p = positions[i];
            if (p.isAfter(result)) {
                result = p;
            }
        }
        return result;
    }
    static isPosition(other) {
        if (!other) {
            return false;
        }
        if (other instanceof Position_1) {
            return true;
        }
        const { line, character } = other;
        if (typeof line === 'number' && typeof character === 'number') {
            return true;
        }
        return false;
    }
    static of(obj) {
        if (obj instanceof Position_1) {
            return obj;
        }
        else if (this.isPosition(obj)) {
            return (
                 (new Position_1(obj.line, obj.character))
            );
        }
        throw new Error('Invalid argument, is NOT a position-like object');
    }
    get line() {
        return this._line;
    }
    get character() {
        return this._character;
    }
    constructor(line, character) {
        if (line < 0) {
            throw illegalArgument('line must be non-negative');
        }
        if (character < 0) {
            throw illegalArgument('character must be non-negative');
        }
        this._line = line;
        this._character = character;
    }
    isBefore(other) {
        if (this._line < other._line) {
            return true;
        }
        if (other._line < this._line) {
            return false;
        }
        return this._character < other._character;
    }
    isBeforeOrEqual(other) {
        if (this._line < other._line) {
            return true;
        }
        if (other._line < this._line) {
            return false;
        }
        return this._character <= other._character;
    }
    isAfter(other) {
        return !this.isBeforeOrEqual(other);
    }
    isAfterOrEqual(other) {
        return !this.isBefore(other);
    }
    isEqual(other) {
        return this._line === other._line && this._character === other._character;
    }
    compareTo(other) {
        if (this._line < other._line) {
            return -1;
        }
        else if (this._line > other.line) {
            return 1;
        }
        else {
            if (this._character < other._character) {
                return -1;
            }
            else if (this._character > other._character) {
                return 1;
            }
            else {
                return 0;
            }
        }
    }
    translate(lineDeltaOrChange, characterDelta = 0) {
        if (lineDeltaOrChange === null || characterDelta === null) {
            throw illegalArgument();
        }
        let lineDelta;
        if (typeof lineDeltaOrChange === 'undefined') {
            lineDelta = 0;
        }
        else if (typeof lineDeltaOrChange === 'number') {
            lineDelta = lineDeltaOrChange;
        }
        else {
            lineDelta = typeof lineDeltaOrChange.lineDelta === 'number' ? lineDeltaOrChange.lineDelta : 0;
            characterDelta = typeof lineDeltaOrChange.characterDelta === 'number' ? lineDeltaOrChange.characterDelta : 0;
        }
        if (lineDelta === 0 && characterDelta === 0) {
            return this;
        }
        return (
             (new Position_1(this.line + lineDelta, this.character + characterDelta))
        );
    }
    with(lineOrChange, character = this.character) {
        if (lineOrChange === null || character === null) {
            throw illegalArgument();
        }
        let line;
        if (typeof lineOrChange === 'undefined') {
            line = this.line;
        }
        else if (typeof lineOrChange === 'number') {
            line = lineOrChange;
        }
        else {
            line = typeof lineOrChange.line === 'number' ? lineOrChange.line : this.line;
            character = typeof lineOrChange.character === 'number' ? lineOrChange.character : this.character;
        }
        if (line === this.line && character === this.character) {
            return this;
        }
        return (
             (new Position_1(line, character))
        );
    }
    toJSON() {
        return { line: this.line, character: this.character };
    }
};
Position = Position_1 = ( (__decorate([
    es5ClassCompat
], Position)));
let Range = Range_1 = class Range {
    static isRange(thing) {
        if (thing instanceof Range_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Position.isPosition(thing.start)
            && Position.isPosition(thing.end);
    }
    static of(obj) {
        if (obj instanceof Range_1) {
            return obj;
        }
        if (this.isRange(obj)) {
            return (
                 (new Range_1(obj.start, obj.end))
            );
        }
        throw new Error('Invalid argument, is NOT a range-like object');
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    constructor(startLineOrStart, startColumnOrEnd, endLine, endColumn) {
        let start;
        let end;
        if (typeof startLineOrStart === 'number' && typeof startColumnOrEnd === 'number' && typeof endLine === 'number' && typeof endColumn === 'number') {
            start = ( (new Position(startLineOrStart, startColumnOrEnd)));
            end = ( (new Position(endLine, endColumn)));
        }
        else if (Position.isPosition(startLineOrStart) && Position.isPosition(startColumnOrEnd)) {
            start = Position.of(startLineOrStart);
            end = Position.of(startColumnOrEnd);
        }
        if (!start || !end) {
            throw new Error('Invalid arguments');
        }
        if (start.isBefore(end)) {
            this._start = start;
            this._end = end;
        }
        else {
            this._start = end;
            this._end = start;
        }
    }
    contains(positionOrRange) {
        if (Range_1.isRange(positionOrRange)) {
            return this.contains(positionOrRange.start)
                && this.contains(positionOrRange.end);
        }
        else if (Position.isPosition(positionOrRange)) {
            if (Position.of(positionOrRange).isBefore(this._start)) {
                return false;
            }
            if (this._end.isBefore(positionOrRange)) {
                return false;
            }
            return true;
        }
        return false;
    }
    isEqual(other) {
        return this._start.isEqual(other._start) && this._end.isEqual(other._end);
    }
    intersection(other) {
        const start = Position.Max(other.start, this._start);
        const end = Position.Min(other.end, this._end);
        if (start.isAfter(end)) {
            return undefined;
        }
        return (
             (new Range_1(start, end))
        );
    }
    union(other) {
        if (this.contains(other)) {
            return this;
        }
        else if (other.contains(this)) {
            return other;
        }
        const start = Position.Min(other.start, this._start);
        const end = Position.Max(other.end, this.end);
        return (
             (new Range_1(start, end))
        );
    }
    get isEmpty() {
        return this._start.isEqual(this._end);
    }
    get isSingleLine() {
        return this._start.line === this._end.line;
    }
    with(startOrChange, end = this.end) {
        if (startOrChange === null || end === null) {
            throw illegalArgument();
        }
        let start;
        if (!startOrChange) {
            start = this.start;
        }
        else if (Position.isPosition(startOrChange)) {
            start = startOrChange;
        }
        else {
            start = startOrChange.start || this.start;
            end = startOrChange.end || this.end;
        }
        if (start.isEqual(this._start) && end.isEqual(this.end)) {
            return this;
        }
        return (
             (new Range_1(start, end))
        );
    }
    toJSON() {
        return [this.start, this.end];
    }
};
Range = Range_1 = ( (__decorate([
    es5ClassCompat
], Range)));
let Selection = Selection_1 = class Selection extends Range {
    static isSelection(thing) {
        if (thing instanceof Selection_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Range.isRange(thing)
            && Position.isPosition(thing.anchor)
            && Position.isPosition(thing.active)
            && typeof thing.isReversed === 'boolean';
    }
    get anchor() {
        return this._anchor;
    }
    get active() {
        return this._active;
    }
    constructor(anchorLineOrAnchor, anchorColumnOrActive, activeLine, activeColumn) {
        let anchor;
        let active;
        if (typeof anchorLineOrAnchor === 'number' && typeof anchorColumnOrActive === 'number' && typeof activeLine === 'number' && typeof activeColumn === 'number') {
            anchor = ( (new Position(anchorLineOrAnchor, anchorColumnOrActive)));
            active = ( (new Position(activeLine, activeColumn)));
        }
        else if (Position.isPosition(anchorLineOrAnchor) && Position.isPosition(anchorColumnOrActive)) {
            anchor = Position.of(anchorLineOrAnchor);
            active = Position.of(anchorColumnOrActive);
        }
        if (!anchor || !active) {
            throw new Error('Invalid arguments');
        }
        super(anchor, active);
        this._anchor = anchor;
        this._active = active;
    }
    get isReversed() {
        return this._anchor === this._end;
    }
    toJSON() {
        return {
            start: this.start,
            end: this.end,
            active: this.active,
            anchor: this.anchor
        };
    }
};
Selection = Selection_1 = ( (__decorate([
    es5ClassCompat
], Selection)));
class RemoteAuthorityResolverError extends Error {
    static NotAvailable(message, handled) {
        return (
             (new RemoteAuthorityResolverError(message, RemoteAuthorityResolverErrorCode.NotAvailable, handled))
        );
    }
    static TemporarilyNotAvailable(message) {
        return (
             (new RemoteAuthorityResolverError(message, RemoteAuthorityResolverErrorCode.TemporarilyNotAvailable))
        );
    }
    constructor(message, code = RemoteAuthorityResolverErrorCode.Unknown, detail) {
        super(message);
        this._message = message;
        this._code = code;
        this._detail = detail;
        Object.setPrototypeOf(this, RemoteAuthorityResolverError.prototype);
    }
}
var EndOfLine;
( ((function(EndOfLine) {
    EndOfLine[EndOfLine["LF"] = 1] = "LF";
    EndOfLine[EndOfLine["CRLF"] = 2] = "CRLF";
})(EndOfLine || (EndOfLine = {}))));
var EnvironmentVariableMutatorType;
( ((function(EnvironmentVariableMutatorType) {
    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Replace"] = 1] = "Replace";
    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Append"] = 2] = "Append";
    EnvironmentVariableMutatorType[EnvironmentVariableMutatorType["Prepend"] = 3] = "Prepend";
})(EnvironmentVariableMutatorType || (EnvironmentVariableMutatorType = {}))));
let TextEdit = TextEdit_1 = class TextEdit {
    static isTextEdit(thing) {
        if (thing instanceof TextEdit_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Range.isRange(thing)
            && typeof thing.newText === 'string';
    }
    static replace(range, newText) {
        return (
             (new TextEdit_1(range, newText))
        );
    }
    static insert(position, newText) {
        return TextEdit_1.replace(( (new Range(position, position))), newText);
    }
    static delete(range) {
        return TextEdit_1.replace(range, '');
    }
    static setEndOfLine(eol) {
        const ret = ( (new TextEdit_1(
             (new Range( (new Position(0, 0)),  (new Position(0, 0)))),
            ''
        )));
        ret.newEol = eol;
        return ret;
    }
    get range() {
        return this._range;
    }
    set range(value) {
        if (value && !Range.isRange(value)) {
            throw illegalArgument('range');
        }
        this._range = value;
    }
    get newText() {
        return this._newText || '';
    }
    set newText(value) {
        if (value && typeof value !== 'string') {
            throw illegalArgument('newText');
        }
        this._newText = value;
    }
    get newEol() {
        return this._newEol;
    }
    set newEol(value) {
        if (value && typeof value !== 'number') {
            throw illegalArgument('newEol');
        }
        this._newEol = value;
    }
    constructor(range, newText) {
        this._range = range;
        this._newText = newText;
    }
    toJSON() {
        return {
            range: this.range,
            newText: this.newText,
            newEol: this._newEol
        };
    }
};
TextEdit = TextEdit_1 = ( (__decorate([
    es5ClassCompat
], TextEdit)));
let NotebookEdit = NotebookEdit_1 = class NotebookEdit {
    static isNotebookCellEdit(thing) {
        if (thing instanceof NotebookEdit_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return NotebookRange.isNotebookRange(thing)
            && Array.isArray(thing.newCells);
    }
    static replaceCells(range, newCells) {
        return (
             (new NotebookEdit_1(range, newCells))
        );
    }
    static insertCells(index, newCells) {
        return (
             (new NotebookEdit_1( (new NotebookRange(index, index)), newCells))
        );
    }
    static deleteCells(range) {
        return (
             (new NotebookEdit_1(range, []))
        );
    }
    static updateCellMetadata(index, newMetadata) {
        const edit = ( (new NotebookEdit_1( (new NotebookRange(index, index)), [])));
        edit.newCellMetadata = newMetadata;
        return edit;
    }
    static updateNotebookMetadata(newMetadata) {
        const edit = ( (new NotebookEdit_1( (new NotebookRange(0, 0)), [])));
        edit.newNotebookMetadata = newMetadata;
        return edit;
    }
    constructor(range, newCells) {
        this.range = range;
        this.newCells = newCells;
    }
};
NotebookEdit = NotebookEdit_1 = ( (__decorate([
    es5ClassCompat
], NotebookEdit)));
class SnippetTextEdit {
    static isSnippetTextEdit(thing) {
        if (thing instanceof SnippetTextEdit) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Range.isRange(thing.range)
            && SnippetString.isSnippetString(thing.snippet);
    }
    static replace(range, snippet) {
        return (
             (new SnippetTextEdit(range, snippet))
        );
    }
    static insert(position, snippet) {
        return SnippetTextEdit.replace(( (new Range(position, position))), snippet);
    }
    constructor(range, snippet) {
        this.range = range;
        this.snippet = snippet;
    }
}
let WorkspaceEdit = class WorkspaceEdit {
    constructor() {
        this._edits = [];
    }
    _allEntries() {
        return this._edits;
    }
    renameFile(from, to, options, metadata) {
        this._edits.push({ _type: 1 , from, to, options, metadata });
    }
    createFile(uri, options, metadata) {
        this._edits.push({ _type: 1 , from: undefined, to: uri, options, metadata });
    }
    deleteFile(uri, options, metadata) {
        this._edits.push({ _type: 1 , from: uri, to: undefined, options, metadata });
    }
    replaceNotebookMetadata(uri, value, metadata) {
        this._edits.push({ _type: 3 , metadata, uri, edit: { editType: 5 , metadata: value }, notebookMetadata: value });
    }
    replaceNotebookCells(uri, startOrRange, cellData, metadata) {
        const start = startOrRange.start;
        const end = startOrRange.end;
        if (start !== end || cellData.length > 0) {
            this._edits.push({ _type: 5 , uri, index: start, count: end - start, cells: cellData, metadata });
        }
    }
    replaceNotebookCellMetadata(uri, index, cellMetadata, metadata) {
        this._edits.push({ _type: 3 , metadata, uri, edit: { editType: 8 , index, metadata: cellMetadata } });
    }
    replace(uri, range, newText, metadata) {
        this._edits.push({ _type: 2 , uri, edit: ( (new TextEdit(range, newText))), metadata });
    }
    insert(resource, position, newText, metadata) {
        this.replace(resource, ( (new Range(position, position))), newText, metadata);
    }
    delete(resource, range, metadata) {
        this.replace(resource, range, '', metadata);
    }
    has(uri) {
        return this._edits.some(edit => edit._type === 2  && ( (edit.uri.toString())) === ( (uri.toString())));
    }
    set(uri, edits) {
        if (!edits) {
            for (let i = 0; i < this._edits.length; i++) {
                const element = this._edits[i];
                switch (element._type) {
                    case 2 :
                    case 6 :
                    case 3 :
                    case 5 :
                        if (( (element.uri.toString())) === ( (uri.toString()))) {
                            this._edits[i] = undefined;
                        }
                        break;
                }
            }
            coalesceInPlace(this._edits);
        }
        else {
            for (const editOrTuple of edits) {
                if (!editOrTuple) {
                    continue;
                }
                let edit;
                let metadata;
                if (Array.isArray(editOrTuple)) {
                    edit = editOrTuple[0];
                    metadata = editOrTuple[1];
                }
                else {
                    edit = editOrTuple;
                }
                if (NotebookEdit.isNotebookCellEdit(edit)) {
                    if (edit.newCellMetadata) {
                        this.replaceNotebookCellMetadata(uri, edit.range.start, edit.newCellMetadata, metadata);
                    }
                    else if (edit.newNotebookMetadata) {
                        this.replaceNotebookMetadata(uri, edit.newNotebookMetadata, metadata);
                    }
                    else {
                        this.replaceNotebookCells(uri, edit.range, edit.newCells, metadata);
                    }
                }
                else if (SnippetTextEdit.isSnippetTextEdit(edit)) {
                    this._edits.push({ _type: 6 , uri, range: edit.range, edit: edit.snippet, metadata });
                }
                else {
                    this._edits.push({ _type: 2 , uri, edit, metadata });
                }
            }
        }
    }
    get(uri) {
        const res = [];
        for (const candidate of this._edits) {
            if (candidate._type === 2  && ( (candidate.uri.toString())) === ( (uri.toString()))) {
                res.push(candidate.edit);
            }
        }
        return res;
    }
    entries() {
        const textEdits = ( (new ResourceMap()));
        for (const candidate of this._edits) {
            if (candidate._type === 2 ) {
                let textEdit = textEdits.get(candidate.uri);
                if (!textEdit) {
                    textEdit = [candidate.uri, []];
                    textEdits.set(candidate.uri, textEdit);
                }
                textEdit[1].push(candidate.edit);
            }
        }
        return [...( (textEdits.values()))];
    }
    get size() {
        return this.entries().length;
    }
    toJSON() {
        return this.entries();
    }
};
WorkspaceEdit = ( (__decorate([
    es5ClassCompat
], WorkspaceEdit)));
let SnippetString = SnippetString_1 = class SnippetString {
    static isSnippetString(thing) {
        if (thing instanceof SnippetString_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.value === 'string';
    }
    static _escape(value) {
        return value.replace(/\$|}|\\/g, '\\$&');
    }
    constructor(value) {
        this._tabstop = 1;
        this.value = value || '';
    }
    appendText(string) {
        this.value += SnippetString_1._escape(string);
        return this;
    }
    appendTabstop(number = this._tabstop++) {
        this.value += '$';
        this.value += number;
        return this;
    }
    appendPlaceholder(value, number = this._tabstop++) {
        if (typeof value === 'function') {
            const nested = ( (new SnippetString_1()));
            nested._tabstop = this._tabstop;
            value(nested);
            this._tabstop = nested._tabstop;
            value = nested.value;
        }
        else {
            value = SnippetString_1._escape(value);
        }
        this.value += '${';
        this.value += number;
        this.value += ':';
        this.value += value;
        this.value += '}';
        return this;
    }
    appendChoice(values, number = this._tabstop++) {
        const value = ( (values.map(s => s.replace(/\$|}|\\|,/g, '\\$&')))).join(',');
        this.value += '${';
        this.value += number;
        this.value += '|';
        this.value += value;
        this.value += '|}';
        return this;
    }
    appendVariable(name, defaultValue) {
        if (typeof defaultValue === 'function') {
            const nested = ( (new SnippetString_1()));
            nested._tabstop = this._tabstop;
            defaultValue(nested);
            this._tabstop = nested._tabstop;
            defaultValue = nested.value;
        }
        else if (typeof defaultValue === 'string') {
            defaultValue = defaultValue.replace(/\$|}/g, '\\$&');
        }
        this.value += '${';
        this.value += name;
        if (defaultValue) {
            this.value += ':';
            this.value += defaultValue;
        }
        this.value += '}';
        return this;
    }
};
SnippetString = SnippetString_1 = ( (__decorate([
    es5ClassCompat
], SnippetString)));
var DiagnosticTag;
( ((function(DiagnosticTag) {
    DiagnosticTag[DiagnosticTag["Unnecessary"] = 1] = "Unnecessary";
    DiagnosticTag[DiagnosticTag["Deprecated"] = 2] = "Deprecated";
})(DiagnosticTag || (DiagnosticTag = {}))));
var DiagnosticSeverity;
( ((function(DiagnosticSeverity) {
    DiagnosticSeverity[DiagnosticSeverity["Hint"] = 3] = "Hint";
    DiagnosticSeverity[DiagnosticSeverity["Information"] = 2] = "Information";
    DiagnosticSeverity[DiagnosticSeverity["Warning"] = 1] = "Warning";
    DiagnosticSeverity[DiagnosticSeverity["Error"] = 0] = "Error";
})(DiagnosticSeverity || (DiagnosticSeverity = {}))));
let Location = Location_1 = class Location {
    static isLocation(thing) {
        if (thing instanceof Location_1) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return Range.isRange(thing.range)
            && URI.isUri(thing.uri);
    }
    constructor(uri, rangeOrPosition) {
        this.uri = uri;
        if (!rangeOrPosition) ;
        else if (Range.isRange(rangeOrPosition)) {
            this.range = Range.of(rangeOrPosition);
        }
        else if (Position.isPosition(rangeOrPosition)) {
            this.range = ( (new Range(rangeOrPosition, rangeOrPosition)));
        }
        else {
            throw new Error('Illegal argument');
        }
    }
    toJSON() {
        return {
            uri: this.uri,
            range: this.range
        };
    }
};
Location = Location_1 = ( (__decorate([
    es5ClassCompat
], Location)));
let DiagnosticRelatedInformation = class DiagnosticRelatedInformation {
    static is(thing) {
        if (!thing) {
            return false;
        }
        return typeof thing.message === 'string'
            && thing.location
            && Range.isRange(thing.location.range)
            && URI.isUri(thing.location.uri);
    }
    constructor(location, message) {
        this.location = location;
        this.message = message;
    }
    static isEqual(a, b) {
        if (a === b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return a.message === b.message
            && a.location.range.isEqual(b.location.range)
            && ( (a.location.uri.toString())) === ( (b.location.uri.toString()));
    }
};
DiagnosticRelatedInformation = ( (__decorate([
    es5ClassCompat
], DiagnosticRelatedInformation)));
let Diagnostic = class Diagnostic {
    constructor(range, message, severity = DiagnosticSeverity.Error) {
        if (!Range.isRange(range)) {
            throw new TypeError('range must be set');
        }
        if (!message) {
            throw new TypeError('message must be set');
        }
        this.range = range;
        this.message = message;
        this.severity = severity;
    }
    toJSON() {
        return {
            severity: DiagnosticSeverity[this.severity],
            message: this.message,
            range: this.range,
            source: this.source,
            code: this.code,
        };
    }
    static isEqual(a, b) {
        if (a === b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return a.message === b.message
            && a.severity === b.severity
            && a.code === b.code
            && a.severity === b.severity
            && a.source === b.source
            && a.range.isEqual(b.range)
            && equals$1(a.tags, b.tags)
            && equals$1(a.relatedInformation, b.relatedInformation, DiagnosticRelatedInformation.isEqual);
    }
};
Diagnostic = ( (__decorate([
    es5ClassCompat
], Diagnostic)));
let Hover = class Hover {
    constructor(contents, range) {
        if (!contents) {
            throw new Error('Illegal argument, contents must be defined');
        }
        if (Array.isArray(contents)) {
            this.contents = contents;
        }
        else {
            this.contents = [contents];
        }
        this.range = range;
    }
};
Hover = ( (__decorate([
    es5ClassCompat
], Hover)));
var DocumentHighlightKind;
( ((function(DocumentHighlightKind) {
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}))));
let DocumentHighlight = class DocumentHighlight {
    constructor(range, kind = DocumentHighlightKind.Text) {
        this.range = range;
        this.kind = kind;
    }
    toJSON() {
        return {
            range: this.range,
            kind: DocumentHighlightKind[this.kind]
        };
    }
};
DocumentHighlight = ( (__decorate([
    es5ClassCompat
], DocumentHighlight)));
var SymbolKind;
( ((function(SymbolKind) {
    SymbolKind[SymbolKind["File"] = 0] = "File";
    SymbolKind[SymbolKind["Module"] = 1] = "Module";
    SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
    SymbolKind[SymbolKind["Package"] = 3] = "Package";
    SymbolKind[SymbolKind["Class"] = 4] = "Class";
    SymbolKind[SymbolKind["Method"] = 5] = "Method";
    SymbolKind[SymbolKind["Property"] = 6] = "Property";
    SymbolKind[SymbolKind["Field"] = 7] = "Field";
    SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
    SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
    SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
    SymbolKind[SymbolKind["Function"] = 11] = "Function";
    SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
    SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
    SymbolKind[SymbolKind["String"] = 14] = "String";
    SymbolKind[SymbolKind["Number"] = 15] = "Number";
    SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
    SymbolKind[SymbolKind["Array"] = 17] = "Array";
    SymbolKind[SymbolKind["Object"] = 18] = "Object";
    SymbolKind[SymbolKind["Key"] = 19] = "Key";
    SymbolKind[SymbolKind["Null"] = 20] = "Null";
    SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
    SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
    SymbolKind[SymbolKind["Event"] = 23] = "Event";
    SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
    SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}))));
var SymbolTag;
( ((function(SymbolTag) {
    SymbolTag[SymbolTag["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}))));
let SymbolInformation = SymbolInformation_1 = class SymbolInformation {
    static validate(candidate) {
        if (!candidate.name) {
            throw new Error('name must not be falsy');
        }
    }
    constructor(name, kind, rangeOrContainer, locationOrUri, containerName) {
        this.name = name;
        this.kind = kind;
        this.containerName = containerName;
        if (typeof rangeOrContainer === 'string') {
            this.containerName = rangeOrContainer;
        }
        if (locationOrUri instanceof Location) {
            this.location = locationOrUri;
        }
        else if (rangeOrContainer instanceof Range) {
            this.location = ( (new Location(locationOrUri, rangeOrContainer)));
        }
        SymbolInformation_1.validate(this);
    }
    toJSON() {
        return {
            name: this.name,
            kind: SymbolKind[this.kind],
            location: this.location,
            containerName: this.containerName
        };
    }
};
SymbolInformation = SymbolInformation_1 = ( (__decorate([
    es5ClassCompat
], SymbolInformation)));
let DocumentSymbol = DocumentSymbol_1 = class DocumentSymbol {
    static validate(candidate) {
        if (!candidate.name) {
            throw new Error('name must not be falsy');
        }
        if (!candidate.range.contains(candidate.selectionRange)) {
            throw new Error('selectionRange must be contained in fullRange');
        }
        candidate.children?.forEach(DocumentSymbol_1.validate);
    }
    constructor(name, detail, kind, range, selectionRange) {
        this.name = name;
        this.detail = detail;
        this.kind = kind;
        this.range = range;
        this.selectionRange = selectionRange;
        this.children = [];
        DocumentSymbol_1.validate(this);
    }
};
DocumentSymbol = DocumentSymbol_1 = ( (__decorate([
    es5ClassCompat
], DocumentSymbol)));
var CodeActionTriggerKind;
( ((function(CodeActionTriggerKind) {
    CodeActionTriggerKind[CodeActionTriggerKind["Invoke"] = 1] = "Invoke";
    CodeActionTriggerKind[CodeActionTriggerKind["Automatic"] = 2] = "Automatic";
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}))));
let CodeAction = class CodeAction {
    constructor(title, kind) {
        this.title = title;
        this.kind = kind;
    }
};
CodeAction = ( (__decorate([
    es5ClassCompat
], CodeAction)));
let CodeActionKind = CodeActionKind_1 = class CodeActionKind {
    constructor(value) {
        this.value = value;
    }
    append(parts) {
        return (
             (new CodeActionKind_1(this.value ? this.value + CodeActionKind_1.sep + parts : parts))
        );
    }
    intersects(other) {
        return this.contains(other) || other.contains(this);
    }
    contains(other) {
        return this.value === other.value || other.value.startsWith(this.value + CodeActionKind_1.sep);
    }
};
CodeActionKind.sep = '.';
CodeActionKind = CodeActionKind_1 = ( (__decorate([
    es5ClassCompat
], CodeActionKind)));
CodeActionKind.Empty = ( (new CodeActionKind('')));
CodeActionKind.QuickFix = CodeActionKind.Empty.append('quickfix');
CodeActionKind.Refactor = CodeActionKind.Empty.append('refactor');
CodeActionKind.RefactorExtract = CodeActionKind.Refactor.append('extract');
CodeActionKind.RefactorInline = CodeActionKind.Refactor.append('inline');
CodeActionKind.RefactorMove = CodeActionKind.Refactor.append('move');
CodeActionKind.RefactorRewrite = CodeActionKind.Refactor.append('rewrite');
CodeActionKind.Source = CodeActionKind.Empty.append('source');
CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append('organizeImports');
CodeActionKind.SourceFixAll = CodeActionKind.Source.append('fixAll');
let SelectionRange = class SelectionRange {
    constructor(range, parent) {
        this.range = range;
        this.parent = parent;
        if (parent && !parent.range.contains(this.range)) {
            throw new Error('Invalid argument: parent must contain this range');
        }
    }
};
SelectionRange = ( (__decorate([
    es5ClassCompat
], SelectionRange)));
class CallHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange) {
        this.kind = kind;
        this.name = name;
        this.detail = detail;
        this.uri = uri;
        this.range = range;
        this.selectionRange = selectionRange;
    }
}
class CallHierarchyIncomingCall {
    constructor(item, fromRanges) {
        this.fromRanges = fromRanges;
        this.from = item;
    }
}
class CallHierarchyOutgoingCall {
    constructor(item, fromRanges) {
        this.fromRanges = fromRanges;
        this.to = item;
    }
}
var LanguageStatusSeverity;
( ((function(LanguageStatusSeverity) {
    LanguageStatusSeverity[LanguageStatusSeverity["Information"] = 0] = "Information";
    LanguageStatusSeverity[LanguageStatusSeverity["Warning"] = 1] = "Warning";
    LanguageStatusSeverity[LanguageStatusSeverity["Error"] = 2] = "Error";
})(LanguageStatusSeverity || (LanguageStatusSeverity = {}))));
let CodeLens = class CodeLens {
    constructor(range, command) {
        this.range = range;
        this.command = command;
    }
    get isResolved() {
        return !!this.command;
    }
};
CodeLens = ( (__decorate([
    es5ClassCompat
], CodeLens)));
let MarkdownString = MarkdownString_1 = class MarkdownString {
    static isMarkdownString(thing) {
        if (thing instanceof MarkdownString_1) {
            return true;
        }
        return thing && thing.appendCodeblock && thing.appendMarkdown && thing.appendText && (thing.value !== undefined);
    }
    constructor(value, supportThemeIcons = false) {
        _MarkdownString_delegate.set(this, void 0);
        __classPrivateFieldSet(this, _MarkdownString_delegate, ( (new MarkdownString$1(value, { supportThemeIcons }))), "f");
    }
    get value() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").value;
    }
    set value(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").value = value;
    }
    get isTrusted() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").isTrusted;
    }
    set isTrusted(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").isTrusted = value;
    }
    get supportThemeIcons() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportThemeIcons;
    }
    set supportThemeIcons(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportThemeIcons = value;
    }
    get supportHtml() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportHtml;
    }
    set supportHtml(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").supportHtml = value;
    }
    get baseUri() {
        return __classPrivateFieldGet(this, _MarkdownString_delegate, "f").baseUri;
    }
    set baseUri(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").baseUri = value;
    }
    appendText(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendText(value);
        return this;
    }
    appendMarkdown(value) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendMarkdown(value);
        return this;
    }
    appendCodeblock(value, language) {
        __classPrivateFieldGet(this, _MarkdownString_delegate, "f").appendCodeblock(language ?? '', value);
        return this;
    }
};
_MarkdownString_delegate = ( (new WeakMap()));
MarkdownString = MarkdownString_1 = ( (__decorate([
    es5ClassCompat
], MarkdownString)));
let ParameterInformation = class ParameterInformation {
    constructor(label, documentation) {
        this.label = label;
        this.documentation = documentation;
    }
};
ParameterInformation = ( (__decorate([
    es5ClassCompat
], ParameterInformation)));
let SignatureInformation = class SignatureInformation {
    constructor(label, documentation) {
        this.label = label;
        this.documentation = documentation;
        this.parameters = [];
    }
};
SignatureInformation = ( (__decorate([
    es5ClassCompat
], SignatureInformation)));
let SignatureHelp = class SignatureHelp {
    constructor() {
        this.activeSignature = 0;
        this.activeParameter = 0;
        this.signatures = [];
    }
};
SignatureHelp = ( (__decorate([
    es5ClassCompat
], SignatureHelp)));
var SignatureHelpTriggerKind;
( ((function(SignatureHelpTriggerKind) {
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}))));
var InlayHintKind;
( ((function(InlayHintKind) {
    InlayHintKind[InlayHintKind["Type"] = 1] = "Type";
    InlayHintKind[InlayHintKind["Parameter"] = 2] = "Parameter";
})(InlayHintKind || (InlayHintKind = {}))));
let InlayHintLabelPart = class InlayHintLabelPart {
    constructor(value) {
        this.value = value;
    }
};
InlayHintLabelPart = ( (__decorate([
    es5ClassCompat
], InlayHintLabelPart)));
let InlayHint = class InlayHint {
    constructor(position, label, kind) {
        this.position = position;
        this.label = label;
        this.kind = kind;
    }
};
InlayHint = ( (__decorate([
    es5ClassCompat
], InlayHint)));
var CompletionTriggerKind;
( ((function(CompletionTriggerKind) {
    CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}))));
var CompletionItemKind;
( ((function(CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
    CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
    CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
    CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
    CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
    CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
    CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
    CompletionItemKind[CompletionItemKind["EnumMember"] = 19] = "EnumMember";
    CompletionItemKind[CompletionItemKind["Constant"] = 20] = "Constant";
    CompletionItemKind[CompletionItemKind["Struct"] = 21] = "Struct";
    CompletionItemKind[CompletionItemKind["Event"] = 22] = "Event";
    CompletionItemKind[CompletionItemKind["Operator"] = 23] = "Operator";
    CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind[CompletionItemKind["User"] = 25] = "User";
    CompletionItemKind[CompletionItemKind["Issue"] = 26] = "Issue";
})(CompletionItemKind || (CompletionItemKind = {}))));
var CompletionItemTag;
( ((function(CompletionItemTag) {
    CompletionItemTag[CompletionItemTag["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}))));
let CompletionItem = class CompletionItem {
    constructor(label, kind) {
        this.label = label;
        this.kind = kind;
    }
    toJSON() {
        return {
            label: this.label,
            kind: this.kind && CompletionItemKind[this.kind],
            detail: this.detail,
            documentation: this.documentation,
            sortText: this.sortText,
            filterText: this.filterText,
            preselect: this.preselect,
            insertText: this.insertText,
            textEdit: this.textEdit
        };
    }
};
CompletionItem = ( (__decorate([
    es5ClassCompat
], CompletionItem)));
let CompletionList = class CompletionList {
    constructor(items = [], isIncomplete = false) {
        this.items = items;
        this.isIncomplete = isIncomplete;
    }
};
CompletionList = ( (__decorate([
    es5ClassCompat
], CompletionList)));
let InlineSuggestion = class InlineSuggestion {
    constructor(insertText, range, command) {
        this.insertText = insertText;
        this.range = range;
        this.command = command;
    }
};
InlineSuggestion = ( (__decorate([
    es5ClassCompat
], InlineSuggestion)));
let InlineSuggestionList = class InlineSuggestionList {
    constructor(items) {
        this.commands = undefined;
        this.items = items;
    }
};
InlineSuggestionList = ( (__decorate([
    es5ClassCompat
], InlineSuggestionList)));
var ViewColumn;
( ((function(ViewColumn) {
    ViewColumn[ViewColumn["Active"] = -1] = "Active";
    ViewColumn[ViewColumn["Beside"] = -2] = "Beside";
    ViewColumn[ViewColumn["One"] = 1] = "One";
    ViewColumn[ViewColumn["Two"] = 2] = "Two";
    ViewColumn[ViewColumn["Three"] = 3] = "Three";
    ViewColumn[ViewColumn["Four"] = 4] = "Four";
    ViewColumn[ViewColumn["Five"] = 5] = "Five";
    ViewColumn[ViewColumn["Six"] = 6] = "Six";
    ViewColumn[ViewColumn["Seven"] = 7] = "Seven";
    ViewColumn[ViewColumn["Eight"] = 8] = "Eight";
    ViewColumn[ViewColumn["Nine"] = 9] = "Nine";
})(ViewColumn || (ViewColumn = {}))));
var TextEditorLineNumbersStyle;
( ((function(TextEditorLineNumbersStyle) {
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Off"] = 0] = "Off";
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["On"] = 1] = "On";
    TextEditorLineNumbersStyle[TextEditorLineNumbersStyle["Relative"] = 2] = "Relative";
})(TextEditorLineNumbersStyle || (TextEditorLineNumbersStyle = {}))));
var TextDocumentSaveReason;
( ((function(TextDocumentSaveReason) {
    TextDocumentSaveReason[TextDocumentSaveReason["Manual"] = 1] = "Manual";
    TextDocumentSaveReason[TextDocumentSaveReason["AfterDelay"] = 2] = "AfterDelay";
    TextDocumentSaveReason[TextDocumentSaveReason["FocusOut"] = 3] = "FocusOut";
})(TextDocumentSaveReason || (TextDocumentSaveReason = {}))));
var TextEditorRevealType;
( ((function(TextEditorRevealType) {
    TextEditorRevealType[TextEditorRevealType["Default"] = 0] = "Default";
    TextEditorRevealType[TextEditorRevealType["InCenter"] = 1] = "InCenter";
    TextEditorRevealType[TextEditorRevealType["InCenterIfOutsideViewport"] = 2] = "InCenterIfOutsideViewport";
    TextEditorRevealType[TextEditorRevealType["AtTop"] = 3] = "AtTop";
})(TextEditorRevealType || (TextEditorRevealType = {}))));
var TextEditorSelectionChangeKind;
( ((function(TextEditorSelectionChangeKind) {
    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Keyboard"] = 1] = "Keyboard";
    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Mouse"] = 2] = "Mouse";
    TextEditorSelectionChangeKind[TextEditorSelectionChangeKind["Command"] = 3] = "Command";
})(TextEditorSelectionChangeKind || (TextEditorSelectionChangeKind = {}))));
var TextDocumentChangeReason;
( ((function(TextDocumentChangeReason) {
    TextDocumentChangeReason[TextDocumentChangeReason["Undo"] = 1] = "Undo";
    TextDocumentChangeReason[TextDocumentChangeReason["Redo"] = 2] = "Redo";
})(TextDocumentChangeReason || (TextDocumentChangeReason = {}))));
var DecorationRangeBehavior;
( ((function(DecorationRangeBehavior) {
    DecorationRangeBehavior[DecorationRangeBehavior["OpenOpen"] = 0] = "OpenOpen";
    DecorationRangeBehavior[DecorationRangeBehavior["ClosedClosed"] = 1] = "ClosedClosed";
    DecorationRangeBehavior[DecorationRangeBehavior["OpenClosed"] = 2] = "OpenClosed";
    DecorationRangeBehavior[DecorationRangeBehavior["ClosedOpen"] = 3] = "ClosedOpen";
})(DecorationRangeBehavior || (DecorationRangeBehavior = {}))));
( ((function(TextEditorSelectionChangeKind) {
    function fromValue(s) {
        switch (s) {
            case 'keyboard': return TextEditorSelectionChangeKind.Keyboard;
            case 'mouse': return TextEditorSelectionChangeKind.Mouse;
            case 'api': return TextEditorSelectionChangeKind.Command;
        }
        return undefined;
    }
    TextEditorSelectionChangeKind.fromValue = fromValue;
})(TextEditorSelectionChangeKind || (TextEditorSelectionChangeKind = {}))));
let DocumentLink = class DocumentLink {
    constructor(range, target) {
        if (target && !(URI.isUri(target))) {
            throw illegalArgument('target');
        }
        if (!Range.isRange(range) || range.isEmpty) {
            throw illegalArgument('range');
        }
        this.range = range;
        this.target = target;
    }
};
DocumentLink = ( (__decorate([
    es5ClassCompat
], DocumentLink)));
let Color = class Color {
    constructor(red, green, blue, alpha) {
        this.red = red;
        this.green = green;
        this.blue = blue;
        this.alpha = alpha;
    }
};
Color = ( (__decorate([
    es5ClassCompat
], Color)));
let ColorInformation = class ColorInformation {
    constructor(range, color) {
        if (color && !(color instanceof Color)) {
            throw illegalArgument('color');
        }
        if (!Range.isRange(range) || range.isEmpty) {
            throw illegalArgument('range');
        }
        this.range = range;
        this.color = color;
    }
};
ColorInformation = ( (__decorate([
    es5ClassCompat
], ColorInformation)));
let ColorPresentation = class ColorPresentation {
    constructor(label) {
        if (!label || typeof label !== 'string') {
            throw illegalArgument('label');
        }
        this.label = label;
    }
};
ColorPresentation = ( (__decorate([
    es5ClassCompat
], ColorPresentation)));
let TaskGroup = TaskGroup_1 = class TaskGroup {
    static from(value) {
        switch (value) {
            case 'clean':
                return TaskGroup_1.Clean;
            case 'build':
                return TaskGroup_1.Build;
            case 'rebuild':
                return TaskGroup_1.Rebuild;
            case 'test':
                return TaskGroup_1.Test;
            default:
                return undefined;
        }
    }
    constructor(id, label) {
        this.label = label;
        if (typeof id !== 'string') {
            throw illegalArgument('name');
        }
        if (typeof label !== 'string') {
            throw illegalArgument('name');
        }
        this._id = id;
    }
    get id() {
        return this._id;
    }
};
TaskGroup.Clean = ( (new TaskGroup_1('clean', 'Clean')));
TaskGroup.Build = ( (new TaskGroup_1('build', 'Build')));
TaskGroup.Rebuild = ( (new TaskGroup_1('rebuild', 'Rebuild')));
TaskGroup.Test = ( (new TaskGroup_1('test', 'Test')));
TaskGroup = TaskGroup_1 = ( (__decorate([
    es5ClassCompat
], TaskGroup)));
function computeTaskExecutionId(values) {
    let id = '';
    for (let i = 0; i < values.length; i++) {
        id += values[i].replace(/,/g, ',,') + ',';
    }
    return id;
}
let ProcessExecution = class ProcessExecution {
    constructor(process, varg1, varg2) {
        if (typeof process !== 'string') {
            throw illegalArgument('process');
        }
        this._args = [];
        this._process = process;
        if (varg1 !== undefined) {
            if (Array.isArray(varg1)) {
                this._args = varg1;
                this._options = varg2;
            }
            else {
                this._options = varg1;
            }
        }
    }
    get process() {
        return this._process;
    }
    set process(value) {
        if (typeof value !== 'string') {
            throw illegalArgument('process');
        }
        this._process = value;
    }
    get args() {
        return this._args;
    }
    set args(value) {
        if (!Array.isArray(value)) {
            value = [];
        }
        this._args = value;
    }
    get options() {
        return this._options;
    }
    set options(value) {
        this._options = value;
    }
    computeId() {
        const props = [];
        props.push('process');
        if (this._process !== undefined) {
            props.push(this._process);
        }
        if (this._args && this._args.length > 0) {
            for (const arg of this._args) {
                props.push(arg);
            }
        }
        return computeTaskExecutionId(props);
    }
};
ProcessExecution = ( (__decorate([
    es5ClassCompat
], ProcessExecution)));
let ShellExecution = class ShellExecution {
    constructor(arg0, arg1, arg2) {
        this._args = [];
        if (Array.isArray(arg1)) {
            if (!arg0) {
                throw illegalArgument('command can\'t be undefined or null');
            }
            if (typeof arg0 !== 'string' && typeof arg0.value !== 'string') {
                throw illegalArgument('command');
            }
            this._command = arg0;
            this._args = arg1;
            this._options = arg2;
        }
        else {
            if (typeof arg0 !== 'string') {
                throw illegalArgument('commandLine');
            }
            this._commandLine = arg0;
            this._options = arg1;
        }
    }
    get commandLine() {
        return this._commandLine;
    }
    set commandLine(value) {
        if (typeof value !== 'string') {
            throw illegalArgument('commandLine');
        }
        this._commandLine = value;
    }
    get command() {
        return this._command ? this._command : '';
    }
    set command(value) {
        if (typeof value !== 'string' && typeof value.value !== 'string') {
            throw illegalArgument('command');
        }
        this._command = value;
    }
    get args() {
        return this._args;
    }
    set args(value) {
        this._args = value || [];
    }
    get options() {
        return this._options;
    }
    set options(value) {
        this._options = value;
    }
    computeId() {
        const props = [];
        props.push('shell');
        if (this._commandLine !== undefined) {
            props.push(this._commandLine);
        }
        if (this._command !== undefined) {
            props.push(typeof this._command === 'string' ? this._command : this._command.value);
        }
        if (this._args && this._args.length > 0) {
            for (const arg of this._args) {
                props.push(typeof arg === 'string' ? arg : arg.value);
            }
        }
        return computeTaskExecutionId(props);
    }
};
ShellExecution = ( (__decorate([
    es5ClassCompat
], ShellExecution)));
var ShellQuoting;
( ((function(ShellQuoting) {
    ShellQuoting[ShellQuoting["Escape"] = 1] = "Escape";
    ShellQuoting[ShellQuoting["Strong"] = 2] = "Strong";
    ShellQuoting[ShellQuoting["Weak"] = 3] = "Weak";
})(ShellQuoting || (ShellQuoting = {}))));
var TaskScope;
( ((function(TaskScope) {
    TaskScope[TaskScope["Global"] = 1] = "Global";
    TaskScope[TaskScope["Workspace"] = 2] = "Workspace";
})(TaskScope || (TaskScope = {}))));
class CustomExecution {
    constructor(callback) {
        this._callback = callback;
    }
    computeId() {
        return 'customExecution' + generateUuid();
    }
    set callback(value) {
        this._callback = value;
    }
    get callback() {
        return this._callback;
    }
}
let Task = Task_1 = class Task {
    constructor(definition, arg2, arg3, arg4, arg5, arg6) {
        this.__deprecated = false;
        this._definition = this.definition = definition;
        let problemMatchers;
        if (typeof arg2 === 'string') {
            this._name = this.name = arg2;
            this._source = this.source = arg3;
            this.execution = arg4;
            problemMatchers = arg5;
            this.__deprecated = true;
        }
        else if (arg2 === TaskScope.Global || arg2 === TaskScope.Workspace) {
            this.target = arg2;
            this._name = this.name = arg3;
            this._source = this.source = arg4;
            this.execution = arg5;
            problemMatchers = arg6;
        }
        else {
            this.target = arg2;
            this._name = this.name = arg3;
            this._source = this.source = arg4;
            this.execution = arg5;
            problemMatchers = arg6;
        }
        if (typeof problemMatchers === 'string') {
            this._problemMatchers = [problemMatchers];
            this._hasDefinedMatchers = true;
        }
        else if (Array.isArray(problemMatchers)) {
            this._problemMatchers = problemMatchers;
            this._hasDefinedMatchers = true;
        }
        else {
            this._problemMatchers = [];
            this._hasDefinedMatchers = false;
        }
        this._isBackground = false;
        this._presentationOptions = Object.create(null);
        this._runOptions = Object.create(null);
    }
    get _id() {
        return this.__id;
    }
    set _id(value) {
        this.__id = value;
    }
    get _deprecated() {
        return this.__deprecated;
    }
    clear() {
        if (this.__id === undefined) {
            return;
        }
        this.__id = undefined;
        this._scope = undefined;
        this.computeDefinitionBasedOnExecution();
    }
    computeDefinitionBasedOnExecution() {
        if (this._execution instanceof ProcessExecution) {
            this._definition = {
                type: Task_1.ProcessType,
                id: this._execution.computeId()
            };
        }
        else if (this._execution instanceof ShellExecution) {
            this._definition = {
                type: Task_1.ShellType,
                id: this._execution.computeId()
            };
        }
        else if (this._execution instanceof CustomExecution) {
            this._definition = {
                type: Task_1.ExtensionCallbackType,
                id: this._execution.computeId()
            };
        }
        else {
            this._definition = {
                type: Task_1.EmptyType,
                id: generateUuid()
            };
        }
    }
    get definition() {
        return this._definition;
    }
    set definition(value) {
        if (value === undefined || value === null) {
            throw illegalArgument('Kind can\'t be undefined or null');
        }
        this.clear();
        this._definition = value;
    }
    get scope() {
        return this._scope;
    }
    set target(value) {
        this.clear();
        this._scope = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        if (typeof value !== 'string') {
            throw illegalArgument('name');
        }
        this.clear();
        this._name = value;
    }
    get execution() {
        return this._execution;
    }
    set execution(value) {
        if (value === null) {
            value = undefined;
        }
        this.clear();
        this._execution = value;
        const type = this._definition.type;
        if (Task_1.EmptyType === type || Task_1.ProcessType === type || Task_1.ShellType === type || Task_1.ExtensionCallbackType === type) {
            this.computeDefinitionBasedOnExecution();
        }
    }
    get problemMatchers() {
        return this._problemMatchers;
    }
    set problemMatchers(value) {
        if (!Array.isArray(value)) {
            this.clear();
            this._problemMatchers = [];
            this._hasDefinedMatchers = false;
            return;
        }
        else {
            this.clear();
            this._problemMatchers = value;
            this._hasDefinedMatchers = true;
        }
    }
    get hasDefinedMatchers() {
        return this._hasDefinedMatchers;
    }
    get isBackground() {
        return this._isBackground;
    }
    set isBackground(value) {
        if (value !== true && value !== false) {
            value = false;
        }
        this.clear();
        this._isBackground = value;
    }
    get source() {
        return this._source;
    }
    set source(value) {
        if (typeof value !== 'string' || value.length === 0) {
            throw illegalArgument('source must be a string of length > 0');
        }
        this.clear();
        this._source = value;
    }
    get group() {
        return this._group;
    }
    set group(value) {
        if (value === null) {
            value = undefined;
        }
        this.clear();
        this._group = value;
    }
    get detail() {
        return this._detail;
    }
    set detail(value) {
        if (value === null) {
            value = undefined;
        }
        this._detail = value;
    }
    get presentationOptions() {
        return this._presentationOptions;
    }
    set presentationOptions(value) {
        if (value === null || value === undefined) {
            value = Object.create(null);
        }
        this.clear();
        this._presentationOptions = value;
    }
    get runOptions() {
        return this._runOptions;
    }
    set runOptions(value) {
        if (value === null || value === undefined) {
            value = Object.create(null);
        }
        this.clear();
        this._runOptions = value;
    }
};
Task.ExtensionCallbackType = 'customExecution';
Task.ProcessType = 'process';
Task.ShellType = 'shell';
Task.EmptyType = '$empty';
Task = Task_1 = ( (__decorate([
    es5ClassCompat
], Task)));
var ProgressLocation;
( ((function(ProgressLocation) {
    ProgressLocation[ProgressLocation["SourceControl"] = 1] = "SourceControl";
    ProgressLocation[ProgressLocation["Window"] = 10] = "Window";
    ProgressLocation[ProgressLocation["Notification"] = 15] = "Notification";
})(ProgressLocation || (ProgressLocation = {}))));
let TreeItem = TreeItem_1 = class TreeItem {
    static isTreeItem(thing, extension) {
        const treeItemThing = thing;
        if (treeItemThing.checkboxState !== undefined) {
            checkProposedApiEnabled(extension, 'treeItemCheckbox');
            const checkbox = isNumber(treeItemThing.checkboxState) ? treeItemThing.checkboxState :
                isObject(treeItemThing.checkboxState) && isNumber(treeItemThing.checkboxState.state) ? treeItemThing.checkboxState.state : undefined;
            const tooltip = !isNumber(treeItemThing.checkboxState) && isObject(treeItemThing.checkboxState) ? treeItemThing.checkboxState.tooltip : undefined;
            if (checkbox === undefined || (checkbox !== TreeItemCheckboxState.Checked && checkbox !== TreeItemCheckboxState.Unchecked) || (tooltip !== undefined && !isString(tooltip))) {
                console.log('INVALID tree item, invalid checkboxState', treeItemThing.checkboxState);
                return false;
            }
        }
        if (thing instanceof TreeItem_1) {
            return true;
        }
        if (treeItemThing.label !== undefined && !isString(treeItemThing.label) && !(treeItemThing.label?.label)) {
            console.log('INVALID tree item, invalid label', treeItemThing.label);
            return false;
        }
        if ((treeItemThing.id !== undefined) && !isString(treeItemThing.id)) {
            console.log('INVALID tree item, invalid id', treeItemThing.id);
            return false;
        }
        if ((treeItemThing.iconPath !== undefined) && !isString(treeItemThing.iconPath) && !URI.isUri(treeItemThing.iconPath) && (!treeItemThing.iconPath || !isString(treeItemThing.iconPath.id))) {
            const asLightAndDarkThing = treeItemThing.iconPath;
            if (!asLightAndDarkThing || (!isString(asLightAndDarkThing.light) && !URI.isUri(asLightAndDarkThing.light) && !isString(asLightAndDarkThing.dark) && !URI.isUri(asLightAndDarkThing.dark))) {
                console.log('INVALID tree item, invalid iconPath', treeItemThing.iconPath);
                return false;
            }
        }
        if ((treeItemThing.description !== undefined) && !isString(treeItemThing.description) && (typeof treeItemThing.description !== 'boolean')) {
            console.log('INVALID tree item, invalid description', treeItemThing.description);
            return false;
        }
        if ((treeItemThing.resourceUri !== undefined) && !URI.isUri(treeItemThing.resourceUri)) {
            console.log('INVALID tree item, invalid resourceUri', treeItemThing.resourceUri);
            return false;
        }
        if ((treeItemThing.tooltip !== undefined) && !isString(treeItemThing.tooltip) && !(treeItemThing.tooltip instanceof MarkdownString)) {
            console.log('INVALID tree item, invalid tooltip', treeItemThing.tooltip);
            return false;
        }
        if ((treeItemThing.command !== undefined) && !treeItemThing.command.command) {
            console.log('INVALID tree item, invalid command', treeItemThing.command);
            return false;
        }
        if ((treeItemThing.collapsibleState !== undefined) && (treeItemThing.collapsibleState < TreeItemCollapsibleState.None) && (treeItemThing.collapsibleState > TreeItemCollapsibleState.Expanded)) {
            console.log('INVALID tree item, invalid collapsibleState', treeItemThing.collapsibleState);
            return false;
        }
        if ((treeItemThing.contextValue !== undefined) && !isString(treeItemThing.contextValue)) {
            console.log('INVALID tree item, invalid contextValue', treeItemThing.contextValue);
            return false;
        }
        if ((treeItemThing.accessibilityInformation !== undefined) && !treeItemThing.accessibilityInformation?.label) {
            console.log('INVALID tree item, invalid accessibilityInformation', treeItemThing.accessibilityInformation);
            return false;
        }
        return true;
    }
    constructor(arg1, collapsibleState = TreeItemCollapsibleState.None) {
        this.collapsibleState = collapsibleState;
        if (URI.isUri(arg1)) {
            this.resourceUri = arg1;
        }
        else {
            this.label = arg1;
        }
    }
};
TreeItem = TreeItem_1 = ( (__decorate([
    es5ClassCompat
], TreeItem)));
var TreeItemCollapsibleState;
( ((function(TreeItemCollapsibleState) {
    TreeItemCollapsibleState[TreeItemCollapsibleState["None"] = 0] = "None";
    TreeItemCollapsibleState[TreeItemCollapsibleState["Collapsed"] = 1] = "Collapsed";
    TreeItemCollapsibleState[TreeItemCollapsibleState["Expanded"] = 2] = "Expanded";
})(TreeItemCollapsibleState || (TreeItemCollapsibleState = {}))));
var TreeItemCheckboxState;
( ((function(TreeItemCheckboxState) {
    TreeItemCheckboxState[TreeItemCheckboxState["Unchecked"] = 0] = "Unchecked";
    TreeItemCheckboxState[TreeItemCheckboxState["Checked"] = 1] = "Checked";
})(TreeItemCheckboxState || (TreeItemCheckboxState = {}))));
let DataTransferItem = class DataTransferItem {
    async asString() {
        return typeof this.value === 'string' ? this.value : JSON.stringify(this.value);
    }
    asFile() {
        return undefined;
    }
    constructor(value, id) {
        this.value = value;
        this.id = id ?? generateUuid();
    }
};
DataTransferItem = ( (__decorate([
    es5ClassCompat
], DataTransferItem)));
let DataTransfer = class DataTransfer {
    constructor(init) {
        _DataTransfer_items.set(this, ( (new Map())));
        for (const [mime, item] of init ?? []) {
            const existing = __classPrivateFieldGet(this, _DataTransfer_items, "f").get(mime);
            if (existing) {
                existing.push(item);
            }
            else {
                __classPrivateFieldGet(this, _DataTransfer_items, "f").set(mime, [item]);
            }
        }
    }
    get(mimeType) {
        return __classPrivateFieldGet(this, _DataTransfer_items, "f").get(mimeType)?.[0];
    }
    set(mimeType, value) {
        __classPrivateFieldGet(this, _DataTransfer_items, "f").set(mimeType, [value]);
    }
    forEach(callbackfn, thisArg) {
        for (const [mime, items] of __classPrivateFieldGet(this, _DataTransfer_items, "f")) {
            for (const item of items) {
                callbackfn.call(thisArg, item, mime, this);
            }
        }
    }
    *[(_DataTransfer_items = ( (new WeakMap())), Symbol.iterator)]() {
        for (const [mime, items] of __classPrivateFieldGet(this, _DataTransfer_items, "f")) {
            for (const item of items) {
                yield [mime, item];
            }
        }
    }
};
DataTransfer = ( (__decorate([
    es5ClassCompat
], DataTransfer)));
let DocumentDropEdit = class DocumentDropEdit {
    constructor(insertText) {
        this.insertText = insertText;
    }
};
DocumentDropEdit = ( (__decorate([
    es5ClassCompat
], DocumentDropEdit)));
let ThemeIcon = class ThemeIcon {
    constructor(id, color) {
        this.id = id;
        this.color = color;
    }
    static isThemeIcon(thing) {
        if (typeof thing.id !== 'string') {
            console.log('INVALID ThemeIcon, invalid id', thing.id);
            return false;
        }
        return true;
    }
};
ThemeIcon = ( (__decorate([
    es5ClassCompat
], ThemeIcon)));
ThemeIcon.File = ( (new ThemeIcon('file')));
ThemeIcon.Folder = ( (new ThemeIcon('folder')));
let ThemeColor = class ThemeColor {
    constructor(id) {
        this.id = id;
    }
};
ThemeColor = ( (__decorate([
    es5ClassCompat
], ThemeColor)));
var ConfigurationTarget;
( ((function(ConfigurationTarget) {
    ConfigurationTarget[ConfigurationTarget["Global"] = 1] = "Global";
    ConfigurationTarget[ConfigurationTarget["Workspace"] = 2] = "Workspace";
    ConfigurationTarget[ConfigurationTarget["WorkspaceFolder"] = 3] = "WorkspaceFolder";
})(ConfigurationTarget || (ConfigurationTarget = {}))));
let RelativePattern = class RelativePattern {
    get base() {
        return this._base;
    }
    set base(base) {
        this._base = base;
        this._baseUri = URI.file(base);
    }
    get baseUri() {
        return this._baseUri;
    }
    set baseUri(baseUri) {
        this._baseUri = baseUri;
        this._base = baseUri.fsPath;
    }
    constructor(base, pattern) {
        if (typeof base !== 'string') {
            if (!base || !URI.isUri(base) && !URI.isUri(base.uri)) {
                throw illegalArgument('base');
            }
        }
        if (typeof pattern !== 'string') {
            throw illegalArgument('pattern');
        }
        if (typeof base === 'string') {
            this.baseUri = URI.file(base);
        }
        else if (URI.isUri(base)) {
            this.baseUri = base;
        }
        else {
            this.baseUri = base.uri;
        }
        this.pattern = pattern;
    }
    toJSON() {
        return {
            pattern: this.pattern,
            base: this.base,
            baseUri: this.baseUri.toJSON()
        };
    }
};
RelativePattern = ( (__decorate([
    es5ClassCompat
], RelativePattern)));
const breakpointIds = ( (new WeakMap()));
function setBreakpointId(bp, id) {
    breakpointIds.set(bp, id);
}
let Breakpoint = class Breakpoint {
    constructor(enabled, condition, hitCondition, logMessage) {
        this.enabled = typeof enabled === 'boolean' ? enabled : true;
        if (typeof condition === 'string') {
            this.condition = condition;
        }
        if (typeof hitCondition === 'string') {
            this.hitCondition = hitCondition;
        }
        if (typeof logMessage === 'string') {
            this.logMessage = logMessage;
        }
    }
    get id() {
        if (!this._id) {
            this._id = breakpointIds.get(this) ?? generateUuid();
        }
        return this._id;
    }
};
Breakpoint = ( (__decorate([
    es5ClassCompat
], Breakpoint)));
let SourceBreakpoint = class SourceBreakpoint extends Breakpoint {
    constructor(location, enabled, condition, hitCondition, logMessage) {
        super(enabled, condition, hitCondition, logMessage);
        if (location === null) {
            throw illegalArgument('location');
        }
        this.location = location;
    }
};
SourceBreakpoint = ( (__decorate([
    es5ClassCompat
], SourceBreakpoint)));
let FunctionBreakpoint = class FunctionBreakpoint extends Breakpoint {
    constructor(functionName, enabled, condition, hitCondition, logMessage) {
        super(enabled, condition, hitCondition, logMessage);
        this.functionName = functionName;
    }
};
FunctionBreakpoint = ( (__decorate([
    es5ClassCompat
], FunctionBreakpoint)));
let DataBreakpoint = class DataBreakpoint extends Breakpoint {
    constructor(label, dataId, canPersist, enabled, condition, hitCondition, logMessage) {
        super(enabled, condition, hitCondition, logMessage);
        if (!dataId) {
            throw illegalArgument('dataId');
        }
        this.label = label;
        this.dataId = dataId;
        this.canPersist = canPersist;
    }
};
DataBreakpoint = ( (__decorate([
    es5ClassCompat
], DataBreakpoint)));
let DebugAdapterExecutable = class DebugAdapterExecutable {
    constructor(command, args, options) {
        this.command = command;
        this.args = args || [];
        this.options = options;
    }
};
DebugAdapterExecutable = ( (__decorate([
    es5ClassCompat
], DebugAdapterExecutable)));
let DebugAdapterServer = class DebugAdapterServer {
    constructor(port, host) {
        this.port = port;
        this.host = host;
    }
};
DebugAdapterServer = ( (__decorate([
    es5ClassCompat
], DebugAdapterServer)));
let DebugAdapterNamedPipeServer = class DebugAdapterNamedPipeServer {
    constructor(path) {
        this.path = path;
    }
};
DebugAdapterNamedPipeServer = ( (__decorate([
    es5ClassCompat
], DebugAdapterNamedPipeServer)));
let DebugAdapterInlineImplementation = class DebugAdapterInlineImplementation {
    constructor(impl) {
        this.implementation = impl;
    }
};
DebugAdapterInlineImplementation = ( (__decorate([
    es5ClassCompat
], DebugAdapterInlineImplementation)));
let EvaluatableExpression = class EvaluatableExpression {
    constructor(range, expression) {
        this.range = range;
        this.expression = expression;
    }
};
EvaluatableExpression = ( (__decorate([
    es5ClassCompat
], EvaluatableExpression)));
var InlineCompletionTriggerKind;
( ((function(InlineCompletionTriggerKind) {
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Invoke"] = 0] = "Invoke";
    InlineCompletionTriggerKind[InlineCompletionTriggerKind["Automatic"] = 1] = "Automatic";
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}))));
let InlineValueText = class InlineValueText {
    constructor(range, text) {
        this.range = range;
        this.text = text;
    }
};
InlineValueText = ( (__decorate([
    es5ClassCompat
], InlineValueText)));
let InlineValueVariableLookup = class InlineValueVariableLookup {
    constructor(range, variableName, caseSensitiveLookup = true) {
        this.range = range;
        this.variableName = variableName;
        this.caseSensitiveLookup = caseSensitiveLookup;
    }
};
InlineValueVariableLookup = ( (__decorate([
    es5ClassCompat
], InlineValueVariableLookup)));
let InlineValueEvaluatableExpression = class InlineValueEvaluatableExpression {
    constructor(range, expression) {
        this.range = range;
        this.expression = expression;
    }
};
InlineValueEvaluatableExpression = ( (__decorate([
    es5ClassCompat
], InlineValueEvaluatableExpression)));
let InlineValueContext = class InlineValueContext {
    constructor(frameId, range) {
        this.frameId = frameId;
        this.stoppedLocation = range;
    }
};
InlineValueContext = ( (__decorate([
    es5ClassCompat
], InlineValueContext)));
var FileChangeType;
( ((function(FileChangeType) {
    FileChangeType[FileChangeType["Changed"] = 1] = "Changed";
    FileChangeType[FileChangeType["Created"] = 2] = "Created";
    FileChangeType[FileChangeType["Deleted"] = 3] = "Deleted";
})(FileChangeType || (FileChangeType = {}))));
let FileSystemError = FileSystemError_1 = class FileSystemError extends Error {
    static FileExists(messageOrUri) {
        return (
             (new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.FileExists,
                FileSystemError_1.FileExists
            ))
        );
    }
    static FileNotFound(messageOrUri) {
        return (
             (new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.FileNotFound,
                FileSystemError_1.FileNotFound
            ))
        );
    }
    static FileNotADirectory(messageOrUri) {
        return (
             (new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.FileNotADirectory,
                FileSystemError_1.FileNotADirectory
            ))
        );
    }
    static FileIsADirectory(messageOrUri) {
        return (
             (new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.FileIsADirectory,
                FileSystemError_1.FileIsADirectory
            ))
        );
    }
    static NoPermissions(messageOrUri) {
        return (
             (new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.NoPermissions,
                FileSystemError_1.NoPermissions
            ))
        );
    }
    static Unavailable(messageOrUri) {
        return (
             (new FileSystemError_1(
                messageOrUri,
                FileSystemProviderErrorCode.Unavailable,
                FileSystemError_1.Unavailable
            ))
        );
    }
    constructor(uriOrMessage, code = FileSystemProviderErrorCode.Unknown, terminator) {
        super(URI.isUri(uriOrMessage) ? ( (uriOrMessage.toString(true))) : uriOrMessage);
        this.code = terminator?.name ?? 'Unknown';
        markAsFileSystemProviderError(this, code);
        Object.setPrototypeOf(this, FileSystemError_1.prototype);
        if (typeof Error.captureStackTrace === 'function' && typeof terminator === 'function') {
            Error.captureStackTrace(this, terminator);
        }
    }
};
FileSystemError = FileSystemError_1 = ( (__decorate([
    es5ClassCompat
], FileSystemError)));
let FoldingRange = class FoldingRange {
    constructor(start, end, kind) {
        this.start = start;
        this.end = end;
        this.kind = kind;
    }
};
FoldingRange = ( (__decorate([
    es5ClassCompat
], FoldingRange)));
var FoldingRangeKind;
( ((function(FoldingRangeKind) {
    FoldingRangeKind[FoldingRangeKind["Comment"] = 1] = "Comment";
    FoldingRangeKind[FoldingRangeKind["Imports"] = 2] = "Imports";
    FoldingRangeKind[FoldingRangeKind["Region"] = 3] = "Region";
})(FoldingRangeKind || (FoldingRangeKind = {}))));
var CommentThreadCollapsibleState;
( ((function(CommentThreadCollapsibleState) {
    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Collapsed"] = 0] = "Collapsed";
    CommentThreadCollapsibleState[CommentThreadCollapsibleState["Expanded"] = 1] = "Expanded";
})(CommentThreadCollapsibleState || (CommentThreadCollapsibleState = {}))));
var CommentMode;
( ((function(CommentMode) {
    CommentMode[CommentMode["Editing"] = 0] = "Editing";
    CommentMode[CommentMode["Preview"] = 1] = "Preview";
})(CommentMode || (CommentMode = {}))));
class SemanticTokensLegend {
    constructor(tokenTypes, tokenModifiers = []) {
        this.tokenTypes = tokenTypes;
        this.tokenModifiers = tokenModifiers;
    }
}
function isStrArrayOrUndefined(arg) {
    return ((typeof arg === 'undefined') || isStringArray(arg));
}
class SemanticTokensBuilder {
    constructor(legend) {
        this._prevLine = 0;
        this._prevChar = 0;
        this._dataIsSortedAndDeltaEncoded = true;
        this._data = [];
        this._dataLen = 0;
        this._tokenTypeStrToInt = ( (new Map()));
        this._tokenModifierStrToInt = ( (new Map()));
        this._hasLegend = false;
        if (legend) {
            this._hasLegend = true;
            for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
                this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);
            }
            for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
                this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);
            }
        }
    }
    push(arg0, arg1, arg2, arg3, arg4) {
        if (typeof arg0 === 'number' && typeof arg1 === 'number' && typeof arg2 === 'number' && typeof arg3 === 'number' && (typeof arg4 === 'number' || typeof arg4 === 'undefined')) {
            if (typeof arg4 === 'undefined') {
                arg4 = 0;
            }
            return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);
        }
        if (Range.isRange(arg0) && typeof arg1 === 'string' && isStrArrayOrUndefined(arg2)) {
            return this._push(arg0, arg1, arg2);
        }
        throw illegalArgument();
    }
    _push(range, tokenType, tokenModifiers) {
        if (!this._hasLegend) {
            throw new Error('Legend must be provided in constructor');
        }
        if (range.start.line !== range.end.line) {
            throw new Error('`range` cannot span multiple lines');
        }
        if (!this._tokenTypeStrToInt.has(tokenType)) {
            throw new Error('`tokenType` is not in the provided legend');
        }
        const line = range.start.line;
        const char = range.start.character;
        const length = range.end.character - range.start.character;
        const nTokenType = this._tokenTypeStrToInt.get(tokenType);
        let nTokenModifiers = 0;
        if (tokenModifiers) {
            for (const tokenModifier of tokenModifiers) {
                if (!this._tokenModifierStrToInt.has(tokenModifier)) {
                    throw new Error('`tokenModifier` is not in the provided legend');
                }
                const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);
                nTokenModifiers |= (1 << nTokenModifier) >>> 0;
            }
        }
        this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);
    }
    _pushEncoded(line, char, length, tokenType, tokenModifiers) {
        if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || (line === this._prevLine && char < this._prevChar))) {
            this._dataIsSortedAndDeltaEncoded = false;
            const tokenCount = (this._data.length / 5) | 0;
            let prevLine = 0;
            let prevChar = 0;
            for (let i = 0; i < tokenCount; i++) {
                let line = this._data[5 * i];
                let char = this._data[5 * i + 1];
                if (line === 0) {
                    line = prevLine;
                    char += prevChar;
                }
                else {
                    line += prevLine;
                }
                this._data[5 * i] = line;
                this._data[5 * i + 1] = char;
                prevLine = line;
                prevChar = char;
            }
        }
        let pushLine = line;
        let pushChar = char;
        if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    static _sortAndDeltaEncode(data) {
        const pos = [];
        const tokenCount = (data.length / 5) | 0;
        for (let i = 0; i < tokenCount; i++) {
            pos[i] = i;
        }
        pos.sort((a, b) => {
            const aLine = data[5 * a];
            const bLine = data[5 * b];
            if (aLine === bLine) {
                const aChar = data[5 * a + 1];
                const bChar = data[5 * b + 1];
                return aChar - bChar;
            }
            return aLine - bLine;
        });
        const result = ( (new Uint32Array(data.length)));
        let prevLine = 0;
        let prevChar = 0;
        for (let i = 0; i < tokenCount; i++) {
            const srcOffset = 5 * pos[i];
            const line = data[srcOffset + 0];
            const char = data[srcOffset + 1];
            const length = data[srcOffset + 2];
            const tokenType = data[srcOffset + 3];
            const tokenModifiers = data[srcOffset + 4];
            const pushLine = line - prevLine;
            const pushChar = (pushLine === 0 ? char - prevChar : char);
            const dstOffset = 5 * i;
            result[dstOffset + 0] = pushLine;
            result[dstOffset + 1] = pushChar;
            result[dstOffset + 2] = length;
            result[dstOffset + 3] = tokenType;
            result[dstOffset + 4] = tokenModifiers;
            prevLine = line;
            prevChar = char;
        }
        return result;
    }
    build(resultId) {
        if (!this._dataIsSortedAndDeltaEncoded) {
            return (
                 (new SemanticTokens(SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId))
            );
        }
        return (
             (new SemanticTokens( (new Uint32Array(this._data)), resultId))
        );
    }
}
class SemanticTokens {
    constructor(data, resultId) {
        this.resultId = resultId;
        this.data = data;
    }
}
class SemanticTokensEdit {
    constructor(start, deleteCount, data) {
        this.start = start;
        this.deleteCount = deleteCount;
        this.data = data;
    }
}
class SemanticTokensEdits {
    constructor(edits, resultId) {
        this.resultId = resultId;
        this.edits = edits;
    }
}
var DebugConsoleMode;
( ((function(DebugConsoleMode) {
    DebugConsoleMode[DebugConsoleMode["Separate"] = 0] = "Separate";
    DebugConsoleMode[DebugConsoleMode["MergeWithParent"] = 1] = "MergeWithParent";
})(DebugConsoleMode || (DebugConsoleMode = {}))));
let QuickInputButtons = class QuickInputButtons {
    constructor() { }
};
QuickInputButtons.Back = { iconPath: ( (new ThemeIcon('arrow-left'))) };
QuickInputButtons = ( (__decorate([
    es5ClassCompat
], QuickInputButtons)));
var QuickPickItemKind;
( ((function(QuickPickItemKind) {
    QuickPickItemKind[QuickPickItemKind["Separator"] = -1] = "Separator";
    QuickPickItemKind[QuickPickItemKind["Default"] = 0] = "Default";
})(QuickPickItemKind || (QuickPickItemKind = {}))));
var InputBoxValidationSeverity;
( ((function(InputBoxValidationSeverity) {
    InputBoxValidationSeverity[InputBoxValidationSeverity["Info"] = 1] = "Info";
    InputBoxValidationSeverity[InputBoxValidationSeverity["Warning"] = 2] = "Warning";
    InputBoxValidationSeverity[InputBoxValidationSeverity["Error"] = 3] = "Error";
})(InputBoxValidationSeverity || (InputBoxValidationSeverity = {}))));
var ExtensionKind;
( ((function(ExtensionKind) {
    ExtensionKind[ExtensionKind["UI"] = 1] = "UI";
    ExtensionKind[ExtensionKind["Workspace"] = 2] = "Workspace";
})(ExtensionKind || (ExtensionKind = {}))));
class FileDecoration {
    static validate(d) {
        if (typeof d.badge === 'string') {
            let len = nextCharLength(d.badge, 0);
            if (len < d.badge.length) {
                len += nextCharLength(d.badge, len);
            }
            if (d.badge.length > len) {
                throw new Error(`The 'badge'-property must be undefined or a short character`);
            }
        }
        else if (d.badge) {
            if (!ThemeIcon.isThemeIcon(d.badge)) {
                throw new Error(`The 'badge'-property is not a valid ThemeIcon`);
            }
        }
        if (!d.color && !d.badge && !d.tooltip) {
            throw new Error(`The decoration is empty`);
        }
        return true;
    }
    constructor(badge, tooltip, color) {
        this.badge = badge;
        this.tooltip = tooltip;
        this.color = color;
    }
}
class NotebookRange {
    static isNotebookRange(thing) {
        if (thing instanceof NotebookRange) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.start === 'number'
            && typeof thing.end === 'number';
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    get isEmpty() {
        return this._start === this._end;
    }
    constructor(start, end) {
        if (start < 0) {
            throw illegalArgument('start must be positive');
        }
        if (end < 0) {
            throw illegalArgument('end must be positive');
        }
        if (start <= end) {
            this._start = start;
            this._end = end;
        }
        else {
            this._start = end;
            this._end = start;
        }
    }
    with(change) {
        let start = this._start;
        let end = this._end;
        if (change.start !== undefined) {
            start = change.start;
        }
        if (change.end !== undefined) {
            end = change.end;
        }
        if (start === this._start && end === this._end) {
            return this;
        }
        return (
             (new NotebookRange(start, end))
        );
    }
}
class NotebookCellData {
    static validate(data) {
        if (typeof data.kind !== 'number') {
            throw new Error('NotebookCellData MUST have \'kind\' property');
        }
        if (typeof data.value !== 'string') {
            throw new Error('NotebookCellData MUST have \'value\' property');
        }
        if (typeof data.languageId !== 'string') {
            throw new Error('NotebookCellData MUST have \'languageId\' property');
        }
    }
    static isNotebookCellDataArray(value) {
        return Array.isArray(value) && value.every(elem => NotebookCellData.isNotebookCellData(elem));
    }
    static isNotebookCellData(value) {
        return true;
    }
    constructor(kind, value, languageId, mime, outputs, metadata, executionSummary) {
        this.kind = kind;
        this.value = value;
        this.languageId = languageId;
        this.mime = mime;
        this.outputs = outputs ?? [];
        this.metadata = metadata;
        this.executionSummary = executionSummary;
        NotebookCellData.validate(this);
    }
}
class NotebookCellOutputItem {
    static isNotebookCellOutputItem(obj) {
        if (obj instanceof NotebookCellOutputItem) {
            return true;
        }
        if (!obj) {
            return false;
        }
        return typeof obj.mime === 'string'
            && obj.data instanceof Uint8Array;
    }
    static error(err) {
        const obj = {
            name: err.name,
            message: err.message,
            stack: err.stack
        };
        return NotebookCellOutputItem.json(obj, 'application/vnd.code.notebook.error');
    }
    static stdout(value) {
        return NotebookCellOutputItem.text(value, 'application/vnd.code.notebook.stdout');
    }
    static stderr(value) {
        return NotebookCellOutputItem.text(value, 'application/vnd.code.notebook.stderr');
    }
    static bytes(value, mime = 'application/octet-stream') {
        return (
             (new NotebookCellOutputItem(value, mime))
        );
    }
    static text(value, mime = Mimes.text) {
        const bytes = __classPrivateFieldGet(NotebookCellOutputItem, _a, "f", _NotebookCellOutputItem_encoder).encode(String(value));
        return (
             (new NotebookCellOutputItem(bytes, mime))
        );
    }
    static json(value, mime = 'text/x-json') {
        const rawStr = JSON.stringify(value, undefined, '\t');
        return NotebookCellOutputItem.text(rawStr, mime);
    }
    constructor(data, mime) {
        this.data = data;
        this.mime = mime;
        const mimeNormalized = normalizeMimeType(mime, true);
        if (!mimeNormalized) {
            throw new Error(`INVALID mime type: ${mime}. Must be in the format "type/subtype[;optionalparameter]"`);
        }
        this.mime = mimeNormalized;
    }
}
_a = NotebookCellOutputItem;
_NotebookCellOutputItem_encoder = { value: ( (new TextEncoder())) };
class NotebookCellOutput {
    static isNotebookCellOutput(candidate) {
        if (candidate instanceof NotebookCellOutput) {
            return true;
        }
        if (!candidate || typeof candidate !== 'object') {
            return false;
        }
        return typeof candidate.id === 'string' && Array.isArray(candidate.items);
    }
    static ensureUniqueMimeTypes(items, warn = false) {
        const seen = ( (new Set()));
        const removeIdx = ( (new Set()));
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            const normalMime = normalizeMimeType(item.mime);
            if (!seen.has(normalMime) || isTextStreamMime(normalMime)) {
                seen.add(normalMime);
                continue;
            }
            removeIdx.add(i);
            if (warn) {
                console.warn(`DUPLICATED mime type '${item.mime}' will be dropped`);
            }
        }
        if (removeIdx.size === 0) {
            return items;
        }
        return items.filter((_item, index) => !removeIdx.has(index));
    }
    constructor(items, idOrMetadata, metadata) {
        this.items = NotebookCellOutput.ensureUniqueMimeTypes(items, true);
        if (typeof idOrMetadata === 'string') {
            this.id = idOrMetadata;
            this.metadata = metadata;
        }
        else {
            this.id = generateUuid();
            this.metadata = idOrMetadata ?? metadata;
        }
    }
}
var NotebookCellKind;
( ((function(NotebookCellKind) {
    NotebookCellKind[NotebookCellKind["Markup"] = 1] = "Markup";
    NotebookCellKind[NotebookCellKind["Code"] = 2] = "Code";
})(NotebookCellKind || (NotebookCellKind = {}))));
var ExtensionMode;
( ((function(ExtensionMode) {
    ExtensionMode[ExtensionMode["Production"] = 1] = "Production";
    ExtensionMode[ExtensionMode["Development"] = 2] = "Development";
    ExtensionMode[ExtensionMode["Test"] = 3] = "Test";
})(ExtensionMode || (ExtensionMode = {}))));
var ExtensionRuntime;
( ((function(ExtensionRuntime) {
    ExtensionRuntime[ExtensionRuntime["Node"] = 1] = "Node";
    ExtensionRuntime[ExtensionRuntime["Webworker"] = 2] = "Webworker";
})(ExtensionRuntime || (ExtensionRuntime = {}))));
var StandardTokenType;
( ((function(StandardTokenType) {
    StandardTokenType[StandardTokenType["Other"] = 0] = "Other";
    StandardTokenType[StandardTokenType["Comment"] = 1] = "Comment";
    StandardTokenType[StandardTokenType["String"] = 2] = "String";
    StandardTokenType[StandardTokenType["RegEx"] = 3] = "RegEx";
})(StandardTokenType || (StandardTokenType = {}))));
class LinkedEditingRanges {
    constructor(ranges, wordPattern) {
        this.ranges = ranges;
        this.wordPattern = wordPattern;
    }
}
var TestRunProfileKind;
( ((function(TestRunProfileKind) {
    TestRunProfileKind[TestRunProfileKind["Run"] = 1] = "Run";
    TestRunProfileKind[TestRunProfileKind["Debug"] = 2] = "Debug";
    TestRunProfileKind[TestRunProfileKind["Coverage"] = 3] = "Coverage";
})(TestRunProfileKind || (TestRunProfileKind = {}))));
let TestRunRequest = class TestRunRequest {
    constructor(include = undefined, exclude = undefined, profile = undefined) {
        this.include = include;
        this.exclude = exclude;
        this.profile = profile;
    }
};
TestRunRequest = ( (__decorate([
    es5ClassCompat
], TestRunRequest)));
let TestMessage = TestMessage_1 = class TestMessage {
    static diff(message, expected, actual) {
        const msg = ( (new TestMessage_1(message)));
        msg.expectedOutput = expected;
        msg.actualOutput = actual;
        return msg;
    }
    constructor(message) {
        this.message = message;
    }
};
TestMessage = TestMessage_1 = ( (__decorate([
    es5ClassCompat
], TestMessage)));
let TestTag = class TestTag {
    constructor(id) {
        this.id = id;
    }
};
TestTag = ( (__decorate([
    es5ClassCompat
], TestTag)));
class TypeHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange) {
        this.kind = kind;
        this.name = name;
        this.detail = detail;
        this.uri = uri;
        this.range = range;
        this.selectionRange = selectionRange;
    }
}
class TextTabInput {
    constructor(uri) {
        this.uri = uri;
    }
}
class TextDiffTabInput {
    constructor(original, modified) {
        this.original = original;
        this.modified = modified;
    }
}
class TextMergeTabInput {
    constructor(base, input1, input2, result) {
        this.base = base;
        this.input1 = input1;
        this.input2 = input2;
        this.result = result;
    }
}
class CustomEditorTabInput {
    constructor(uri, viewType) {
        this.uri = uri;
        this.viewType = viewType;
    }
}
class WebviewEditorTabInput {
    constructor(viewType) {
        this.viewType = viewType;
    }
}
class NotebookEditorTabInput {
    constructor(uri, notebookType) {
        this.uri = uri;
        this.notebookType = notebookType;
    }
}
class NotebookDiffEditorTabInput {
    constructor(original, modified, notebookType) {
        this.original = original;
        this.modified = modified;
        this.notebookType = notebookType;
    }
}
class TerminalEditorTabInput {
    constructor() { }
}
class InteractiveWindowInput {
    constructor(uri, inputBoxUri) {
        this.uri = uri;
        this.inputBoxUri = inputBoxUri;
    }
}
const IURITransformerService = ( (createDecorator('IURITransformerService')));
class URITransformerService {
    constructor(delegate) {
        if (!delegate) {
            this.transformIncoming = arg => arg;
            this.transformOutgoing = arg => arg;
            this.transformOutgoingURI = arg => arg;
            this.transformOutgoingScheme = arg => arg;
        }
        else {
            this.transformIncoming = delegate.transformIncoming.bind(delegate);
            this.transformOutgoing = delegate.transformOutgoing.bind(delegate);
            this.transformOutgoingURI = delegate.transformOutgoingURI.bind(delegate);
            this.transformOutgoingScheme = delegate.transformOutgoingScheme.bind(delegate);
        }
    }
}
const SEARCH_ELIDED_PREFIX = ' ';
const SEARCH_ELIDED_SUFFIX = ' characters skipped ';
const SEARCH_ELIDED_MIN_LEN = (SEARCH_ELIDED_PREFIX.length + SEARCH_ELIDED_SUFFIX.length + 5) * 2;
const ISearchService = ( (createDecorator('searchService')));
function resultIsMatch(result) {
    return !!result.preview;
}
function isFileMatch(p) {
    return !!p.resource;
}
function isProgressMessage(p) {
    return !!p.message;
}
class FileMatch {
    constructor(resource) {
        this.resource = resource;
        this.results = [];
    }
}
class TextSearchMatch {
    constructor(text, range, previewOptions) {
        this.ranges = range;
        const ranges = Array.isArray(range) ? range : [range];
        if (previewOptions && previewOptions.matchLines === 1 && isSingleLineRangeList(ranges)) {
            text = getNLines(text, previewOptions.matchLines);
            let result = '';
            let shift = 0;
            let lastEnd = 0;
            const leadingChars = Math.floor(previewOptions.charsPerLine / 5);
            const matches = [];
            for (const range of ranges) {
                const previewStart = Math.max(range.startColumn - leadingChars, 0);
                const previewEnd = range.startColumn + previewOptions.charsPerLine;
                if (previewStart > lastEnd + leadingChars + SEARCH_ELIDED_MIN_LEN) {
                    const elision = SEARCH_ELIDED_PREFIX + (previewStart - lastEnd) + SEARCH_ELIDED_SUFFIX;
                    result += elision + text.slice(previewStart, previewEnd);
                    shift += previewStart - (lastEnd + elision.length);
                }
                else {
                    result += text.slice(lastEnd, previewEnd);
                }
                matches.push(( (new OneLineRange(0, range.startColumn - shift, range.endColumn - shift))));
                lastEnd = previewEnd;
            }
            this.preview = { text: result, matches: Array.isArray(this.ranges) ? matches : matches[0] };
        }
        else {
            const firstMatchLine = Array.isArray(range) ? range[0].startLineNumber : range.startLineNumber;
            this.preview = {
                text,
                matches: mapArrayOrNot(range, r => ( (new SearchRange(
                    r.startLineNumber - firstMatchLine,
                    r.startColumn,
                    r.endLineNumber - firstMatchLine,
                    r.endColumn
                ))))
            };
        }
    }
}
function isSingleLineRangeList(ranges) {
    const line = ranges[0].startLineNumber;
    for (const r of ranges) {
        if (r.startLineNumber !== line || r.endLineNumber !== line) {
            return false;
        }
    }
    return true;
}
class SearchRange {
    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
        this.startLineNumber = startLineNumber;
        this.startColumn = startColumn;
        this.endLineNumber = endLineNumber;
        this.endColumn = endColumn;
    }
}
class OneLineRange extends SearchRange {
    constructor(lineNumber, startColumn, endColumn) {
        super(lineNumber, startColumn, lineNumber, endColumn);
    }
}
function getExcludes(configuration, includeSearchExcludes = true) {
    const fileExcludes = configuration && configuration.files && configuration.files.exclude;
    const searchExcludes = includeSearchExcludes && configuration && configuration.search && configuration.search.exclude;
    if (!fileExcludes && !searchExcludes) {
        return undefined;
    }
    if (!fileExcludes || !searchExcludes) {
        return fileExcludes || searchExcludes;
    }
    let allExcludes = Object.create(null);
    allExcludes = mixin(allExcludes, deepClone(fileExcludes));
    allExcludes = mixin(allExcludes, deepClone(searchExcludes), true);
    return allExcludes;
}
function pathIncludedInQuery(queryProps, fsPath) {
    if (queryProps.excludePattern && match(queryProps.excludePattern, fsPath)) {
        return false;
    }
    if (queryProps.includePattern || queryProps.usingSearchPaths) {
        if (queryProps.includePattern && match(queryProps.includePattern, fsPath)) {
            return true;
        }
        if (queryProps.usingSearchPaths) {
            return !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {
                const searchPath = fq.folder.fsPath;
                if (isEqualOrParent(fsPath, searchPath)) {
                    const relPath = relative(searchPath, fsPath);
                    return !fq.includePattern || !!match(fq.includePattern, relPath);
                }
                else {
                    return false;
                }
            });
        }
        return false;
    }
    return true;
}
var SearchErrorCode;
( ((function(SearchErrorCode) {
    SearchErrorCode[SearchErrorCode["unknownEncoding"] = 1] = "unknownEncoding";
    SearchErrorCode[SearchErrorCode["regexParseError"] = 2] = "regexParseError";
    SearchErrorCode[SearchErrorCode["globParseError"] = 3] = "globParseError";
    SearchErrorCode[SearchErrorCode["invalidLiteral"] = 4] = "invalidLiteral";
    SearchErrorCode[SearchErrorCode["rgProcessError"] = 5] = "rgProcessError";
    SearchErrorCode[SearchErrorCode["other"] = 6] = "other";
    SearchErrorCode[SearchErrorCode["canceled"] = 7] = "canceled";
})(SearchErrorCode || (SearchErrorCode = {}))));
class SearchError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
function deserializeSearchError(error) {
    const errorMsg = error.message;
    if (isCancellationError(error)) {
        return (
             (new SearchError(errorMsg, SearchErrorCode.canceled))
        );
    }
    try {
        const details = JSON.parse(errorMsg);
        return (
             (new SearchError(details.message, details.code))
        );
    }
    catch (e) {
        return (
             (new SearchError(errorMsg, SearchErrorCode.other))
        );
    }
}
const ILifecycleService = ( (createDecorator('lifecycleService')));
const ILanguageDetectionService = ( (createDecorator('ILanguageDetectionService')));
const LanguageDetectionLanguageEventSource = 'languageDetection';
const IKeyboardLayoutService = ( (createDecorator('keyboardLayoutService')));
function getKeyboardLayoutId(layout) {
    if (layout.name) {
        return layout.name;
    }
    if (layout.id) {
        return layout.id;
    }
    return layout.layout;
}
const IRequestService = ( (createDecorator('requestService')));
const IActivityService = ( (createDecorator('activityService')));
class BaseBadge {
    constructor(descriptorFn) {
        this.descriptorFn = descriptorFn;
        this.descriptorFn = descriptorFn;
    }
    getDescription() {
        return this.descriptorFn(null);
    }
}
class NumberBadge extends BaseBadge {
    constructor(number, descriptorFn) {
        super(descriptorFn);
        this.number = number;
        this.number = number;
    }
    getDescription() {
        return this.descriptorFn(this.number);
    }
}
const IBrowserWorkbenchEnvironmentService = refineServiceDecorator(IEnvironmentService);
const IUserDataInitializationService = ( (createDecorator('IUserDataInitializationService')));
const IHostColorSchemeService = ( (createDecorator('hostColorSchemeService')));
class BrowserHostColorSchemeService extends Disposable$1 {
    constructor() {
        super();
        this._onDidSchemeChangeEvent = this._register(( (new Emitter())));
        this.registerListeners();
    }
    registerListeners() {
        addMatchMediaChangeListener('(prefers-color-scheme: dark)', () => {
            this._onDidSchemeChangeEvent.fire();
        });
        addMatchMediaChangeListener('(forced-colors: active)', () => {
            this._onDidSchemeChangeEvent.fire();
        });
    }
    get onDidChangeColorScheme() {
        return this._onDidSchemeChangeEvent.event;
    }
    get dark() {
        if (window.matchMedia(`(prefers-color-scheme: light)`).matches) {
            return false;
        }
        else if (window.matchMedia(`(prefers-color-scheme: dark)`).matches) {
            return true;
        }
        return false;
    }
    get highContrast() {
        if (window.matchMedia(`(forced-colors: active)`).matches) {
            return true;
        }
        return false;
    }
}
const IPreferencesService = ( (createDecorator('preferencesService')));
const IUserDataProfileService = ( (createDecorator('IUserDataProfileService')));
const defaultUserDataProfileIcon = ( (registerIcon(
    'defaultProfile-icon',
    Codicon.settings,
     (localize('defaultProfileIcon', 'Icon for Default Profile.'))
)));
let UserDataProfileService = class UserDataProfileService extends Disposable$1 {
    get currentProfile() { return this._currentProfile; }
    constructor(currentProfile, userDataProfilesService) {
        super();
        this._onDidChangeCurrentProfile = this._register(( (new Emitter())));
        this.onDidChangeCurrentProfile = this._onDidChangeCurrentProfile.event;
        this._onDidUpdateCurrentProfile = this._register(( (new Emitter())));
        this.onDidUpdateCurrentProfile = this._onDidUpdateCurrentProfile.event;
        this._currentProfile = currentProfile;
        this._register(userDataProfilesService.onDidChangeProfiles(e => {
            const updatedCurrentProfile = e.updated.find(p => this._currentProfile.id === p.id);
            if (updatedCurrentProfile) {
                this._currentProfile = updatedCurrentProfile;
                this._onDidUpdateCurrentProfile.fire();
            }
        }));
    }
    async updateCurrentProfile(userDataProfile, preserveData) {
        if (this._currentProfile.id === userDataProfile.id) {
            return;
        }
        const previous = this._currentProfile;
        this._currentProfile = userDataProfile;
        const joiners = [];
        this._onDidChangeCurrentProfile.fire({
            preserveData,
            previous,
            profile: userDataProfile,
            join(promise) {
                joiners.push(promise);
            }
        });
        await Promises.settled(joiners);
    }
    getShortName(profile) {
        if (!profile.isDefault && profile.shortName && ThemeIcon$1.fromId(profile.shortName)) {
            return profile.shortName;
        }
        return `$(${defaultUserDataProfileIcon.id})`;
    }
};
UserDataProfileService = ( (__decorate([
    ( (__param(1, IUserDataProfilesService)))
], UserDataProfileService)));
class FallbackKeyboardMapper {
    constructor(_mapAltGrToCtrlAlt, _OS) {
        this._mapAltGrToCtrlAlt = _mapAltGrToCtrlAlt;
        this._OS = _OS;
    }
    dumpDebugInfo() {
        return 'FallbackKeyboardMapper dispatching on keyCode';
    }
    resolveKeyboardEvent(keyboardEvent) {
        const ctrlKey = keyboardEvent.ctrlKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);
        const altKey = keyboardEvent.altKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);
        const chord = ( (new KeyCodeChord(
            ctrlKey,
            keyboardEvent.shiftKey,
            altKey,
            keyboardEvent.metaKey,
            keyboardEvent.keyCode
        )));
        const result = this.resolveKeybinding(( (new Keybinding([chord]))));
        return result[0];
    }
    resolveKeybinding(keybinding) {
        return USLayoutResolvedKeybinding.resolveKeybinding(keybinding, this._OS);
    }
}
const ITextMateTokenizationService = ( (createDecorator('textMateTokenizationFeature')));
const IExtensionHostDebugService = ( (createDecorator('extensionHostDebugService')));
const defaultViewIcon = ( (registerIcon(
    'default-view-icon',
    Codicon.window,
     (localize('defaultViewIcon', 'Default view icon.'))
)));
var Extensions;
( ((function(Extensions) {
    Extensions.ViewContainersRegistry = 'workbench.registry.view.containers';
    Extensions.ViewsRegistry = 'workbench.registry.view';
})(Extensions || (Extensions = {}))));
function ViewContainerLocationToString(viewContainerLocation) {
    switch (viewContainerLocation) {
        case 0 : return 'sidebar';
        case 1 : return 'panel';
        case 2 : return 'auxiliarybar';
    }
}
const IViewsService = ( (createDecorator('viewsService')));
const IViewDescriptorService = ( (createDecorator('viewDescriptorService')));
const IHistoryService = ( (createDecorator('historyService')));
const ITaskService = ( (createDecorator('taskService')));
const IConfigurationResolverService = ( (createDecorator('configurationResolverService')));
var VariableKind;
( ((function(VariableKind) {
    VariableKind["Unknown"] = "unknown";
    VariableKind["Env"] = "env";
    VariableKind["Config"] = "config";
    VariableKind["Command"] = "command";
    VariableKind["Input"] = "input";
    VariableKind["ExtensionInstallFolder"] = "extensionInstallFolder";
    VariableKind["WorkspaceFolder"] = "workspaceFolder";
    VariableKind["Cwd"] = "cwd";
    VariableKind["WorkspaceFolderBasename"] = "workspaceFolderBasename";
    VariableKind["UserHome"] = "userHome";
    VariableKind["LineNumber"] = "lineNumber";
    VariableKind["SelectedText"] = "selectedText";
    VariableKind["File"] = "file";
    VariableKind["FileWorkspaceFolder"] = "fileWorkspaceFolder";
    VariableKind["RelativeFile"] = "relativeFile";
    VariableKind["RelativeFileDirname"] = "relativeFileDirname";
    VariableKind["FileDirname"] = "fileDirname";
    VariableKind["FileExtname"] = "fileExtname";
    VariableKind["FileBasename"] = "fileBasename";
    VariableKind["FileBasenameNoExtension"] = "fileBasenameNoExtension";
    VariableKind["FileDirnameBasename"] = "fileDirnameBasename";
    VariableKind["ExecPath"] = "execPath";
    VariableKind["ExecInstallFolder"] = "execInstallFolder";
    VariableKind["PathSeparator"] = "pathSeparator";
})(VariableKind || (VariableKind = {}))));
class VariableError extends Error {
    constructor(variable, message) {
        super(message);
        this.variable = variable;
    }
}
let BrowserPathService = class BrowserPathService extends AbstractPathService {
    constructor(remoteAgentService, environmentService, contextService) {
        super(guessLocalUserHome(environmentService, contextService), remoteAgentService, environmentService, contextService);
    }
};
BrowserPathService = ( (__decorate([
    ( (__param(0, IRemoteAgentService))),
    ( (__param(1, IWorkbenchEnvironmentService))),
    ( (__param(2, IWorkspaceContextService)))
], BrowserPathService)));
function guessLocalUserHome(environmentService, contextService) {
    const workspace = contextService.getWorkspace();
    const firstFolder = firstOrDefault(workspace.folders);
    if (firstFolder) {
        return firstFolder.uri;
    }
    if (workspace.configuration) {
        return dirname(workspace.configuration);
    }
    return (
         (URI.from({
            scheme: AbstractPathService.findDefaultUriScheme(environmentService, contextService),
            authority: environmentService.remoteAuthority,
            path: '/'
        }))
    );
}
function editorMatchToTextSearchResult(matches, model, previewOptions) {
    const firstLine = matches[0].range.startLineNumber;
    const lastLine = matches[matches.length - 1].range.endLineNumber;
    const lineTexts = [];
    for (let i = firstLine; i <= lastLine; i++) {
        lineTexts.push(model.getLineContent(i));
    }
    return (
         (new TextSearchMatch(
            lineTexts.join('\n') + '\n',
             (matches.map(m => ( (new Range$1(
                m.range.startLineNumber - 1,
                m.range.startColumn - 1,
                m.range.endLineNumber - 1,
                m.range.endColumn - 1
            ))))),
            previewOptions
        ))
    );
}
function editorMatchesToTextSearchResults(matches, model, previewOptions) {
    let previousEndLine = -1;
    const groupedMatches = [];
    let currentMatches = [];
    matches.forEach((match) => {
        if (match.range.startLineNumber !== previousEndLine) {
            currentMatches = [];
            groupedMatches.push(currentMatches);
        }
        currentMatches.push(match);
        previousEndLine = match.range.endLineNumber;
    });
    return (
         (groupedMatches.map(sameLineMatches => {
            return editorMatchToTextSearchResult(sameLineMatches, model, previewOptions);
        }))
    );
}
function addContextToEditorMatches(matches, model, query) {
    const results = [];
    let prevLine = -1;
    for (let i = 0; i < matches.length; i++) {
        const { start: matchStartLine, end: matchEndLine } = getMatchStartEnd(matches[i]);
        if (typeof query.beforeContext === 'number' && query.beforeContext > 0) {
            const beforeContextStartLine = Math.max(prevLine + 1, matchStartLine - query.beforeContext);
            for (let b = beforeContextStartLine; b < matchStartLine; b++) {
                results.push({
                    text: model.getLineContent(b + 1),
                    lineNumber: b
                });
            }
        }
        results.push(matches[i]);
        const nextMatch = matches[i + 1];
        const nextMatchStartLine = nextMatch ? getMatchStartEnd(nextMatch).start : Number.MAX_VALUE;
        if (typeof query.afterContext === 'number' && query.afterContext > 0) {
            const afterContextToLine = Math.min(nextMatchStartLine - 1, matchEndLine + query.afterContext, model.getLineCount() - 1);
            for (let a = matchEndLine + 1; a <= afterContextToLine; a++) {
                results.push({
                    text: model.getLineContent(a + 1),
                    lineNumber: a
                });
            }
        }
        prevLine = matchEndLine;
    }
    return results;
}
function getMatchStartEnd(match) {
    const matchRanges = match.ranges;
    const matchStartLine = Array.isArray(matchRanges) ? matchRanges[0].startLineNumber : matchRanges.startLineNumber;
    const matchEndLine = Array.isArray(matchRanges) ? matchRanges[matchRanges.length - 1].endLineNumber : matchRanges.endLineNumber;
    return {
        start: matchStartLine,
        end: matchEndLine
    };
}
let SearchService = class SearchService extends Disposable$1 {
    constructor(modelService, editorService, telemetryService, logService, extensionService, fileService, uriIdentityService) {
        super();
        this.modelService = modelService;
        this.editorService = editorService;
        this.telemetryService = telemetryService;
        this.logService = logService;
        this.extensionService = extensionService;
        this.fileService = fileService;
        this.uriIdentityService = uriIdentityService;
        this.fileSearchProviders = ( (new Map()));
        this.textSearchProviders = ( (new Map()));
        this.deferredFileSearchesByScheme = ( (new Map()));
        this.deferredTextSearchesByScheme = ( (new Map()));
        this.loggedSchemesMissingProviders = ( (new Set()));
    }
    registerSearchResultProvider(scheme, type, provider) {
        let list;
        let deferredMap;
        if (type === 0 ) {
            list = this.fileSearchProviders;
            deferredMap = this.deferredFileSearchesByScheme;
        }
        else if (type === 1 ) {
            list = this.textSearchProviders;
            deferredMap = this.deferredTextSearchesByScheme;
        }
        else {
            throw new Error('Unknown SearchProviderType');
        }
        list.set(scheme, provider);
        if (deferredMap.has(scheme)) {
            deferredMap.get(scheme).complete(provider);
            deferredMap.delete(scheme);
        }
        return toDisposable(() => {
            list.delete(scheme);
        });
    }
    async textSearch(query, token, onProgress, notebookURIs) {
        const localResults = this.getLocalResults(query);
        if (onProgress) {
            coalesce([...( (localResults.results.values()))]).forEach(onProgress);
        }
        const onProviderProgress = (progress) => {
            if (isFileMatch(progress)) {
                if (!localResults.results.has(progress.resource) && !(notebookURIs && notebookURIs.has(progress.resource)) && onProgress) {
                    onProgress(progress);
                }
            }
            else if (onProgress) {
                onProgress(progress);
            }
            if (isProgressMessage(progress)) {
                this.logService.debug('SearchService#search', progress.message);
            }
        };
        const otherResults = await this.doSearch(query, token, onProviderProgress);
        return {
            ...otherResults,
            ...{
                limitHit: otherResults.limitHit || localResults.limitHit
            },
            results: [...otherResults.results, ...coalesce([...( (localResults.results.values()))])]
        };
    }
    fileSearch(query, token) {
        return this.doSearch(query, token);
    }
    doSearch(query, token, onProgress) {
        this.logService.trace('SearchService#search', JSON.stringify(query));
        const schemesInQuery = this.getSchemesInQuery(query);
        const providerActivations = [Promise.resolve(null)];
        schemesInQuery.forEach(scheme => providerActivations.push(this.extensionService.activateByEvent(`onSearch:${scheme}`)));
        providerActivations.push(this.extensionService.activateByEvent('onSearch:file'));
        const providerPromise = (async () => {
            await Promise.all(providerActivations);
            await this.extensionService.whenInstalledExtensionsRegistered();
            if (token && token.isCancellationRequested) {
                return Promise.reject(( (new CancellationError())));
            }
            const progressCallback = (item) => {
                if (token && token.isCancellationRequested) {
                    return;
                }
                onProgress?.(item);
            };
            const exists = await Promise.all(( (query.folderQueries.map(query => this.fileService.exists(query.folder)))));
            query.folderQueries = query.folderQueries.filter((_, i) => exists[i]);
            let completes = await this.searchWithProviders(query, progressCallback, token);
            completes = coalesce(completes);
            if (!completes.length) {
                return {
                    limitHit: false,
                    results: [],
                    messages: [],
                };
            }
            return {
                limitHit: completes[0] && completes[0].limitHit,
                stats: completes[0].stats,
                messages: coalesce(flatten(( (completes.map(i => i.messages))))).filter(uniqueFilter(message => message.type + message.text + message.trusted)),
                results: flatten(( (completes.map((c) => c.results))))
            };
        })();
        return (
             (new Promise((resolve, reject) => {
                if (token) {
                    token.onCancellationRequested(() => {
                        reject(( (new CancellationError())));
                    });
                }
                providerPromise.then(resolve, reject);
            }))
        );
    }
    getSchemesInQuery(query) {
        const schemes = ( (new Set()));
        query.folderQueries?.forEach(fq => schemes.add(fq.folder.scheme));
        query.extraFileResources?.forEach(extraFile => schemes.add(extraFile.scheme));
        return schemes;
    }
    async waitForProvider(queryType, scheme) {
        const deferredMap = queryType === 1  ?
            this.deferredFileSearchesByScheme :
            this.deferredTextSearchesByScheme;
        if (deferredMap.has(scheme)) {
            return deferredMap.get(scheme).p;
        }
        else {
            const deferred = ( (new DeferredPromise()));
            deferredMap.set(scheme, deferred);
            return deferred.p;
        }
    }
    async searchWithProviders(query, onProviderProgress, token) {
        const e2eSW = StopWatch.create(false);
        const searchPs = [];
        const fqs = this.groupFolderQueriesByScheme(query);
        const someSchemeHasProvider = [...( (fqs.keys()))].some(scheme => {
            return query.type === 1  ?
                this.fileSearchProviders.has(scheme) :
                this.textSearchProviders.has(scheme);
        });
        await Promise.all(( ([...( (fqs.keys()))].map(async (scheme) => {
            const schemeFQs = fqs.get(scheme);
            let provider = query.type === 1  ?
                this.fileSearchProviders.get(scheme) :
                this.textSearchProviders.get(scheme);
            if (!provider) {
                if (someSchemeHasProvider) {
                    if (!this.loggedSchemesMissingProviders.has(scheme)) {
                        this.logService.warn(`No search provider registered for scheme: ${scheme}. Another scheme has a provider, not waiting for ${scheme}`);
                        this.loggedSchemesMissingProviders.add(scheme);
                    }
                    return;
                }
                else {
                    if (!this.loggedSchemesMissingProviders.has(scheme)) {
                        this.logService.warn(`No search provider registered for scheme: ${scheme}, waiting`);
                        this.loggedSchemesMissingProviders.add(scheme);
                    }
                    provider = await this.waitForProvider(query.type, scheme);
                }
            }
            const oneSchemeQuery = {
                ...query,
                ...{
                    folderQueries: schemeFQs
                }
            };
            searchPs.push(query.type === 1  ?
                provider.fileSearch(oneSchemeQuery, token) :
                provider.textSearch(oneSchemeQuery, onProviderProgress, token));
        }))));
        return Promise.all(searchPs).then(completes => {
            const endToEndTime = e2eSW.elapsed();
            this.logService.trace(`SearchService#search: ${endToEndTime}ms`);
            completes.forEach(complete => {
                this.sendTelemetry(query, endToEndTime, complete);
            });
            return completes;
        }, err => {
            const endToEndTime = e2eSW.elapsed();
            this.logService.trace(`SearchService#search: ${endToEndTime}ms`);
            const searchError = deserializeSearchError(err);
            this.logService.trace(`SearchService#searchError: ${searchError.message}`);
            this.sendTelemetry(query, endToEndTime, undefined, searchError);
            throw searchError;
        });
    }
    groupFolderQueriesByScheme(query) {
        const queries = ( (new Map()));
        query.folderQueries.forEach(fq => {
            const schemeFQs = queries.get(fq.folder.scheme) || [];
            schemeFQs.push(fq);
            queries.set(fq.folder.scheme, schemeFQs);
        });
        return queries;
    }
    sendTelemetry(query, endToEndTime, complete, err) {
        const fileSchemeOnly = query.folderQueries.every(fq => fq.folder.scheme === Schemas.file);
        const otherSchemeOnly = query.folderQueries.every(fq => fq.folder.scheme !== Schemas.file);
        const scheme = fileSchemeOnly ? Schemas.file :
            otherSchemeOnly ? 'other' :
                'mixed';
        if (query.type === 1  && complete && complete.stats) {
            const fileSearchStats = complete.stats;
            if (fileSearchStats.fromCache) {
                const cacheStats = fileSearchStats.detailStats;
                this.telemetryService.publicLog2('cachedSearchComplete', {
                    reason: query._reason,
                    resultCount: fileSearchStats.resultCount,
                    workspaceFolderCount: query.folderQueries.length,
                    endToEndTime: endToEndTime,
                    sortingTime: fileSearchStats.sortingTime,
                    cacheWasResolved: cacheStats.cacheWasResolved,
                    cacheLookupTime: cacheStats.cacheLookupTime,
                    cacheFilterTime: cacheStats.cacheFilterTime,
                    cacheEntryCount: cacheStats.cacheEntryCount,
                    scheme
                });
            }
            else {
                const searchEngineStats = fileSearchStats.detailStats;
                this.telemetryService.publicLog2('searchComplete', {
                    reason: query._reason,
                    resultCount: fileSearchStats.resultCount,
                    workspaceFolderCount: query.folderQueries.length,
                    endToEndTime: endToEndTime,
                    sortingTime: fileSearchStats.sortingTime,
                    fileWalkTime: searchEngineStats.fileWalkTime,
                    directoriesWalked: searchEngineStats.directoriesWalked,
                    filesWalked: searchEngineStats.filesWalked,
                    cmdTime: searchEngineStats.cmdTime,
                    cmdResultCount: searchEngineStats.cmdResultCount,
                    scheme
                });
            }
        }
        else if (query.type === 2 ) {
            let errorType;
            if (err) {
                errorType = err.code === SearchErrorCode.regexParseError ? 'regex' :
                    err.code === SearchErrorCode.unknownEncoding ? 'encoding' :
                        err.code === SearchErrorCode.globParseError ? 'glob' :
                            err.code === SearchErrorCode.invalidLiteral ? 'literal' :
                                err.code === SearchErrorCode.other ? 'other' :
                                    err.code === SearchErrorCode.canceled ? 'canceled' :
                                        'unknown';
            }
            this.telemetryService.publicLog2('textSearchComplete', {
                reason: query._reason,
                workspaceFolderCount: query.folderQueries.length,
                endToEndTime: endToEndTime,
                scheme,
                error: errorType,
            });
        }
    }
    getLocalResults(query) {
        const localResults = ( (new ResourceMap(uri => this.uriIdentityService.extUri.getComparisonKey(uri))));
        let limitHit = false;
        if (query.type === 2 ) {
            const canonicalToOriginalResources = ( (new ResourceMap()));
            for (const editorInput of this.editorService.editors) {
                const canonical = EditorResourceAccessor.getCanonicalUri(editorInput, { supportSideBySide: SideBySideEditor.PRIMARY });
                const original = EditorResourceAccessor.getOriginalUri(editorInput, { supportSideBySide: SideBySideEditor.PRIMARY });
                if (canonical) {
                    canonicalToOriginalResources.set(canonical, original ?? canonical);
                }
            }
            const models = this.modelService.getModels();
            models.forEach((model) => {
                const resource = model.uri;
                if (!resource) {
                    return;
                }
                if (limitHit) {
                    return;
                }
                const originalResource = canonicalToOriginalResources.get(resource);
                if (!originalResource) {
                    return;
                }
                if (model.getLanguageId() === 'search-result' && !(query.includePattern && query.includePattern['**/*.code-search'])) {
                    return;
                }
                if (originalResource.scheme !== Schemas.untitled && !this.fileService.hasProvider(originalResource)) {
                    return;
                }
                if (originalResource.scheme === 'git') {
                    return;
                }
                if (!this.matches(originalResource, query)) {
                    return;
                }
                const askMax = isNumber(query.maxResults) ? query.maxResults + 1 : Number.MAX_SAFE_INTEGER;
                let matches = model.findMatches(query.contentPattern.pattern, false, !!query.contentPattern.isRegExp, !!query.contentPattern.isCaseSensitive, query.contentPattern.isWordMatch ? query.contentPattern.wordSeparators : null, false, askMax);
                if (matches.length) {
                    if (askMax && matches.length >= askMax) {
                        limitHit = true;
                        matches = matches.slice(0, askMax - 1);
                    }
                    const fileMatch = ( (new FileMatch(originalResource)));
                    localResults.set(originalResource, fileMatch);
                    const textSearchResults = editorMatchesToTextSearchResults(matches, model, query.previewOptions);
                    fileMatch.results = addContextToEditorMatches(textSearchResults, model, query);
                }
                else {
                    localResults.set(originalResource, null);
                }
            });
        }
        return {
            results: localResults,
            limitHit
        };
    }
    matches(resource, query) {
        return pathIncludedInQuery(query, resource.fsPath);
    }
    async clearCache(cacheKey) {
        const clearPs = ( (Array.from(( (this.fileSearchProviders.values())))
            .map(provider => provider && provider.clearCache(cacheKey))));
        await Promise.all(clearPs);
    }
};
SearchService = ( (__decorate([
    ( (__param(0, IModelService))),
    ( (__param(1, IEditorService))),
    ( (__param(2, ITelemetryService))),
    ( (__param(3, ILogService))),
    ( (__param(4, IExtensionService))),
    ( (__param(5, IFileService))),
    ( (__param(6, IUriIdentityService)))
], SearchService)));
const IEditSessionIdentityService = ( (createDecorator('editSessionIdentityService')));
const IWorkspaceEditingService = ( (createDecorator('workspaceEditingService')));
const ITimerService = ( (createDecorator('timerService')));
const IExtensionsWorkbenchService = ( (createDecorator('extensionsWorkbenchService')));
const IWorkbenchExtensionEnablementService = ( (createDecorator('extensionEnablementService')));
const ITunnelService = ( (createDecorator('tunnelService')));
const IWorkingCopyBackupService = ( (createDecorator('workingCopyBackupService')));
const AutoSaveAfterShortDelayContext = ( (new RawContextKey('autoSaveAfterShortDelayContext', false, true)));
const IFilesConfigurationService = ( (createDecorator('filesConfigurationService')));
let FilesConfigurationService = class FilesConfigurationService extends Disposable$1 {
    constructor(contextKeyService, configurationService, contextService) {
        super();
        this.configurationService = configurationService;
        this.contextService = contextService;
        this._onAutoSaveConfigurationChange = this._register(( (new Emitter())));
        this.onAutoSaveConfigurationChange = this._onAutoSaveConfigurationChange.event;
        this._onFilesAssociationChange = this._register(( (new Emitter())));
        this.onFilesAssociationChange = this._onFilesAssociationChange.event;
        this.autoSaveAfterShortDelayContext = AutoSaveAfterShortDelayContext.bindTo(contextKeyService);
        const configuration = configurationService.getValue();
        this.currentFilesAssociationConfig = configuration?.files?.associations;
        this.currentHotExitConfig = configuration?.files?.hotExit || HotExitConfiguration.ON_EXIT;
        this.onFilesConfigurationChange(configuration);
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('files')) {
                this.onFilesConfigurationChange(this.configurationService.getValue());
            }
        }));
    }
    onFilesConfigurationChange(configuration) {
        const autoSaveMode = configuration?.files?.autoSave || FilesConfigurationService.DEFAULT_AUTO_SAVE_MODE;
        switch (autoSaveMode) {
            case AutoSaveConfiguration.AFTER_DELAY:
                this.configuredAutoSaveDelay = configuration?.files?.autoSaveDelay;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = false;
                break;
            case AutoSaveConfiguration.ON_FOCUS_CHANGE:
                this.configuredAutoSaveDelay = undefined;
                this.configuredAutoSaveOnFocusChange = true;
                this.configuredAutoSaveOnWindowChange = false;
                break;
            case AutoSaveConfiguration.ON_WINDOW_CHANGE:
                this.configuredAutoSaveDelay = undefined;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = true;
                break;
            default:
                this.configuredAutoSaveDelay = undefined;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = false;
                break;
        }
        this.autoSaveAfterShortDelayContext.set(this.getAutoSaveMode() === 1 );
        this._onAutoSaveConfigurationChange.fire(this.getAutoSaveConfiguration());
        const filesAssociation = configuration?.files?.associations;
        if (!equals(this.currentFilesAssociationConfig, filesAssociation)) {
            this.currentFilesAssociationConfig = filesAssociation;
            this._onFilesAssociationChange.fire();
        }
        const hotExitMode = configuration?.files?.hotExit;
        if (hotExitMode === HotExitConfiguration.OFF || hotExitMode === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {
            this.currentHotExitConfig = hotExitMode;
        }
        else {
            this.currentHotExitConfig = HotExitConfiguration.ON_EXIT;
        }
    }
    getAutoSaveMode() {
        if (this.configuredAutoSaveOnFocusChange) {
            return 3 ;
        }
        if (this.configuredAutoSaveOnWindowChange) {
            return 4 ;
        }
        if (typeof this.configuredAutoSaveDelay === 'number' && this.configuredAutoSaveDelay >= 0) {
            return this.configuredAutoSaveDelay <= 1000 ? 1  : 2 ;
        }
        return 0 ;
    }
    getAutoSaveConfiguration() {
        return {
            autoSaveDelay: typeof this.configuredAutoSaveDelay === 'number' && this.configuredAutoSaveDelay >= 0 ? this.configuredAutoSaveDelay : undefined,
            autoSaveFocusChange: !!this.configuredAutoSaveOnFocusChange,
            autoSaveApplicationChange: !!this.configuredAutoSaveOnWindowChange
        };
    }
    async toggleAutoSave() {
        const currentSetting = this.configurationService.getValue('files.autoSave');
        let newAutoSaveValue;
        if ([AutoSaveConfiguration.AFTER_DELAY, AutoSaveConfiguration.ON_FOCUS_CHANGE, AutoSaveConfiguration.ON_WINDOW_CHANGE].some(setting => setting === currentSetting)) {
            newAutoSaveValue = AutoSaveConfiguration.OFF;
        }
        else {
            newAutoSaveValue = AutoSaveConfiguration.AFTER_DELAY;
        }
        return this.configurationService.updateValue('files.autoSave', newAutoSaveValue);
    }
    get isHotExitEnabled() {
        if (this.contextService.getWorkspace().transient) {
            return false;
        }
        return this.currentHotExitConfig !== HotExitConfiguration.OFF;
    }
    get hotExitConfiguration() {
        return this.currentHotExitConfig;
    }
    preventSaveConflicts(resource, language) {
        return this.configurationService.getValue('files.saveConflictResolution', { resource, overrideIdentifier: language }) !== 'overwriteFileOnDisk';
    }
};
FilesConfigurationService.DEFAULT_AUTO_SAVE_MODE = isWeb ? AutoSaveConfiguration.AFTER_DELAY : AutoSaveConfiguration.OFF;
FilesConfigurationService = ( (__decorate([
    ( (__param(0, IContextKeyService))),
    ( (__param(1, IConfigurationService))),
    ( (__param(2, IWorkspaceContextService)))
], FilesConfigurationService)));
const IUntitledTextEditorService = ( (createDecorator('untitledTextEditorService')));
const IElevatedFileService = ( (createDecorator('elevatedFileService')));
class BrowserElevatedFileService {
    isSupported(resource) {
        return false;
    }
    async writeFileElevated(resource, value, options) {
        throw new Error('Unsupported');
    }
}
const IDecorationsService = ( (createDecorator('IFileDecorationsService')));
function unsupported() {
    throw new Error('unsupported');
}
registerSingleton(ILoggerService, NullLoggerService, 0 );
registerSingleton(IEditorService, class EditorService {
    constructor() {
        this._serviceBrand = undefined;
        this.onDidActiveEditorChange = Event.None;
        this.onDidVisibleEditorsChange = Event.None;
        this.onDidEditorsChange = Event.None;
        this.onDidCloseEditor = Event.None;
        this.activeEditorPane = undefined;
        this.activeEditor = undefined;
        this.activeTextEditorLanguageId = undefined;
        this.visibleEditorPanes = [];
        this.visibleEditors = [];
        this.visibleTextEditorControls = [];
        this.editors = [];
        this.count = 0;
        this.getEditors = () => [];
        this.openEditor = unsupported;
        this.openEditors = unsupported;
        this.replaceEditors = async () => { };
        this.isOpened = () => false;
        this.isVisible = () => false;
        this.closeEditor = async () => { };
        this.closeEditors = async () => { };
        this.findEditors = () => [];
        this.save = async () => false;
        this.saveAll = async () => false;
        this.revert = async () => false;
        this.revertAll = async () => false;
    }
    get activeTextEditorControl() { return StandaloneServices.get(ICodeEditorService).getFocusedCodeEditor() ?? undefined; }
}, 0 );
registerSingleton(IPaneCompositePartService, class PaneCompositePartService {
    constructor() {
        this._serviceBrand = undefined;
        this.onDidPaneCompositeOpen = Event.None;
        this.onDidPaneCompositeClose = Event.None;
        this.openPaneComposite = async () => undefined;
        this.getActivePaneComposite = () => undefined;
        this.getPaneComposite = () => undefined;
        this.getPaneComposites = () => [];
        this.getPinnedPaneCompositeIds = () => [];
        this.getVisiblePaneCompositeIds = () => [];
        this.getProgressIndicator = () => undefined;
        this.hideActivePaneComposite = () => { };
        this.getLastActivePaneCompositeId = unsupported;
        this.showActivity = unsupported;
    }
}, 0 );
registerSingleton(IUriIdentityService, class UriIdentityService {
    constructor() {
        this._serviceBrand = undefined;
        this.extUri = new ExtUri(() => false);
    }
    asCanonicalUri(uri) {
        return uri;
    }
}, 0 );
const onDidSave = new Emitter();
class TextFileEditorModelManager {
    constructor() {
        this.onDidCreate = Event.None;
        this.onDidResolve = Event.None;
        this.onDidChangeDirty = Event.None;
        this.onDidChangeReadonly = Event.None;
        this.onDidRemove = Event.None;
        this.onDidChangeOrphaned = Event.None;
        this.onDidChangeEncoding = Event.None;
        this.onDidSaveError = Event.None;
        this.onDidSave = onDidSave.event;
        this.onDidRevert = Event.None;
        this.models = [];
        this.saveErrorHandler = {
            onSaveError: unsupported
        };
        this.get = () => undefined;
        this.resolve = unsupported;
        this.addSaveParticipant = unsupported;
        this.runSaveParticipants = unsupported;
    }
    canDispose() {
        return true;
    }
}
registerSingleton(ITextFileService, class TextFileService {
    constructor() {
        this._serviceBrand = undefined;
        this.files = new TextFileEditorModelManager();
        this.isDirty = () => false;
        this.save = unsupported;
        this.saveAs = unsupported;
        this.revert = unsupported;
        this.read = unsupported;
        this.readStream = unsupported;
        this.write = unsupported;
        this.create = unsupported;
        this.getEncodedReadable = unsupported;
        this.getDecodedStream = unsupported;
    }
    get untitled() { return unsupported(); }
    get encoding() { return unsupported(); }
    dispose() {
    }
}, 0 );
registerSingleton(IFileService, class FileService {
    constructor() {
        this._serviceBrand = undefined;
        this.onDidChangeFileSystemProviderRegistrations = Event.None;
        this.onDidChangeFileSystemProviderCapabilities = Event.None;
        this.onWillActivateFileSystemProvider = Event.None;
        this.registerProvider = unsupported;
        this.getProvider = function () {
            return undefined;
        };
        this.activateProvider = async () => { };
        this.canHandleResource = async () => false;
        this.hasProvider = () => false;
        this.hasCapability = () => false;
        this.listCapabilities = () => [];
        this.onDidFilesChange = Event.None;
        this.onDidRunOperation = Event.None;
        this.resolve = unsupported;
        this.resolveAll = unsupported;
        this.stat = unsupported;
        this.exists = async () => false;
        this.readFile = unsupported;
        this.readFileStream = unsupported;
        this.writeFile = unsupported;
        this.move = unsupported;
        this.canMove = unsupported;
        this.copy = unsupported;
        this.canCopy = unsupported;
        this.cloneFile = unsupported;
        this.createFile = unsupported;
        this.canCreateFile = unsupported;
        this.createFolder = unsupported;
        this.del = unsupported;
        this.canDelete = unsupported;
        this.onDidWatchError = Event.None;
        this.watch = unsupported;
    }
    dispose() {
    }
}, 0 );
class EmptyEditorGroup {
    constructor() {
        this.onDidModelChange = Event.None;
        this.onWillDispose = Event.None;
        this.onDidActiveEditorChange = Event.None;
        this.onWillCloseEditor = Event.None;
        this.onDidCloseEditor = Event.None;
        this.onWillMoveEditor = Event.None;
        this.onWillOpenEditor = Event.None;
        this.id = 0;
        this.index = 0;
        this.label = 'main';
        this.ariaLabel = 'main';
        this.activeEditorPane = undefined;
        this.activeEditor = null;
        this.previewEditor = null;
        this.count = 0;
        this.isEmpty = false;
        this.isLocked = false;
        this.stickyCount = 0;
        this.editors = [];
        this.getEditors = unsupported;
        this.findEditors = unsupported;
        this.getEditorByIndex = unsupported;
        this.getIndexOfEditor = unsupported;
        this.openEditor = unsupported;
        this.openEditors = unsupported;
        this.isPinned = unsupported;
        this.isSticky = unsupported;
        this.isActive = unsupported;
        this.contains = unsupported;
        this.moveEditor = unsupported;
        this.moveEditors = unsupported;
        this.copyEditor = unsupported;
        this.copyEditors = unsupported;
        this.closeEditor = unsupported;
        this.closeEditors = unsupported;
        this.closeAllEditors = unsupported;
        this.replaceEditors = unsupported;
        this.pinEditor = unsupported;
        this.stickEditor = unsupported;
        this.unstickEditor = unsupported;
        this.lock = unsupported;
        this.isFirst = () => true;
        this.isLast = () => true;
    }
    get scopedContextKeyService() { return StandaloneServices.get(IContextKeyService); }
    focus() {
    }
}
registerSingleton(IEditorGroupsService, class EditorGroupsService {
    constructor() {
        this._serviceBrand = undefined;
        this.onDidChangeActiveGroup = Event.None;
        this.onDidAddGroup = Event.None;
        this.onDidRemoveGroup = Event.None;
        this.onDidMoveGroup = Event.None;
        this.onDidActivateGroup = Event.None;
        this.onDidLayout = Event.None;
        this.onDidScroll = Event.None;
        this.onDidChangeGroupIndex = Event.None;
        this.onDidChangeGroupLocked = Event.None;
        this.activeGroup = new EmptyEditorGroup();
        this.groups = [];
        this.count = 0;
        this.orientation = 0 ;
        this.isReady = false;
        this.whenReady = Promise.resolve();
        this.whenRestored = Promise.resolve();
        this.hasRestorableState = false;
        this.getGroups = () => [];
        this.getGroup = () => undefined;
        this.activateGroup = unsupported;
        this.getSize = unsupported;
        this.setSize = unsupported;
        this.arrangeGroups = unsupported;
        this.applyLayout = unsupported;
        this.centerLayout = unsupported;
        this.isLayoutCentered = () => false;
        this.setGroupOrientation = unsupported;
        this.findGroup = () => undefined;
        this.addGroup = unsupported;
        this.removeGroup = unsupported;
        this.moveGroup = unsupported;
        this.mergeGroup = unsupported;
        this.mergeAllGroups = unsupported;
        this.copyGroup = unsupported;
        this.onDidChangeEditorPartOptions = Event.None;
        this.enforcePartOptions = unsupported;
    }
    get contentDimension() { return unsupported(); }
    get sideGroup() { return unsupported(); }
    get partOptions() { return unsupported(); }
}, 0 );
class WorkbenchEnvironmentService {
    constructor() {
        this._serviceBrand = undefined;
        this.skipReleaseNotes = true;
        this.skipWelcome = true;
        this.disableWorkspaceTrust = true;
        this.debugRenderer = false;
        this.userRoamingDataHome = ( URI.from({ scheme: 'user', path: '/userRoamingDataHome' }));
        this.keyboardLayoutResource = ( URI.from({ scheme: 'user', path: '/keyboardLayout.json' }));
        this.snippetsHome = ( URI.from({ scheme: 'user', path: '/snippets' }));
        this.untitledWorkspacesHome = ( URI.from({ scheme: 'user', path: '/untitledWorkspacesHome' }));
        this.sync = undefined;
        this.debugExtensionHost = {
            port: null,
            break: false
        };
        this.isExtensionDevelopment = false;
        this.disableExtensions = false;
        this.logsPath = '';
        this.verbose = false;
        this.isBuilt = true;
        this.disableTelemetry = false;
    }
    get windowLogsPath() { return unsupported(); }
    get extHostTelemetryLogFile() { return unsupported(); }
    get logFile() { return unsupported(); }
    get extHostLogsPath() { return unsupported(); }
    get webviewExternalEndpoint() { return unsupported(); }
    get argvResource() { return unsupported(); }
    get globalStorageHome() { return unsupported(); }
    get workspaceStorageHome() { return unsupported(); }
    get localHistoryHome() { return unsupported(); }
    get cacheHome() { return unsupported(); }
    get userDataSyncHome() { return unsupported(); }
    get userDataSyncLogResource() { return unsupported(); }
    get telemetryLogResource() { return unsupported(); }
    get serviceMachineIdResource() { return unsupported(); }
    get stateResource() { return unsupported(); }
    get editSessionsLogResource() { return unsupported(); }
}
registerSingleton(IWorkbenchEnvironmentService, WorkbenchEnvironmentService, 0 );
registerSingleton(IEnvironmentService, WorkbenchEnvironmentService, 0 );
registerSingleton(IBrowserWorkbenchEnvironmentService, WorkbenchEnvironmentService, 0 );
registerSingleton(IWorkingCopyFileService, class WorkingCopyFileService {
    constructor() {
        this._serviceBrand = undefined;
        this.onWillRunWorkingCopyFileOperation = Event.None;
        this.onDidFailWorkingCopyFileOperation = Event.None;
        this.onDidRunWorkingCopyFileOperation = Event.None;
        this.addFileOperationParticipant = unsupported;
        this.hasSaveParticipants = false;
        this.addSaveParticipant = unsupported;
        this.runSaveParticipants = unsupported;
        this.create = unsupported;
        this.createFolder = unsupported;
        this.move = unsupported;
        this.copy = unsupported;
        this.delete = unsupported;
        this.registerWorkingCopyProvider = unsupported;
        this.getDirty = unsupported;
    }
}, 0 );
registerSingleton(IPathService, BrowserPathService, 0 );
registerSingleton(IProgressService, class ProgressService {
    constructor() {
        this._serviceBrand = undefined;
    }
    withProgress(options, task, onDidCancel) {
        const { window } = Services.get();
        if (window?.withProgress != null) {
            return window.withProgress(options, task, onDidCancel);
        }
        return task({ report: () => { } });
    }
}, 0 );
registerSingleton(IProductService, class ProductService {
    constructor() {
        this._serviceBrand = undefined;
        this.version = "1.76.0";
        this.nameShort = 'Code - OSS Dev';
        this.nameLong = 'Code - OSS Dev';
        this.applicationName = 'code-oss';
        this.dataFolderName = '.vscode-oss';
        this.urlProtocol = 'code-oss';
        this.reportIssueUrl = 'https://github.com/microsoft/vscode/issues/new';
        this.licenseName = 'MIT';
        this.licenseUrl = 'https://github.com/microsoft/vscode/blob/main/LICENSE.txt';
        this.serverApplicationName = 'code-server-oss';
    }
}, 0 );
registerSingleton(ILanguageStatusService, class LanguageStatusServiceImpl {
    constructor() {
        this._provider = new LanguageFeatureRegistry();
        this.onDidChange = this._provider.onDidChange;
    }
    addStatus(status) {
        return this._provider.register(status.selector, status);
    }
    getLanguageStatus(model) {
        return this._provider.ordered(model).sort((a, b) => {
            let res = b.severity - a.severity;
            if (res === 0) {
                res = compare(a.source, b.source);
            }
            if (res === 0) {
                res = compare(a.id, b.id);
            }
            return res;
        });
    }
}, 0 );
const focusTracker = trackFocus(window);
const onVisibilityChange = new DomEmitter(window.document, 'visibilitychange');
const onDidChangeFocus = Event.latch(Event.any(( Event.map(focusTracker.onDidFocus, () => document.hasFocus())), ( Event.map(focusTracker.onDidBlur, () => document.hasFocus())), ( Event.map(onVisibilityChange.event, () => document.hasFocus()))));
registerSingleton(IHostService, class HostService {
    constructor() {
        this.onDidChangeFocus = onDidChangeFocus;
        this.openWindow = unsupported;
        this.restart = unsupported;
        this.reload = unsupported;
        this.close = unsupported;
    }
    get hasFocus() {
        return document.hasFocus();
    }
    async hadLastFocus() {
        return true;
    }
    async focus() {
        window.focus();
    }
    async toggleFullScreen() {
        if (document.fullscreenEnabled) {
            await document.body.requestFullscreen();
        }
        else {
            await document.exitFullscreen();
        }
    }
}, 0 );
registerSingleton(ILifecycleService, class LifecycleService {
    constructor() {
        this.startupKind = 1 ;
        this.phase = 2 ;
        this.onBeforeShutdown = Event.None;
        this.onShutdownVeto = Event.None;
        this.onBeforeShutdownError = Event.None;
        this.onWillShutdown = Event.None;
        this.onDidShutdown = Event.None;
        this.shutdown = unsupported;
    }
    async when() {
    }
}, 0 );
registerSingleton(ILanguageDetectionService, class LanguageDetectionService {
    isEnabledForLanguage() {
        return false;
    }
    async detectLanguage() {
        return undefined;
    }
}, 0 );
registerSingleton(IExtensionService, NullExtensionService, 0 );
registerSingleton(IKeyboardLayoutService, class KeyboardLayoutService {
    constructor() {
        this.onDidChangeKeyboardLayout = Event.None;
        this.getRawKeyboardMapping = () => null;
        this.getCurrentKeyboardLayout = () => null;
        this.getAllKeyboardLayouts = () => [];
        this.getKeyboardMapper = () => new FallbackKeyboardMapper(false, OS);
        this.validateCurrentKeyboardMapping = () => { };
    }
}, 0 );
registerSingleton(IUserDataInitializationService, class NullUserDataInitializationService {
    async requiresInitialization() {
        return false;
    }
    async whenInitializationFinished() { }
    async initializeRequiredResources() { }
    async initializeInstalledExtensions() { }
    async initializeOtherResources() { }
}, 0 );
registerSingleton(IHostColorSchemeService, BrowserHostColorSchemeService, 0 );
registerSingleton(IPreferencesService, class PreferencesService {
    constructor() {
        this.userSettingsResource = profile.settingsResource;
        this.workspaceSettingsResource = null;
        this.getFolderSettingsResource = unsupported;
        this.createPreferencesEditorModel = unsupported;
        this.resolveModel = unsupported;
        this.createSettings2EditorModel = unsupported;
        this.openRawDefaultSettings = unsupported;
        this.openSettings = unsupported;
        this.openUserSettings = unsupported;
        this.openRemoteSettings = unsupported;
        this.openWorkspaceSettings = unsupported;
        this.openFolderSettings = unsupported;
        this.openGlobalKeybindingSettings = unsupported;
        this.openDefaultKeybindingsFile = unsupported;
        this.getEditableSettingsURI = unsupported;
        this.createSplitJsonEditorInput = unsupported;
        this.openApplicationSettings = unsupported;
        this.openLanguageSpecificSettings = unsupported;
    }
}, 0 );
registerSingleton(ITextMateTokenizationService, class NullTextMateService {
    constructor() {
        this.onDidEncounterLanguage = Event.None;
        this.createGrammar = unsupported;
        this.startDebugMode = unsupported;
    }
}, 0 );
const profile = {
    id: 'default',
    isDefault: true,
    name: 'default',
    location: ( URI.from({ scheme: 'user', path: '/profile.json' })),
    get globalStorageHome() { return unsupported(); },
    settingsResource: ( URI.from({ scheme: 'user', path: '/settings.json' })),
    keybindingsResource: ( URI.from({ scheme: 'user', path: '/keybindings.json' })),
    get tasksResource() { return unsupported(); },
    get snippetsHome() { return ( URI.from({ scheme: 'user', path: '/snippets' })); },
    get extensionsResource() { return unsupported(); }
};
registerSingleton(IUserDataProfilesService, class UserDataProfilesService {
    constructor() {
        this.onDidResetWorkspaces = Event.None;
        this.isEnabled = () => false;
        this.createNamedProfile = unsupported;
        this.createTransientProfile = unsupported;
        this.resetWorkspaces = unsupported;
        this.cleanUp = unsupported;
        this.cleanUpTransientProfiles = unsupported;
        this.defaultProfile = profile;
        this.onDidChangeProfiles = Event.None;
        this.profiles = [profile];
        this.createProfile = unsupported;
        this.updateProfile = unsupported;
        this.setProfileForWorkspace = unsupported;
        this.getProfile = () => profile;
        this.removeProfile = unsupported;
    }
    get profilesHome() { return unsupported(); }
}, 0 );
let InjectedUserDataProfileService = class InjectedUserDataProfileService extends UserDataProfileService {
    constructor(userDataProfilesService) {
        super(profile, userDataProfilesService);
    }
};
InjectedUserDataProfileService = ( __decorate([
    ( __param(0, IUserDataProfilesService))
], InjectedUserDataProfileService));
registerSingleton(IUserDataProfileService, InjectedUserDataProfileService, 0 );
registerSingleton(IPolicyService, class PolicyService {
    constructor() {
        this.updatePolicyDefinitions = unsupported;
        this.onDidChange = Event.None;
        this.registerPolicyDefinitions = unsupported;
        this.getPolicyValue = () => undefined;
        this.serialize = () => undefined;
    }
}, 0 );
registerSingleton(ISnippetsService, class SnippetsService {
    constructor() {
        this.getSnippetFiles = unsupported;
        this.isEnabled = unsupported;
        this.updateEnablement = unsupported;
        this.updateUsageTimestamp = unsupported;
        this.getSnippets = async () => [];
        this.getSnippetsSync = unsupported;
    }
}, 0 );
const debugModel = {
    getSession: () => undefined,
    getSessions: () => [],
    getBreakpoints: () => [],
    areBreakpointsActivated: () => false,
    getFunctionBreakpoints: () => [],
    getDataBreakpoints: () => [],
    getExceptionBreakpoints: () => [],
    getExceptionBreakpointsForSession: () => [],
    getInstructionBreakpoints: () => [],
    getWatchExpressions: () => [],
    onDidChangeBreakpoints: Event.None,
    onDidChangeCallStack: Event.None,
    onDidChangeWatchExpressions: Event.None,
    fetchCallstack: unsupported,
    getId: unsupported
};
class FakeViewModel {
    constructor() {
        this.getId = unsupported;
        this.focusedSession = undefined;
        this.focusedThread = undefined;
        this.focusedStackFrame = undefined;
        this.getSelectedExpression = unsupported;
        this.setSelectedExpression = unsupported;
        this.updateViews = unsupported;
        this.isMultiSessionView = unsupported;
        this.onDidFocusSession = Event.None;
        this.onDidFocusStackFrame = Event.None;
        this.onDidSelectExpression = Event.None;
        this.onDidEvaluateLazyExpression = Event.None;
        this.onWillUpdateViews = Event.None;
        this.evaluateLazyExpression = unsupported;
    }
}
class FakeAdapterManager {
    constructor() {
        this.onDidRegisterDebugger = Event.None;
        this.hasEnabledDebuggers = () => false;
        this.getDebugAdapterDescriptor = unsupported;
        this.getDebuggerLabel = unsupported;
        this.someDebuggerInterestedInLanguage = () => false;
        this.getDebugger = () => undefined;
        this.activateDebuggers = unsupported;
        this.registerDebugAdapterFactory = () => new Disposable(() => { });
        this.createDebugAdapter = unsupported;
        this.registerDebugAdapterDescriptorFactory = unsupported;
        this.unregisterDebugAdapterDescriptorFactory = unsupported;
        this.substituteVariables = unsupported;
        this.runInTerminal = unsupported;
        this.getEnabledDebugger = unsupported;
        this.guessDebugger = unsupported;
        this.onDidDebuggersExtPointRead = Event.None;
    }
}
registerSingleton(IDebugService, class DebugService {
    constructor() {
        this.onDidChangeState = Event.None;
        this.onDidNewSession = Event.None;
        this.onWillNewSession = Event.None;
        this.onDidEndSession = Event.None;
        this.getConfigurationManager = unsupported;
        this.getAdapterManager = () => new FakeAdapterManager();
        this.focusStackFrame = unsupported;
        this.canSetBreakpointsIn = unsupported;
        this.addBreakpoints = unsupported;
        this.updateBreakpoints = unsupported;
        this.enableOrDisableBreakpoints = unsupported;
        this.setBreakpointsActivated = unsupported;
        this.removeBreakpoints = unsupported;
        this.addFunctionBreakpoint = unsupported;
        this.updateFunctionBreakpoint = unsupported;
        this.removeFunctionBreakpoints = unsupported;
        this.addDataBreakpoint = unsupported;
        this.removeDataBreakpoints = unsupported;
        this.addInstructionBreakpoint = unsupported;
        this.removeInstructionBreakpoints = unsupported;
        this.setExceptionBreakpointCondition = unsupported;
        this.setExceptionBreakpointsForSession = unsupported;
        this.sendAllBreakpoints = unsupported;
        this.addWatchExpression = unsupported;
        this.renameWatchExpression = unsupported;
        this.moveWatchExpression = unsupported;
        this.removeWatchExpressions = unsupported;
        this.startDebugging = unsupported;
        this.restartSession = unsupported;
        this.stopSession = unsupported;
        this.sourceIsNotAvailable = unsupported;
        this.getModel = () => debugModel;
        this.getViewModel = () => new FakeViewModel();
        this.runTo = unsupported;
    }
    get state() { return unsupported(); }
}, 0 );
registerSingleton(IWorkspaceTrustRequestService, class WorkspaceTrustRequestService {
    constructor() {
        this.onDidInitiateOpenFilesTrustRequest = Event.None;
        this.onDidInitiateWorkspaceTrustRequest = Event.None;
        this.onDidInitiateWorkspaceTrustRequestOnStartup = Event.None;
        this.completeOpenFilesTrustRequest = unsupported;
        this.requestOpenFilesTrust = unsupported;
        this.cancelWorkspaceTrustRequest = unsupported;
        this.completeWorkspaceTrustRequest = unsupported;
        this.requestWorkspaceTrust = async () => true;
        this.requestWorkspaceTrustOnStartup = () => null;
    }
}, 0 );
registerSingleton(IActivityService, class ActivityService {
    constructor() {
        this.showViewContainerActivity = unsupported;
        this.showViewActivity = unsupported;
        this.showAccountsActivity = unsupported;
        this.showGlobalActivity = unsupported;
    }
}, 0 );
registerSingleton(IExtensionHostDebugService, class ExtensionHostDebugService {
    constructor() {
        this.reload = unsupported;
        this.onReload = Event.None;
        this.close = unsupported;
        this.onClose = Event.None;
        this.attachSession = unsupported;
        this.onAttachSession = Event.None;
        this.terminateSession = unsupported;
        this.onTerminateSession = Event.None;
        this.openExtensionDevelopmentHostWindow = unsupported;
    }
}, 0 );
registerSingleton(IViewsService, class ViewsService {
    constructor() {
        this.onDidChangeViewContainerVisibility = Event.None;
        this.isViewContainerVisible = () => false;
        this.openViewContainer = unsupported;
        this.closeViewContainer = unsupported;
        this.getVisibleViewContainer = unsupported;
        this.getActiveViewPaneContainerWithId = () => null;
        this.onDidChangeViewVisibility = Event.None;
        this.isViewVisible = () => false;
        this.openView = async () => null;
        this.closeView = unsupported;
        this.getActiveViewWithId = () => null;
        this.getViewWithId = () => null;
        this.getViewProgressIndicator = () => undefined;
    }
}, 0 );
registerSingleton(IViewDescriptorService, class ViewDescriptorService {
    constructor() {
        this.viewContainers = [];
        this.onDidChangeViewContainers = Event.None;
        this.getDefaultViewContainer = () => undefined;
        this.getViewContainerById = () => null;
        this.isViewContainerRemovedPermanently = unsupported;
        this.getDefaultViewContainerLocation = () => null;
        this.getViewContainerLocation = () => null;
        this.getViewContainersByLocation = unsupported;
        this.getViewContainerModel = unsupported;
        this.onDidChangeContainerLocation = Event.None;
        this.moveViewContainerToLocation = unsupported;
        this.getViewContainerBadgeEnablementState = unsupported;
        this.setViewContainerBadgeEnablementState = unsupported;
        this.getViewDescriptorById = () => null;
        this.getViewContainerByViewId = () => null;
        this.getDefaultContainerById = () => null;
        this.getViewLocationById = () => null;
        this.onDidChangeContainer = Event.None;
        this.moveViewsToContainer = unsupported;
        this.onDidChangeLocation = Event.None;
        this.moveViewToLocation = () => null;
        this.reset = () => null;
    }
}, 0 );
registerSingleton(IHistoryService, class HistoryService {
    constructor() {
        this.goForward = unsupported;
        this.goBack = unsupported;
        this.goPrevious = unsupported;
        this.goLast = unsupported;
        this.reopenLastClosedEditor = unsupported;
        this.getHistory = unsupported;
        this.removeFromHistory = unsupported;
        this.getLastActiveWorkspaceRoot = () => undefined;
        this.getLastActiveFile = () => undefined;
        this.openNextRecentlyUsedEditor = unsupported;
        this.openPreviouslyUsedEditor = unsupported;
        this.clear = unsupported;
        this.clearRecentlyOpened = unsupported;
    }
}, 0 );
registerSingleton(ITaskService, class TaskService {
    constructor() {
        this.onDidStateChange = Event.None;
        this.supportsMultipleTaskExecutions = false;
        this.configureAction = unsupported;
        this.run = unsupported;
        this.inTerminal = () => false;
        this.getActiveTasks = async () => [];
        this.getBusyTasks = unsupported;
        this.terminate = unsupported;
        this.tasks = unsupported;
        this.taskTypes = unsupported;
        this.getWorkspaceTasks = unsupported;
        this.getSavedTasks = unsupported;
        this.removeRecentlyUsedTask = unsupported;
        this.getTask = unsupported;
        this.tryResolveTask = unsupported;
        this.createSorter = unsupported;
        this.getTaskDescription = unsupported;
        this.customize = unsupported;
        this.openConfig = unsupported;
        this.registerTaskProvider = unsupported;
        this.registerTaskSystem = unsupported;
        this.onDidChangeTaskSystemInfo = Event.None;
        this.hasTaskSystemInfo = false;
        this.registerSupportedExecutions = unsupported;
        this.extensionCallbackTaskComplete = unsupported;
    }
}, 0 );
registerSingleton(IURITransformerService, class InjectedURITransformerService extends URITransformerService {
    constructor() {
        super(null);
    }
}, 0 );
registerSingleton(IConfigurationResolverService, class ConfigurationResolverService {
    constructor() {
        this.resolveWithEnvironment = unsupported;
        this.resolveAsync = unsupported;
        this.resolveAnyAsync = unsupported;
        this.resolveAnyMap = unsupported;
        this.resolveWithInteractionReplace = unsupported;
        this.resolveWithInteraction = unsupported;
        this.contributeVariable = unsupported;
    }
}, 0 );
class SocketFactory {
    constructor() {
        this.connect = unsupported;
    }
}
registerSingleton(IRemoteAgentService, class RemoteAgentService {
    constructor() {
        this.socketFactory = new SocketFactory();
        this.getConnection = () => null;
        this.getEnvironment = async () => null;
        this.getRawEnvironment = async () => null;
        this.getExtensionHostExitInfo = async () => null;
        this.getRoundTripTime = async () => undefined;
        this.whenExtensionsReady = async () => undefined;
        this.scanExtensions = async () => [];
        this.scanSingleExtension = async () => null;
        this.getDiagnosticInfo = async () => undefined;
        this.updateTelemetryLevel = async () => undefined;
        this.logTelemetry = async () => undefined;
        this.flushTelemetry = async () => undefined;
    }
}, 0 );
registerSingleton(ICustomEndpointTelemetryService, NullEndpointTelemetryService, 0 );
registerSingleton(ISearchService, SearchService, 0 );
registerSingleton(IRequestService, class RequestService {
    constructor() {
        this.request = unsupported;
        this.resolveProxy = async () => undefined;
    }
}, 0 );
registerSingleton(IEditSessionIdentityService, class EditSessionIdentityService {
    constructor() {
        this.registerEditSessionIdentityProvider = unsupported;
        this.getEditSessionIdentifier = unsupported;
        this.provideEditSessionIdentityMatch = unsupported;
        this.addEditSessionIdentityCreateParticipant = unsupported;
        this.onWillCreateEditSessionIdentity = unsupported;
    }
}, 0 );
registerSingleton(IWorkspaceEditingService, class WorkspaceEditingService {
    constructor() {
        this.addFolders = unsupported;
        this.removeFolders = unsupported;
        this.updateFolders = unsupported;
        this.enterWorkspace = unsupported;
        this.createAndEnterWorkspace = unsupported;
        this.saveAndEnterWorkspace = unsupported;
        this.copyWorkspaceSettings = unsupported;
        this.pickNewWorkspacePath = unsupported;
    }
}, 0 );
registerSingleton(ITimerService, class TimerService {
    constructor() {
        this.whenReady = unsupported;
        this.setPerformanceMarks = () => { };
        this.getPerformanceMarks = unsupported;
        this.getDuration = unsupported;
    }
    get perfBaseline() { return unsupported(); }
    get startupMetrics() { return unsupported(); }
}, 0 );
registerSingleton(IExtensionsWorkbenchService, class ExtensionsWorkbenchService {
    constructor() {
        this.onChange = Event.None;
        this.onReset = Event.None;
        this.preferPreReleases = false;
        this.local = [];
        this.installed = [];
        this.outdated = [];
        this.queryLocal = unsupported;
        this.queryGallery = unsupported;
        this.getExtensions = unsupported;
        this.canInstall = unsupported;
        this.install = unsupported;
        this.installInServer = unsupported;
        this.uninstall = unsupported;
        this.installVersion = unsupported;
        this.reinstall = unsupported;
        this.canSetLanguage = unsupported;
        this.setLanguage = unsupported;
        this.setEnablement = unsupported;
        this.pinExtension = unsupported;
        this.open = unsupported;
        this.checkForUpdates = unsupported;
        this.getExtensionStatus = unsupported;
        this.isExtensionIgnoredToSync = unsupported;
        this.toggleExtensionIgnoredToSync = unsupported;
    }
}, 0 );
registerSingleton(IWorkbenchExtensionEnablementService, class WorkbenchExtensionEnablementService {
    constructor() {
        this.onEnablementChanged = Event.None;
        this.getEnablementState = unsupported;
        this.getEnablementStates = unsupported;
        this.getDependenciesEnablementStates = unsupported;
        this.canChangeEnablement = unsupported;
        this.canChangeWorkspaceEnablement = unsupported;
        this.isEnabled = unsupported;
        this.isEnabledEnablementState = unsupported;
        this.isDisabledGlobally = unsupported;
        this.setEnablement = unsupported;
        this.updateExtensionsEnablementsWhenWorkspaceTrustChanges = unsupported;
    }
}, 0 );
registerSingleton(ITunnelService, class TunnelService {
    constructor() {
        this.tunnels = Promise.resolve([]);
        this.canChangePrivacy = false;
        this.privacyOptions = [];
        this.onTunnelOpened = Event.None;
        this.onTunnelClosed = Event.None;
        this.canElevate = false;
        this.hasTunnelProvider = false;
        this.onAddedTunnelProvider = Event.None;
        this.canTunnel = () => false;
        this.openTunnel = unsupported;
        this.getExistingTunnel = async () => undefined;
        this.setEnvironmentTunnel = unsupported;
        this.closeTunnel = unsupported;
        this.setTunnelProvider = unsupported;
        this.setTunnelFeatures = unsupported;
        this.isPortPrivileged = () => false;
    }
}, 0 );
registerSingleton(IWorkingCopyBackupService, class WorkingCopyBackupService {
    constructor() {
        this.hasBackups = async () => false;
        this.hasBackupSync = () => false;
        this.getBackups = async () => [];
        this.resolve = async () => undefined;
        this.backup = unsupported;
        this.discardBackup = unsupported;
        this.discardBackups = unsupported;
    }
}, 0 );
registerSingleton(IWorkingCopyService, class WorkingCopyService {
    constructor() {
        this.onDidRegister = Event.None;
        this.onDidUnregister = Event.None;
        this.onDidChangeDirty = Event.None;
        this.onDidChangeContent = Event.None;
        this.onDidSave = Event.None;
        this.dirtyCount = 0;
        this.dirtyWorkingCopies = [];
        this.hasDirty = false;
        this.isDirty = () => false;
        this.workingCopies = [];
        this.registerWorkingCopy = () => new Disposable(() => { });
        this.has = () => false;
        this.get = () => undefined;
        this.getAll = () => undefined;
    }
}, 0 );
registerSingleton(IFilesConfigurationService, FilesConfigurationService, 0 );
registerSingleton(IUntitledTextEditorService, class UntitledTextEditorService {
    constructor() {
        this.onDidChangeDirty = Event.None;
        this.onDidChangeEncoding = Event.None;
        this.onDidChangeLabel = Event.None;
        this.onWillDispose = Event.None;
        this.create = unsupported;
        this.get = () => undefined;
        this.getValue = () => undefined;
        this.resolve = unsupported;
    }
}, 0 );
registerSingleton(IFileDialogService, class FileDialogService {
    constructor() {
        this.defaultFilePath = unsupported;
        this.defaultFolderPath = unsupported;
        this.defaultWorkspacePath = unsupported;
        this.pickFileFolderAndOpen = unsupported;
        this.pickFileAndOpen = unsupported;
        this.pickFolderAndOpen = unsupported;
        this.pickWorkspaceAndOpen = unsupported;
        this.pickFileToSave = unsupported;
        this.showSaveDialog = unsupported;
        this.showSaveConfirm = unsupported;
        this.showOpenDialog = unsupported;
    }
}, 0 );
registerSingleton(IElevatedFileService, BrowserElevatedFileService, 0 );
registerSingleton(IDecorationsService, class DecorationsService {
    constructor() {
        this.onDidChangeDecorations = Event.None;
        this.registerDecorationsProvider = () => new Disposable(() => { });
        this.getDecoration = unsupported;
    }
}, 0 );
export { Color as $, setBreakpointId as A, FunctionBreakpoint as B, DebugAdapterExecutable as C, Disposable as D, ExtensionRuntime as E, FileSystemError as F, DebugAdapterServer as G, DebugAdapterNamedPipeServer as H, IWorkingCopyService as I, DebugAdapterInlineImplementation as J, count as K, Location as L, ProgressLocation as M, NotebookRange as N, ExtensionKind as O, Position as P, Breakpoint as Q, Range as R, Selection as S, TelemetryTrustedValue as T, CallHierarchyIncomingCall as U, CallHierarchyItem as V, CallHierarchyOutgoingCall as W, CodeAction as X, CodeActionKind as Y, CodeActionTriggerKind as Z, CodeLens as _, getRemoteName as a, InlayHintLabelPart as a$, ColorInformation as a0, ColorPresentation as a1, CommentMode as a2, CommentThreadCollapsibleState as a3, CompletionItem as a4, CompletionItemKind as a5, CompletionItemTag as a6, CompletionList as a7, CompletionTriggerKind as a8, ConfigurationTarget as a9, SemanticTokens as aA, SemanticTokensBuilder as aB, SemanticTokensEdit as aC, SemanticTokensEdits as aD, SemanticTokensLegend as aE, ShellExecution as aF, ShellQuoting as aG, SignatureHelp as aH, SignatureHelpTriggerKind as aI, SignatureInformation as aJ, SnippetString as aK, SymbolInformation as aL, SymbolKind as aM, SymbolTag as aN, TextDocumentSaveReason as aO, TextEdit as aP, TextEditorLineNumbersStyle as aQ, TextEditorSelectionChangeKind as aR, TextDocumentChangeReason as aS, ThemeColor as aT, ThemeIcon as aU, TreeItem as aV, TreeItemCollapsibleState as aW, TypeHierarchyItem as aX, ViewColumn as aY, WorkspaceEdit as aZ, InlayHint as a_, CustomExecution as aa, DecorationRangeBehavior as ab, Diagnostic as ac, DiagnosticRelatedInformation as ad, DiagnosticSeverity as ae, DiagnosticTag as af, DocumentHighlight as ag, DocumentHighlightKind as ah, DocumentLink as ai, DocumentSymbol as aj, EnvironmentVariableMutatorType as ak, EvaluatableExpression as al, InlineValueText as am, InlineValueVariableLookup as an, InlineValueEvaluatableExpression as ao, ExtensionMode as ap, FileChangeType as aq, FoldingRange as ar, FoldingRangeKind as as, Hover as at, MarkdownString as au, ParameterInformation as av, ProcessExecution as aw, QuickInputButtons as ax, RelativePattern as ay, SelectionRange as az, cleanData as b, SaveSourceRegistry as b$, InlayHintKind as b0, LinkedEditingRanges as b1, TestRunRequest as b2, TestMessage as b3, TestTag as b4, TestRunProfileKind as b5, LanguageStatusSeverity as b6, QuickPickItemKind as b7, TextDiffTabInput as b8, CustomEditorTabInput as b9, areSameExtensions as bA, pathIncludedInQuery as bB, getExcludes as bC, InlineValueContext as bD, NotebookCellData as bE, DataTransfer as bF, NotebookCellOutput as bG, CellKind as bH, NotebookCellKind as bI, DataTransferItem as bJ, NotebookCellOutputItem as bK, ILifecycleService as bL, AbstractDialogHandler as bM, isResourceEditorInput as bN, isEditorInput as bO, ILanguageDetectionService as bP, isTextEditorViewState as bQ, IKeyboardLayoutService as bR, IPreferencesService as bS, getKeyboardLayoutId as bT, IUserDataProfileService as bU, FallbackKeyboardMapper as bV, ITextMateTokenizationService as bW, getRemoteAuthority as bX, IBrowserWorkbenchEnvironmentService as bY, IHostColorSchemeService as bZ, IUserDataInitializationService as b_, NotebookEditorTabInput as ba, NotebookDiffEditorTabInput as bb, WebviewEditorTabInput as bc, TerminalEditorTabInput as bd, InputBoxValidationSeverity as be, InlineSuggestionList as bf, InlineCompletionTriggerKind as bg, InlineSuggestion as bh, DocumentDropEdit as bi, SnippetTextEdit as bj, MissingExtensionDependency as bk, TextTabInput as bl, DataBreakpoint as bm, InteractiveWindowInput as bn, TextMergeTabInput as bo, IExtensionService as bp, ISearchService as bq, IWorkspaceTrustRequestService as br, IRequestService as bs, IEditSessionIdentityService as bt, IWorkspaceEditingService as bu, ITimerService as bv, IExtensionsWorkbenchService as bw, IWorkbenchExtensionEnablementService as bx, URITransformerService as by, StandardTokenType as bz, cleanRemoteAuthority as c, IWorkingCopyBackupService as c0, IUntitledTextEditorService as c1, IFileDialogService as c2, IFilesConfigurationService as c3, IElevatedFileService as c4, IDecorationsService as c5, LanguageDetectionLanguageEventSource as c6, IViewsService as c7, ViewContainerLocationToString as c8, defaultViewIcon as c9, NumberBadge as ca, IConfigurationResolverService as cb, AbstractEditorInput as cc, EditorResourceAccessor as cd, IViewDescriptorService as ce, IHistoryService as cf, ICustomEndpointTelemetryService as cg, ITaskService as ch, IExtensionHostDebugService as ci, IActivityService as cj, Extensions as ck, SideBySideEditor as cl, ITunnelService as cm, replaceAsync as cn, VariableKind as co, VariableError as cp, getRemoteServerRootPath as cq, getTelemetryLevel as cr, TELEMETRY_SETTING_ID as d, extensionTelemetryLogChannelId as e, TELEMETRY_OLD_SETTING_ID as f, getExtensionId as g, format2 as h, isLogLevel as i, FileDecoration as j, checkProposedApiEnabled as k, ILoggerService as l, EndOfLine as m, IURITransformerService as n, TextEditorRevealType as o, extensionIdentifiersArrayToSet as p, isProposedApiEnabled as q, resultIsMatch as r, supportsTelemetry as s, toExtensionDescription as t, unsupported as u, RemoteAuthorityResolverErrorCode as v, RemoteAuthorityResolverError as w, getRemoteAuthorityPrefix as x, SourceBreakpoint as y, DebugConsoleMode as z };
