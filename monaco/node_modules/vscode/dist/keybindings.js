import { _ as __decorate, a as __param, J as IUserDataProfilesService, n as IFileService, I as IEditorService, d as IEditorGroupsService, e as IProductService, E as Emitter, t as IHostService } from './services2.js';
import { h as index, p as parse, j as getNodeType, f as flatten } from './polyfill.js';
import { q as isProposedApiEnabled, bR as IKeyboardLayoutService, bp as IExtensionService, bS as IPreferencesService, bT as getKeyboardLayoutId, bU as IUserDataProfileService, bV as FallbackKeyboardMapper } from './missing-services.js';
import { KeyCodeChord, ScanCodeChord, Keybinding } from 'monaco-editor/esm/vs/base/common/keybindings.js';
import { KeyCodeUtils, IMMUTABLE_CODE_TO_KEY_CODE, NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE, IMMUTABLE_KEY_CODE_TO_CODE } from 'monaco-editor/esm/vs/base/common/keyCodes.js';
import { E as ExtensionsRegistry } from './extensionsRegistry.js';
import { ContextKeyExpr, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { getConfiguredDefaultLocale, localize } from 'monaco-editor/esm/vs/nls.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { joinPath, dirname } from 'monaco-editor/esm/vs/base/common/resources.js';
import { MenuId, MenuRegistry, MenuItemAction, Action2, IMenuService, isIMenuItem } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { DisposableStore, Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { isFalsyOrWhitespace } from 'monaco-editor/esm/vs/base/common/strings.js';
import { EditorExtensionsRegistry } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { ICommandService, CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { isNonEmptyArray } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { AbstractKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/abstractKeybindingService.js';
import { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { addDisposableListener, EventType } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { BrowserFeatures } from 'monaco-editor/esm/vs/base/browser/canIUse.js';
import { UserSettingsLabelProvider, UILabelProvider } from 'monaco-editor/esm/vs/base/common/keybindingLabels.js';
import { OS, isMacintosh, isWindows, isLinux } from 'monaco-editor/esm/vs/base/common/platform.js';
import { KeybindingResolver } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingResolver.js';
import { ResolvedKeybindingItem, toEmptyArrayIfContainsNull } from 'monaco-editor/esm/vs/platform/keybinding/common/resolvedKeybindingItem.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { timeout, RunOnceScheduler } from 'monaco-editor/esm/vs/base/common/async.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { equals } from 'monaco-editor/esm/vs/base/common/objects.js';
import { StandardKeyboardEvent } from 'monaco-editor/esm/vs/base/browser/keyboardEvent.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from 'monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js';
import { AbstractEditorCommandsQuickAccessProvider } from 'monaco-editor/esm/vs/editor/contrib/quickAccess/browser/commandsQuickAccess.js';
import { DefaultQuickAccessFilterValue, Extensions as Extensions$2 } from 'monaco-editor/esm/vs/platform/quickinput/common/quickAccess.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { TriggerAction } from 'monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js';
import { stripIcons } from 'monaco-editor/esm/vs/base/common/iconLabels.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { IDialogService } from 'monaco-editor/esm/vs/platform/dialogs/common/dialogs.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { isFirefox } from 'monaco-editor/esm/vs/base/browser/browser.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { Extensions as Extensions$1 } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { BaseResolvedKeybinding } from 'monaco-editor/esm/vs/platform/keybinding/common/baseResolvedKeybinding.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { g as getServiceOverride$1 } from './files.js';
import getServiceOverride$2, { configurationRegistry as configurationRegistry$2 } from './configuration.js';
import { c as createInjectedClass } from './injection.js';
import { StandaloneCommandsQuickAccessProvider } from 'monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { StandaloneServices, StandaloneKeybindingService } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
class WindowManager {
    constructor() {
        this._zoomLevel = 0;
        this._zoomFactor = 1;
        this._fullscreen = false;
        this._onDidChangeFullscreen = ( (new Emitter()));
        this.onDidChangeFullscreen = this._onDidChangeFullscreen.event;
    }
    getZoomLevel() {
        return this._zoomLevel;
    }
    setZoomLevel(zoomLevel, isTrusted) {
        if (this._zoomLevel === zoomLevel) {
            return;
        }
        this._zoomLevel = zoomLevel;
    }
    getZoomFactor() {
        return this._zoomFactor;
    }
    setZoomFactor(zoomFactor) {
        this._zoomFactor = zoomFactor;
    }
    setFullscreen(fullscreen) {
        if (this._fullscreen === fullscreen) {
            return;
        }
        this._fullscreen = fullscreen;
        this._onDidChangeFullscreen.fire();
    }
    isFullscreen() {
        return this._fullscreen;
    }
}
WindowManager.INSTANCE = ( (new WindowManager()));
function addMatchMediaChangeListener(query, callback) {
    if (typeof query === 'string') {
        query = window.matchMedia(query);
    }
    query.addEventListener('change', callback);
}
function isFullscreen() {
    return WindowManager.INSTANCE.isFullscreen();
}
const onDidChangeFullscreen = WindowManager.INSTANCE.onDidChangeFullscreen;
const userAgent$1 = navigator.userAgent;
(userAgent$1.indexOf('Firefox') >= 0);
(userAgent$1.indexOf('AppleWebKit') >= 0);
const isChrome$1 = (userAgent$1.indexOf('Chrome') >= 0);
(!isChrome$1 && (userAgent$1.indexOf('Safari') >= 0));
(userAgent$1.indexOf('Electron/') >= 0);
(userAgent$1.indexOf('Android') >= 0);
let standalone = false;
if (window.matchMedia) {
    const standaloneMatchMedia = window.matchMedia('(display-mode: standalone) or (display-mode: window-controls-overlay)');
    const fullScreenMatchMedia = window.matchMedia('(display-mode: fullscreen)');
    standalone = standaloneMatchMedia.matches;
    addMatchMediaChangeListener(standaloneMatchMedia, ({ matches }) => {
        if (standalone && fullScreenMatchMedia.matches) {
            return;
        }
        standalone = matches;
    });
}
const LANGUAGE_DEFAULT = 'en';
let _locale = undefined;
let _language = LANGUAGE_DEFAULT;
let _userAgent = undefined;
const globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});
let nodeProcess = undefined;
if (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {
    nodeProcess = globals.vscode.process;
}
else if (typeof process !== 'undefined') {
    nodeProcess = process;
}
const isElectronProcess = typeof nodeProcess?.versions?.electron === 'string';
const isElectronRenderer = isElectronProcess && nodeProcess?.type === 'renderer';
if (typeof navigator === 'object' && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _userAgent.indexOf('Windows') >= 0;
    _userAgent.indexOf('Macintosh') >= 0;
    (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _userAgent.indexOf('Linux') >= 0;
    _userAgent?.indexOf('Mobi') >= 0;
    const configuredLocale = getConfiguredDefaultLocale(
    (
    (localize({ key: 'ensureLoaderPluginIsLoaded', comment: ['{Locked}'] }, '_'))));
    _locale = configuredLocale || LANGUAGE_DEFAULT;
    _language = _locale;
}
else if (typeof nodeProcess === 'object') {
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];
    if (rawNlsConfig) {
        try {
            const nlsConfig = JSON.parse(rawNlsConfig);
            const resolved = nlsConfig.availableLanguages['*'];
            _locale = nlsConfig.locale;
            _language = resolved ? resolved : LANGUAGE_DEFAULT;
        }
        catch (e) {
        }
    }
}
else {
    console.error('Unable to resolve platform.');
}
const userAgent = _userAgent;
const language = _language;
var Language;
( ((function(Language) {
    function value() {
        return language;
    }
    Language.value = value;
    function isDefaultVariant() {
        if (language.length === 2) {
            return language === 'en';
        }
        else if (language.length >= 3) {
            return language[0] === 'e' && language[1] === 'n' && language[2] === '-';
        }
        else {
            return false;
        }
    }
    Language.isDefaultVariant = isDefaultVariant;
    function isDefault() {
        return language === 'en';
    }
    Language.isDefault = isDefault;
})(Language || (Language = {}))));
const setTimeout0IsFaster = (typeof globals.postMessage === 'function' && !globals.importScripts);
(() => {
    if (setTimeout0IsFaster) {
        const pending = [];
        globals.addEventListener('message', (e) => {
            if (e.data && e.data.vscodeScheduleAsyncWork) {
                for (let i = 0, len = pending.length; i < len; i++) {
                    const candidate = pending[i];
                    if (candidate.id === e.data.vscodeScheduleAsyncWork) {
                        pending.splice(i, 1);
                        candidate.callback();
                        return;
                    }
                }
            }
        });
        let lastId = 0;
        return (callback) => {
            const myId = ++lastId;
            pending.push({
                id: myId,
                callback: callback
            });
            globals.postMessage({ vscodeScheduleAsyncWork: myId }, '*');
        };
    }
    return (callback) => setTimeout(callback);
})();
const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);
!!(userAgent && userAgent.indexOf('Firefox') >= 0);
!!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));
!!(userAgent && userAgent.indexOf('Edg/') >= 0);
!!(userAgent && userAgent.indexOf('Android') >= 0);
class KeyCodeStrMap {
    constructor() {
        this._keyCodeToStr = [];
        this._strToKeyCode = Object.create(null);
    }
    define(keyCode, str) {
        this._keyCodeToStr[keyCode] = str;
        this._strToKeyCode[str.toLowerCase()] = keyCode;
    }
    keyCodeToStr(keyCode) {
        return this._keyCodeToStr[keyCode];
    }
    strToKeyCode(str) {
        return this._strToKeyCode[str.toLowerCase()] || 0 ;
    }
}
const uiMap = ( (new KeyCodeStrMap()));
const userSettingsUSMap = ( (new KeyCodeStrMap()));
const userSettingsGeneralMap = ( (new KeyCodeStrMap()));
const EVENT_KEY_CODE_MAP = ( (new Array(230)));
const scanCodeIntToStr = [];
const scanCodeStrToInt = Object.create(null);
const scanCodeLowerCaseStrToInt = Object.create(null);
const ScanCodeUtils = {
    lowerCaseToEnum: (scanCode) => scanCodeLowerCaseStrToInt[scanCode] || 0 ,
    toEnum: (scanCode) => scanCodeStrToInt[scanCode] || 0 ,
    toString: (scanCode) => scanCodeIntToStr[scanCode] || 'None'
};
(function () {
    const empty = '';
    const mappings = [
        [0, 1, 0 , 'None', 0 , 'unknown', 0, 'VK_UNKNOWN', empty, empty],
        [0, 1, 1 , 'Hyper', 0 , empty, 0, empty, empty, empty],
        [0, 1, 2 , 'Super', 0 , empty, 0, empty, empty, empty],
        [0, 1, 3 , 'Fn', 0 , empty, 0, empty, empty, empty],
        [0, 1, 4 , 'FnLock', 0 , empty, 0, empty, empty, empty],
        [0, 1, 5 , 'Suspend', 0 , empty, 0, empty, empty, empty],
        [0, 1, 6 , 'Resume', 0 , empty, 0, empty, empty, empty],
        [0, 1, 7 , 'Turbo', 0 , empty, 0, empty, empty, empty],
        [0, 1, 8 , 'Sleep', 0 , empty, 0, 'VK_SLEEP', empty, empty],
        [0, 1, 9 , 'WakeUp', 0 , empty, 0, empty, empty, empty],
        [31, 0, 10 , 'KeyA', 31 , 'A', 65, 'VK_A', empty, empty],
        [32, 0, 11 , 'KeyB', 32 , 'B', 66, 'VK_B', empty, empty],
        [33, 0, 12 , 'KeyC', 33 , 'C', 67, 'VK_C', empty, empty],
        [34, 0, 13 , 'KeyD', 34 , 'D', 68, 'VK_D', empty, empty],
        [35, 0, 14 , 'KeyE', 35 , 'E', 69, 'VK_E', empty, empty],
        [36, 0, 15 , 'KeyF', 36 , 'F', 70, 'VK_F', empty, empty],
        [37, 0, 16 , 'KeyG', 37 , 'G', 71, 'VK_G', empty, empty],
        [38, 0, 17 , 'KeyH', 38 , 'H', 72, 'VK_H', empty, empty],
        [39, 0, 18 , 'KeyI', 39 , 'I', 73, 'VK_I', empty, empty],
        [40, 0, 19 , 'KeyJ', 40 , 'J', 74, 'VK_J', empty, empty],
        [41, 0, 20 , 'KeyK', 41 , 'K', 75, 'VK_K', empty, empty],
        [42, 0, 21 , 'KeyL', 42 , 'L', 76, 'VK_L', empty, empty],
        [43, 0, 22 , 'KeyM', 43 , 'M', 77, 'VK_M', empty, empty],
        [44, 0, 23 , 'KeyN', 44 , 'N', 78, 'VK_N', empty, empty],
        [45, 0, 24 , 'KeyO', 45 , 'O', 79, 'VK_O', empty, empty],
        [46, 0, 25 , 'KeyP', 46 , 'P', 80, 'VK_P', empty, empty],
        [47, 0, 26 , 'KeyQ', 47 , 'Q', 81, 'VK_Q', empty, empty],
        [48, 0, 27 , 'KeyR', 48 , 'R', 82, 'VK_R', empty, empty],
        [49, 0, 28 , 'KeyS', 49 , 'S', 83, 'VK_S', empty, empty],
        [50, 0, 29 , 'KeyT', 50 , 'T', 84, 'VK_T', empty, empty],
        [51, 0, 30 , 'KeyU', 51 , 'U', 85, 'VK_U', empty, empty],
        [52, 0, 31 , 'KeyV', 52 , 'V', 86, 'VK_V', empty, empty],
        [53, 0, 32 , 'KeyW', 53 , 'W', 87, 'VK_W', empty, empty],
        [54, 0, 33 , 'KeyX', 54 , 'X', 88, 'VK_X', empty, empty],
        [55, 0, 34 , 'KeyY', 55 , 'Y', 89, 'VK_Y', empty, empty],
        [56, 0, 35 , 'KeyZ', 56 , 'Z', 90, 'VK_Z', empty, empty],
        [22, 0, 36 , 'Digit1', 22 , '1', 49, 'VK_1', empty, empty],
        [23, 0, 37 , 'Digit2', 23 , '2', 50, 'VK_2', empty, empty],
        [24, 0, 38 , 'Digit3', 24 , '3', 51, 'VK_3', empty, empty],
        [25, 0, 39 , 'Digit4', 25 , '4', 52, 'VK_4', empty, empty],
        [26, 0, 40 , 'Digit5', 26 , '5', 53, 'VK_5', empty, empty],
        [27, 0, 41 , 'Digit6', 27 , '6', 54, 'VK_6', empty, empty],
        [28, 0, 42 , 'Digit7', 28 , '7', 55, 'VK_7', empty, empty],
        [29, 0, 43 , 'Digit8', 29 , '8', 56, 'VK_8', empty, empty],
        [30, 0, 44 , 'Digit9', 30 , '9', 57, 'VK_9', empty, empty],
        [21, 0, 45 , 'Digit0', 21 , '0', 48, 'VK_0', empty, empty],
        [3, 1, 46 , 'Enter', 3 , 'Enter', 13, 'VK_RETURN', empty, empty],
        [9, 1, 47 , 'Escape', 9 , 'Escape', 27, 'VK_ESCAPE', empty, empty],
        [1, 1, 48 , 'Backspace', 1 , 'Backspace', 8, 'VK_BACK', empty, empty],
        [2, 1, 49 , 'Tab', 2 , 'Tab', 9, 'VK_TAB', empty, empty],
        [10, 1, 50 , 'Space', 10 , 'Space', 32, 'VK_SPACE', empty, empty],
        [83, 0, 51 , 'Minus', 83 , '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'],
        [81, 0, 52 , 'Equal', 81 , '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'],
        [87, 0, 53 , 'BracketLeft', 87 , '[', 219, 'VK_OEM_4', '[', 'OEM_4'],
        [89, 0, 54 , 'BracketRight', 89 , ']', 221, 'VK_OEM_6', ']', 'OEM_6'],
        [88, 0, 55 , 'Backslash', 88 , '\\', 220, 'VK_OEM_5', '\\', 'OEM_5'],
        [0, 0, 56 , 'IntlHash', 0 , empty, 0, empty, empty, empty],
        [80, 0, 57 , 'Semicolon', 80 , ';', 186, 'VK_OEM_1', ';', 'OEM_1'],
        [90, 0, 58 , 'Quote', 90 , '\'', 222, 'VK_OEM_7', '\'', 'OEM_7'],
        [86, 0, 59 , 'Backquote', 86 , '`', 192, 'VK_OEM_3', '`', 'OEM_3'],
        [82, 0, 60 , 'Comma', 82 , ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'],
        [84, 0, 61 , 'Period', 84 , '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'],
        [85, 0, 62 , 'Slash', 85 , '/', 191, 'VK_OEM_2', '/', 'OEM_2'],
        [8, 1, 63 , 'CapsLock', 8 , 'CapsLock', 20, 'VK_CAPITAL', empty, empty],
        [59, 1, 64 , 'F1', 59 , 'F1', 112, 'VK_F1', empty, empty],
        [60, 1, 65 , 'F2', 60 , 'F2', 113, 'VK_F2', empty, empty],
        [61, 1, 66 , 'F3', 61 , 'F3', 114, 'VK_F3', empty, empty],
        [62, 1, 67 , 'F4', 62 , 'F4', 115, 'VK_F4', empty, empty],
        [63, 1, 68 , 'F5', 63 , 'F5', 116, 'VK_F5', empty, empty],
        [64, 1, 69 , 'F6', 64 , 'F6', 117, 'VK_F6', empty, empty],
        [65, 1, 70 , 'F7', 65 , 'F7', 118, 'VK_F7', empty, empty],
        [66, 1, 71 , 'F8', 66 , 'F8', 119, 'VK_F8', empty, empty],
        [67, 1, 72 , 'F9', 67 , 'F9', 120, 'VK_F9', empty, empty],
        [68, 1, 73 , 'F10', 68 , 'F10', 121, 'VK_F10', empty, empty],
        [69, 1, 74 , 'F11', 69 , 'F11', 122, 'VK_F11', empty, empty],
        [70, 1, 75 , 'F12', 70 , 'F12', 123, 'VK_F12', empty, empty],
        [0, 1, 76 , 'PrintScreen', 0 , empty, 0, empty, empty, empty],
        [79, 1, 77 , 'ScrollLock', 79 , 'ScrollLock', 145, 'VK_SCROLL', empty, empty],
        [7, 1, 78 , 'Pause', 7 , 'PauseBreak', 19, 'VK_PAUSE', empty, empty],
        [19, 1, 79 , 'Insert', 19 , 'Insert', 45, 'VK_INSERT', empty, empty],
        [14, 1, 80 , 'Home', 14 , 'Home', 36, 'VK_HOME', empty, empty],
        [11, 1, 81 , 'PageUp', 11 , 'PageUp', 33, 'VK_PRIOR', empty, empty],
        [20, 1, 82 , 'Delete', 20 , 'Delete', 46, 'VK_DELETE', empty, empty],
        [13, 1, 83 , 'End', 13 , 'End', 35, 'VK_END', empty, empty],
        [12, 1, 84 , 'PageDown', 12 , 'PageDown', 34, 'VK_NEXT', empty, empty],
        [17, 1, 85 , 'ArrowRight', 17 , 'RightArrow', 39, 'VK_RIGHT', 'Right', empty],
        [15, 1, 86 , 'ArrowLeft', 15 , 'LeftArrow', 37, 'VK_LEFT', 'Left', empty],
        [18, 1, 87 , 'ArrowDown', 18 , 'DownArrow', 40, 'VK_DOWN', 'Down', empty],
        [16, 1, 88 , 'ArrowUp', 16 , 'UpArrow', 38, 'VK_UP', 'Up', empty],
        [78, 1, 89 , 'NumLock', 78 , 'NumLock', 144, 'VK_NUMLOCK', empty, empty],
        [108, 1, 90 , 'NumpadDivide', 108 , 'NumPad_Divide', 111, 'VK_DIVIDE', empty, empty],
        [103, 1, 91 , 'NumpadMultiply', 103 , 'NumPad_Multiply', 106, 'VK_MULTIPLY', empty, empty],
        [106, 1, 92 , 'NumpadSubtract', 106 , 'NumPad_Subtract', 109, 'VK_SUBTRACT', empty, empty],
        [104, 1, 93 , 'NumpadAdd', 104 , 'NumPad_Add', 107, 'VK_ADD', empty, empty],
        [3, 1, 94 , 'NumpadEnter', 3 , empty, 0, empty, empty, empty],
        [94, 1, 95 , 'Numpad1', 94 , 'NumPad1', 97, 'VK_NUMPAD1', empty, empty],
        [95, 1, 96 , 'Numpad2', 95 , 'NumPad2', 98, 'VK_NUMPAD2', empty, empty],
        [96, 1, 97 , 'Numpad3', 96 , 'NumPad3', 99, 'VK_NUMPAD3', empty, empty],
        [97, 1, 98 , 'Numpad4', 97 , 'NumPad4', 100, 'VK_NUMPAD4', empty, empty],
        [98, 1, 99 , 'Numpad5', 98 , 'NumPad5', 101, 'VK_NUMPAD5', empty, empty],
        [99, 1, 100 , 'Numpad6', 99 , 'NumPad6', 102, 'VK_NUMPAD6', empty, empty],
        [100, 1, 101 , 'Numpad7', 100 , 'NumPad7', 103, 'VK_NUMPAD7', empty, empty],
        [101, 1, 102 , 'Numpad8', 101 , 'NumPad8', 104, 'VK_NUMPAD8', empty, empty],
        [102, 1, 103 , 'Numpad9', 102 , 'NumPad9', 105, 'VK_NUMPAD9', empty, empty],
        [93, 1, 104 , 'Numpad0', 93 , 'NumPad0', 96, 'VK_NUMPAD0', empty, empty],
        [107, 1, 105 , 'NumpadDecimal', 107 , 'NumPad_Decimal', 110, 'VK_DECIMAL', empty, empty],
        [92, 0, 106 , 'IntlBackslash', 92 , 'OEM_102', 226, 'VK_OEM_102', empty, empty],
        [58, 1, 107 , 'ContextMenu', 58 , 'ContextMenu', 93, empty, empty, empty],
        [0, 1, 108 , 'Power', 0 , empty, 0, empty, empty, empty],
        [0, 1, 109 , 'NumpadEqual', 0 , empty, 0, empty, empty, empty],
        [71, 1, 110 , 'F13', 71 , 'F13', 124, 'VK_F13', empty, empty],
        [72, 1, 111 , 'F14', 72 , 'F14', 125, 'VK_F14', empty, empty],
        [73, 1, 112 , 'F15', 73 , 'F15', 126, 'VK_F15', empty, empty],
        [74, 1, 113 , 'F16', 74 , 'F16', 127, 'VK_F16', empty, empty],
        [75, 1, 114 , 'F17', 75 , 'F17', 128, 'VK_F17', empty, empty],
        [76, 1, 115 , 'F18', 76 , 'F18', 129, 'VK_F18', empty, empty],
        [77, 1, 116 , 'F19', 77 , 'F19', 130, 'VK_F19', empty, empty],
        [0, 1, 117 , 'F20', 0 , empty, 0, 'VK_F20', empty, empty],
        [0, 1, 118 , 'F21', 0 , empty, 0, 'VK_F21', empty, empty],
        [0, 1, 119 , 'F22', 0 , empty, 0, 'VK_F22', empty, empty],
        [0, 1, 120 , 'F23', 0 , empty, 0, 'VK_F23', empty, empty],
        [0, 1, 121 , 'F24', 0 , empty, 0, 'VK_F24', empty, empty],
        [0, 1, 122 , 'Open', 0 , empty, 0, empty, empty, empty],
        [0, 1, 123 , 'Help', 0 , empty, 0, empty, empty, empty],
        [0, 1, 124 , 'Select', 0 , empty, 0, empty, empty, empty],
        [0, 1, 125 , 'Again', 0 , empty, 0, empty, empty, empty],
        [0, 1, 126 , 'Undo', 0 , empty, 0, empty, empty, empty],
        [0, 1, 127 , 'Cut', 0 , empty, 0, empty, empty, empty],
        [0, 1, 128 , 'Copy', 0 , empty, 0, empty, empty, empty],
        [0, 1, 129 , 'Paste', 0 , empty, 0, empty, empty, empty],
        [0, 1, 130 , 'Find', 0 , empty, 0, empty, empty, empty],
        [0, 1, 131 , 'AudioVolumeMute', 112 , 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', empty, empty],
        [0, 1, 132 , 'AudioVolumeUp', 113 , 'AudioVolumeUp', 175, 'VK_VOLUME_UP', empty, empty],
        [0, 1, 133 , 'AudioVolumeDown', 114 , 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', empty, empty],
        [105, 1, 134 , 'NumpadComma', 105 , 'NumPad_Separator', 108, 'VK_SEPARATOR', empty, empty],
        [110, 0, 135 , 'IntlRo', 110 , 'ABNT_C1', 193, 'VK_ABNT_C1', empty, empty],
        [0, 1, 136 , 'KanaMode', 0 , empty, 0, empty, empty, empty],
        [0, 0, 137 , 'IntlYen', 0 , empty, 0, empty, empty, empty],
        [0, 1, 138 , 'Convert', 0 , empty, 0, empty, empty, empty],
        [0, 1, 139 , 'NonConvert', 0 , empty, 0, empty, empty, empty],
        [0, 1, 140 , 'Lang1', 0 , empty, 0, empty, empty, empty],
        [0, 1, 141 , 'Lang2', 0 , empty, 0, empty, empty, empty],
        [0, 1, 142 , 'Lang3', 0 , empty, 0, empty, empty, empty],
        [0, 1, 143 , 'Lang4', 0 , empty, 0, empty, empty, empty],
        [0, 1, 144 , 'Lang5', 0 , empty, 0, empty, empty, empty],
        [0, 1, 145 , 'Abort', 0 , empty, 0, empty, empty, empty],
        [0, 1, 146 , 'Props', 0 , empty, 0, empty, empty, empty],
        [0, 1, 147 , 'NumpadParenLeft', 0 , empty, 0, empty, empty, empty],
        [0, 1, 148 , 'NumpadParenRight', 0 , empty, 0, empty, empty, empty],
        [0, 1, 149 , 'NumpadBackspace', 0 , empty, 0, empty, empty, empty],
        [0, 1, 150 , 'NumpadMemoryStore', 0 , empty, 0, empty, empty, empty],
        [0, 1, 151 , 'NumpadMemoryRecall', 0 , empty, 0, empty, empty, empty],
        [0, 1, 152 , 'NumpadMemoryClear', 0 , empty, 0, empty, empty, empty],
        [0, 1, 153 , 'NumpadMemoryAdd', 0 , empty, 0, empty, empty, empty],
        [0, 1, 154 , 'NumpadMemorySubtract', 0 , empty, 0, empty, empty, empty],
        [0, 1, 155 , 'NumpadClear', 126 , 'Clear', 12, 'VK_CLEAR', empty, empty],
        [0, 1, 156 , 'NumpadClearEntry', 0 , empty, 0, empty, empty, empty],
        [5, 1, 0 , empty, 5 , 'Ctrl', 17, 'VK_CONTROL', empty, empty],
        [4, 1, 0 , empty, 4 , 'Shift', 16, 'VK_SHIFT', empty, empty],
        [6, 1, 0 , empty, 6 , 'Alt', 18, 'VK_MENU', empty, empty],
        [57, 1, 0 , empty, 57 , 'Meta', 0, 'VK_COMMAND', empty, empty],
        [5, 1, 157 , 'ControlLeft', 5 , empty, 0, 'VK_LCONTROL', empty, empty],
        [4, 1, 158 , 'ShiftLeft', 4 , empty, 0, 'VK_LSHIFT', empty, empty],
        [6, 1, 159 , 'AltLeft', 6 , empty, 0, 'VK_LMENU', empty, empty],
        [57, 1, 160 , 'MetaLeft', 57 , empty, 0, 'VK_LWIN', empty, empty],
        [5, 1, 161 , 'ControlRight', 5 , empty, 0, 'VK_RCONTROL', empty, empty],
        [4, 1, 162 , 'ShiftRight', 4 , empty, 0, 'VK_RSHIFT', empty, empty],
        [6, 1, 163 , 'AltRight', 6 , empty, 0, 'VK_RMENU', empty, empty],
        [57, 1, 164 , 'MetaRight', 57 , empty, 0, 'VK_RWIN', empty, empty],
        [0, 1, 165 , 'BrightnessUp', 0 , empty, 0, empty, empty, empty],
        [0, 1, 166 , 'BrightnessDown', 0 , empty, 0, empty, empty, empty],
        [0, 1, 167 , 'MediaPlay', 0 , empty, 0, empty, empty, empty],
        [0, 1, 168 , 'MediaRecord', 0 , empty, 0, empty, empty, empty],
        [0, 1, 169 , 'MediaFastForward', 0 , empty, 0, empty, empty, empty],
        [0, 1, 170 , 'MediaRewind', 0 , empty, 0, empty, empty, empty],
        [114, 1, 171 , 'MediaTrackNext', 119 , 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', empty, empty],
        [115, 1, 172 , 'MediaTrackPrevious', 120 , 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', empty, empty],
        [116, 1, 173 , 'MediaStop', 121 , 'MediaStop', 178, 'VK_MEDIA_STOP', empty, empty],
        [0, 1, 174 , 'Eject', 0 , empty, 0, empty, empty, empty],
        [117, 1, 175 , 'MediaPlayPause', 122 , 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', empty, empty],
        [0, 1, 176 , 'MediaSelect', 123 , 'LaunchMediaPlayer', 181, 'VK_MEDIA_LAUNCH_MEDIA_SELECT', empty, empty],
        [0, 1, 177 , 'LaunchMail', 124 , 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', empty, empty],
        [0, 1, 178 , 'LaunchApp2', 125 , 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', empty, empty],
        [0, 1, 179 , 'LaunchApp1', 0 , empty, 0, 'VK_MEDIA_LAUNCH_APP1', empty, empty],
        [0, 1, 180 , 'SelectTask', 0 , empty, 0, empty, empty, empty],
        [0, 1, 181 , 'LaunchScreenSaver', 0 , empty, 0, empty, empty, empty],
        [0, 1, 182 , 'BrowserSearch', 115 , 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', empty, empty],
        [0, 1, 183 , 'BrowserHome', 116 , 'BrowserHome', 172, 'VK_BROWSER_HOME', empty, empty],
        [112, 1, 184 , 'BrowserBack', 117 , 'BrowserBack', 166, 'VK_BROWSER_BACK', empty, empty],
        [113, 1, 185 , 'BrowserForward', 118 , 'BrowserForward', 167, 'VK_BROWSER_FORWARD', empty, empty],
        [0, 1, 186 , 'BrowserStop', 0 , empty, 0, 'VK_BROWSER_STOP', empty, empty],
        [0, 1, 187 , 'BrowserRefresh', 0 , empty, 0, 'VK_BROWSER_REFRESH', empty, empty],
        [0, 1, 188 , 'BrowserFavorites', 0 , empty, 0, 'VK_BROWSER_FAVORITES', empty, empty],
        [0, 1, 189 , 'ZoomToggle', 0 , empty, 0, empty, empty, empty],
        [0, 1, 190 , 'MailReply', 0 , empty, 0, empty, empty, empty],
        [0, 1, 191 , 'MailForward', 0 , empty, 0, empty, empty, empty],
        [0, 1, 192 , 'MailSend', 0 , empty, 0, empty, empty, empty],
        [109, 1, 0 , empty, 109 , 'KeyInComposition', 229, empty, empty, empty],
        [111, 1, 0 , empty, 111 , 'ABNT_C2', 194, 'VK_ABNT_C2', empty, empty],
        [91, 1, 0 , empty, 91 , 'OEM_8', 223, 'VK_OEM_8', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_KANA', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_HANGUL', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_JUNJA', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_FINAL', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_HANJA', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_KANJI', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_CONVERT', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_NONCONVERT', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_ACCEPT', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_MODECHANGE', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_SELECT', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_PRINT', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_EXECUTE', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_SNAPSHOT', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_HELP', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_APPS', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_PROCESSKEY', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_PACKET', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_DBE_SBCSCHAR', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_DBE_DBCSCHAR', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_ATTN', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_CRSEL', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_EXSEL', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_EREOF', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_PLAY', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_ZOOM', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_NONAME', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_PA1', empty, empty],
        [0, 1, 0 , empty, 0 , empty, 0, 'VK_OEM_CLEAR', empty, empty],
    ];
    const seenKeyCode = [];
    const seenScanCode = [];
    for (const mapping of mappings) {
        const [_keyCodeOrd, immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;
        if (!seenScanCode[scanCode]) {
            seenScanCode[scanCode] = true;
            scanCodeIntToStr[scanCode] = scanCodeStr;
            scanCodeStrToInt[scanCodeStr] = scanCode;
            scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;
        }
        if (!seenKeyCode[keyCode]) {
            seenKeyCode[keyCode] = true;
            if (!keyCodeStr) {
                throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);
            }
            uiMap.define(keyCode, keyCodeStr);
            userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);
            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);
        }
        if (eventKeyCode) {
            EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;
        }
    }
})();
function printKeyboardEvent(e) {
    const modifiers = [];
    if (e.ctrlKey) {
        modifiers.push(`ctrl`);
    }
    if (e.shiftKey) {
        modifiers.push(`shift`);
    }
    if (e.altKey) {
        modifiers.push(`alt`);
    }
    if (e.metaKey) {
        modifiers.push(`meta`);
    }
    return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode}, key: ${e.key}`;
}
function printStandardKeyboardEvent(e) {
    const modifiers = [];
    if (e.ctrlKey) {
        modifiers.push(`ctrl`);
    }
    if (e.shiftKey) {
        modifiers.push(`shift`);
    }
    if (e.altKey) {
        modifiers.push(`alt`);
    }
    if (e.metaKey) {
        modifiers.push(`meta`);
    }
    return `modifiers: [${modifiers.join(',')}], code: ${e.code}, keyCode: ${e.keyCode} ('${( ( KeyCodeUtils.toString(e.keyCode)))}')`;
}
class KeybindingParser {
    static _readModifiers(input) {
        input = input.toLowerCase().trim();
        let ctrl = false;
        let shift = false;
        let alt = false;
        let meta = false;
        let matchedModifier;
        do {
            matchedModifier = false;
            if (/^ctrl(\+|\-)/.test(input)) {
                ctrl = true;
                input = input.substr('ctrl-'.length);
                matchedModifier = true;
            }
            if (/^shift(\+|\-)/.test(input)) {
                shift = true;
                input = input.substr('shift-'.length);
                matchedModifier = true;
            }
            if (/^alt(\+|\-)/.test(input)) {
                alt = true;
                input = input.substr('alt-'.length);
                matchedModifier = true;
            }
            if (/^meta(\+|\-)/.test(input)) {
                meta = true;
                input = input.substr('meta-'.length);
                matchedModifier = true;
            }
            if (/^win(\+|\-)/.test(input)) {
                meta = true;
                input = input.substr('win-'.length);
                matchedModifier = true;
            }
            if (/^cmd(\+|\-)/.test(input)) {
                meta = true;
                input = input.substr('cmd-'.length);
                matchedModifier = true;
            }
        } while (matchedModifier);
        let key;
        const firstSpaceIdx = input.indexOf(' ');
        if (firstSpaceIdx > 0) {
            key = input.substring(0, firstSpaceIdx);
            input = input.substring(firstSpaceIdx);
        }
        else {
            key = input;
            input = '';
        }
        return {
            remains: input,
            ctrl,
            shift,
            alt,
            meta,
            key
        };
    }
    static parseChord(input) {
        const mods = this._readModifiers(input);
        const scanCodeMatch = mods.key.match(/^\[([^\]]+)\]$/);
        if (scanCodeMatch) {
            const strScanCode = scanCodeMatch[1];
            const scanCode = ScanCodeUtils.lowerCaseToEnum(strScanCode);
            return [( (new ScanCodeChord(mods.ctrl, mods.shift, mods.alt, mods.meta, scanCode))), mods.remains];
        }
        const keyCode = KeyCodeUtils.fromUserSettings(mods.key);
        return [( (new KeyCodeChord(mods.ctrl, mods.shift, mods.alt, mods.meta, keyCode))), mods.remains];
    }
    static parseKeybinding(input) {
        if (!input) {
            return null;
        }
        const chords = [];
        let chord;
        while (input.length > 0) {
            [chord, input] = this.parseChord(input);
            chords.push(chord);
        }
        return (chords.length > 0 ?  (new Keybinding(chords)) : null);
    }
}
class KeybindingIO {
    static writeKeybindingItem(out, item) {
        if (!item.resolvedKeybinding) {
            return;
        }
        const quotedSerializedKeybinding = JSON.stringify(item.resolvedKeybinding.getUserSettingsLabel());
        out.write(`{ "key": ${rightPaddedString(quotedSerializedKeybinding + ',', 25)} "command": `);
        const quotedSerializedWhen = item.when ? JSON.stringify(item.when.serialize()) : '';
        const quotedSerializeCommand = JSON.stringify(item.command);
        if (quotedSerializedWhen.length > 0) {
            out.write(`${quotedSerializeCommand},`);
            out.writeLine();
            out.write(`                                     "when": ${quotedSerializedWhen}`);
        }
        else {
            out.write(`${quotedSerializeCommand}`);
        }
        if (item.commandArgs) {
            out.write(',');
            out.writeLine();
            out.write(`                                     "args": ${JSON.stringify(item.commandArgs)}`);
        }
        out.write(' }');
    }
    static readUserKeybindingItem(input) {
        const keybinding = (typeof input.key === 'string' ? KeybindingParser.parseKeybinding(input.key) : null);
        const when = (typeof input.when === 'string' ? ContextKeyExpr.deserialize(input.when) : undefined);
        const command = (typeof input.command === 'string' ? input.command : null);
        const commandArgs = (typeof input.args !== 'undefined' ? input.args : undefined);
        return {
            keybinding,
            command,
            commandArgs,
            when,
            _source: input
        };
    }
}
function rightPaddedString(str, minChars) {
    if (str.length < minChars) {
        return str + (( (new Array(minChars - str.length))).join(' '));
    }
    return str;
}
class OutputBuilder {
    constructor() {
        this._lines = [];
        this._currentLine = '';
    }
    write(str) {
        this._currentLine += str;
    }
    writeLine(str = '') {
        this._lines.push(this._currentLine + str);
        this._currentLine = '';
    }
    toString() {
        this.writeLine();
        return this._lines.join('\n');
    }
}
const apiMenus = [
    {
        key: 'commandPalette',
        id: MenuId.CommandPalette,
        description: ( (localize('menus.commandPalette', "The Command Palette"))),
        supportsSubmenus: false
    },
    {
        key: 'touchBar',
        id: MenuId.TouchBarContext,
        description: ( (localize('menus.touchBar', "The touch bar (macOS only)"))),
        supportsSubmenus: false
    },
    {
        key: 'editor/title',
        id: MenuId.EditorTitle,
        description: ( (localize('menus.editorTitle', "The editor title menu")))
    },
    {
        key: 'editor/title/run',
        id: MenuId.EditorTitleRun,
        description: ( (localize('menus.editorTitleRun', "Run submenu inside the editor title menu")))
    },
    {
        key: 'editor/context',
        id: MenuId.EditorContext,
        description: ( (localize('menus.editorContext', "The editor context menu")))
    },
    {
        key: 'editor/context/copy',
        id: MenuId.EditorContextCopy,
        description: ( (localize(
            'menus.editorContextCopyAs',
            "'Copy as' submenu in the editor context menu"
        )))
    },
    {
        key: 'editor/context/share',
        id: MenuId.EditorContextShare,
        description: ( (localize('menus.editorContextShare', "'Share' submenu in the editor context menu"))),
        proposed: 'contribShareMenu'
    },
    {
        key: 'explorer/context',
        id: MenuId.ExplorerContext,
        description: ( (localize('menus.explorerContext', "The file explorer context menu")))
    },
    {
        key: 'editor/title/context',
        id: MenuId.EditorTitleContext,
        description: ( (localize('menus.editorTabContext', "The editor tabs context menu")))
    },
    {
        key: 'debug/callstack/context',
        id: MenuId.DebugCallStackContext,
        description: ( (localize('menus.debugCallstackContext', "The debug callstack view context menu")))
    },
    {
        key: 'debug/variables/context',
        id: MenuId.DebugVariablesContext,
        description: ( (localize('menus.debugVariablesContext', "The debug variables view context menu")))
    },
    {
        key: 'debug/toolBar',
        id: MenuId.DebugToolBar,
        description: ( (localize('menus.debugToolBar', "The debug toolbar menu")))
    },
    {
        key: 'menuBar/home',
        id: MenuId.MenubarHomeMenu,
        description: ( (localize('menus.home', "The home indicator context menu (web only)"))),
        proposed: 'contribMenuBarHome',
        supportsSubmenus: false
    },
    {
        key: 'menuBar/edit/copy',
        id: MenuId.MenubarCopy,
        description: ( (localize('menus.opy', "'Copy as' submenu in the top level Edit menu")))
    },
    {
        key: 'scm/title',
        id: MenuId.SCMTitle,
        description: ( (localize('menus.scmTitle', "The Source Control title menu")))
    },
    {
        key: 'scm/sourceControl',
        id: MenuId.SCMSourceControl,
        description: ( (localize('menus.scmSourceControl', "The Source Control menu")))
    },
    {
        key: 'scm/resourceState/context',
        id: MenuId.SCMResourceContext,
        description: ( (localize(
            'menus.resourceStateContext',
            "The Source Control resource state context menu"
        )))
    },
    {
        key: 'scm/resourceFolder/context',
        id: MenuId.SCMResourceFolderContext,
        description: ( (localize(
            'menus.resourceFolderContext',
            "The Source Control resource folder context menu"
        )))
    },
    {
        key: 'scm/resourceGroup/context',
        id: MenuId.SCMResourceGroupContext,
        description: ( (localize(
            'menus.resourceGroupContext',
            "The Source Control resource group context menu"
        )))
    },
    {
        key: 'scm/change/title',
        id: MenuId.SCMChangeContext,
        description: ( (localize('menus.changeTitle', "The Source Control inline change menu")))
    },
    {
        key: 'statusBar/remoteIndicator',
        id: MenuId.StatusBarRemoteIndicatorMenu,
        description: ( (localize(
            'menus.statusBarRemoteIndicator',
            "The remote indicator menu in the status bar"
        ))),
        supportsSubmenus: false
    },
    {
        key: 'view/title',
        id: MenuId.ViewTitle,
        description: ( (localize('view.viewTitle', "The contributed view title menu")))
    },
    {
        key: 'view/item/context',
        id: MenuId.ViewItemContext,
        description: ( (localize('view.itemContext', "The contributed view item context menu")))
    },
    {
        key: 'comments/comment/editorActions',
        id: MenuId.CommentEditorActions,
        description: ( (localize('commentThread.editorActions', "The contributed comment editor actions"))),
        proposed: 'contribCommentEditorActionsMenu'
    },
    {
        key: 'comments/commentThread/title',
        id: MenuId.CommentThreadTitle,
        description: ( (localize('commentThread.title', "The contributed comment thread title menu")))
    },
    {
        key: 'comments/commentThread/context',
        id: MenuId.CommentThreadActions,
        description: ( (localize(
            'commentThread.actions',
            "The contributed comment thread context menu, rendered as buttons below the comment editor"
        ))),
        supportsSubmenus: false
    },
    {
        key: 'comments/commentThread/additionalActions',
        id: MenuId.CommentThreadAdditionalActions,
        description: ( (localize(
            'commentThread.actions',
            "The contributed comment thread context menu, rendered as buttons below the comment editor"
        ))),
        supportsSubmenus: false,
        proposed: 'contribCommentThreadAdditionalMenu'
    },
    {
        key: 'comments/commentThread/title/context',
        id: MenuId.CommentThreadTitleContext,
        description: ( (localize(
            'commentThread.titleContext',
            "The contributed comment thread title's peek context menu, rendered as a right click menu on the comment thread's peek title."
        ))),
        proposed: 'contribCommentPeekContext'
    },
    {
        key: 'comments/comment/title',
        id: MenuId.CommentTitle,
        description: ( (localize('comment.title', "The contributed comment title menu")))
    },
    {
        key: 'comments/comment/context',
        id: MenuId.CommentActions,
        description: ( (localize(
            'comment.actions',
            "The contributed comment context menu, rendered as buttons below the comment editor"
        ))),
        supportsSubmenus: false
    },
    {
        key: 'comments/commentThread/comment/context',
        id: MenuId.CommentThreadCommentContext,
        description: ( (localize(
            'comment.commentContext',
            "The contributed comment context menu, rendered as a right click menu on the an individual comment in the comment thread's peek view."
        ))),
        proposed: 'contribCommentPeekContext'
    },
    {
        key: 'notebook/toolbar',
        id: MenuId.NotebookToolbar,
        description: ( (localize('notebook.toolbar', "The contributed notebook toolbar menu")))
    },
    {
        key: 'notebook/kernelSource',
        id: MenuId.NotebookKernelSource,
        description: ( (localize('notebook.kernelSource', "The contributed notebook kernel sources menu"))),
        proposed: 'notebookKernelSource'
    },
    {
        key: 'notebook/cell/title',
        id: MenuId.NotebookCellTitle,
        description: ( (localize('notebook.cell.title', "The contributed notebook cell title menu")))
    },
    {
        key: 'notebook/cell/execute',
        id: MenuId.NotebookCellExecute,
        description: ( (localize('notebook.cell.execute', "The contributed notebook cell execution menu")))
    },
    {
        key: 'interactive/toolbar',
        id: MenuId.InteractiveToolbar,
        description: ( (localize('interactive.toolbar', "The contributed interactive toolbar menu"))),
    },
    {
        key: 'interactive/cell/title',
        id: MenuId.InteractiveCellTitle,
        description: ( (localize('interactive.cell.title', "The contributed interactive cell title menu"))),
    },
    {
        key: 'testing/item/context',
        id: MenuId.TestItem,
        description: ( (localize('testing.item.context', "The contributed test item menu"))),
    },
    {
        key: 'testing/item/gutter',
        id: MenuId.TestItemGutter,
        description: ( (localize(
            'testing.item.gutter.title',
            "The menu for a gutter decoration for a test item"
        ))),
    },
    {
        key: 'extension/context',
        id: MenuId.ExtensionContext,
        description: ( (localize('menus.extensionContext', "The extension context menu")))
    },
    {
        key: 'timeline/title',
        id: MenuId.TimelineTitle,
        description: ( (localize('view.timelineTitle', "The Timeline view title menu")))
    },
    {
        key: 'timeline/item/context',
        id: MenuId.TimelineItemContext,
        description: ( (localize('view.timelineContext', "The Timeline view item context menu")))
    },
    {
        key: 'ports/item/context',
        id: MenuId.TunnelContext,
        description: ( (localize('view.tunnelContext', "The Ports view item context menu")))
    },
    {
        key: 'ports/item/origin/inline',
        id: MenuId.TunnelOriginInline,
        description: ( (localize('view.tunnelOriginInline', "The Ports view item origin inline menu")))
    },
    {
        key: 'ports/item/port/inline',
        id: MenuId.TunnelPortInline,
        description: ( (localize('view.tunnelPortInline', "The Ports view item port inline menu")))
    },
    {
        key: 'file/newFile',
        id: MenuId.NewFile,
        description: ( (localize(
            'file.newFile',
            "The 'New File...' quick pick, shown on welcome page and File menu."
        ))),
        supportsSubmenus: false,
    },
    {
        key: 'webview/context',
        id: MenuId.WebviewContext,
        description: ( (localize('webview.context', "The webview context menu")))
    },
    {
        key: 'file/share',
        id: MenuId.MenubarShare,
        description: ( (localize('menus.share', "Share submenu shown in the top level File menu."))),
        proposed: 'contribShareMenu'
    },
    {
        key: 'editor/inlineCompletions/actions',
        id: MenuId.InlineCompletionsActions,
        description: ( (localize(
            'inlineCompletions.actions',
            "The actions shown when hovering on an inline completion"
        ))),
        supportsSubmenus: false,
        proposed: 'inlineCompletionsAdditions'
    },
    {
        key: 'editor/content',
        id: MenuId.EditorContent,
        description: ( (localize('merge.toolbar', "The prominent button in an editor, overlays its content"))),
        proposed: 'contribEditorContentMenu'
    },
    {
        key: 'mergeEditor/result/title',
        id: MenuId.MergeInputResultToolbar,
        description: ( (localize('menus.mergeEditorResult', "The result toolbar of the merge editor"))),
        proposed: 'contribMergeEditorMenus'
    },
];
var schema$1;
( ((function(schema) {
    function isMenuItem(item) {
        return typeof item.command === 'string';
    }
    schema.isMenuItem = isMenuItem;
    function isValidMenuItem(item, collector) {
        if (typeof item.command !== 'string') {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'command'
            ))));
            return false;
        }
        if (item.alt && typeof item.alt !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'alt'
            ))));
            return false;
        }
        if (item.when && typeof item.when !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'when'
            ))));
            return false;
        }
        if (item.group && typeof item.group !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'group'
            ))));
            return false;
        }
        return true;
    }
    schema.isValidMenuItem = isValidMenuItem;
    function isValidSubmenuItem(item, collector) {
        if (typeof item.submenu !== 'string') {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'submenu'
            ))));
            return false;
        }
        if (item.when && typeof item.when !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'when'
            ))));
            return false;
        }
        if (item.group && typeof item.group !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'group'
            ))));
            return false;
        }
        return true;
    }
    schema.isValidSubmenuItem = isValidSubmenuItem;
    function isValidItems(items, collector) {
        if (!Array.isArray(items)) {
            collector.error(( (localize('requirearray', "submenu items must be an array"))));
            return false;
        }
        for (const item of items) {
            if (isMenuItem(item)) {
                if (!isValidMenuItem(item, collector)) {
                    return false;
                }
            }
            else {
                if (!isValidSubmenuItem(item, collector)) {
                    return false;
                }
            }
        }
        return true;
    }
    schema.isValidItems = isValidItems;
    function isValidSubmenu(submenu, collector) {
        if (typeof submenu !== 'object') {
            collector.error(( (localize('require', "submenu items must be an object"))));
            return false;
        }
        if (typeof submenu.id !== 'string') {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'id'
            ))));
            return false;
        }
        if (typeof submenu.label !== 'string') {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'label'
            ))));
            return false;
        }
        return true;
    }
    schema.isValidSubmenu = isValidSubmenu;
    const menuItem = {
        type: 'object',
        required: ['command'],
        properties: {
            command: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.command',
                    'Identifier of the command to execute. The command must be declared in the \'commands\'-section'
                ))),
                type: 'string'
            },
            alt: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.alt',
                    'Identifier of an alternative command to execute. The command must be declared in the \'commands\'-section'
                ))),
                type: 'string'
            },
            when: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.when',
                    'Condition which must be true to show this item'
                ))),
                type: 'string'
            },
            group: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.group',
                    'Group into which this item belongs'
                ))),
                type: 'string'
            }
        }
    };
    const submenuItem = {
        type: 'object',
        required: ['submenu'],
        properties: {
            submenu: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.submenu',
                    'Identifier of the submenu to display in this item.'
                ))),
                type: 'string'
            },
            when: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.when',
                    'Condition which must be true to show this item'
                ))),
                type: 'string'
            },
            group: {
                description: ( (localize(
                    'vscode.extension.contributes.menuItem.group',
                    'Group into which this item belongs'
                ))),
                type: 'string'
            }
        }
    };
    const submenu = {
        type: 'object',
        required: ['id', 'label'],
        properties: {
            id: {
                description: ( (localize(
                    'vscode.extension.contributes.submenu.id',
                    'Identifier of the menu to display as a submenu.'
                ))),
                type: 'string'
            },
            label: {
                description: ( (localize(
                    'vscode.extension.contributes.submenu.label',
                    'The label of the menu item which leads to this submenu.'
                ))),
                type: 'string'
            },
            icon: {
                description: ( (localize(
                    { key: 'vscode.extension.contributes.submenu.icon', comment: ['do not translate or change `\\$(zap)`, \\ in front of $ is important.'] },
                    '(Optional) Icon which is used to represent the submenu in the UI. Either a file path, an object with file paths for dark and light themes, or a theme icon references, like `\\$(zap)`'
                ))),
                anyOf: [{
                        type: 'string'
                    },
                    {
                        type: 'object',
                        properties: {
                            light: {
                                description: ( (localize(
                                    'vscode.extension.contributes.submenu.icon.light',
                                    'Icon path when a light theme is used'
                                ))),
                                type: 'string'
                            },
                            dark: {
                                description: ( (localize(
                                    'vscode.extension.contributes.submenu.icon.dark',
                                    'Icon path when a dark theme is used'
                                ))),
                                type: 'string'
                            }
                        }
                    }]
            }
        }
    };
    schema.menusContribution = {
        description: ( (localize(
            'vscode.extension.contributes.menus',
            "Contributes menu items to the editor"
        ))),
        type: 'object',
        properties: index(apiMenus, menu => menu.key, menu => ({
            markdownDescription: menu.proposed ? ( (localize(
                'proposed',
                "Proposed API, requires `enabledApiProposal: [\"{0}\"]` - {1}",
                menu.proposed,
                menu.description
            ))) : menu.description,
            type: 'array',
            items: menu.supportsSubmenus === false ? menuItem : { oneOf: [menuItem, submenuItem] }
        })),
        additionalProperties: {
            description: 'Submenu',
            type: 'array',
            items: { oneOf: [menuItem, submenuItem] }
        }
    };
    schema.submenusContribution = {
        description: ( (localize(
            'vscode.extension.contributes.submenus',
            "Contributes submenu items to the editor"
        ))),
        type: 'array',
        items: submenu
    };
    function isValidCommand(command, collector) {
        if (!command) {
            collector.error(( (localize('nonempty', "expected non-empty value."))));
            return false;
        }
        if (isFalsyOrWhitespace(command.command)) {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                'command'
            ))));
            return false;
        }
        if (!isValidLocalizedString(command.title, collector, 'title')) {
            return false;
        }
        if (command.shortTitle && !isValidLocalizedString(command.shortTitle, collector, 'shortTitle')) {
            return false;
        }
        if (command.enablement && typeof command.enablement !== 'string') {
            collector.error(( (localize(
                'optstring',
                "property `{0}` can be omitted or must be of type `string`",
                'precondition'
            ))));
            return false;
        }
        if (command.category && !isValidLocalizedString(command.category, collector, 'category')) {
            return false;
        }
        if (!isValidIcon(command.icon, collector)) {
            return false;
        }
        return true;
    }
    schema.isValidCommand = isValidCommand;
    function isValidIcon(icon, collector) {
        if (typeof icon === 'undefined') {
            return true;
        }
        if (typeof icon === 'string') {
            return true;
        }
        else if (typeof icon.dark === 'string' && typeof icon.light === 'string') {
            return true;
        }
        collector.error(( (localize(
            'opticon',
            "property `icon` can be omitted or must be either a string or a literal like `{dark, light}`"
        ))));
        return false;
    }
    function isValidLocalizedString(localized, collector, propertyName) {
        if (typeof localized === 'undefined') {
            collector.error(( (localize(
                'requireStringOrObject',
                "property `{0}` is mandatory and must be of type `string` or `object`",
                propertyName
            ))));
            return false;
        }
        else if (typeof localized === 'string' && isFalsyOrWhitespace(localized)) {
            collector.error(( (localize(
                'requirestring',
                "property `{0}` is mandatory and must be of type `string`",
                propertyName
            ))));
            return false;
        }
        else if (typeof localized !== 'string' && (isFalsyOrWhitespace(localized.original) || isFalsyOrWhitespace(localized.value))) {
            collector.error(( (localize(
                'requirestrings',
                "properties `{0}` and `{1}` are mandatory and must be of type `string`",
                `${propertyName}.value`,
                `${propertyName}.original`
            ))));
            return false;
        }
        return true;
    }
    const commandType = {
        type: 'object',
        required: ['command', 'title'],
        properties: {
            command: {
                description: ( (localize(
                    'vscode.extension.contributes.commandType.command',
                    'Identifier of the command to execute'
                ))),
                type: 'string'
            },
            title: {
                description: ( (localize(
                    'vscode.extension.contributes.commandType.title',
                    'Title by which the command is represented in the UI'
                ))),
                type: 'string'
            },
            shortTitle: {
                markdownDescription: ( (localize(
                    'vscode.extension.contributes.commandType.shortTitle',
                    '(Optional) Short title by which the command is represented in the UI. Menus pick either `title` or `shortTitle` depending on the context in which they show commands.'
                ))),
                type: 'string'
            },
            category: {
                description: ( (localize(
                    'vscode.extension.contributes.commandType.category',
                    '(Optional) Category string by which the command is grouped in the UI'
                ))),
                type: 'string'
            },
            enablement: {
                description: ( (localize(
                    'vscode.extension.contributes.commandType.precondition',
                    '(Optional) Condition which must be true to enable the command in the UI (menu and keybindings). Does not prevent executing the command by other means, like the `executeCommand`-api.'
                ))),
                type: 'string'
            },
            icon: {
                description: ( (localize(
                    { key: 'vscode.extension.contributes.commandType.icon', comment: ['do not translate or change `\\$(zap)`, \\ in front of $ is important.'] },
                    '(Optional) Icon which is used to represent the command in the UI. Either a file path, an object with file paths for dark and light themes, or a theme icon references, like `\\$(zap)`'
                ))),
                anyOf: [{
                        type: 'string'
                    },
                    {
                        type: 'object',
                        properties: {
                            light: {
                                description: ( (localize(
                                    'vscode.extension.contributes.commandType.icon.light',
                                    'Icon path when a light theme is used'
                                ))),
                                type: 'string'
                            },
                            dark: {
                                description: ( (localize(
                                    'vscode.extension.contributes.commandType.icon.dark',
                                    'Icon path when a dark theme is used'
                                ))),
                                type: 'string'
                            }
                        }
                    }]
            }
        }
    };
    schema.commandsContribution = {
        description: ( (localize(
            'vscode.extension.contributes.commands',
            "Contributes commands to the command palette."
        ))),
        oneOf: [
            commandType,
            {
                type: 'array',
                items: commandType
            }
        ]
    };
})(schema$1 || (schema$1 = {}))));
const _commandRegistrations = ( (new DisposableStore()));
const commandsExtensionPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'commands',
    jsonSchema: schema$1.commandsContribution,
    activationEventsGenerator: (contribs, result) => {
        for (const contrib of contribs) {
            if (contrib.command) {
                result.push(`onCommand:${contrib.command}`);
            }
        }
    }
})));
commandsExtensionPoint.setHandler(extensions => {
    function handleCommand(userFriendlyCommand, extension) {
        if (!schema$1.isValidCommand(userFriendlyCommand, extension.collector)) {
            return;
        }
        const { icon, enablement, category, title, shortTitle, command } = userFriendlyCommand;
        let absoluteIcon;
        if (icon) {
            if (typeof icon === 'string') {
                absoluteIcon = ThemeIcon.fromString(icon) ?? { dark: joinPath(extension.description.extensionLocation, icon), light: joinPath(extension.description.extensionLocation, icon) };
            }
            else {
                absoluteIcon = {
                    dark: joinPath(extension.description.extensionLocation, icon.dark),
                    light: joinPath(extension.description.extensionLocation, icon.light)
                };
            }
        }
        if (MenuRegistry.getCommand(command)) {
            extension.collector.info(( (localize(
                'dup',
                "Command `{0}` appears multiple times in the `commands` section.",
                userFriendlyCommand.command
            ))));
        }
        _commandRegistrations.add(MenuRegistry.addCommand({
            id: command,
            title,
            source: { id: extension.description.identifier.value, title: extension.description.displayName ?? extension.description.name },
            shortTitle,
            tooltip: title,
            category,
            precondition: ContextKeyExpr.deserialize(enablement),
            icon: absoluteIcon
        }));
    }
    _commandRegistrations.clear();
    for (const extension of extensions) {
        const { value } = extension;
        if (Array.isArray(value)) {
            for (const command of value) {
                handleCommand(command, extension);
            }
        }
        else {
            handleCommand(value, extension);
        }
    }
});
const _submenus = ( (new Map()));
const submenusExtensionPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'submenus',
    jsonSchema: schema$1.submenusContribution
})));
submenusExtensionPoint.setHandler(extensions => {
    _submenus.clear();
    for (const extension of extensions) {
        const { value, collector } = extension;
        for (const [, submenuInfo] of Object.entries(value)) {
            if (!schema$1.isValidSubmenu(submenuInfo, collector)) {
                continue;
            }
            if (!submenuInfo.id) {
                collector.warn(( (localize(
                    'submenuId.invalid.id',
                    "`{0}` is not a valid submenu identifier",
                    submenuInfo.id
                ))));
                continue;
            }
            if (_submenus.has(submenuInfo.id)) {
                collector.info(( (localize(
                    'submenuId.duplicate.id',
                    "The `{0}` submenu was already previously registered.",
                    submenuInfo.id
                ))));
                continue;
            }
            if (!submenuInfo.label) {
                collector.warn(( (localize(
                    'submenuId.invalid.label',
                    "`{0}` is not a valid submenu label",
                    submenuInfo.label
                ))));
                continue;
            }
            let absoluteIcon;
            if (submenuInfo.icon) {
                if (typeof submenuInfo.icon === 'string') {
                    absoluteIcon = ThemeIcon.fromString(submenuInfo.icon) || { dark: joinPath(extension.description.extensionLocation, submenuInfo.icon) };
                }
                else {
                    absoluteIcon = {
                        dark: joinPath(extension.description.extensionLocation, submenuInfo.icon.dark),
                        light: joinPath(extension.description.extensionLocation, submenuInfo.icon.light)
                    };
                }
            }
            const item = {
                id: MenuId.for(`api:${submenuInfo.id}`),
                label: submenuInfo.label,
                icon: absoluteIcon
            };
            _submenus.set(submenuInfo.id, item);
        }
    }
});
const _apiMenusByKey = ( (new Map( (apiMenus.map(menu => ([menu.key, menu]))))));
const _menuRegistrations = ( (new DisposableStore()));
const _submenuMenuItems = ( (new Map()));
const menusExtensionPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'menus',
    jsonSchema: schema$1.menusContribution,
    deps: [submenusExtensionPoint]
})));
menusExtensionPoint.setHandler(extensions => {
    _menuRegistrations.clear();
    _submenuMenuItems.clear();
    for (const extension of extensions) {
        const { value, collector } = extension;
        for (const entry of Object.entries(value)) {
            if (!schema$1.isValidItems(entry[1], collector)) {
                continue;
            }
            let menu = _apiMenusByKey.get(entry[0]);
            if (!menu) {
                const submenu = _submenus.get(entry[0]);
                if (submenu) {
                    menu = {
                        key: entry[0],
                        id: submenu.id,
                        description: ''
                    };
                }
            }
            if (!menu) {
                continue;
            }
            if (menu.proposed && !isProposedApiEnabled(extension.description, menu.proposed)) {
                collector.error(( (localize(
                    'proposedAPI.invalid',
                    "{0} is a proposed menu identifier. It requires 'package.json#enabledApiProposals: [\"{1}\"]' and is only available when running out of dev or with the following command line switch: --enable-proposed-api {2}",
                    entry[0],
                    menu.proposed,
                    extension.description.identifier.value
                ))));
                continue;
            }
            for (const menuItem of entry[1]) {
                let item;
                if (schema$1.isMenuItem(menuItem)) {
                    const command = MenuRegistry.getCommand(menuItem.command);
                    const alt = menuItem.alt && MenuRegistry.getCommand(menuItem.alt) || undefined;
                    if (!command) {
                        collector.error(( (localize(
                            'missing.command',
                            "Menu item references a command `{0}` which is not defined in the 'commands' section.",
                            menuItem.command
                        ))));
                        continue;
                    }
                    if (menuItem.alt && !alt) {
                        collector.warn(( (localize(
                            'missing.altCommand',
                            "Menu item references an alt-command `{0}` which is not defined in the 'commands' section.",
                            menuItem.alt
                        ))));
                    }
                    if (menuItem.command === menuItem.alt) {
                        collector.info(( (localize(
                            'dupe.command',
                            "Menu item references the same command as default and alt-command"
                        ))));
                    }
                    item = { command, alt, group: undefined, order: undefined, when: undefined };
                }
                else {
                    if (menu.supportsSubmenus === false) {
                        collector.error(( (localize(
                            'unsupported.submenureference',
                            "Menu item references a submenu for a menu which doesn't have submenu support."
                        ))));
                        continue;
                    }
                    const submenu = _submenus.get(menuItem.submenu);
                    if (!submenu) {
                        collector.error(( (localize(
                            'missing.submenu',
                            "Menu item references a submenu `{0}` which is not defined in the 'submenus' section.",
                            menuItem.submenu
                        ))));
                        continue;
                    }
                    let submenuRegistrations = _submenuMenuItems.get(menu.id.id);
                    if (!submenuRegistrations) {
                        submenuRegistrations = ( (new Set()));
                        _submenuMenuItems.set(menu.id.id, submenuRegistrations);
                    }
                    if (submenuRegistrations.has(submenu.id.id)) {
                        collector.warn(( (localize(
                            'submenuItem.duplicate',
                            "The `{0}` submenu was already contributed to the `{1}` menu.",
                            menuItem.submenu,
                            entry[0]
                        ))));
                        continue;
                    }
                    submenuRegistrations.add(submenu.id.id);
                    item = { submenu: submenu.id, icon: submenu.icon, title: submenu.label, group: undefined, order: undefined, when: undefined };
                }
                if (menuItem.group) {
                    const idx = menuItem.group.lastIndexOf('@');
                    if (idx > 0) {
                        item.group = menuItem.group.substr(0, idx);
                        item.order = Number(menuItem.group.substr(idx + 1)) || undefined;
                    }
                    else {
                        item.group = menuItem.group;
                    }
                }
                item.when = ContextKeyExpr.deserialize(menuItem.when);
                _menuRegistrations.add(MenuRegistry.appendMenuItem(menu.id, item));
            }
        }
    }
});
function getAllUnboundCommands(boundCommands) {
    const unboundCommands = [];
    const seenMap = ( (new Map()));
    const addCommand = (id, includeCommandWithArgs) => {
        if (seenMap.has(id)) {
            return;
        }
        seenMap.set(id, true);
        if (id[0] === '_' || id.indexOf('vscode.') === 0) {
            return;
        }
        if (boundCommands.get(id) === true) {
            return;
        }
        if (!includeCommandWithArgs) {
            const command = CommandsRegistry.getCommand(id);
            if (command && typeof command.description === 'object'
                && isNonEmptyArray(command.description.args)) {
                return;
            }
        }
        unboundCommands.push(id);
    };
    for (const menuItem of MenuRegistry.getMenuItems(MenuId.CommandPalette)) {
        if (isIMenuItem(menuItem)) {
            addCommand(menuItem.command.id, true);
        }
    }
    for (const editorAction of EditorExtensionsRegistry.getEditorActions()) {
        addCommand(editorAction.id, true);
    }
    for (const id of ( (CommandsRegistry.getCommands().keys()))) {
        addCommand(id, false);
    }
    return unboundCommands;
}
function isContributedKeyBindingsArray(thing) {
    return Array.isArray(thing);
}
function isValidContributedKeyBinding(keyBinding, rejects) {
    if (!keyBinding) {
        rejects.push(( (localize('nonempty', "expected non-empty value."))));
        return false;
    }
    if (typeof keyBinding.command !== 'string') {
        rejects.push(( (localize(
            'requirestring',
            "property `{0}` is mandatory and must be of type `string`",
            'command'
        ))));
        return false;
    }
    if (keyBinding.key && typeof keyBinding.key !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'key'
        ))));
        return false;
    }
    if (keyBinding.when && typeof keyBinding.when !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'when'
        ))));
        return false;
    }
    if (keyBinding.mac && typeof keyBinding.mac !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'mac'
        ))));
        return false;
    }
    if (keyBinding.linux && typeof keyBinding.linux !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'linux'
        ))));
        return false;
    }
    if (keyBinding.win && typeof keyBinding.win !== 'string') {
        rejects.push(( (localize(
            'optstring',
            "property `{0}` can be omitted or must be of type `string`",
            'win'
        ))));
        return false;
    }
    return true;
}
const keybindingType = {
    type: 'object',
    default: { command: '', key: '' },
    properties: {
        command: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.command',
                'Identifier of the command to run when keybinding is triggered.'
            ))),
            type: 'string'
        },
        args: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.args',
                "Arguments to pass to the command to execute."
            )))
        },
        key: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.key',
                'Key or key sequence (separate keys with plus-sign and sequences with space, e.g. Ctrl+O and Ctrl+L L for a chord).'
            ))),
            type: 'string'
        },
        mac: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.mac',
                'Mac specific key or key sequence.'
            ))),
            type: 'string'
        },
        linux: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.linux',
                'Linux specific key or key sequence.'
            ))),
            type: 'string'
        },
        win: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.win',
                'Windows specific key or key sequence.'
            ))),
            type: 'string'
        },
        when: {
            description: ( (localize(
                'vscode.extension.contributes.keybindings.when',
                'Condition when the key is active.'
            ))),
            type: 'string'
        },
    }
};
const keybindingsExtPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'keybindings',
    deps: [commandsExtensionPoint],
    jsonSchema: {
        description: ( (localize('vscode.extension.contributes.keybindings', "Contributes keybindings."))),
        oneOf: [
            keybindingType,
            {
                type: 'array',
                items: keybindingType
            }
        ]
    }
})));
const NUMPAD_PRINTABLE_SCANCODES = [
    90 ,
    91 ,
    92 ,
    93 ,
    95 ,
    96 ,
    97 ,
    98 ,
    99 ,
    100 ,
    101 ,
    102 ,
    103 ,
    104 ,
    105
];
const otherMacNumpadMapping = ( (new Map()));
otherMacNumpadMapping.set(95 , 22 );
otherMacNumpadMapping.set(96 , 23 );
otherMacNumpadMapping.set(97 , 24 );
otherMacNumpadMapping.set(98 , 25 );
otherMacNumpadMapping.set(99 , 26 );
otherMacNumpadMapping.set(100 , 27 );
otherMacNumpadMapping.set(101 , 28 );
otherMacNumpadMapping.set(102 , 29 );
otherMacNumpadMapping.set(103 , 30 );
otherMacNumpadMapping.set(104 , 21 );
let WorkbenchKeybindingService = class WorkbenchKeybindingService extends AbstractKeybindingService {
    constructor(contextKeyService, commandService, telemetryService, notificationService, userDataProfileService, hostService, extensionService, fileService, logService, keyboardLayoutService) {
        super(contextKeyService, commandService, telemetryService, notificationService, logService);
        this.hostService = hostService;
        this.keyboardLayoutService = keyboardLayoutService;
        this._contributions = [];
        this.isComposingGlobalContextKey = contextKeyService.createKey('isComposing', false);
        this.updateSchema();
        this._keyboardMapper = this.keyboardLayoutService.getKeyboardMapper();
        this.keyboardLayoutService.onDidChangeKeyboardLayout(() => {
            this._keyboardMapper = this.keyboardLayoutService.getKeyboardMapper();
            this.updateResolver();
        });
        this._cachedResolver = null;
        this.userKeybindings = this._register(( (new UserKeybindings(userDataProfileService, fileService, logService))));
        this.userKeybindings.initialize().then(() => {
            if (this.userKeybindings.keybindings.length) {
                this.updateResolver();
            }
        });
        this._register(this.userKeybindings.onDidChange(() => {
            logService.debug('User keybindings changed');
            this.updateResolver();
        }));
        keybindingsExtPoint.setHandler((extensions) => {
            const keybindings = [];
            for (const extension of extensions) {
                this._handleKeybindingsExtensionPointUser(extension.description.identifier, extension.description.isBuiltin, extension.value, extension.collector, keybindings);
            }
            KeybindingsRegistry.setExtensionKeybindings(keybindings);
            this.updateResolver();
        });
        this.updateSchema();
        this._register(extensionService.onDidRegisterExtensions(() => this.updateSchema()));
        this._register(addDisposableListener(window, EventType.KEY_DOWN, (e) => {
            this.isComposingGlobalContextKey.set(e.isComposing);
            const keyEvent = ( (new StandardKeyboardEvent(e)));
            this._log(`/ Received  keydown event - ${printKeyboardEvent(e)}`);
            this._log(`| Converted keydown event - ${printStandardKeyboardEvent(keyEvent)}`);
            const shouldPreventDefault = this._dispatch(keyEvent, keyEvent.target);
            if (shouldPreventDefault) {
                keyEvent.preventDefault();
            }
            this.isComposingGlobalContextKey.set(false);
        }));
        this._register(addDisposableListener(window, EventType.KEY_UP, (e) => {
            this.isComposingGlobalContextKey.set(e.isComposing);
            const keyEvent = ( (new StandardKeyboardEvent(e)));
            const shouldPreventDefault = this._singleModifierDispatch(keyEvent, keyEvent.target);
            if (shouldPreventDefault) {
                keyEvent.preventDefault();
            }
            this.isComposingGlobalContextKey.set(false);
        }));
        this._register(onDidChangeFullscreen(() => {
            const keyboard = navigator.keyboard;
            if (BrowserFeatures.keyboard === 2 ) {
                return;
            }
            if (isFullscreen()) {
                keyboard?.lock(['Escape']);
            }
            else {
                keyboard?.unlock();
            }
            this._cachedResolver = null;
            this._onDidUpdateKeybindings.fire();
        }));
    }
    registerSchemaContribution(contribution) {
        this._contributions.push(contribution);
        if (contribution.onDidChange) {
            this._register(contribution.onDidChange(() => this.updateSchema()));
        }
        this.updateSchema();
    }
    updateSchema() {
        updateSchema(flatten(( (this._contributions.map(x => x.getSchemaAdditions())))));
    }
    _printKeybinding(keybinding) {
        return UserSettingsLabelProvider.toLabel(OS, keybinding.chords, (chord) => {
            if (chord instanceof KeyCodeChord) {
                return (
                     (KeyCodeUtils.toString(chord.keyCode))
                );
            }
            return (
                 (ScanCodeUtils.toString(chord.scanCode))
            );
        }) || '[null]';
    }
    _printResolvedKeybinding(resolvedKeybinding) {
        return ( (resolvedKeybinding.getDispatchChords().map(x => x || '[null]'))).join(' ');
    }
    _printResolvedKeybindings(output, input, resolvedKeybindings) {
        const padLength = 35;
        const firstRow = `${input.padStart(padLength, ' ')} => `;
        if (resolvedKeybindings.length === 0) {
            output.push(`${firstRow}${'[NO BINDING]'.padStart(padLength, ' ')}`);
            return;
        }
        for (const resolvedKeybinding of resolvedKeybindings) {
            {
                output.push(`${firstRow}${this._printResolvedKeybinding(resolvedKeybinding).padStart(padLength, ' ')}`);
            }
        }
    }
    _dumpResolveKeybindingDebugInfo() {
        const seenBindings = ( (new Set()));
        const result = [];
        result.push(`Default Resolved Keybindings (unique only):`);
        for (const item of KeybindingsRegistry.getDefaultKeybindings()) {
            if (!item.keybinding) {
                continue;
            }
            const input = this._printKeybinding(item.keybinding);
            if (seenBindings.has(input)) {
                continue;
            }
            seenBindings.add(input);
            const resolvedKeybindings = this._keyboardMapper.resolveKeybinding(item.keybinding);
            this._printResolvedKeybindings(result, input, resolvedKeybindings);
        }
        result.push(`User Resolved Keybindings (unique only):`);
        for (const item of this.userKeybindings.keybindings) {
            if (!item.keybinding) {
                continue;
            }
            const input = item._source.key;
            if (seenBindings.has(input)) {
                continue;
            }
            seenBindings.add(input);
            const resolvedKeybindings = this._keyboardMapper.resolveKeybinding(item.keybinding);
            this._printResolvedKeybindings(result, input, resolvedKeybindings);
        }
        return result.join('\n');
    }
    _dumpDebugInfo() {
        const layoutInfo = JSON.stringify(this.keyboardLayoutService.getCurrentKeyboardLayout(), null, '\t');
        const mapperInfo = this._keyboardMapper.dumpDebugInfo();
        const resolvedKeybindings = this._dumpResolveKeybindingDebugInfo();
        const rawMapping = JSON.stringify(this.keyboardLayoutService.getRawKeyboardMapping(), null, '\t');
        return `Layout info:\n${layoutInfo}\n\n${resolvedKeybindings}\n\n${mapperInfo}\n\nRaw mapping:\n${rawMapping}`;
    }
    _dumpDebugInfoJSON() {
        const info = {
            layout: this.keyboardLayoutService.getCurrentKeyboardLayout(),
            rawMapping: this.keyboardLayoutService.getRawKeyboardMapping()
        };
        return JSON.stringify(info, null, '\t');
    }
    customKeybindingsCount() {
        return this.userKeybindings.keybindings.length;
    }
    updateResolver() {
        this._cachedResolver = null;
        this._onDidUpdateKeybindings.fire();
    }
    _getResolver() {
        if (!this._cachedResolver) {
            const defaults = this._resolveKeybindingItems(KeybindingsRegistry.getDefaultKeybindings(), true);
            const overrides = this._resolveUserKeybindingItems(this.userKeybindings.keybindings, false);
            this._cachedResolver = ( (new KeybindingResolver(defaults, overrides, (str) => this._log(str))));
        }
        return this._cachedResolver;
    }
    _documentHasFocus() {
        return this.hostService.hasFocus;
    }
    _resolveKeybindingItems(items, isDefault) {
        const result = [];
        let resultLen = 0;
        for (const item of items) {
            const when = item.when || undefined;
            const keybinding = item.keybinding;
            if (!keybinding) {
                result[resultLen++] = ( (new ResolvedKeybindingItem(
                    undefined,
                    item.command,
                    item.commandArgs,
                    when,
                    isDefault,
                    item.extensionId,
                    item.isBuiltinExtension
                )));
            }
            else {
                if (this._assertBrowserConflicts(keybinding, item.command)) {
                    continue;
                }
                const resolvedKeybindings = this._keyboardMapper.resolveKeybinding(keybinding);
                for (let i = resolvedKeybindings.length - 1; i >= 0; i--) {
                    const resolvedKeybinding = resolvedKeybindings[i];
                    result[resultLen++] = ( (new ResolvedKeybindingItem(
                        resolvedKeybinding,
                        item.command,
                        item.commandArgs,
                        when,
                        isDefault,
                        item.extensionId,
                        item.isBuiltinExtension
                    )));
                }
            }
        }
        return result;
    }
    _resolveUserKeybindingItems(items, isDefault) {
        const result = [];
        let resultLen = 0;
        for (const item of items) {
            const when = item.when || undefined;
            if (!item.keybinding) {
                result[resultLen++] = ( (new ResolvedKeybindingItem(undefined, item.command, item.commandArgs, when, isDefault, null, false)));
            }
            else {
                const resolvedKeybindings = this._keyboardMapper.resolveKeybinding(item.keybinding);
                for (const resolvedKeybinding of resolvedKeybindings) {
                    result[resultLen++] = ( (new ResolvedKeybindingItem(
                        resolvedKeybinding,
                        item.command,
                        item.commandArgs,
                        when,
                        isDefault,
                        null,
                        false
                    )));
                }
            }
        }
        return result;
    }
    _assertBrowserConflicts(keybinding, commandId) {
        if (BrowserFeatures.keyboard === 0 ) {
            return false;
        }
        if (BrowserFeatures.keyboard === 1  && isFullscreen()) {
            return false;
        }
        for (const chord of keybinding.chords) {
            if (!chord.metaKey && !chord.altKey && !chord.ctrlKey && !chord.shiftKey) {
                continue;
            }
            const modifiersMask = 2048  | 512  | 1024 ;
            let partModifiersMask = 0;
            if (chord.metaKey) {
                partModifiersMask |= 2048 ;
            }
            if (chord.shiftKey) {
                partModifiersMask |= 1024 ;
            }
            if (chord.altKey) {
                partModifiersMask |= 512 ;
            }
            if (chord.ctrlKey && OS === 2 ) {
                partModifiersMask |= 256 ;
            }
            if ((partModifiersMask & modifiersMask) === ((2048  | 512) )) {
                if (chord instanceof ScanCodeChord && ((chord.scanCode === 86  || chord.scanCode === 85) )) {
                    return true;
                }
                if (chord instanceof KeyCodeChord && ((chord.keyCode === 15  || chord.keyCode === 17) )) {
                    return true;
                }
            }
            if ((partModifiersMask & modifiersMask) === 2048 ) {
                if (chord instanceof ScanCodeChord && ((chord.scanCode >= 36  && chord.scanCode <= 45) )) {
                    return true;
                }
                if (chord instanceof KeyCodeChord && ((chord.keyCode >= 21  && chord.keyCode <= 30) )) {
                    return true;
                }
            }
        }
        return false;
    }
    resolveKeybinding(kb) {
        return this._keyboardMapper.resolveKeybinding(kb);
    }
    resolveKeyboardEvent(keyboardEvent) {
        this.keyboardLayoutService.validateCurrentKeyboardMapping(keyboardEvent);
        return this._keyboardMapper.resolveKeyboardEvent(keyboardEvent);
    }
    resolveUserBinding(userBinding) {
        const keybinding = KeybindingParser.parseKeybinding(userBinding);
        return (keybinding ? this._keyboardMapper.resolveKeybinding(keybinding) : []);
    }
    _handleKeybindingsExtensionPointUser(extensionId, isBuiltin, keybindings, collector, result) {
        if (isContributedKeyBindingsArray(keybindings)) {
            for (let i = 0, len = keybindings.length; i < len; i++) {
                this._handleKeybinding(extensionId, isBuiltin, i + 1, keybindings[i], collector, result);
            }
        }
        else {
            this._handleKeybinding(extensionId, isBuiltin, 1, keybindings, collector, result);
        }
    }
    _handleKeybinding(extensionId, isBuiltin, idx, keybindings, collector, result) {
        const rejects = [];
        if (isValidContributedKeyBinding(keybindings, rejects)) {
            const rule = this._asCommandRule(extensionId, isBuiltin, idx++, keybindings);
            if (rule) {
                result.push(rule);
            }
        }
        if (rejects.length > 0) {
            collector.error(( (localize(
                'invalid.keybindings',
                "Invalid `contributes.{0}`: {1}",
                keybindingsExtPoint.name,
                rejects.join('\n')
            ))));
        }
    }
    static bindToCurrentPlatform(key, mac, linux, win) {
        if (OS === 1  && win) {
            if (win) {
                return win;
            }
        }
        else if (OS === 2 ) {
            if (mac) {
                return mac;
            }
        }
        else {
            if (linux) {
                return linux;
            }
        }
        return key;
    }
    _asCommandRule(extensionId, isBuiltin, idx, binding) {
        const { command, args, when, key, mac, linux, win } = binding;
        const keybinding = WorkbenchKeybindingService.bindToCurrentPlatform(key, mac, linux, win);
        if (!keybinding) {
            return undefined;
        }
        let weight;
        if (isBuiltin) {
            weight = 300  + idx;
        }
        else {
            weight = 400  + idx;
        }
        const commandAction = MenuRegistry.getCommand(command);
        const precondition = commandAction && commandAction.precondition;
        let fullWhen;
        if (when && precondition) {
            fullWhen = ( (ContextKeyExpr.and(precondition, ContextKeyExpr.deserialize(when))));
        }
        else if (when) {
            fullWhen = ContextKeyExpr.deserialize(when);
        }
        else if (precondition) {
            fullWhen = precondition;
        }
        const desc = {
            id: command,
            args,
            when: fullWhen,
            weight: weight,
            keybinding: KeybindingParser.parseKeybinding(keybinding),
            extensionId: extensionId.value,
            isBuiltinExtension: isBuiltin
        };
        return desc;
    }
    getDefaultKeybindingsContent() {
        const resolver = this._getResolver();
        const defaultKeybindings = resolver.getDefaultKeybindings();
        const boundCommands = resolver.getDefaultBoundCommands();
        return (WorkbenchKeybindingService._getDefaultKeybindings(defaultKeybindings)
            + '\n\n'
            + WorkbenchKeybindingService._getAllCommandsAsComment(boundCommands));
    }
    static _getDefaultKeybindings(defaultKeybindings) {
        const out = ( (new OutputBuilder()));
        out.writeLine('[');
        const lastIndex = defaultKeybindings.length - 1;
        defaultKeybindings.forEach((k, index) => {
            KeybindingIO.writeKeybindingItem(out, k);
            if (index !== lastIndex) {
                out.writeLine(',');
            }
            else {
                out.writeLine();
            }
        });
        out.writeLine(']');
        return (
             (out.toString())
        );
    }
    static _getAllCommandsAsComment(boundCommands) {
        const unboundCommands = getAllUnboundCommands(boundCommands);
        const pretty = unboundCommands.sort().join('\n// - ');
        return '// ' + ( (localize('unboundCommands', "Here are other available commands: "))) + '\n// - ' + pretty;
    }
    mightProducePrintableCharacter(event) {
        if (event.ctrlKey || event.metaKey || event.altKey) {
            return false;
        }
        const code = ScanCodeUtils.toEnum(event.code);
        if (NUMPAD_PRINTABLE_SCANCODES.indexOf(code) !== -1) {
            if (event.keyCode === IMMUTABLE_CODE_TO_KEY_CODE[code]) {
                return true;
            }
            if (isMacintosh && event.keyCode === otherMacNumpadMapping.get(code)) {
                return true;
            }
            return false;
        }
        const keycode = IMMUTABLE_CODE_TO_KEY_CODE[code];
        if (keycode !== -1) {
            return false;
        }
        const mapping = this.keyboardLayoutService.getRawKeyboardMapping();
        if (!mapping) {
            return false;
        }
        const keyInfo = mapping[event.code];
        if (!keyInfo) {
            return false;
        }
        if (!keyInfo.value || /\s/.test(keyInfo.value)) {
            return false;
        }
        return true;
    }
};
WorkbenchKeybindingService = ( (__decorate([
    ( (__param(0, IContextKeyService))),
    ( (__param(1, ICommandService))),
    ( (__param(2, ITelemetryService))),
    ( (__param(3, INotificationService))),
    ( (__param(4, IUserDataProfileService))),
    ( (__param(5, IHostService))),
    ( (__param(6, IExtensionService))),
    ( (__param(7, IFileService))),
    ( (__param(8, ILogService))),
    ( (__param(9, IKeyboardLayoutService)))
], WorkbenchKeybindingService)));
class UserKeybindings extends Disposable {
    get keybindings() { return this._keybindings; }
    constructor(userDataProfileService, fileService, logService) {
        super();
        this.userDataProfileService = userDataProfileService;
        this.fileService = fileService;
        this._rawKeybindings = [];
        this._keybindings = [];
        this.watchDisposables = this._register(( (new DisposableStore())));
        this._onDidChange = this._register(( (new Emitter())));
        this.onDidChange = this._onDidChange.event;
        this.watch();
        this.reloadConfigurationScheduler = this._register(( (new RunOnceScheduler(() => this.reload().then(changed => {
            if (changed) {
                this._onDidChange.fire();
            }
        }), 50))));
        this._register(Event.filter(this.fileService.onDidFilesChange, e => e.contains(this.userDataProfileService.currentProfile.keybindingsResource))(() => {
            logService.debug('Keybindings file changed');
            this.reloadConfigurationScheduler.schedule();
        }));
        this._register(this.fileService.onDidRunOperation((e) => {
            if (e.operation === 4  && ( (e.resource.toString())) === ( (this.userDataProfileService.currentProfile.keybindingsResource.toString()))) {
                logService.debug('Keybindings file written');
                this.reloadConfigurationScheduler.schedule();
            }
        }));
        this._register(userDataProfileService.onDidChangeCurrentProfile(e => e.join(this.whenCurrentProfieChanged(e))));
    }
    async whenCurrentProfieChanged(e) {
        if (e.preserveData) {
            if (await this.fileService.exists(e.previous.keybindingsResource)) {
                await this.fileService.copy(e.previous.keybindingsResource, e.profile.keybindingsResource);
            }
        }
        this.watch();
        this.reloadConfigurationScheduler.schedule();
    }
    watch() {
        this.watchDisposables.clear();
        this.watchDisposables.add(this.fileService.watch(dirname(this.userDataProfileService.currentProfile.keybindingsResource)));
        this.watchDisposables.add(this.fileService.watch(this.userDataProfileService.currentProfile.keybindingsResource));
    }
    async initialize() {
        await this.reload();
    }
    async reload() {
        const newKeybindings = await this.readUserKeybindings();
        if (equals(this._rawKeybindings, newKeybindings)) {
            return false;
        }
        this._rawKeybindings = newKeybindings;
        this._keybindings = ( (this._rawKeybindings.map((k) => KeybindingIO.readUserKeybindingItem(k))));
        return true;
    }
    async readUserKeybindings() {
        try {
            const content = await this.fileService.readFile(this.userDataProfileService.currentProfile.keybindingsResource);
            const value = parse(( (content.value.toString())));
            return Array.isArray(value) ? value : [];
        }
        catch (e) {
            return [];
        }
    }
}
const schemaId = 'vscode://schemas/keybindings';
const commandsSchemas = [];
const commandsEnum = [];
const commandsEnumDescriptions = [];
const schema = {
    id: schemaId,
    type: 'array',
    title: ( (localize('keybindings.json.title', "Keybindings configuration"))),
    allowTrailingCommas: true,
    allowComments: true,
    definitions: {
        'editorGroupsSchema': {
            'type': 'array',
            'items': {
                'type': 'object',
                'properties': {
                    'groups': {
                        '$ref': '#/definitions/editorGroupsSchema',
                        'default': [{}, {}]
                    },
                    'size': {
                        'type': 'number',
                        'default': 0.5
                    }
                }
            }
        }
    },
    items: {
        'required': ['key'],
        'type': 'object',
        'defaultSnippets': [{ 'body': { 'key': '$1', 'command': '$2', 'when': '$3' } }],
        'properties': {
            'key': {
                'type': 'string',
                'description': ( (localize('keybindings.json.key', "Key or key sequence (separated by space)"))),
            },
            'command': {
                'anyOf': [
                    {
                        'type': 'string',
                        'enum': commandsEnum,
                        'enumDescriptions': commandsEnumDescriptions,
                        'description': ( (localize('keybindings.json.command', "Name of the command to execute"))),
                    },
                    {
                        'type': 'string'
                    }
                ]
            },
            'when': {
                'type': 'string',
                'description': ( (localize('keybindings.json.when', "Condition when the key is active.")))
            },
            'args': {
                'description': ( (localize('keybindings.json.args', "Arguments to pass to the command to execute.")))
            }
        },
        'allOf': commandsSchemas
    }
};
const schemaRegistry = ( (Registry.as(Extensions.JSONContribution)));
schemaRegistry.registerSchema(schemaId, schema);
function updateSchema(additionalContributions) {
    commandsSchemas.length = 0;
    commandsEnum.length = 0;
    commandsEnumDescriptions.length = 0;
    const knownCommands = ( (new Set()));
    const addKnownCommand = (commandId, description) => {
        if (!/^_/.test(commandId)) {
            if (!knownCommands.has(commandId)) {
                knownCommands.add(commandId);
                commandsEnum.push(commandId);
                commandsEnumDescriptions.push(description);
                commandsEnum.push(`-${commandId}`);
                commandsEnumDescriptions.push(description);
            }
        }
    };
    const allCommands = CommandsRegistry.getCommands();
    for (const [commandId, command] of allCommands) {
        const commandDescription = command.description;
        addKnownCommand(commandId, commandDescription ? commandDescription.description : undefined);
        if (!commandDescription || !commandDescription.args || commandDescription.args.length !== 1 || !commandDescription.args[0].schema) {
            continue;
        }
        const argsSchema = commandDescription.args[0].schema;
        const argsRequired = ((typeof commandDescription.args[0].isOptional !== 'undefined')
            ? (!commandDescription.args[0].isOptional)
            : (Array.isArray(argsSchema.required) && argsSchema.required.length > 0));
        const addition = {
            'if': {
                'properties': {
                    'command': { 'const': commandId }
                }
            },
            'then': {
                'required': [].concat(argsRequired ? ['args'] : []),
                'properties': {
                    'args': argsSchema
                }
            }
        };
        commandsSchemas.push(addition);
    }
    const menuCommands = MenuRegistry.getCommands();
    for (const commandId of ( (menuCommands.keys()))) {
        addKnownCommand(commandId);
    }
    commandsSchemas.push(...additionalContributions);
    schemaRegistry.notifySchemaChanged(schemaId);
}
let CommandsQuickAccessProvider = class CommandsQuickAccessProvider extends AbstractEditorCommandsQuickAccessProvider {
    get activeTextEditorControl() { return this.editorService.activeTextEditorControl; }
    get defaultFilterValue() {
        if (this.configuration.preserveInput) {
            return DefaultQuickAccessFilterValue.LAST;
        }
        return undefined;
    }
    constructor(editorService, menuService, extensionService, instantiationService, keybindingService, commandService, telemetryService, dialogService, configurationService, editorGroupService, preferencesService, productService) {
        super({
            showAlias: !Language.isDefaultVariant(),
            noResultsPick: {
                label: ( (localize('noCommandResults', "No matching commands"))),
                commandId: ''
            }
        }, instantiationService, keybindingService, commandService, telemetryService, dialogService);
        this.editorService = editorService;
        this.menuService = menuService;
        this.extensionService = extensionService;
        this.configurationService = configurationService;
        this.editorGroupService = editorGroupService;
        this.preferencesService = preferencesService;
        this.productService = productService;
        this.extensionRegistrationRace = Promise.race([
            timeout(800),
            this.extensionService.whenInstalledExtensionsRegistered()
        ]);
        this._register(configurationService.onDidChangeConfiguration((e) => this.updateSuggestedCommandIds(e)));
        this.updateSuggestedCommandIds();
    }
    get configuration() {
        const commandPaletteConfig = this.configurationService.getValue().workbench.commandPalette;
        return {
            preserveInput: commandPaletteConfig.preserveInput,
            experimental: commandPaletteConfig.experimental
        };
    }
    updateSuggestedCommandIds(e) {
        if (e && !e.affectsConfiguration('workbench.commandPalette.experimental.suggestCommands')) {
            return;
        }
        const config = this.configuration;
        const suggestedCommandIds = config.experimental.suggestCommands && this.productService.commandPaletteSuggestedCommandIds?.length
            ? ( (new Set(this.productService.commandPaletteSuggestedCommandIds)))
            : undefined;
        this.options.suggestedCommandIds = suggestedCommandIds;
    }
    async getCommandPicks(token) {
        await this.extensionRegistrationRace;
        if (token.isCancellationRequested) {
            return [];
        }
        return (
             ([
                ...this.getCodeEditorCommandPicks(),
                ...this.getGlobalCommandPicks()
            ].map(c => ({
                ...c,
                buttons: [{
                        iconClass: ThemeIcon.asClassName(Codicon.gear),
                        tooltip: ( (localize('configure keybinding', "Configure Keybinding"))),
                    }],
                trigger: () => {
                    this.preferencesService.openGlobalKeybindingSettings(false, { query: `@command:${c.commandId}` });
                    return TriggerAction.CLOSE_PICKER;
                },
            })))
        );
    }
    getGlobalCommandPicks() {
        const globalCommandPicks = [];
        const scopedContextKeyService = this.editorService.activeEditorPane?.scopedContextKeyService || this.editorGroupService.activeGroup.scopedContextKeyService;
        const globalCommandsMenu = this.menuService.createMenu(MenuId.CommandPalette, scopedContextKeyService);
        const globalCommandsMenuActions = globalCommandsMenu.getActions()
            .reduce((r, [, actions]) => [...r, ...actions], [])
            .filter(action => action instanceof MenuItemAction && action.enabled);
        for (const action of globalCommandsMenuActions) {
            let label = (typeof action.item.title === 'string' ? action.item.title : action.item.title.value) || action.item.id;
            const category = typeof action.item.category === 'string' ? action.item.category : action.item.category?.value;
            if (category) {
                label = ( (localize('commandWithCategory', "{0}: {1}", category, label)));
            }
            const aliasLabel = typeof action.item.title !== 'string' ? action.item.title.original : undefined;
            const aliasCategory = (category && action.item.category && typeof action.item.category !== 'string') ? action.item.category.original : undefined;
            const commandAlias = (aliasLabel && category) ?
                aliasCategory ? `${aliasCategory}: ${aliasLabel}` : `${category}: ${aliasLabel}` :
                aliasLabel;
            globalCommandPicks.push({
                commandId: action.item.id,
                commandAlias,
                label: stripIcons(label)
            });
        }
        globalCommandsMenu.dispose();
        return globalCommandPicks;
    }
};
CommandsQuickAccessProvider = ( (__decorate([
    ( (__param(0, IEditorService))),
    ( (__param(1, IMenuService))),
    ( (__param(2, IExtensionService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IKeybindingService))),
    ( (__param(5, ICommandService))),
    ( (__param(6, ITelemetryService))),
    ( (__param(7, IDialogService))),
    ( (__param(8, IConfigurationService))),
    ( (__param(9, IEditorGroupsService))),
    ( (__param(10, IPreferencesService))),
    ( (__param(11, IProductService)))
], CommandsQuickAccessProvider)));
class ShowAllCommandsAction extends Action2 {
    constructor() {
        super({
            id: ShowAllCommandsAction.ID,
            title: { value: ( (localize('showTriggerActions', "Show All Commands"))), original: 'Show All Commands' },
            keybinding: {
                weight: 200 ,
                when: undefined,
                primary: !isFirefox ? ((2048  | 1024  | 46) ) : undefined,
                secondary: [59 ]
            },
            f1: true
        });
    }
    async run(accessor) {
        accessor.get(IQuickInputService).quickAccess.show(CommandsQuickAccessProvider.PREFIX);
    }
}
ShowAllCommandsAction.ID = 'workbench.action.showCommands';
function deserializeMapping(serializedMapping) {
    const mapping = serializedMapping;
    const ret = {};
    for (const key in mapping) {
        const result = mapping[key];
        if (result.length) {
            const value = result[0];
            const withShift = result[1];
            const withAltGr = result[2];
            const withShiftAltGr = result[3];
            const mask = Number(result[4]);
            const vkey = result.length === 6 ? result[5] : undefined;
            ret[key] = {
                'value': value,
                'vkey': vkey,
                'withShift': withShift,
                'withAltGr': withAltGr,
                'withShiftAltGr': withShiftAltGr,
                'valueIsDeadKey': (mask & 1) > 0,
                'withShiftIsDeadKey': (mask & 2) > 0,
                'withAltGrIsDeadKey': (mask & 4) > 0,
                'withShiftAltGrIsDeadKey': (mask & 8) > 0
            };
        }
        else {
            ret[key] = {
                'value': '',
                'valueIsDeadKey': false,
                'withShift': '',
                'withShiftIsDeadKey': false,
                'withAltGr': '',
                'withAltGrIsDeadKey': false,
                'withShiftAltGr': '',
                'withShiftAltGrIsDeadKey': false
            };
        }
    }
    return ret;
}
class KeymapInfo {
    constructor(layout, secondaryLayouts, keyboardMapping, isUserKeyboardLayout) {
        this.layout = layout;
        this.secondaryLayouts = secondaryLayouts;
        this.mapping = deserializeMapping(keyboardMapping);
        this.isUserKeyboardLayout = !!isUserKeyboardLayout;
        this.layout.isUserKeyboardLayout = !!isUserKeyboardLayout;
    }
    static createKeyboardLayoutFromDebugInfo(layout, value, isUserKeyboardLayout) {
        const keyboardLayoutInfo = ( (new KeymapInfo(layout, [], {}, true)));
        keyboardLayoutInfo.mapping = value;
        return keyboardLayoutInfo;
    }
    update(other) {
        this.layout = other.layout;
        this.secondaryLayouts = other.secondaryLayouts;
        this.mapping = other.mapping;
        this.isUserKeyboardLayout = other.isUserKeyboardLayout;
        this.layout.isUserKeyboardLayout = other.isUserKeyboardLayout;
    }
    getScore(other) {
        let score = 0;
        for (const key in other) {
            if (isWindows && (key === 'Backslash' || key === 'KeyQ')) {
                continue;
            }
            if (isLinux && (key === 'Backspace' || key === 'Escape')) {
                continue;
            }
            const currentMapping = this.mapping[key];
            if (currentMapping === undefined) {
                score -= 1;
            }
            const otherMapping = other[key];
            if (currentMapping && otherMapping && currentMapping.value !== otherMapping.value) {
                score -= 1;
            }
        }
        return score;
    }
    equal(other) {
        if (this.isUserKeyboardLayout !== other.isUserKeyboardLayout) {
            return false;
        }
        if (getKeyboardLayoutId(this.layout) !== getKeyboardLayoutId(other.layout)) {
            return false;
        }
        return this.fuzzyEqual(other.mapping);
    }
    fuzzyEqual(other) {
        for (const key in other) {
            if (isWindows && (key === 'Backslash' || key === 'KeyQ')) {
                continue;
            }
            if (this.mapping[key] === undefined) {
                return false;
            }
            const currentMapping = this.mapping[key];
            const otherMapping = other[key];
            if (currentMapping.value !== otherMapping.value) {
                return false;
            }
        }
        return true;
    }
}
function readKeyboardConfig(configurationService) {
    const keyboard = configurationService.getValue('keyboard');
    const dispatch = ((keyboard?.dispatch === 'keyCode' ? 1  : 0) );
    const mapAltGrToCtrlAlt = Boolean(keyboard?.mapAltGrToCtrlAlt);
    return { dispatch, mapAltGrToCtrlAlt };
}
const configurationRegistry$1 = ( (Registry.as(Extensions$1.Configuration)));
const keyboardConfiguration$1 = {
    'id': 'keyboard',
    'order': 15,
    'type': 'object',
    'title': ( (localize('keyboardConfigurationTitle', "Keyboard"))),
    'properties': {
        'keyboard.dispatch': {
            scope: 1 ,
            type: 'string',
            enum: ['code', 'keyCode'],
            default: 'code',
            markdownDescription: ( (localize(
                'dispatch',
                "Controls the dispatching logic for key presses to use either `code` (recommended) or `keyCode`."
            ))),
            included: OS === 2  || OS === 3
        },
        'keyboard.mapAltGrToCtrlAlt': {
            scope: 1 ,
            type: 'boolean',
            default: false,
            markdownDescription: ( (localize(
                'mapAltGrToCtrlAlt',
                "Controls if the AltGraph+ modifier should be treated as Ctrl+Alt+."
            ))),
            included: OS === 1
        }
    }
};
configurationRegistry$1.registerConfiguration(keyboardConfiguration$1);
class CachedKeyboardMapper {
    constructor(actual) {
        this._actual = actual;
        this._cache = ( (new Map()));
    }
    dumpDebugInfo() {
        return this._actual.dumpDebugInfo();
    }
    resolveKeyboardEvent(keyboardEvent) {
        return this._actual.resolveKeyboardEvent(keyboardEvent);
    }
    resolveKeybinding(keybinding) {
        const hashCode = keybinding.getHashCode();
        const resolved = this._cache.get(hashCode);
        if (!resolved) {
            const r = this._actual.resolveKeybinding(keybinding);
            this._cache.set(hashCode, r);
            return r;
        }
        return resolved;
    }
}
class WindowsNativeResolvedKeybinding extends BaseResolvedKeybinding {
    constructor(mapper, chords) {
        super(1 , chords);
        this._mapper = mapper;
    }
    _getLabel(chord) {
        if (chord.isDuplicateModifierCase()) {
            return '';
        }
        return this._mapper.getUILabelForKeyCode(chord.keyCode);
    }
    _getUSLabelForKeybinding(chord) {
        if (chord.isDuplicateModifierCase()) {
            return '';
        }
        return (
             (KeyCodeUtils.toString(chord.keyCode))
        );
    }
    getUSLabel() {
        return UILabelProvider.toLabel(this._os, this._chords, (keybinding) => this._getUSLabelForKeybinding(keybinding));
    }
    _getAriaLabel(chord) {
        if (chord.isDuplicateModifierCase()) {
            return '';
        }
        return this._mapper.getAriaLabelForKeyCode(chord.keyCode);
    }
    _getElectronAccelerator(chord) {
        return this._mapper.getElectronAcceleratorForKeyBinding(chord);
    }
    _getUserSettingsLabel(chord) {
        if (chord.isDuplicateModifierCase()) {
            return '';
        }
        const result = this._mapper.getUserSettingsLabelForKeyCode(chord.keyCode);
        return (result ? result.toLowerCase() : result);
    }
    _isWYSIWYG(chord) {
        return this.__isWYSIWYG(chord.keyCode);
    }
    __isWYSIWYG(keyCode) {
        if (keyCode === 15
            || keyCode === 16
            || keyCode === 17
            || keyCode === 18 ) {
            return true;
        }
        const ariaLabel = this._mapper.getAriaLabelForKeyCode(keyCode);
        const userSettingsLabel = this._mapper.getUserSettingsLabelForKeyCode(keyCode);
        return (ariaLabel === userSettingsLabel);
    }
    _getChordDispatch(chord) {
        if (chord.isModifierKey()) {
            return null;
        }
        let result = '';
        if (chord.ctrlKey) {
            result += 'ctrl+';
        }
        if (chord.shiftKey) {
            result += 'shift+';
        }
        if (chord.altKey) {
            result += 'alt+';
        }
        if (chord.metaKey) {
            result += 'meta+';
        }
        result += ( (KeyCodeUtils.toString(chord.keyCode)));
        return result;
    }
    _getSingleModifierChordDispatch(chord) {
        if (chord.keyCode === 5  && !chord.shiftKey && !chord.altKey && !chord.metaKey) {
            return 'ctrl';
        }
        if (chord.keyCode === 4  && !chord.ctrlKey && !chord.altKey && !chord.metaKey) {
            return 'shift';
        }
        if (chord.keyCode === 6  && !chord.ctrlKey && !chord.shiftKey && !chord.metaKey) {
            return 'alt';
        }
        if (chord.keyCode === 57  && !chord.ctrlKey && !chord.shiftKey && !chord.altKey) {
            return 'meta';
        }
        return null;
    }
    static getProducedCharCode(chord, mapping) {
        if (!mapping) {
            return null;
        }
        if (chord.ctrlKey && chord.shiftKey && chord.altKey) {
            return mapping.withShiftAltGr;
        }
        if (chord.ctrlKey && chord.altKey) {
            return mapping.withAltGr;
        }
        if (chord.shiftKey) {
            return mapping.withShift;
        }
        return mapping.value;
    }
    static getProducedChar(chord, mapping) {
        const char = this.getProducedCharCode(chord, mapping);
        if (char === null || char.length === 0) {
            return ' --- ';
        }
        return '  ' + char + '  ';
    }
}
class WindowsKeyboardMapper {
    constructor(_isUSStandard, rawMappings, _mapAltGrToCtrlAlt) {
        this._isUSStandard = _isUSStandard;
        this._mapAltGrToCtrlAlt = _mapAltGrToCtrlAlt;
        this._keyCodeToLabel = [];
        this._scanCodeToKeyCode = [];
        this._keyCodeToLabel = [];
        this._keyCodeExists = [];
        this._keyCodeToLabel[0 ] = ( (KeyCodeUtils.toString(0 )));
        for (let scanCode = 0 ; scanCode < 193 ; scanCode++) {
            const immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[scanCode];
            if (immutableKeyCode !== -1 ) {
                this._scanCodeToKeyCode[scanCode] = immutableKeyCode;
                this._keyCodeToLabel[immutableKeyCode] = ( (KeyCodeUtils.toString(immutableKeyCode)));
                this._keyCodeExists[immutableKeyCode] = true;
            }
        }
        const producesLetter = [];
        let producesLetters = false;
        this._codeInfo = [];
        for (const strCode in rawMappings) {
            if (rawMappings.hasOwnProperty(strCode)) {
                const scanCode = ScanCodeUtils.toEnum(strCode);
                if (scanCode === 0 ) {
                    continue;
                }
                const rawMapping = rawMappings[strCode];
                const immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[scanCode];
                if (immutableKeyCode !== -1 ) {
                    const keyCode = NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[rawMapping.vkey] || 0 ;
                    if (keyCode === 0  || immutableKeyCode === keyCode) {
                        continue;
                    }
                    if (scanCode !== 134 ) {
                        continue;
                    }
                }
                const value = rawMapping.value;
                const withShift = rawMapping.withShift;
                const withAltGr = rawMapping.withAltGr;
                const withShiftAltGr = rawMapping.withShiftAltGr;
                const keyCode = NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[rawMapping.vkey] || 0 ;
                const mapping = {
                    scanCode: scanCode,
                    keyCode: keyCode,
                    value: value,
                    withShift: withShift,
                    withAltGr: withAltGr,
                    withShiftAltGr: withShiftAltGr,
                };
                this._codeInfo[scanCode] = mapping;
                this._scanCodeToKeyCode[scanCode] = keyCode;
                if (keyCode === 0 ) {
                    continue;
                }
                this._keyCodeExists[keyCode] = true;
                if (value.length === 0) {
                    this._keyCodeToLabel[keyCode] = null;
                }
                else if (value.length > 1) {
                    this._keyCodeToLabel[keyCode] = value;
                }
                else {
                    const charCode = value.charCodeAt(0);
                    if (charCode >= 97  && charCode <= 122 ) {
                        const upperCaseValue = 65  + ((charCode - 97) );
                        producesLetter[upperCaseValue] = true;
                        producesLetters = true;
                        this._keyCodeToLabel[keyCode] = String.fromCharCode(65  + ((charCode - 97) ));
                    }
                    else if (charCode >= 65  && charCode <= 90 ) {
                        producesLetter[charCode] = true;
                        producesLetters = true;
                        this._keyCodeToLabel[keyCode] = value;
                    }
                    else {
                        this._keyCodeToLabel[keyCode] = value;
                    }
                }
            }
        }
        const _registerLetterIfMissing = (charCode, keyCode) => {
            if (!producesLetter[charCode]) {
                this._keyCodeToLabel[keyCode] = String.fromCharCode(charCode);
            }
        };
        _registerLetterIfMissing(65 , 31 );
        _registerLetterIfMissing(66 , 32 );
        _registerLetterIfMissing(67 , 33 );
        _registerLetterIfMissing(68 , 34 );
        _registerLetterIfMissing(69 , 35 );
        _registerLetterIfMissing(70 , 36 );
        _registerLetterIfMissing(71 , 37 );
        _registerLetterIfMissing(72 , 38 );
        _registerLetterIfMissing(73 , 39 );
        _registerLetterIfMissing(74 , 40 );
        _registerLetterIfMissing(75 , 41 );
        _registerLetterIfMissing(76 , 42 );
        _registerLetterIfMissing(77 , 43 );
        _registerLetterIfMissing(78 , 44 );
        _registerLetterIfMissing(79 , 45 );
        _registerLetterIfMissing(80 , 46 );
        _registerLetterIfMissing(81 , 47 );
        _registerLetterIfMissing(82 , 48 );
        _registerLetterIfMissing(83 , 49 );
        _registerLetterIfMissing(84 , 50 );
        _registerLetterIfMissing(85 , 51 );
        _registerLetterIfMissing(86 , 52 );
        _registerLetterIfMissing(87 , 53 );
        _registerLetterIfMissing(88 , 54 );
        _registerLetterIfMissing(89 , 55 );
        _registerLetterIfMissing(90 , 56 );
        if (!producesLetters) {
            const _registerLabel = (keyCode, charCode) => {
                this._keyCodeToLabel[keyCode] = String.fromCharCode(charCode);
            };
            _registerLabel(80 , 59 );
            _registerLabel(81 , 61 );
            _registerLabel(82 , 44 );
            _registerLabel(83 , 45 );
            _registerLabel(84 , 46 );
            _registerLabel(85 , 47 );
            _registerLabel(86 , 96 );
            _registerLabel(87 , 91 );
            _registerLabel(88 , 92 );
            _registerLabel(89 , 93 );
            _registerLabel(90 , 39 );
        }
    }
    dumpDebugInfo() {
        const result = [];
        const immutableSamples = [
            88 ,
            104
        ];
        let cnt = 0;
        result.push(`-----------------------------------------------------------------------------------------------------------------------------------------`);
        for (let scanCode = 0 ; scanCode < 193 ; scanCode++) {
            if (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1 ) {
                if (immutableSamples.indexOf(scanCode) === -1) {
                    continue;
                }
            }
            if (cnt % 6 === 0) {
                result.push(`|       HW Code combination      |  Key  |    KeyCode combination    |          UI label         |        User settings       | WYSIWYG |`);
                result.push(`-----------------------------------------------------------------------------------------------------------------------------------------`);
            }
            cnt++;
            const mapping = this._codeInfo[scanCode];
            const strCode = ( (ScanCodeUtils.toString(scanCode)));
            const mods = [0b000, 0b010, 0b101, 0b111];
            for (const mod of mods) {
                const ctrlKey = (mod & 0b001) ? true : false;
                const shiftKey = (mod & 0b010) ? true : false;
                const altKey = (mod & 0b100) ? true : false;
                const scanCodeChord = ( (new ScanCodeChord(ctrlKey, shiftKey, altKey, false, scanCode)));
                const keyCodeChord = this._resolveChord(scanCodeChord);
                const strKeyCode = (keyCodeChord ? ( (KeyCodeUtils.toString(keyCodeChord.keyCode))) : null);
                const resolvedKb = (keyCodeChord ? ( (new WindowsNativeResolvedKeybinding(this, [keyCodeChord]))) : null);
                const outScanCode = `${ctrlKey ? 'Ctrl+' : ''}${shiftKey ? 'Shift+' : ''}${altKey ? 'Alt+' : ''}${strCode}`;
                const ariaLabel = (resolvedKb ? resolvedKb.getAriaLabel() : null);
                const outUILabel = (ariaLabel ? ariaLabel.replace(/Control\+/, 'Ctrl+') : null);
                const outUserSettings = (resolvedKb ? resolvedKb.getUserSettingsLabel() : null);
                const outKey = WindowsNativeResolvedKeybinding.getProducedChar(scanCodeChord, mapping);
                const outKb = (strKeyCode ? `${ctrlKey ? 'Ctrl+' : ''}${shiftKey ? 'Shift+' : ''}${altKey ? 'Alt+' : ''}${strKeyCode}` : null);
                const isWYSIWYG = (resolvedKb ? resolvedKb.isWYSIWYG() : false);
                const outWYSIWYG = (isWYSIWYG ? '       ' : '   NO  ');
                result.push(`| ${this._leftPad(outScanCode, 30)} | ${outKey} | ${this._leftPad(outKb, 25)} | ${this._leftPad(outUILabel, 25)} |  ${this._leftPad(outUserSettings, 25)} | ${outWYSIWYG} |`);
            }
            result.push(`-----------------------------------------------------------------------------------------------------------------------------------------`);
        }
        return result.join('\n');
    }
    _leftPad(str, cnt) {
        if (str === null) {
            str = 'null';
        }
        while (str.length < cnt) {
            str = ' ' + str;
        }
        return str;
    }
    getUILabelForKeyCode(keyCode) {
        return this._getLabelForKeyCode(keyCode);
    }
    getAriaLabelForKeyCode(keyCode) {
        return this._getLabelForKeyCode(keyCode);
    }
    getUserSettingsLabelForKeyCode(keyCode) {
        if (this._isUSStandard) {
            return KeyCodeUtils.toUserSettingsUS(keyCode);
        }
        return KeyCodeUtils.toUserSettingsGeneral(keyCode);
    }
    getElectronAcceleratorForKeyBinding(chord) {
        return KeyCodeUtils.toElectronAccelerator(chord.keyCode);
    }
    _getLabelForKeyCode(keyCode) {
        return this._keyCodeToLabel[keyCode] || ( (KeyCodeUtils.toString(0 )));
    }
    resolveKeyboardEvent(keyboardEvent) {
        const ctrlKey = keyboardEvent.ctrlKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);
        const altKey = keyboardEvent.altKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);
        const chord = ( (new KeyCodeChord(
            ctrlKey,
            keyboardEvent.shiftKey,
            altKey,
            keyboardEvent.metaKey,
            keyboardEvent.keyCode
        )));
        return (
             (new WindowsNativeResolvedKeybinding(this, [chord]))
        );
    }
    _resolveChord(chord) {
        if (!chord) {
            return null;
        }
        if (chord instanceof KeyCodeChord) {
            if (!this._keyCodeExists[chord.keyCode]) {
                return null;
            }
            return chord;
        }
        const keyCode = this._scanCodeToKeyCode[chord.scanCode] || 0 ;
        if (keyCode === 0  || !this._keyCodeExists[keyCode]) {
            return null;
        }
        return (
             (new KeyCodeChord(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.metaKey, keyCode))
        );
    }
    resolveKeybinding(keybinding) {
        const chords = toEmptyArrayIfContainsNull(( (keybinding.chords.map(chord => this._resolveChord(chord)))));
        if (chords.length > 0) {
            return [( (new WindowsNativeResolvedKeybinding(this, chords)))];
        }
        return [];
    }
}
const CHAR_CODE_TO_KEY_CODE = [];
class NativeResolvedKeybinding extends BaseResolvedKeybinding {
    constructor(mapper, os, chords) {
        super(os, chords);
        this._mapper = mapper;
    }
    _getLabel(chord) {
        return this._mapper.getUILabelForScanCodeChord(chord);
    }
    _getAriaLabel(chord) {
        return this._mapper.getAriaLabelForScanCodeChord(chord);
    }
    _getElectronAccelerator(chord) {
        return this._mapper.getElectronAcceleratorLabelForScanCodeChord(chord);
    }
    _getUserSettingsLabel(chord) {
        return this._mapper.getUserSettingsLabelForScanCodeChord(chord);
    }
    _isWYSIWYG(binding) {
        if (!binding) {
            return true;
        }
        if (IMMUTABLE_CODE_TO_KEY_CODE[binding.scanCode] !== -1 ) {
            return true;
        }
        const a = this._mapper.getAriaLabelForScanCodeChord(binding);
        const b = this._mapper.getUserSettingsLabelForScanCodeChord(binding);
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return (a.toLowerCase() === b.toLowerCase());
    }
    _getChordDispatch(chord) {
        return this._mapper.getDispatchStrForScanCodeChord(chord);
    }
    _getSingleModifierChordDispatch(chord) {
        if (((chord.scanCode === 157  || chord.scanCode === 161) ) && !chord.shiftKey && !chord.altKey && !chord.metaKey) {
            return 'ctrl';
        }
        if (((chord.scanCode === 159  || chord.scanCode === 163) ) && !chord.ctrlKey && !chord.shiftKey && !chord.metaKey) {
            return 'alt';
        }
        if (((chord.scanCode === 158  || chord.scanCode === 162) ) && !chord.ctrlKey && !chord.altKey && !chord.metaKey) {
            return 'shift';
        }
        if (((chord.scanCode === 160  || chord.scanCode === 164) ) && !chord.ctrlKey && !chord.shiftKey && !chord.altKey) {
            return 'meta';
        }
        return null;
    }
}
class ScanCodeCombo {
    constructor(ctrlKey, shiftKey, altKey, scanCode) {
        this.ctrlKey = ctrlKey;
        this.shiftKey = shiftKey;
        this.altKey = altKey;
        this.scanCode = scanCode;
    }
    toString() {
        return `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${( ( ScanCodeUtils.toString(this.scanCode)))}`;
    }
    equals(other) {
        return (this.ctrlKey === other.ctrlKey
            && this.shiftKey === other.shiftKey
            && this.altKey === other.altKey
            && this.scanCode === other.scanCode);
    }
    getProducedCharCode(mapping) {
        if (!mapping) {
            return '';
        }
        if (this.ctrlKey && this.shiftKey && this.altKey) {
            return mapping.withShiftAltGr;
        }
        if (this.ctrlKey && this.altKey) {
            return mapping.withAltGr;
        }
        if (this.shiftKey) {
            return mapping.withShift;
        }
        return mapping.value;
    }
    getProducedChar(mapping) {
        const charCode = MacLinuxKeyboardMapper.getCharCode(this.getProducedCharCode(mapping));
        if (charCode === 0) {
            return ' --- ';
        }
        if (charCode >= 768  && charCode <= 879 ) {
            return 'U+' + ( (charCode.toString(16)));
        }
        return '  ' + String.fromCharCode(charCode) + '  ';
    }
}
class KeyCodeCombo {
    constructor(ctrlKey, shiftKey, altKey, keyCode) {
        this.ctrlKey = ctrlKey;
        this.shiftKey = shiftKey;
        this.altKey = altKey;
        this.keyCode = keyCode;
    }
    toString() {
        return `${this.ctrlKey ? 'Ctrl+' : ''}${this.shiftKey ? 'Shift+' : ''}${this.altKey ? 'Alt+' : ''}${( ( KeyCodeUtils.toString(this.keyCode)))}`;
    }
}
class ScanCodeKeyCodeMapper {
    constructor() {
        this._scanCodeToKeyCode = [];
        this._keyCodeToScanCode = [];
        this._scanCodeToKeyCode = [];
        this._keyCodeToScanCode = [];
    }
    registrationComplete() {
        this._moveToEnd(56 );
        this._moveToEnd(106 );
    }
    _moveToEnd(scanCode) {
        for (let mod = 0; mod < 8; mod++) {
            const encodedKeyCodeCombos = this._scanCodeToKeyCode[(scanCode << 3) + mod];
            if (!encodedKeyCodeCombos) {
                continue;
            }
            for (let i = 0, len = encodedKeyCodeCombos.length; i < len; i++) {
                const encodedScanCodeCombos = this._keyCodeToScanCode[encodedKeyCodeCombos[i]];
                if (encodedScanCodeCombos.length === 1) {
                    continue;
                }
                for (let j = 0, len = encodedScanCodeCombos.length; j < len; j++) {
                    const entry = encodedScanCodeCombos[j];
                    const entryScanCode = (entry >>> 3);
                    if (entryScanCode === scanCode) {
                        for (let k = j + 1; k < len; k++) {
                            encodedScanCodeCombos[k - 1] = encodedScanCodeCombos[k];
                        }
                        encodedScanCodeCombos[len - 1] = entry;
                    }
                }
            }
        }
    }
    registerIfUnknown(scanCodeCombo, keyCodeCombo) {
        if (keyCodeCombo.keyCode === 0 ) {
            return;
        }
        const scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);
        const keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);
        const keyCodeIsDigit = ((keyCodeCombo.keyCode >= 21  && keyCodeCombo.keyCode <= 30) );
        const keyCodeIsLetter = ((keyCodeCombo.keyCode >= 31  && keyCodeCombo.keyCode <= 56) );
        const existingKeyCodeCombos = this._scanCodeToKeyCode[scanCodeComboEncoded];
        if (keyCodeIsDigit || keyCodeIsLetter) {
            if (existingKeyCodeCombos) {
                for (let i = 0, len = existingKeyCodeCombos.length; i < len; i++) {
                    if (existingKeyCodeCombos[i] === keyCodeComboEncoded) {
                        return;
                    }
                }
            }
        }
        else {
            if (existingKeyCodeCombos && existingKeyCodeCombos.length !== 0) {
                return;
            }
        }
        this._scanCodeToKeyCode[scanCodeComboEncoded] = this._scanCodeToKeyCode[scanCodeComboEncoded] || [];
        this._scanCodeToKeyCode[scanCodeComboEncoded].unshift(keyCodeComboEncoded);
        this._keyCodeToScanCode[keyCodeComboEncoded] = this._keyCodeToScanCode[keyCodeComboEncoded] || [];
        this._keyCodeToScanCode[keyCodeComboEncoded].unshift(scanCodeComboEncoded);
    }
    lookupKeyCodeCombo(keyCodeCombo) {
        const keyCodeComboEncoded = this._encodeKeyCodeCombo(keyCodeCombo);
        const scanCodeCombosEncoded = this._keyCodeToScanCode[keyCodeComboEncoded];
        if (!scanCodeCombosEncoded || scanCodeCombosEncoded.length === 0) {
            return [];
        }
        const result = [];
        for (let i = 0, len = scanCodeCombosEncoded.length; i < len; i++) {
            const scanCodeComboEncoded = scanCodeCombosEncoded[i];
            const ctrlKey = (scanCodeComboEncoded & 0b001) ? true : false;
            const shiftKey = (scanCodeComboEncoded & 0b010) ? true : false;
            const altKey = (scanCodeComboEncoded & 0b100) ? true : false;
            const scanCode = (scanCodeComboEncoded >>> 3);
            result[i] = ( (new ScanCodeCombo(ctrlKey, shiftKey, altKey, scanCode)));
        }
        return result;
    }
    lookupScanCodeCombo(scanCodeCombo) {
        const scanCodeComboEncoded = this._encodeScanCodeCombo(scanCodeCombo);
        const keyCodeCombosEncoded = this._scanCodeToKeyCode[scanCodeComboEncoded];
        if (!keyCodeCombosEncoded || keyCodeCombosEncoded.length === 0) {
            return [];
        }
        const result = [];
        for (let i = 0, len = keyCodeCombosEncoded.length; i < len; i++) {
            const keyCodeComboEncoded = keyCodeCombosEncoded[i];
            const ctrlKey = (keyCodeComboEncoded & 0b001) ? true : false;
            const shiftKey = (keyCodeComboEncoded & 0b010) ? true : false;
            const altKey = (keyCodeComboEncoded & 0b100) ? true : false;
            const keyCode = (keyCodeComboEncoded >>> 3);
            result[i] = ( (new KeyCodeCombo(ctrlKey, shiftKey, altKey, keyCode)));
        }
        return result;
    }
    guessStableKeyCode(scanCode) {
        if (scanCode >= 36  && scanCode <= 45 ) {
            switch (scanCode) {
                case 36 : return 22 ;
                case 37 : return 23 ;
                case 38 : return 24 ;
                case 39 : return 25 ;
                case 40 : return 26 ;
                case 41 : return 27 ;
                case 42 : return 28 ;
                case 43 : return 29 ;
                case 44 : return 30 ;
                case 45 : return 21 ;
            }
        }
        const keyCodeCombos1 = this.lookupScanCodeCombo(( (new ScanCodeCombo(false, false, false, scanCode))));
        const keyCodeCombos2 = this.lookupScanCodeCombo(( (new ScanCodeCombo(false, true, false, scanCode))));
        if (keyCodeCombos1.length === 1 && keyCodeCombos2.length === 1) {
            const shiftKey1 = keyCodeCombos1[0].shiftKey;
            const keyCode1 = keyCodeCombos1[0].keyCode;
            const shiftKey2 = keyCodeCombos2[0].shiftKey;
            const keyCode2 = keyCodeCombos2[0].keyCode;
            if (keyCode1 === keyCode2 && shiftKey1 !== shiftKey2) {
                return keyCode1;
            }
        }
        return -1 ;
    }
    _encodeScanCodeCombo(scanCodeCombo) {
        return this._encode(scanCodeCombo.ctrlKey, scanCodeCombo.shiftKey, scanCodeCombo.altKey, scanCodeCombo.scanCode);
    }
    _encodeKeyCodeCombo(keyCodeCombo) {
        return this._encode(keyCodeCombo.ctrlKey, keyCodeCombo.shiftKey, keyCodeCombo.altKey, keyCodeCombo.keyCode);
    }
    _encode(ctrlKey, shiftKey, altKey, principal) {
        return (((ctrlKey ? 1 : 0) << 0)
            | ((shiftKey ? 1 : 0) << 1)
            | ((altKey ? 1 : 0) << 2)
            | principal << 3) >>> 0;
    }
}
class MacLinuxKeyboardMapper {
    constructor(_isUSStandard, rawMappings, _mapAltGrToCtrlAlt, _OS) {
        this._isUSStandard = _isUSStandard;
        this._mapAltGrToCtrlAlt = _mapAltGrToCtrlAlt;
        this._OS = _OS;
        this._scanCodeToLabel = [];
        this._scanCodeToDispatch = [];
        this._codeInfo = [];
        this._scanCodeKeyCodeMapper = ( (new ScanCodeKeyCodeMapper()));
        this._scanCodeToLabel = [];
        this._scanCodeToDispatch = [];
        const _registerIfUnknown = (hwCtrlKey, hwShiftKey, hwAltKey, scanCode, kbCtrlKey, kbShiftKey, kbAltKey, keyCode) => {
            this._scanCodeKeyCodeMapper.registerIfUnknown(( (new ScanCodeCombo(
                hwCtrlKey ? true : false,
                hwShiftKey ? true : false,
                hwAltKey ? true : false,
                scanCode
            ))), ( (new KeyCodeCombo(
                kbCtrlKey ? true : false,
                kbShiftKey ? true : false,
                kbAltKey ? true : false,
                keyCode
            ))));
        };
        const _registerAllCombos = (_ctrlKey, _shiftKey, _altKey, scanCode, keyCode) => {
            for (let ctrlKey = _ctrlKey; ctrlKey <= 1; ctrlKey++) {
                for (let shiftKey = _shiftKey; shiftKey <= 1; shiftKey++) {
                    for (let altKey = _altKey; altKey <= 1; altKey++) {
                        _registerIfUnknown(ctrlKey, shiftKey, altKey, scanCode, ctrlKey, shiftKey, altKey, keyCode);
                    }
                }
            }
        };
        for (let scanCode = 0 ; scanCode < 193 ; scanCode++) {
            this._scanCodeToLabel[scanCode] = null;
        }
        for (let scanCode = 0 ; scanCode < 193 ; scanCode++) {
            this._scanCodeToDispatch[scanCode] = null;
        }
        for (let scanCode = 0 ; scanCode < 193 ; scanCode++) {
            const keyCode = IMMUTABLE_CODE_TO_KEY_CODE[scanCode];
            if (keyCode !== -1 ) {
                _registerAllCombos(0, 0, 0, scanCode, keyCode);
                this._scanCodeToLabel[scanCode] = ( (KeyCodeUtils.toString(keyCode)));
                if (keyCode === 0  || keyCode === 5  || keyCode === 57  || keyCode === 6  || keyCode === 4 ) {
                    this._scanCodeToDispatch[scanCode] = null;
                }
                else {
                    this._scanCodeToDispatch[scanCode] = `[${( ( ScanCodeUtils.toString(scanCode)))}]`;
                }
            }
        }
        const missingLatinLettersOverride = {};
        {
            const producesLatinLetter = [];
            for (const strScanCode in rawMappings) {
                if (rawMappings.hasOwnProperty(strScanCode)) {
                    const scanCode = ScanCodeUtils.toEnum(strScanCode);
                    if (scanCode === 0 ) {
                        continue;
                    }
                    if (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1 ) {
                        continue;
                    }
                    const rawMapping = rawMappings[strScanCode];
                    const value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);
                    if (value >= 97  && value <= 122 ) {
                        const upperCaseValue = 65  + ((value - 97) );
                        producesLatinLetter[upperCaseValue] = true;
                    }
                }
            }
            const _registerLetterIfMissing = (charCode, scanCode, value, withShift) => {
                if (!producesLatinLetter[charCode]) {
                    missingLatinLettersOverride[( (ScanCodeUtils.toString(scanCode)))] = {
                        value: value,
                        withShift: withShift,
                        withAltGr: '',
                        withShiftAltGr: ''
                    };
                }
            };
            _registerLetterIfMissing(65 , 10 , 'a', 'A');
            _registerLetterIfMissing(66 , 11 , 'b', 'B');
            _registerLetterIfMissing(67 , 12 , 'c', 'C');
            _registerLetterIfMissing(68 , 13 , 'd', 'D');
            _registerLetterIfMissing(69 , 14 , 'e', 'E');
            _registerLetterIfMissing(70 , 15 , 'f', 'F');
            _registerLetterIfMissing(71 , 16 , 'g', 'G');
            _registerLetterIfMissing(72 , 17 , 'h', 'H');
            _registerLetterIfMissing(73 , 18 , 'i', 'I');
            _registerLetterIfMissing(74 , 19 , 'j', 'J');
            _registerLetterIfMissing(75 , 20 , 'k', 'K');
            _registerLetterIfMissing(76 , 21 , 'l', 'L');
            _registerLetterIfMissing(77 , 22 , 'm', 'M');
            _registerLetterIfMissing(78 , 23 , 'n', 'N');
            _registerLetterIfMissing(79 , 24 , 'o', 'O');
            _registerLetterIfMissing(80 , 25 , 'p', 'P');
            _registerLetterIfMissing(81 , 26 , 'q', 'Q');
            _registerLetterIfMissing(82 , 27 , 'r', 'R');
            _registerLetterIfMissing(83 , 28 , 's', 'S');
            _registerLetterIfMissing(84 , 29 , 't', 'T');
            _registerLetterIfMissing(85 , 30 , 'u', 'U');
            _registerLetterIfMissing(86 , 31 , 'v', 'V');
            _registerLetterIfMissing(87 , 32 , 'w', 'W');
            _registerLetterIfMissing(88 , 33 , 'x', 'X');
            _registerLetterIfMissing(89 , 34 , 'y', 'Y');
            _registerLetterIfMissing(90 , 35 , 'z', 'Z');
        }
        const mappings = [];
        let mappingsLen = 0;
        for (const strScanCode in rawMappings) {
            if (rawMappings.hasOwnProperty(strScanCode)) {
                const scanCode = ScanCodeUtils.toEnum(strScanCode);
                if (scanCode === 0 ) {
                    continue;
                }
                if (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1 ) {
                    continue;
                }
                this._codeInfo[scanCode] = rawMappings[strScanCode];
                const rawMapping = missingLatinLettersOverride[strScanCode] || rawMappings[strScanCode];
                const value = MacLinuxKeyboardMapper.getCharCode(rawMapping.value);
                const withShift = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShift);
                const withAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withAltGr);
                const withShiftAltGr = MacLinuxKeyboardMapper.getCharCode(rawMapping.withShiftAltGr);
                const mapping = {
                    scanCode: scanCode,
                    value: value,
                    withShift: withShift,
                    withAltGr: withAltGr,
                    withShiftAltGr: withShiftAltGr,
                };
                mappings[mappingsLen++] = mapping;
                this._scanCodeToDispatch[scanCode] = `[${( ( ScanCodeUtils.toString(scanCode)))}]`;
                if (value >= 97  && value <= 122 ) {
                    const upperCaseValue = 65  + ((value - 97) );
                    this._scanCodeToLabel[scanCode] = String.fromCharCode(upperCaseValue);
                }
                else if (value >= 65  && value <= 90 ) {
                    this._scanCodeToLabel[scanCode] = String.fromCharCode(value);
                }
                else if (value) {
                    this._scanCodeToLabel[scanCode] = String.fromCharCode(value);
                }
                else {
                    this._scanCodeToLabel[scanCode] = null;
                }
            }
        }
        for (let i = mappings.length - 1; i >= 0; i--) {
            const mapping = mappings[i];
            const scanCode = mapping.scanCode;
            const withShiftAltGr = mapping.withShiftAltGr;
            if (withShiftAltGr === mapping.withAltGr || withShiftAltGr === mapping.withShift || withShiftAltGr === mapping.value) {
                continue;
            }
            const kb = MacLinuxKeyboardMapper._charCodeToKb(withShiftAltGr);
            if (!kb) {
                continue;
            }
            const kbShiftKey = kb.shiftKey;
            const keyCode = kb.keyCode;
            if (kbShiftKey) {
                _registerIfUnknown(1, 1, 1, scanCode, 0, 1, 0, keyCode);
            }
            else {
                _registerIfUnknown(1, 1, 1, scanCode, 0, 0, 0, keyCode);
            }
        }
        for (let i = mappings.length - 1; i >= 0; i--) {
            const mapping = mappings[i];
            const scanCode = mapping.scanCode;
            const withAltGr = mapping.withAltGr;
            if (withAltGr === mapping.withShift || withAltGr === mapping.value) {
                continue;
            }
            const kb = MacLinuxKeyboardMapper._charCodeToKb(withAltGr);
            if (!kb) {
                continue;
            }
            const kbShiftKey = kb.shiftKey;
            const keyCode = kb.keyCode;
            if (kbShiftKey) {
                _registerIfUnknown(1, 0, 1, scanCode, 0, 1, 0, keyCode);
            }
            else {
                _registerIfUnknown(1, 0, 1, scanCode, 0, 0, 0, keyCode);
            }
        }
        for (let i = mappings.length - 1; i >= 0; i--) {
            const mapping = mappings[i];
            const scanCode = mapping.scanCode;
            const withShift = mapping.withShift;
            if (withShift === mapping.value) {
                continue;
            }
            const kb = MacLinuxKeyboardMapper._charCodeToKb(withShift);
            if (!kb) {
                continue;
            }
            const kbShiftKey = kb.shiftKey;
            const keyCode = kb.keyCode;
            if (kbShiftKey) {
                _registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode);
                _registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode);
                _registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode);
                _registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode);
            }
            else {
                _registerIfUnknown(0, 1, 0, scanCode, 0, 0, 0, keyCode);
                _registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode);
                _registerIfUnknown(0, 1, 1, scanCode, 0, 0, 1, keyCode);
                _registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode);
                _registerIfUnknown(1, 1, 0, scanCode, 1, 0, 0, keyCode);
                _registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode);
                _registerIfUnknown(1, 1, 1, scanCode, 1, 0, 1, keyCode);
                _registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode);
            }
        }
        for (let i = mappings.length - 1; i >= 0; i--) {
            const mapping = mappings[i];
            const scanCode = mapping.scanCode;
            const kb = MacLinuxKeyboardMapper._charCodeToKb(mapping.value);
            if (!kb) {
                continue;
            }
            const kbShiftKey = kb.shiftKey;
            const keyCode = kb.keyCode;
            if (kbShiftKey) {
                _registerIfUnknown(0, 0, 0, scanCode, 0, 1, 0, keyCode);
                _registerIfUnknown(0, 0, 1, scanCode, 0, 1, 1, keyCode);
                _registerIfUnknown(1, 0, 0, scanCode, 1, 1, 0, keyCode);
                _registerIfUnknown(1, 0, 1, scanCode, 1, 1, 1, keyCode);
            }
            else {
                _registerIfUnknown(0, 0, 0, scanCode, 0, 0, 0, keyCode);
                _registerIfUnknown(0, 0, 1, scanCode, 0, 0, 1, keyCode);
                _registerIfUnknown(0, 1, 0, scanCode, 0, 1, 0, keyCode);
                _registerIfUnknown(0, 1, 1, scanCode, 0, 1, 1, keyCode);
                _registerIfUnknown(1, 0, 0, scanCode, 1, 0, 0, keyCode);
                _registerIfUnknown(1, 0, 1, scanCode, 1, 0, 1, keyCode);
                _registerIfUnknown(1, 1, 0, scanCode, 1, 1, 0, keyCode);
                _registerIfUnknown(1, 1, 1, scanCode, 1, 1, 1, keyCode);
            }
        }
        _registerAllCombos(0, 0, 0, 36 , 22 );
        _registerAllCombos(0, 0, 0, 37 , 23 );
        _registerAllCombos(0, 0, 0, 38 , 24 );
        _registerAllCombos(0, 0, 0, 39 , 25 );
        _registerAllCombos(0, 0, 0, 40 , 26 );
        _registerAllCombos(0, 0, 0, 41 , 27 );
        _registerAllCombos(0, 0, 0, 42 , 28 );
        _registerAllCombos(0, 0, 0, 43 , 29 );
        _registerAllCombos(0, 0, 0, 44 , 30 );
        _registerAllCombos(0, 0, 0, 45 , 21 );
        this._scanCodeKeyCodeMapper.registrationComplete();
    }
    dumpDebugInfo() {
        const result = [];
        const immutableSamples = [
            88 ,
            104
        ];
        let cnt = 0;
        result.push(`isUSStandard: ${this._isUSStandard}`);
        result.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);
        for (let scanCode = 0 ; scanCode < 193 ; scanCode++) {
            if (IMMUTABLE_CODE_TO_KEY_CODE[scanCode] !== -1 ) {
                if (immutableSamples.indexOf(scanCode) === -1) {
                    continue;
                }
            }
            if (cnt % 4 === 0) {
                result.push(`|       HW Code combination      |  Key  |    KeyCode combination    | Pri |          UI label         |         User settings          |    Electron accelerator   |       Dispatching string       | WYSIWYG |`);
                result.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);
            }
            cnt++;
            const mapping = this._codeInfo[scanCode];
            for (let mod = 0; mod < 8; mod++) {
                const hwCtrlKey = (mod & 0b001) ? true : false;
                const hwShiftKey = (mod & 0b010) ? true : false;
                const hwAltKey = (mod & 0b100) ? true : false;
                const scanCodeCombo = ( (new ScanCodeCombo(hwCtrlKey, hwShiftKey, hwAltKey, scanCode)));
                const resolvedKb = this.resolveKeyboardEvent({
                    _standardKeyboardEventBrand: true,
                    ctrlKey: scanCodeCombo.ctrlKey,
                    shiftKey: scanCodeCombo.shiftKey,
                    altKey: scanCodeCombo.altKey,
                    metaKey: false,
                    altGraphKey: false,
                    keyCode: -1 ,
                    code: ( (ScanCodeUtils.toString(scanCode)))
                });
                const outScanCodeCombo = ( (scanCodeCombo.toString()));
                const outKey = scanCodeCombo.getProducedChar(mapping);
                const ariaLabel = resolvedKb.getAriaLabel();
                const outUILabel = (ariaLabel ? ariaLabel.replace(/Control\+/, 'Ctrl+') : null);
                const outUserSettings = resolvedKb.getUserSettingsLabel();
                const outElectronAccelerator = resolvedKb.getElectronAccelerator();
                const outDispatchStr = resolvedKb.getDispatchChords()[0];
                const isWYSIWYG = (resolvedKb ? resolvedKb.isWYSIWYG() : false);
                const outWYSIWYG = (isWYSIWYG ? '       ' : '   NO  ');
                const kbCombos = this._scanCodeKeyCodeMapper.lookupScanCodeCombo(scanCodeCombo);
                if (kbCombos.length === 0) {
                    result.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad('', 25)} | ${this._leftPad('', 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);
                }
                else {
                    for (let i = 0, len = kbCombos.length; i < len; i++) {
                        const kbCombo = kbCombos[i];
                        let colPriority;
                        const scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(kbCombo);
                        if (scanCodeCombos.length === 1) {
                            colPriority = '';
                        }
                        else {
                            let priority = -1;
                            for (let j = 0; j < scanCodeCombos.length; j++) {
                                if (scanCodeCombos[j].equals(scanCodeCombo)) {
                                    priority = j + 1;
                                    break;
                                }
                            }
                            colPriority = String(priority);
                        }
                        const outKeybinding = ( (kbCombo.toString()));
                        if (i === 0) {
                            result.push(`| ${this._leftPad(outScanCodeCombo, 30)} | ${outKey} | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad(outUILabel, 25)} | ${this._leftPad(outUserSettings, 30)} | ${this._leftPad(outElectronAccelerator, 25)} | ${this._leftPad(outDispatchStr, 30)} | ${outWYSIWYG} |`);
                        }
                        else {
                            result.push(`| ${this._leftPad('', 30)} |       | ${this._leftPad(outKeybinding, 25)} | ${this._leftPad(colPriority, 3)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} | ${this._leftPad('', 25)} | ${this._leftPad('', 30)} |         |`);
                        }
                    }
                }
            }
            result.push(`----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------`);
        }
        return result.join('\n');
    }
    _leftPad(str, cnt) {
        if (str === null) {
            str = 'null';
        }
        while (str.length < cnt) {
            str = ' ' + str;
        }
        return str;
    }
    keyCodeChordToScanCodeChord(chord) {
        if (chord.keyCode === 3 ) {
            return [( (new ScanCodeChord(
                chord.ctrlKey,
                chord.shiftKey,
                chord.altKey,
                chord.metaKey,
                46
            )))];
        }
        const scanCodeCombos = this._scanCodeKeyCodeMapper.lookupKeyCodeCombo(( (new KeyCodeCombo(chord.ctrlKey, chord.shiftKey, chord.altKey, chord.keyCode))));
        const result = [];
        for (let i = 0, len = scanCodeCombos.length; i < len; i++) {
            const scanCodeCombo = scanCodeCombos[i];
            result[i] = ( (new ScanCodeChord(
                scanCodeCombo.ctrlKey,
                scanCodeCombo.shiftKey,
                scanCodeCombo.altKey,
                chord.metaKey,
                scanCodeCombo.scanCode
            )));
        }
        return result;
    }
    getUILabelForScanCodeChord(chord) {
        if (!chord) {
            return null;
        }
        if (chord.isDuplicateModifierCase()) {
            return '';
        }
        if (this._OS === 2 ) {
            switch (chord.scanCode) {
                case 86 :
                    return '';
                case 88 :
                    return '';
                case 85 :
                    return '';
                case 87 :
                    return '';
            }
        }
        return this._scanCodeToLabel[chord.scanCode];
    }
    getAriaLabelForScanCodeChord(chord) {
        if (!chord) {
            return null;
        }
        if (chord.isDuplicateModifierCase()) {
            return '';
        }
        return this._scanCodeToLabel[chord.scanCode];
    }
    getDispatchStrForScanCodeChord(chord) {
        const codeDispatch = this._scanCodeToDispatch[chord.scanCode];
        if (!codeDispatch) {
            return null;
        }
        let result = '';
        if (chord.ctrlKey) {
            result += 'ctrl+';
        }
        if (chord.shiftKey) {
            result += 'shift+';
        }
        if (chord.altKey) {
            result += 'alt+';
        }
        if (chord.metaKey) {
            result += 'meta+';
        }
        result += codeDispatch;
        return result;
    }
    getUserSettingsLabelForScanCodeChord(chord) {
        if (!chord) {
            return null;
        }
        if (chord.isDuplicateModifierCase()) {
            return '';
        }
        const immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[chord.scanCode];
        if (immutableKeyCode !== -1 ) {
            return KeyCodeUtils.toUserSettingsUS(immutableKeyCode).toLowerCase();
        }
        const constantKeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(chord.scanCode);
        if (constantKeyCode !== -1 ) {
            const reverseChords = this.keyCodeChordToScanCodeChord(( (new KeyCodeChord(
                chord.ctrlKey,
                chord.shiftKey,
                chord.altKey,
                chord.metaKey,
                constantKeyCode
            ))));
            for (let i = 0, len = reverseChords.length; i < len; i++) {
                const reverseChord = reverseChords[i];
                if (reverseChord.scanCode === chord.scanCode) {
                    return KeyCodeUtils.toUserSettingsUS(constantKeyCode).toLowerCase();
                }
            }
        }
        return this._scanCodeToDispatch[chord.scanCode];
    }
    getElectronAcceleratorLabelForScanCodeChord(chord) {
        if (!chord) {
            return null;
        }
        const immutableKeyCode = IMMUTABLE_CODE_TO_KEY_CODE[chord.scanCode];
        if (immutableKeyCode !== -1 ) {
            return KeyCodeUtils.toElectronAccelerator(immutableKeyCode);
        }
        const constantKeyCode = this._scanCodeKeyCodeMapper.guessStableKeyCode(chord.scanCode);
        if (this._OS === 3  && !this._isUSStandard) {
            const isOEMKey = ((constantKeyCode === 80
                || constantKeyCode === 81
                || constantKeyCode === 82
                || constantKeyCode === 83
                || constantKeyCode === 84
                || constantKeyCode === 85
                || constantKeyCode === 86
                || constantKeyCode === 87
                || constantKeyCode === 88  || constantKeyCode === 89) );
            if (isOEMKey) {
                return null;
            }
        }
        if (constantKeyCode !== -1 ) {
            return KeyCodeUtils.toElectronAccelerator(constantKeyCode);
        }
        return null;
    }
    _toResolvedKeybinding(chordParts) {
        if (chordParts.length === 0) {
            return [];
        }
        const result = [];
        this._generateResolvedKeybindings(chordParts, 0, [], result);
        return result;
    }
    _generateResolvedKeybindings(chordParts, currentIndex, previousParts, result) {
        const chordPart = chordParts[currentIndex];
        const isFinalIndex = currentIndex === chordParts.length - 1;
        for (let i = 0, len = chordPart.length; i < len; i++) {
            const chords = [...previousParts, chordPart[i]];
            if (isFinalIndex) {
                result.push(( (new NativeResolvedKeybinding(this, this._OS, chords))));
            }
            else {
                this._generateResolvedKeybindings(chordParts, currentIndex + 1, chords, result);
            }
        }
    }
    resolveKeyboardEvent(keyboardEvent) {
        let code = ScanCodeUtils.toEnum(keyboardEvent.code);
        if (code === 94 ) {
            code = 46 ;
        }
        const keyCode = keyboardEvent.keyCode;
        if (((keyCode === 15) )
            || ((keyCode === 16) )
            || ((keyCode === 17) )
            || ((keyCode === 18) )
            || ((keyCode === 20) )
            || ((keyCode === 19) )
            || ((keyCode === 14) )
            || ((keyCode === 13) )
            || ((keyCode === 12) )
            || ((keyCode === 11) )
            || ((keyCode === 1) )) {
            const immutableScanCode = IMMUTABLE_KEY_CODE_TO_CODE[keyCode];
            if (immutableScanCode !== -1 ) {
                code = immutableScanCode;
            }
        }
        else {
            if (((code === 95) )
                || ((code === 96) )
                || ((code === 97) )
                || ((code === 98) )
                || ((code === 99) )
                || ((code === 100) )
                || ((code === 101) )
                || ((code === 102) )
                || ((code === 103) )
                || ((code === 104) )
                || ((code === 105) )) {
                if (keyCode >= 0) {
                    const immutableScanCode = IMMUTABLE_KEY_CODE_TO_CODE[keyCode];
                    if (immutableScanCode !== -1 ) {
                        code = immutableScanCode;
                    }
                }
            }
        }
        const ctrlKey = keyboardEvent.ctrlKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);
        const altKey = keyboardEvent.altKey || (this._mapAltGrToCtrlAlt && keyboardEvent.altGraphKey);
        const chord = ( (new ScanCodeChord(ctrlKey, keyboardEvent.shiftKey, altKey, keyboardEvent.metaKey, code)));
        return (
             (new NativeResolvedKeybinding(this, this._OS, [chord]))
        );
    }
    _resolveChord(chord) {
        if (!chord) {
            return [];
        }
        if (chord instanceof ScanCodeChord) {
            return [chord];
        }
        return this.keyCodeChordToScanCodeChord(chord);
    }
    resolveKeybinding(keybinding) {
        const chords = ( (keybinding.chords.map(chord => this._resolveChord(chord))));
        return this._toResolvedKeybinding(chords);
    }
    static _redirectCharCode(charCode) {
        switch (charCode) {
            case 12290 : return 46 ;
            case 12300 : return 91 ;
            case 12301 : return 93 ;
            case 12304 : return 91 ;
            case 12305 : return 93 ;
            case 65307 : return 59 ;
            case 65292 : return 44 ;
        }
        return charCode;
    }
    static _charCodeToKb(charCode) {
        charCode = this._redirectCharCode(charCode);
        if (charCode < CHAR_CODE_TO_KEY_CODE.length) {
            return CHAR_CODE_TO_KEY_CODE[charCode];
        }
        return null;
    }
    static getCharCode(char) {
        if (char.length === 0) {
            return 0;
        }
        const charCode = char.charCodeAt(0);
        switch (charCode) {
            case 768 : return 96 ;
            case 769 : return 180 ;
            case 770 : return 94 ;
            case 771 : return 732 ;
            case 772 : return 175 ;
            case 773 : return 8254 ;
            case 774 : return 728 ;
            case 775 : return 729 ;
            case 776 : return 168 ;
            case 778 : return 730 ;
            case 779 : return 733 ;
        }
        return charCode;
    }
}
(function () {
    function define(charCode, keyCode, shiftKey) {
        for (let i = CHAR_CODE_TO_KEY_CODE.length; i < charCode; i++) {
            CHAR_CODE_TO_KEY_CODE[i] = null;
        }
        CHAR_CODE_TO_KEY_CODE[charCode] = { keyCode: keyCode, shiftKey: shiftKey };
    }
    for (let chCode = 65 ; chCode <= 90 ; chCode++) {
        define(chCode, 31  + ((chCode - 65) ), true);
    }
    for (let chCode = 97 ; chCode <= 122 ; chCode++) {
        define(chCode, 31  + ((chCode - 97) ), false);
    }
    define(59 , 80 , false);
    define(58 , 80 , true);
    define(61 , 81 , false);
    define(43 , 81 , true);
    define(44 , 82 , false);
    define(60 , 82 , true);
    define(45 , 83 , false);
    define(95 , 83 , true);
    define(46 , 84 , false);
    define(62 , 84 , true);
    define(47 , 85 , false);
    define(63 , 85 , true);
    define(96 , 86 , false);
    define(126 , 86 , true);
    define(91 , 87 , false);
    define(123 , 87 , true);
    define(92 , 88 , false);
    define(124 , 88 , true);
    define(93 , 89 , false);
    define(125 , 89 , true);
    define(39 , 90 , false);
    define(34 , 90 , true);
})();
function __variableDynamicImportRuntime0__(path) {
  switch (path) {
    case './keyboardLayouts/layout.contribution.darwin.js': return import('./layout.contribution.darwin.js').then(module => module.default ?? module);
    case './keyboardLayouts/layout.contribution.linux.js': return import('./layout.contribution.linux.js').then(module => module.default ?? module);
    case './keyboardLayouts/layout.contribution.win.js': return import('./layout.contribution.win.js').then(module => module.default ?? module);
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }
class BrowserKeyboardMapperFactoryBase extends Disposable {
    get activeKeymap() {
        return this._activeKeymapInfo;
    }
    get keymapInfos() {
        return this._keymapInfos;
    }
    get activeKeyboardLayout() {
        if (!this._initialized) {
            return null;
        }
        return this._activeKeymapInfo?.layout ?? null;
    }
    get activeKeyMapping() {
        if (!this._initialized) {
            return null;
        }
        return this._activeKeymapInfo?.mapping ?? null;
    }
    get keyboardLayouts() {
        return (
             (this._keymapInfos.map(keymapInfo => keymapInfo.layout))
        );
    }
    constructor(_configurationService) {
        super();
        this._configurationService = _configurationService;
        this._onDidChangeKeyboardMapper = ( (new Emitter()));
        this.onDidChangeKeyboardMapper = this._onDidChangeKeyboardMapper.event;
        this._keyboardMapper = null;
        this._initialized = false;
        this._keymapInfos = [];
        this._mru = [];
        this._activeKeymapInfo = null;
        if (navigator.keyboard && navigator.keyboard.addEventListener) {
            navigator.keyboard.addEventListener('layoutchange', () => {
                this._getBrowserKeyMapping().then((mapping) => {
                    if (this.isKeyMappingActive(mapping)) {
                        return;
                    }
                    this.setLayoutFromBrowserAPI();
                });
            });
        }
        this._register(this._configurationService.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration('keyboard')) {
                this._keyboardMapper = null;
                this._onDidChangeKeyboardMapper.fire();
            }
        }));
    }
    registerKeyboardLayout(layout) {
        this._keymapInfos.push(layout);
        this._mru = this._keymapInfos;
    }
    removeKeyboardLayout(layout) {
        let index = this._mru.indexOf(layout);
        this._mru.splice(index, 1);
        index = this._keymapInfos.indexOf(layout);
        this._keymapInfos.splice(index, 1);
    }
    getMatchedKeymapInfo(keyMapping) {
        if (!keyMapping) {
            return null;
        }
        const usStandard = this.getUSStandardLayout();
        if (usStandard) {
            let maxScore = usStandard.getScore(keyMapping);
            if (maxScore === 0) {
                return {
                    result: usStandard,
                    score: 0
                };
            }
            let result = usStandard;
            for (let i = 0; i < this._mru.length; i++) {
                const score = this._mru[i].getScore(keyMapping);
                if (score > maxScore) {
                    if (score === 0) {
                        return {
                            result: this._mru[i],
                            score: 0
                        };
                    }
                    maxScore = score;
                    result = this._mru[i];
                }
            }
            return {
                result,
                score: maxScore
            };
        }
        for (let i = 0; i < this._mru.length; i++) {
            if (this._mru[i].fuzzyEqual(keyMapping)) {
                return {
                    result: this._mru[i],
                    score: 0
                };
            }
        }
        return null;
    }
    getUSStandardLayout() {
        const usStandardLayouts = this._mru.filter(layout => layout.layout.isUSStandard);
        if (usStandardLayouts.length) {
            return usStandardLayouts[0];
        }
        return null;
    }
    isKeyMappingActive(keymap) {
        return this._activeKeymapInfo && keymap && this._activeKeymapInfo.fuzzyEqual(keymap);
    }
    setUSKeyboardLayout() {
        this._activeKeymapInfo = this.getUSStandardLayout();
    }
    setActiveKeyMapping(keymap) {
        let keymapUpdated = false;
        const matchedKeyboardLayout = this.getMatchedKeymapInfo(keymap);
        if (matchedKeyboardLayout) {
            if (!this._activeKeymapInfo) {
                this._activeKeymapInfo = matchedKeyboardLayout.result;
                keymapUpdated = true;
            }
            else if (keymap) {
                if (matchedKeyboardLayout.result.getScore(keymap) > this._activeKeymapInfo.getScore(keymap)) {
                    this._activeKeymapInfo = matchedKeyboardLayout.result;
                    keymapUpdated = true;
                }
            }
        }
        if (!this._activeKeymapInfo) {
            this._activeKeymapInfo = this.getUSStandardLayout();
            keymapUpdated = true;
        }
        if (!this._activeKeymapInfo || !keymapUpdated) {
            return;
        }
        const index = this._mru.indexOf(this._activeKeymapInfo);
        this._mru.splice(index, 1);
        this._mru.unshift(this._activeKeymapInfo);
        this._setKeyboardData(this._activeKeymapInfo);
    }
    setActiveKeymapInfo(keymapInfo) {
        this._activeKeymapInfo = keymapInfo;
        const index = this._mru.indexOf(this._activeKeymapInfo);
        if (index === 0) {
            return;
        }
        this._mru.splice(index, 1);
        this._mru.unshift(this._activeKeymapInfo);
        this._setKeyboardData(this._activeKeymapInfo);
    }
    setLayoutFromBrowserAPI() {
        this._updateKeyboardLayoutAsync(this._initialized);
    }
    _updateKeyboardLayoutAsync(initialized, keyboardEvent) {
        if (!initialized) {
            return;
        }
        this._getBrowserKeyMapping(keyboardEvent).then(keyMap => {
            if (this.isKeyMappingActive(keyMap)) {
                return;
            }
            this.setActiveKeyMapping(keyMap);
        });
    }
    getKeyboardMapper() {
        const config = readKeyboardConfig(this._configurationService);
        if (config.dispatch === 1  || !this._initialized || !this._activeKeymapInfo) {
            return (
                 (new FallbackKeyboardMapper(config.mapAltGrToCtrlAlt, OS))
            );
        }
        if (!this._keyboardMapper) {
            this._keyboardMapper = ( (new CachedKeyboardMapper(
                BrowserKeyboardMapperFactory._createKeyboardMapper(this._activeKeymapInfo, config.mapAltGrToCtrlAlt)
            )));
        }
        return this._keyboardMapper;
    }
    validateCurrentKeyboardMapping(keyboardEvent) {
        if (!this._initialized) {
            return;
        }
        const isCurrentKeyboard = this._validateCurrentKeyboardMapping(keyboardEvent);
        if (isCurrentKeyboard) {
            return;
        }
        this._updateKeyboardLayoutAsync(true, keyboardEvent);
    }
    setKeyboardLayout(layoutName) {
        const matchedLayouts = this.keymapInfos.filter(keymapInfo => getKeyboardLayoutId(keymapInfo.layout) === layoutName);
        if (matchedLayouts.length > 0) {
            this.setActiveKeymapInfo(matchedLayouts[0]);
        }
    }
    _setKeyboardData(keymapInfo) {
        this._initialized = true;
        this._keyboardMapper = null;
        this._onDidChangeKeyboardMapper.fire();
    }
    static _createKeyboardMapper(keymapInfo, mapAltGrToCtrlAlt) {
        const rawMapping = keymapInfo.mapping;
        const isUSStandard = !!keymapInfo.layout.isUSStandard;
        if (OS === 1 ) {
            return (
                 (new WindowsKeyboardMapper(isUSStandard, rawMapping, mapAltGrToCtrlAlt))
            );
        }
        if (( (Object.keys(rawMapping))).length === 0) {
            return (
                 (new FallbackKeyboardMapper(mapAltGrToCtrlAlt, OS))
            );
        }
        return (
             (new MacLinuxKeyboardMapper(isUSStandard, rawMapping, mapAltGrToCtrlAlt, OS))
        );
    }
    _validateCurrentKeyboardMapping(keyboardEvent) {
        if (!this._initialized) {
            return true;
        }
        const standardKeyboardEvent = keyboardEvent;
        const currentKeymap = this._activeKeymapInfo;
        if (!currentKeymap) {
            return true;
        }
        if (standardKeyboardEvent.browserEvent.key === 'Dead' || standardKeyboardEvent.browserEvent.isComposing) {
            return true;
        }
        const mapping = currentKeymap.mapping[standardKeyboardEvent.code];
        if (!mapping) {
            return false;
        }
        if (mapping.value === '') {
            if (keyboardEvent.ctrlKey || keyboardEvent.metaKey) {
                setTimeout(() => {
                    this._getBrowserKeyMapping().then((keymap) => {
                        if (this.isKeyMappingActive(keymap)) {
                            return;
                        }
                        this.setLayoutFromBrowserAPI();
                    });
                }, 350);
            }
            return true;
        }
        const expectedValue = standardKeyboardEvent.altKey && standardKeyboardEvent.shiftKey ? mapping.withShiftAltGr :
            standardKeyboardEvent.altKey ? mapping.withAltGr :
                standardKeyboardEvent.shiftKey ? mapping.withShift : mapping.value;
        const isDead = (standardKeyboardEvent.altKey && standardKeyboardEvent.shiftKey && mapping.withShiftAltGrIsDeadKey) ||
            (standardKeyboardEvent.altKey && mapping.withAltGrIsDeadKey) ||
            (standardKeyboardEvent.shiftKey && mapping.withShiftIsDeadKey) ||
            mapping.valueIsDeadKey;
        if (isDead && standardKeyboardEvent.browserEvent.key !== 'Dead') {
            return false;
        }
        if (!isDead && standardKeyboardEvent.browserEvent.key !== expectedValue) {
            return false;
        }
        return true;
    }
    async _getBrowserKeyMapping(keyboardEvent) {
        if (navigator.keyboard) {
            try {
                return navigator.keyboard.getLayoutMap().then((e) => {
                    const ret = {};
                    for (const key of e) {
                        ret[key[0]] = {
                            'value': key[1],
                            'withShift': '',
                            'withAltGr': '',
                            'withShiftAltGr': ''
                        };
                    }
                    return ret;
                });
            }
            catch {
            }
        }
        else if (keyboardEvent && !keyboardEvent.shiftKey && !keyboardEvent.altKey && !keyboardEvent.metaKey && !keyboardEvent.metaKey) {
            const ret = {};
            const standardKeyboardEvent = keyboardEvent;
            ret[standardKeyboardEvent.browserEvent.code] = {
                'value': standardKeyboardEvent.browserEvent.key,
                'withShift': '',
                'withAltGr': '',
                'withShiftAltGr': ''
            };
            const matchedKeyboardLayout = this.getMatchedKeymapInfo(ret);
            if (matchedKeyboardLayout) {
                return ret;
            }
            return null;
        }
        return null;
    }
}
class BrowserKeyboardMapperFactory extends BrowserKeyboardMapperFactoryBase {
    constructor(configurationService, notificationService, storageService, commandService) {
        super(configurationService);
        const platform = isWindows ? 'win' : isMacintosh ? 'darwin' : 'linux';
        __variableDynamicImportRuntime0__('./keyboardLayouts/layout.contribution.' + platform + '.js').then((m) => {
            const keymapInfos = m.KeyboardLayoutContribution.INSTANCE.layoutInfos;
            this._keymapInfos.push(...( (keymapInfos.map(info => (( (new KeymapInfo(
                info.layout,
                info.secondaryLayouts,
                info.mapping,
                info.isUserKeyboardLayout
            ))))))));
            this._mru = this._keymapInfos;
            this._initialized = true;
            this.setLayoutFromBrowserAPI();
        });
    }
}
class UserKeyboardLayout extends Disposable {
    get keyboardLayout() { return this._keyboardLayout; }
    constructor(keyboardLayoutResource, fileService) {
        super();
        this.keyboardLayoutResource = keyboardLayoutResource;
        this.fileService = fileService;
        this._onDidChange = this._register(( (new Emitter())));
        this.onDidChange = this._onDidChange.event;
        this._keyboardLayout = null;
        this.reloadConfigurationScheduler = this._register(( (new RunOnceScheduler(() => this.reload().then(changed => {
            if (changed) {
                this._onDidChange.fire();
            }
        }), 50))));
        this._register(Event.filter(this.fileService.onDidFilesChange, e => e.contains(this.keyboardLayoutResource))(() => this.reloadConfigurationScheduler.schedule()));
    }
    async initialize() {
        await this.reload();
    }
    async reload() {
        const existing = this._keyboardLayout;
        try {
            const content = await this.fileService.readFile(this.keyboardLayoutResource);
            const value = parse(( (content.value.toString())));
            if (getNodeType(value) === 'object') {
                const layoutInfo = value.layout;
                const mappings = value.rawMapping;
                this._keyboardLayout = KeymapInfo.createKeyboardLayoutFromDebugInfo(layoutInfo, mappings, true);
            }
            else {
                this._keyboardLayout = null;
            }
        }
        catch (e) {
            this._keyboardLayout = null;
        }
        return existing ? !equals(existing, this._keyboardLayout) : true;
    }
}
let BrowserKeyboardLayoutService = class BrowserKeyboardLayoutService extends Disposable {
    constructor(environmentService, fileService, notificationService, storageService, commandService, configurationService) {
        super();
        this.configurationService = configurationService;
        this._onDidChangeKeyboardLayout = ( (new Emitter()));
        this.onDidChangeKeyboardLayout = this._onDidChangeKeyboardLayout.event;
        const keyboardConfig = configurationService.getValue('keyboard');
        const layout = keyboardConfig.layout;
        this._keyboardLayoutMode = layout ?? 'autodetect';
        this._factory = ( (new BrowserKeyboardMapperFactory(configurationService, notificationService, storageService, commandService)));
        this._register(this._factory.onDidChangeKeyboardMapper(() => {
            this._onDidChangeKeyboardLayout.fire();
        }));
        if (layout && layout !== 'autodetect') {
            this._factory.setKeyboardLayout(layout);
        }
        this._register(configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('keyboard.layout')) {
                const keyboardConfig = configurationService.getValue('keyboard');
                const layout = keyboardConfig.layout;
                this._keyboardLayoutMode = layout;
                if (layout === 'autodetect') {
                    this._factory.setLayoutFromBrowserAPI();
                }
                else {
                    this._factory.setKeyboardLayout(layout);
                }
            }
        }));
        this._userKeyboardLayout = ( (new UserKeyboardLayout(environmentService.keyboardLayoutResource, fileService)));
        this._userKeyboardLayout.initialize().then(() => {
            if (this._userKeyboardLayout.keyboardLayout) {
                this._factory.registerKeyboardLayout(this._userKeyboardLayout.keyboardLayout);
                this.setUserKeyboardLayoutIfMatched();
            }
        });
        this._register(this._userKeyboardLayout.onDidChange(() => {
            const userKeyboardLayouts = this._factory.keymapInfos.filter(layout => layout.isUserKeyboardLayout);
            if (userKeyboardLayouts.length) {
                if (this._userKeyboardLayout.keyboardLayout) {
                    userKeyboardLayouts[0].update(this._userKeyboardLayout.keyboardLayout);
                }
                else {
                    this._factory.removeKeyboardLayout(userKeyboardLayouts[0]);
                }
            }
            else {
                if (this._userKeyboardLayout.keyboardLayout) {
                    this._factory.registerKeyboardLayout(this._userKeyboardLayout.keyboardLayout);
                }
            }
            this.setUserKeyboardLayoutIfMatched();
        }));
    }
    setUserKeyboardLayoutIfMatched() {
        const keyboardConfig = this.configurationService.getValue('keyboard');
        const layout = keyboardConfig.layout;
        if (layout && this._userKeyboardLayout.keyboardLayout) {
            if (getKeyboardLayoutId(this._userKeyboardLayout.keyboardLayout.layout) === layout && this._factory.activeKeymap) {
                if (!this._userKeyboardLayout.keyboardLayout.equal(this._factory.activeKeymap)) {
                    this._factory.setActiveKeymapInfo(this._userKeyboardLayout.keyboardLayout);
                }
            }
        }
    }
    getKeyboardMapper() {
        return this._factory.getKeyboardMapper();
    }
    getCurrentKeyboardLayout() {
        return this._factory.activeKeyboardLayout;
    }
    getAllKeyboardLayouts() {
        return this._factory.keyboardLayouts;
    }
    getRawKeyboardMapping() {
        return this._factory.activeKeyMapping;
    }
    validateCurrentKeyboardMapping(keyboardEvent) {
        if (this._keyboardLayoutMode !== 'autodetect') {
            return;
        }
        this._factory.validateCurrentKeyboardMapping(keyboardEvent);
    }
};
BrowserKeyboardLayoutService = ( (__decorate([
    ( (__param(0, IEnvironmentService))),
    ( (__param(1, IFileService))),
    ( (__param(2, INotificationService))),
    ( (__param(3, IStorageService))),
    ( (__param(4, ICommandService))),
    ( (__param(5, IConfigurationService)))
], BrowserKeyboardLayoutService)));
const configurationRegistry = ( (Registry.as(Extensions$1.Configuration)));
const keyboardConfiguration = {
    'id': 'keyboard',
    'order': 15,
    'type': 'object',
    'title': ( (localize('keyboardConfigurationTitle', "Keyboard"))),
    'properties': {
        'keyboard.layout': {
            'type': 'string',
            'default': 'autodetect',
            'description': ( (localize('keyboard.layout.config', "Control the keyboard layout used in web.")))
        }
    }
};
configurationRegistry.registerConfiguration(keyboardConfiguration);
let DelegateStandaloneKeybindingService = class DelegateStandaloneKeybindingService extends createInjectedClass(StandaloneKeybindingService) {
    constructor(instantiationService) {
        super(instantiationService);
        this.delegate = instantiationService.createInstance(WorkbenchKeybindingService);
        this._cachedOverridenResolver = null;
        this.onDidUpdateKeybindings(() => {
            this._cachedOverridenResolver = null;
        });
        this.delegate.onDidUpdateKeybindings(() => {
            this._cachedOverridenResolver = null;
        });
    }
    _getResolver() {
        if (this._cachedOverridenResolver == null) {
            const overrides = this['_toNormalizedKeybindingItems'](this['_dynamicKeybindings'], false);
            this._cachedOverridenResolver = new KeybindingResolver(
            [...this.delegate['_getResolver']().getKeybindings()], overrides, (str) => this._log(str));
        }
        return this._cachedOverridenResolver;
    }
};
DelegateStandaloneKeybindingService = ( __decorate([
    ( __param(0, IInstantiationService))
], DelegateStandaloneKeybindingService));
const quickAccessRegistry = ( Registry.as(Extensions$2.Quickaccess));
const provider = quickAccessRegistry.getQuickAccessProviders().find(provider => provider.ctor === StandaloneCommandsQuickAccessProvider);
if (provider != null) {
    provider.ctor = class extends CommandsQuickAccessProvider {
        get defaultFilterValue() { return undefined; }
        async getCommandPicks(token) {
            return ( (await super.getCommandPicks(token)).map(pick => {
                pick.buttons = [];
                return pick;
            }));
        }
    };
}
configurationRegistry$2.registerConfiguration({
    properties: {
        'workbench.commandPalette.history': {
            type: 'number',
            description: ( localize(
                'commandHistory',
                'Controls the number of recently used commands to keep in history for the command palette. Set to 0 to disable command history.'
            )),
            default: 50,
            minimum: 0
        },
        'workbench.commandPalette.preserveInput': {
            type: 'boolean',
            description: ( localize(
                'preserveInput',
                'Controls whether the last typed input to the command palette should be restored when opening it the next time.'
            )),
            default: false
        },
        'workbench.commandPalette.experimental.suggestCommands': {
            type: 'boolean',
            description: ( localize(
                'suggestCommands',
                'Controls whether the command palette should have a list of commonly used commands.'
            )),
            default: false
        }
    }
});
async function updateUserKeybindings(keybindingsJson) {
    const userDataProfilesService = StandaloneServices.get(IUserDataProfilesService);
    await StandaloneServices.get(IFileService).writeFile(userDataProfilesService.defaultProfile.keybindingsResource, VSBuffer.fromString(keybindingsJson));
}
function getServiceOverride() {
    return {
        ...getServiceOverride$1(),
        ...getServiceOverride$2(),
        [( IKeybindingService.toString())]: new SyncDescriptor(DelegateStandaloneKeybindingService),
        [( IKeyboardLayoutService.toString())]: new SyncDescriptor(BrowserKeyboardLayoutService)
    };
}
export { getServiceOverride as default, updateUserKeybindings };
