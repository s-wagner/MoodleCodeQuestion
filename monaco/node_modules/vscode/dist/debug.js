import { n, R as Range, V as disposeIfDisposable, P as Position, o as onServicesInitialized, w as withUndefinedAsNull, p as parse, W as visit, f as flatten, X as decodeBase64, e as encodeBase64 } from './polyfill.js';
import { c7 as IViewsService, bp as IExtensionService, c8 as ViewContainerLocationToString, c9 as defaultViewIcon, ca as NumberBadge, cb as IConfigurationResolverService, cc as AbstractEditorInput, bO as isEditorInput, cd as EditorResourceAccessor, bL as ILifecycleService, ce as IViewDescriptorService, cf as IHistoryService, bS as IPreferencesService, cg as ICustomEndpointTelemetryService, ch as ITaskService, ci as IExtensionHostDebugService, cj as IActivityService, br as IWorkspaceTrustRequestService, c as cleanRemoteAuthority, ck as Extensions$3, cl as SideBySideEditor, cm as ITunnelService } from './missing-services.js';
import { _ as __decorate, a4 as BREAKPOINTS_VIEW_ID, a5 as CONTEXT_DEBUGGERS_AVAILABLE, u as IDebugService, a6 as CONTEXT_BREAKPOINT_ITEM_TYPE, a7 as CONTEXT_BREAKPOINTS_EXIST, a8 as CONTEXT_IN_DEBUG_MODE, a9 as CONTEXT_BREAKPOINT_SUPPORTS_CONDITION, I as IEditorService, aa as BREAKPOINT_EDITOR_CONTRIBUTION_ID, ab as CONTEXT_DISASSEMBLY_VIEW_FOCUS, ac as CONTEXT_JUMP_TO_CURSOR_SUPPORTED, ad as CONTEXT_DEBUG_STATE, ae as CONTEXT_STEP_INTO_TARGETS_SUPPORTED, af as CONTEXT_FOCUSED_SESSION_IS_ATTACH, ag as REPL_VIEW_ID, ah as CONTEXT_BREAKPOINTS_FOCUSED, ai as CONTEXT_WATCH_EXPRESSIONS_FOCUSED, aj as CONTEXT_VARIABLES_FOCUSED, ak as CONTEXT_EXPRESSION_SELECTED, al as CONTEXT_BREAKPOINT_INPUT_FOCUSED, am as VIEWLET_ID$1, an as CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED, ao as CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED, i as SIDE_GROUP, ap as VARIABLES_VIEW_ID, aq as EDITOR_CONTRIBUTION_ID, ar as INTERNAL_CONSOLE_OPTIONS_SCHEMA, as as DEBUG_MEMORY_SCHEME, E as Emitter, a as __param, at as DEBUG_SCHEME, A as ACTIVE_GROUP, au as CALLSTACK_VIEW_ID, av as CONTEXT_DEBUG_TYPE, aw as CONTEXT_HAS_DEBUGGED, ax as CONTEXT_DEBUG_UX, ay as getStateLabel, az as debuggerDisabledMessage, aA as CONTEXT_STEP_BACK_SUPPORTED, aB as CONTEXT_MULTI_SESSION_DEBUG, aC as CONTEXT_BREAKPOINT_WIDGET_VISIBLE, aD as CONTEXT_IN_BREAKPOINT_WIDGET, aE as CONTEXT_EXCEPTION_WIDGET_VISIBLE, aF as CONTEXT_DEBUG_EXTENSION_AVAILABLE, l as ITextFileService, j as IUriIdentityService, aG as CONTEXT_DEBUG_CONFIGURATION_TYPE, D as DebugConfigurationProviderTriggerKind, n as IFileService, f as FileType, h as FilePermission, a2 as createFileSystemProviderError, t as IHostService, k as IPaneCompositePartService, e as IProductService, o as IWorkbenchEnvironmentService, aH as CONTEXT_LOADED_SCRIPTS_SUPPORTED, aI as CONTEXT_RESTART_FRAME_SUPPORTED, aJ as CONTEXT_SET_VARIABLE_SUPPORTED, aK as CONTEXT_SET_EXPRESSION_SUPPORTED, aL as CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED, aM as CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE, r as IPathService, y as ISnippetsService, aN as CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT, aO as CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT, aP as CONTEXT_CAN_VIEW_MEMORY, aQ as CONTEXT_VARIABLE_IS_READONLY, F as FileSystemProviderErrorCode, aR as DebuggerString } from './services2.js';
import { C as CancellationTokenSource } from './cancellation.js';
import { ContextKeyExpr, IContextKeyService, RawContextKey } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { s as saveAllBeforeDebugStart, g as getExtensionHostDebugSession, e as getVisibleAndSorted, f as filterExceptionsFromTelemetry, b as isSessionAttach, h as getEvaluatableExpressionAtPosition, i as isDebuggerMainContribution, k as isUri, d as isAbsolute, l as formatPII, A as AbstractVariableResolverService, j as join } from './variableResolver.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { RemoteAuthorities, Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { ITextResourcePropertiesService } from 'monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js';
import { isUndefinedOrNull, assertIsDefined, withNullAsUndefined, isString, isObject } from 'monaco-editor/esm/vs/base/common/types.js';
import { E as ExtensionsRegistry } from './extensionsRegistry.js';
import { l as launchSchemaId, s as setProperty } from './configuration2.js';
import { deepClone, equals, mixin } from 'monaco-editor/esm/vs/base/common/objects.js';
import { dispose, Disposable, DisposableStore, toDisposable, MutableDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { equalsIgnoreCase, noBreakWhitespace, format } from 'monaco-editor/esm/vs/base/common/strings.js';
import { isCodeEditor, isDiffEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import Severity$1 from 'monaco-editor/esm/vs/base/common/severity.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { IInstantiationService, createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { CommandsRegistry, ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IDialogService } from 'monaco-editor/esm/vs/platform/dialogs/common/dialogs.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions as Extensions$1 } from 'monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js';
import { basenameOrAuthority, isEqual, dirname, joinPath } from 'monaco-editor/esm/vs/base/common/resources.js';
import { basename, normalize, posix } from 'monaco-editor/esm/vs/base/common/path.js';
import { distinct, coalesce, firstOrDefault, lastIndex, equals as equals$1 } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { generateUuid } from 'monaco-editor/esm/vs/base/common/uuid.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { timeout, RunOnceScheduler } from 'monaco-editor/esm/vs/base/common/async.js';
import { stringHash } from 'monaco-editor/esm/vs/base/common/hash.js';
import { P as PanelFocusContext, S as SIDE_BAR_BACKGROUND, h as PANEL_BACKGROUND, i as isErrorWithActions, j as createErrorWithActions } from './contextkeys.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ILabelService } from 'monaco-editor/esm/vs/platform/label/common/label.js';
import { matchesFuzzy, createMatches } from 'monaco-editor/esm/vs/base/common/filters.js';
import { getIconClasses } from 'monaco-editor/esm/vs/editor/common/services/getIconClasses.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { INotificationService, Severity } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { registerAction2, Action2, MenuId, MenuRegistry, SubmenuItemAction, IMenuService } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { isWeb, isMacintosh, isWindows, isLinux, language, isIOS } from 'monaco-editor/esm/vs/base/common/platform.js';
import { InputFocusedContextKey, InputFocusedContext } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkeys.js';
import { IListService, WorkbenchAsyncDataTree } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { List } from 'monaco-editor/esm/vs/base/browser/ui/list/listWidget.js';
import { registerIcon, widgetClose } from 'monaco-editor/esm/vs/platform/theme/common/iconRegistry.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { b as raceTimeout, s as sequence, Q as Queue } from './async.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { assertNever } from 'monaco-editor/esm/vs/base/common/assert.js';
import { clamp } from 'monaco-editor/esm/vs/base/common/numbers.js';
import { isCancellationError, onUnexpectedError, canceled, onUnexpectedExternalError, CancellationError, ErrorNoTelemetry } from 'monaco-editor/esm/vs/base/common/errors.js';
import { Action, SubmenuAction, Separator, toAction } from 'monaco-editor/esm/vs/base/common/actions.js';
import { IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { normalizeDriveLetter } from 'monaco-editor/esm/vs/base/common/labels.js';
import { alert, status } from 'monaco-editor/esm/vs/base/browser/ui/aria/aria.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { MarkerSeverity, IMarkerService } from 'monaco-editor/esm/vs/platform/markers/common/markers.js';
import { I as IWorkbenchLayoutService } from './layoutService.js';
import { LanguageFeatureRegistry } from 'monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js';
import { BaseActionViewItem, SelectActionViewItem } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js';
import { createActionViewItem, createAndFillInContextMenuActions, createAndFillInActionBarActions, MenuEntryActionViewItem } from 'monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js';
import { DropdownMenuActionViewItem } from 'monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js';
import { $ as $$7, append, trackFocus, EventType as EventType$1, addDisposableListener as addDisposableListener$1, EventHelper, asCssValueWithDefault, createCSSRule, asCSSUrl, addStandardDisposableListener, clearNode, isAncestor, addDisposableGenericMouseUpListener, addDisposableGenericMouseDownListener, getComputedStyle, show, hide } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { registerThemingParticipant, themeColorFromId, IThemeService, Themable } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { StandardKeyboardEvent } from 'monaco-editor/esm/vs/base/browser/keyboardEvent.js';
import { registerColor, asCssVariable, foreground, selectBorder, selectBackground, editorInfoForeground, editorWarningForeground, errorForeground, badgeBackground, badgeForeground, listDeemphasizedForeground, toolbarHoverBackground, contrastBorder, inputBorder, editorHoverBackground, editorHoverBorder, editorHoverForeground, widgetShadow, widgetBorder, editorForeground } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { IContextMenuService, IContextViewService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { defaultProgressBarStyles, defaultSelectBoxStyles, defaultButtonStyles, defaultInputBoxStyles } from 'monaco-editor/esm/vs/platform/theme/browser/defaultStyles.js';
import { SelectBox } from 'monaco-editor/esm/vs/base/browser/ui/selectBox/selectBox.js';
import { isHighContrast } from 'monaco-editor/esm/vs/platform/theme/common/theme.js';
import { Color, RGBA } from 'monaco-editor/esm/vs/base/common/color.js';
import { ActionBar } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js';
import { BrowserFeatures } from 'monaco-editor/esm/vs/base/browser/canIUse.js';
import { isFirefox, isSafari, PixelRatio, isWebKit } from 'monaco-editor/esm/vs/base/browser/browser.js';
import { StandardMouseEvent } from 'monaco-editor/esm/vs/base/browser/mouseEvent.js';
import { g as getMimeTypes } from './languageService.js';
import { EditOperation } from 'monaco-editor/esm/vs/editor/common/core/editOperation.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { IEditorWorkerService } from 'monaco-editor/esm/vs/editor/common/services/editorWorker.js';
import { PLAINTEXT_LANGUAGE_ID } from 'monaco-editor/esm/vs/editor/common/languages/modesRegistry.js';
import { g as getServiceOverride$1 } from './layout.js';
import { DomEmitter } from 'monaco-editor/esm/vs/base/browser/event.js';
import { Gesture, EventType as EventType$2 } from 'monaco-editor/esm/vs/base/browser/touch.js';
import { DataTransfers } from 'monaco-editor/esm/vs/base/browser/dnd.js';
import { ServiceCollection } from 'monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js';
import { WorkbenchToolBar } from 'monaco-editor/esm/vs/platform/actions/browser/toolbar.js';
import { DomScrollableElement } from 'monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js';
import { ProgressBar } from 'monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.js';
import { parseLinkedText } from 'monaco-editor/esm/vs/base/common/linkedText.js';
import { Link } from 'monaco-editor/esm/vs/platform/opener/browser/link.js';
import { Button } from 'monaco-editor/esm/vs/base/browser/ui/button/button.js';
import { showSimpleSuggestions, provideSuggestionItems, CompletionOptions } from 'monaco-editor/esm/vs/editor/contrib/suggest/browser/suggest.js';
import { registerEditorContribution, EditorCommand, registerEditorCommand, EditorExtensionsRegistry } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { g as getNonWhitespacePrefix, a as SnippetCompletion } from './snippetsService.js';
import { SnippetController2 } from 'monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetController2.js';
import { ILanguageFeaturesService } from 'monaco-editor/esm/vs/editor/common/services/languageFeatures.js';
import { EditorState } from 'monaco-editor/esm/vs/editor/contrib/editorState/browser/editorState.js';
import { ContextMenuController } from 'monaco-editor/esm/vs/editor/contrib/contextmenu/browser/contextmenu.js';
import { SuggestController } from 'monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestController.js';
import { ZoneWidget } from 'monaco-editor/esm/vs/editor/contrib/zoneWidget/browser/zoneWidget.js';
import { CodeEditorWidget } from 'monaco-editor/esm/vs/editor/browser/widget/codeEditorWidget.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { memoize } from 'monaco-editor/esm/vs/base/common/decorators.js';
import { MarkdownString } from 'monaco-editor/esm/vs/base/common/htmlContent.js';
import { OverviewRulerLane, InjectedTextCursorStops } from 'monaco-editor/esm/vs/editor/common/model.js';
import { PickerQuickAccessProvider, TriggerAction } from 'monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js';
import { once as once$1 } from 'monaco-editor/esm/vs/base/common/functional.js';
import { InputBox } from 'monaco-editor/esm/vs/base/browser/ui/inputbox/inputBox.js';
import { HighlightedLabel } from 'monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js';
import { IProgressService } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { ModelDecorationOptions } from 'monaco-editor/esm/vs/editor/common/model/textModel.js';
import { ModesHoverController } from 'monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js';
import { DEFAULT_WORD_REGEXP } from 'monaco-editor/esm/vs/editor/common/core/wordHelper.js';
import { ILanguageFeatureDebounceService } from 'monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js';
import { CoreEditingCommands } from 'monaco-editor/esm/vs/editor/browser/coreCommands.js';
import { Extensions } from 'monaco-editor/esm/vs/platform/quickinput/common/quickAccess.js';
import { Extensions as Extensions$2 } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
class DomListener {
    constructor(node, type, handler, options) {
        this._node = node;
        this._type = type;
        this._handler = handler;
        this._options = (options || false);
        this._node.addEventListener(this._type, this._handler, this._options);
    }
    dispose() {
        if (!this._handler) {
            return;
        }
        this._node.removeEventListener(this._type, this._handler, this._options);
        this._node = null;
        this._handler = null;
    }
}
function addDisposableListener(node, type, handler, useCaptureOrOptions) {
    return (
         (new DomListener(node, type, handler, useCaptureOrOptions))
    );
}
function addDisposableGenericMouseMoveListener(node, handler, useCapture) {
    return addDisposableListener(node, isIOS && BrowserFeatures.pointerEvents ? EventType.POINTER_MOVE : EventType.MOUSE_MOVE, handler, useCapture);
}
const EventType = {
    CLICK: 'click',
    AUXCLICK: 'auxclick',
    DBLCLICK: 'dblclick',
    MOUSE_UP: 'mouseup',
    MOUSE_DOWN: 'mousedown',
    MOUSE_OVER: 'mouseover',
    MOUSE_MOVE: 'mousemove',
    MOUSE_OUT: 'mouseout',
    MOUSE_ENTER: 'mouseenter',
    MOUSE_LEAVE: 'mouseleave',
    MOUSE_WHEEL: 'wheel',
    POINTER_UP: 'pointerup',
    POINTER_DOWN: 'pointerdown',
    POINTER_MOVE: 'pointermove',
    POINTER_LEAVE: 'pointerleave',
    CONTEXT_MENU: 'contextmenu',
    WHEEL: 'wheel',
    KEY_DOWN: 'keydown',
    KEY_PRESS: 'keypress',
    KEY_UP: 'keyup',
    LOAD: 'load',
    BEFORE_UNLOAD: 'beforeunload',
    UNLOAD: 'unload',
    PAGE_SHOW: 'pageshow',
    PAGE_HIDE: 'pagehide',
    ABORT: 'abort',
    ERROR: 'error',
    RESIZE: 'resize',
    SCROLL: 'scroll',
    FULLSCREEN_CHANGE: 'fullscreenchange',
    WK_FULLSCREEN_CHANGE: 'webkitfullscreenchange',
    SELECT: 'select',
    CHANGE: 'change',
    SUBMIT: 'submit',
    RESET: 'reset',
    FOCUS: 'focus',
    FOCUS_IN: 'focusin',
    FOCUS_OUT: 'focusout',
    BLUR: 'blur',
    INPUT: 'input',
    STORAGE: 'storage',
    DRAG_START: 'dragstart',
    DRAG: 'drag',
    DRAG_ENTER: 'dragenter',
    DRAG_LEAVE: 'dragleave',
    DRAG_OVER: 'dragover',
    DROP: 'drop',
    DRAG_END: 'dragend',
    ANIMATION_START: isWebKit ? 'webkitAnimationStart' : 'animationstart',
    ANIMATION_END: isWebKit ? 'webkitAnimationEnd' : 'animationend',
    ANIMATION_ITERATION: isWebKit ? 'webkitAnimationIteration' : 'animationiteration'
};
function after(sibling, child) {
    sibling.after(child);
    return child;
}
RemoteAuthorities.setPreferredWebSchema(/^https:/.test(window.location.href) ? 'https' : 'http');
function prepareActions(actions) {
    if (!actions.length) {
        return actions;
    }
    let firstIndexOfAction = -1;
    for (let i = 0; i < actions.length; i++) {
        if (actions[i].id === Separator.ID) {
            continue;
        }
        firstIndexOfAction = i;
        break;
    }
    if (firstIndexOfAction === -1) {
        return [];
    }
    actions = actions.slice(firstIndexOfAction);
    for (let h = actions.length - 1; h >= 0; h--) {
        const isSeparator = actions[h].id === Separator.ID;
        if (isSeparator) {
            actions.splice(h, 1);
        }
        else {
            break;
        }
    }
    let foundAction = false;
    for (let k = actions.length - 1; k >= 0; k--) {
        const isSeparator = actions[k].id === Separator.ID;
        if (isSeparator && !foundAction) {
            actions.splice(k, 1);
        }
        else if (!isSeparator) {
            foundAction = true;
        }
        else if (isSeparator) {
            foundAction = false;
        }
    }
    return actions;
}
class EditorInput extends AbstractEditorInput {
    constructor() {
        super(...arguments);
        this._onDidChangeDirty = this._register(( (new Emitter())));
        this._onDidChangeLabel = this._register(( (new Emitter())));
        this._onDidChangeCapabilities = this._register(( (new Emitter())));
        this._onWillDispose = this._register(( (new Emitter())));
        this.onDidChangeDirty = this._onDidChangeDirty.event;
        this.onDidChangeLabel = this._onDidChangeLabel.event;
        this.onDidChangeCapabilities = this._onDidChangeCapabilities.event;
        this.onWillDispose = this._onWillDispose.event;
        this.disposed = false;
    }
    get editorId() {
        return undefined;
    }
    get capabilities() {
        return 2 ;
    }
    hasCapability(capability) {
        if (capability === 0 ) {
            return this.capabilities === 0 ;
        }
        return (this.capabilities & capability) !== 0;
    }
    getName() {
        return `Editor ${this.typeId}`;
    }
    getDescription(verbosity) {
        return undefined;
    }
    getTitle(verbosity) {
        return this.getName();
    }
    getLabelExtraClasses() {
        return [];
    }
    getAriaLabel() {
        return this.getTitle(0 );
    }
    getTelemetryDescriptor() {
        return { typeId: this.typeId };
    }
    isDirty() {
        return false;
    }
    isSaving() {
        return false;
    }
    async resolve(options) {
        return null;
    }
    async save(group, options) {
        return this;
    }
    async saveAs(group, options) {
        return this;
    }
    async revert(group, options) { }
    async rename(group, target) {
        return undefined;
    }
    copy() {
        return this;
    }
    matches(otherInput) {
        if (isEditorInput(otherInput)) {
            return this === otherInput;
        }
        const otherInputEditorId = otherInput.options?.override;
        if (this.editorId !== otherInputEditorId && otherInputEditorId !== undefined && this.editorId !== undefined) {
            return false;
        }
        return isEqual(this.resource, EditorResourceAccessor.getCanonicalUri(otherInput));
    }
    prefersEditorPane(editorPanes) {
        return firstOrDefault(editorPanes);
    }
    toUntyped(options) {
        return undefined;
    }
    isDisposed() {
        return this.disposed;
    }
    dispose() {
        if (!this.disposed) {
            this.disposed = true;
            this._onWillDispose.fire();
        }
        super.dispose();
    }
}
let Breakpoints = class Breakpoints {
    constructor(breakpointContribution, contextKeyService) {
        this.breakpointContribution = breakpointContribution;
        this.contextKeyService = contextKeyService;
        this.breakpointsWhen = typeof breakpointContribution.when === 'string' ? ContextKeyExpr.deserialize(breakpointContribution.when) : undefined;
    }
    get language() {
        return this.breakpointContribution.language;
    }
    get enabled() {
        return !this.breakpointsWhen || this.contextKeyService.contextMatchesRules(this.breakpointsWhen);
    }
};
Breakpoints = ( (__decorate([
    ( (__param(1, IContextKeyService)))
], Breakpoints)));
function applyDeprecatedVariableMessage(schema) {
    schema.pattern = schema.pattern || '^(?!.*\\$\\{(env|config|command)\\.)';
    schema.patternErrorMessage = schema.patternErrorMessage ||
        ( (localize(
        'deprecatedVariables',
        "'env.', 'config.' and 'command.' are deprecated, use 'env:', 'config:' and 'command:' instead."
    )));
}
let Debugger = class Debugger {
    constructor(adapterManager, dbgContribution, extensionDescription, configurationService, resourcePropertiesService, configurationResolverService, environmentService, debugService, contextKeyService) {
        this.adapterManager = adapterManager;
        this.configurationService = configurationService;
        this.resourcePropertiesService = resourcePropertiesService;
        this.configurationResolverService = configurationResolverService;
        this.environmentService = environmentService;
        this.debugService = debugService;
        this.contextKeyService = contextKeyService;
        this.mergedExtensionDescriptions = [];
        this.debuggerContribution = { type: dbgContribution.type };
        this.merge(dbgContribution, extensionDescription);
        this.debuggerWhen = typeof this.debuggerContribution.when === 'string' ? ContextKeyExpr.deserialize(this.debuggerContribution.when) : undefined;
    }
    merge(otherDebuggerContribution, extensionDescription) {
        function mixin(destination, source, overwrite, level = 0) {
            if (!isObject(destination)) {
                return source;
            }
            if (isObject(source)) {
                ( (Object.keys(source))).forEach(key => {
                    if (key !== '__proto__') {
                        if (isObject(destination[key]) && isObject(source[key])) {
                            mixin(destination[key], source[key], overwrite, level + 1);
                        }
                        else {
                            if (key in destination) {
                                if (overwrite) {
                                    if (level === 0 && key === 'type') ;
                                    else {
                                        destination[key] = source[key];
                                    }
                                }
                            }
                            else {
                                destination[key] = source[key];
                            }
                        }
                    }
                });
            }
            return destination;
        }
        if (this.mergedExtensionDescriptions.indexOf(extensionDescription) < 0) {
            this.mergedExtensionDescriptions.push(extensionDescription);
            mixin(this.debuggerContribution, otherDebuggerContribution, extensionDescription.isBuiltin);
            if (isDebuggerMainContribution(otherDebuggerContribution)) {
                this.mainExtensionDescription = extensionDescription;
            }
        }
    }
    async startDebugging(configuration, parentSessionId) {
        const parentSession = this.debugService.getModel().getSession(parentSessionId);
        return await this.debugService.startDebugging(undefined, configuration, { parentSession }, undefined);
    }
    async createDebugAdapter(session) {
        await this.adapterManager.activateDebuggers('onDebugAdapterProtocolTracker', this.type);
        const da = this.adapterManager.createDebugAdapter(session);
        if (da) {
            return Promise.resolve(da);
        }
        throw new Error(localize('cannot.find.da', "Cannot find debug adapter for type '{0}'.", this.type));
    }
    async substituteVariables(folder, config) {
        const substitutedConfig = await this.adapterManager.substituteVariables(this.type, folder, config);
        return await this.configurationResolverService.resolveWithInteractionReplace(folder, substitutedConfig, 'launch', this.variables, substitutedConfig.__configurationTarget);
    }
    runInTerminal(args, sessionId) {
        return this.adapterManager.runInTerminal(this.type, args, sessionId);
    }
    get label() {
        return this.debuggerContribution.label || this.debuggerContribution.type;
    }
    get type() {
        return this.debuggerContribution.type;
    }
    get variables() {
        return this.debuggerContribution.variables;
    }
    get configurationSnippets() {
        return this.debuggerContribution.configurationSnippets;
    }
    get languages() {
        return this.debuggerContribution.languages;
    }
    get when() {
        return this.debuggerWhen;
    }
    get enabled() {
        return !this.debuggerWhen || this.contextKeyService.contextMatchesRules(this.debuggerWhen);
    }
    get strings() {
        return this.debuggerContribution.strings ?? this.debuggerContribution.uiMessages;
    }
    interestedInLanguage(languageId) {
        return !!(this.languages && this.languages.indexOf(languageId) >= 0);
    }
    hasInitialConfiguration() {
        return !!this.debuggerContribution.initialConfigurations;
    }
    hasConfigurationProvider() {
        return this.debugService.getConfigurationManager().hasDebugConfigurationProvider(this.type);
    }
    getInitialConfigurationContent(initialConfigs) {
        let initialConfigurations = this.debuggerContribution.initialConfigurations || [];
        if (initialConfigs) {
            initialConfigurations = initialConfigurations.concat(initialConfigs);
        }
        const eol = this.resourcePropertiesService.getEOL(( (URI.from({ scheme: Schemas.untitled, path: '1' })))) === '\r\n' ? '\r\n' : '\n';
        const configs = ( (JSON.stringify(initialConfigurations, null, '\t').split('\n').map(line => '\t' + line))).join(eol).trim();
        const comment1 = ( (localize(
            'launch.config.comment1',
            "Use IntelliSense to learn about possible attributes."
        )));
        const comment2 = ( (localize(
            'launch.config.comment2',
            "Hover to view descriptions of existing attributes."
        )));
        const comment3 = ( (localize(
            'launch.config.comment3',
            "For more information, visit: {0}",
            'https://go.microsoft.com/fwlink/?linkid=830387'
        )));
        let content = [
            '{',
            `\t// ${comment1}`,
            `\t// ${comment2}`,
            `\t// ${comment3}`,
            `\t"version": "0.2.0",`,
            `\t"configurations": ${configs}`,
            '}'
        ].join(eol);
        const editorConfig = this.configurationService.getValue();
        if (editorConfig.editor && editorConfig.editor.insertSpaces) {
            content = content.replace(( (new RegExp('\t', 'g'))), ' '.repeat(editorConfig.editor.tabSize));
        }
        return Promise.resolve(content);
    }
    getMainExtensionDescriptor() {
        return this.mainExtensionDescription || this.mergedExtensionDescriptions[0];
    }
    getCustomTelemetryEndpoint() {
        const aiKey = this.debuggerContribution.aiKey;
        if (!aiKey) {
            return undefined;
        }
        const sendErrorTelemtry = cleanRemoteAuthority(this.environmentService.remoteAuthority) !== 'other';
        return {
            id: `${this.getMainExtensionDescriptor().publisher}.${this.type}`,
            aiKey,
            sendErrorTelemetry: sendErrorTelemtry
        };
    }
    getSchemaAttributes(definitions) {
        if (!this.debuggerContribution.configurationAttributes) {
            return null;
        }
        return (
             (( (Object.keys(this.debuggerContribution.configurationAttributes))).map(request => {
                const definitionId = `${this.type}:${request}`;
                const attributes = this.debuggerContribution.configurationAttributes[request];
                const defaultRequired = ['name', 'type', 'request'];
                attributes.required = attributes.required && attributes.required.length ? defaultRequired.concat(attributes.required) : defaultRequired;
                attributes.additionalProperties = false;
                attributes.type = 'object';
                if (!attributes.properties) {
                    attributes.properties = {};
                }
                const properties = attributes.properties;
                properties['type'] = {
                    enum: [this.type],
                    enumDescriptions: [this.label],
                    description: ( (localize('debugType', "Type of configuration."))),
                    pattern: '^(?!node2)',
                    deprecationMessage: this.debuggerContribution.deprecated || (this.enabled ? undefined : debuggerDisabledMessage(this.type)),
                    doNotSuggest: !!this.debuggerContribution.deprecated,
                    errorMessage: ( (localize(
                        'debugTypeNotRecognised',
                        "The debug type is not recognized. Make sure that you have a corresponding debug extension installed and that it is enabled."
                    ))),
                    patternErrorMessage: ( (localize(
                        'node2NotSupported',
                        "\"node2\" is no longer supported, use \"node\" instead and set the \"protocol\" attribute to \"inspector\"."
                    )))
                };
                properties['request'] = {
                    enum: [request],
                    description: ( (localize(
                        'debugRequest',
                        "Request type of configuration. Can be \"launch\" or \"attach\"."
                    ))),
                };
                for (const prop in definitions['common'].properties) {
                    properties[prop] = {
                        $ref: `#/definitions/common/properties/${prop}`
                    };
                }
                ( (Object.keys(properties))).forEach(name => {
                    applyDeprecatedVariableMessage(properties[name]);
                });
                definitions[definitionId] = { ...attributes };
                const attributesCopy = { ...attributes };
                attributesCopy.properties = {
                    ...properties,
                    ...{
                        windows: {
                            $ref: `#/definitions/${definitionId}`,
                            description: ( (localize(
                                'debugWindowsConfiguration',
                                "Windows specific launch configuration attributes."
                            ))),
                            required: [],
                        },
                        osx: {
                            $ref: `#/definitions/${definitionId}`,
                            description: ( (localize('debugOSXConfiguration', "OS X specific launch configuration attributes."))),
                            required: [],
                        },
                        linux: {
                            $ref: `#/definitions/${definitionId}`,
                            description: ( (localize(
                                'debugLinuxConfiguration',
                                "Linux specific launch configuration attributes."
                            ))),
                            required: [],
                        }
                    }
                };
                return attributesCopy;
            }))
        );
    }
};
Debugger = ( (__decorate([
    ( (__param(3, IConfigurationService))),
    ( (__param(4, ITextResourcePropertiesService))),
    ( (__param(5, IConfigurationResolverService))),
    ( (__param(6, IWorkbenchEnvironmentService))),
    ( (__param(7, IDebugService))),
    ( (__param(8, IContextKeyService)))
], Debugger)));
const idDescription = ( (localize(
    'JsonSchema.input.id',
    "The input's id is used to associate an input with a variable of the form ${input:id}."
)));
const typeDescription = ( (localize('JsonSchema.input.type', "The type of user input prompt to use.")));
const descriptionDescription = ( (localize(
    'JsonSchema.input.description',
    "The description is shown when the user is prompted for input."
)));
const defaultDescription = ( (localize('JsonSchema.input.default', "The default value for the input.")));
const inputsSchema = {
    definitions: {
        inputs: {
            type: 'array',
            description: ( (localize(
                'JsonSchema.inputs',
                'User inputs. Used for defining user input prompts, such as free string input or a choice from several options.'
            ))),
            items: {
                oneOf: [
                    {
                        type: 'object',
                        required: ['id', 'type', 'description'],
                        additionalProperties: false,
                        properties: {
                            id: {
                                type: 'string',
                                description: idDescription
                            },
                            type: {
                                type: 'string',
                                description: typeDescription,
                                enum: ['promptString'],
                                enumDescriptions: [
                                    ( (localize(
                                    'JsonSchema.input.type.promptString',
                                    "The 'promptString' type opens an input box to ask the user for input."
                                ))),
                                ]
                            },
                            description: {
                                type: 'string',
                                description: descriptionDescription
                            },
                            default: {
                                type: 'string',
                                description: defaultDescription
                            },
                            password: {
                                type: 'boolean',
                                description: ( (localize(
                                    'JsonSchema.input.password',
                                    "Controls if a password input is shown. Password input hides the typed text."
                                ))),
                            },
                        }
                    },
                    {
                        type: 'object',
                        required: ['id', 'type', 'description', 'options'],
                        additionalProperties: false,
                        properties: {
                            id: {
                                type: 'string',
                                description: idDescription
                            },
                            type: {
                                type: 'string',
                                description: typeDescription,
                                enum: ['pickString'],
                                enumDescriptions: [
                                    ( (localize(
                                    'JsonSchema.input.type.pickString',
                                    "The 'pickString' type shows a selection list."
                                ))),
                                ]
                            },
                            description: {
                                type: 'string',
                                description: descriptionDescription
                            },
                            default: {
                                type: 'string',
                                description: defaultDescription
                            },
                            options: {
                                type: 'array',
                                description: ( (localize(
                                    'JsonSchema.input.options',
                                    "An array of strings that defines the options for a quick pick."
                                ))),
                                items: {
                                    oneOf: [
                                        {
                                            type: 'string'
                                        },
                                        {
                                            type: 'object',
                                            required: ['value'],
                                            additionalProperties: false,
                                            properties: {
                                                label: {
                                                    type: 'string',
                                                    description: ( (localize('JsonSchema.input.pickString.optionLabel', "Label for the option.")))
                                                },
                                                value: {
                                                    type: 'string',
                                                    description: ( (localize('JsonSchema.input.pickString.optionValue', "Value for the option.")))
                                                }
                                            }
                                        }
                                    ]
                                }
                            }
                        }
                    },
                    {
                        type: 'object',
                        required: ['id', 'type', 'command'],
                        additionalProperties: false,
                        properties: {
                            id: {
                                type: 'string',
                                description: idDescription
                            },
                            type: {
                                type: 'string',
                                description: typeDescription,
                                enum: ['command'],
                                enumDescriptions: [
                                    ( (localize('JsonSchema.input.type.command', "The 'command' type executes a command."))),
                                ]
                            },
                            command: {
                                type: 'string',
                                description: ( (localize(
                                    'JsonSchema.input.command.command',
                                    "The command to execute for this input variable."
                                )))
                            },
                            args: {
                                oneOf: [
                                    {
                                        type: 'object',
                                        description: ( (localize(
                                            'JsonSchema.input.command.args',
                                            "Optional arguments passed to the command."
                                        )))
                                    },
                                    {
                                        type: 'array',
                                        description: ( (localize(
                                            'JsonSchema.input.command.args',
                                            "Optional arguments passed to the command."
                                        )))
                                    },
                                    {
                                        type: 'string',
                                        description: ( (localize(
                                            'JsonSchema.input.command.args',
                                            "Optional arguments passed to the command."
                                        )))
                                    }
                                ]
                            }
                        }
                    }
                ]
            }
        }
    }
};
const debuggersExtPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'debuggers',
    defaultExtensionKind: ['workspace'],
    jsonSchema: {
        description: ( (localize('vscode.extension.contributes.debuggers', 'Contributes debug adapters.'))),
        type: 'array',
        defaultSnippets: [{ body: [{ type: '' }] }],
        items: {
            additionalProperties: false,
            type: 'object',
            defaultSnippets: [{ body: { type: '', program: '', runtime: '' } }],
            properties: {
                type: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.type',
                        "Unique identifier for this debug adapter."
                    ))),
                    type: 'string'
                },
                label: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.label',
                        "Display name for this debug adapter."
                    ))),
                    type: 'string'
                },
                program: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.program',
                        "Path to the debug adapter program. Path is either absolute or relative to the extension folder."
                    ))),
                    type: 'string'
                },
                args: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.args',
                        "Optional arguments to pass to the adapter."
                    ))),
                    type: 'array'
                },
                runtime: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.runtime',
                        "Optional runtime in case the program attribute is not an executable but requires a runtime."
                    ))),
                    type: 'string'
                },
                runtimeArgs: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.runtimeArgs',
                        "Optional runtime arguments."
                    ))),
                    type: 'array'
                },
                variables: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.variables',
                        "Mapping from interactive variables (e.g. ${action.pickProcess}) in `launch.json` to a command."
                    ))),
                    type: 'object'
                },
                initialConfigurations: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.initialConfigurations',
                        "Configurations for generating the initial \'launch.json\'."
                    ))),
                    type: ['array', 'string'],
                },
                languages: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.languages',
                        "List of languages for which the debug extension could be considered the \"default debugger\"."
                    ))),
                    type: 'array'
                },
                configurationSnippets: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.configurationSnippets',
                        "Snippets for adding new configurations in \'launch.json\'."
                    ))),
                    type: 'array'
                },
                configurationAttributes: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.configurationAttributes',
                        "JSON schema configurations for validating \'launch.json\'."
                    ))),
                    type: 'object'
                },
                when: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.when',
                        "Condition which must be true to enable this type of debugger. Consider using 'shellExecutionSupported', 'virtualWorkspace', 'resourceScheme' or an extension-defined context key as appropriate for this."
                    ))),
                    type: 'string',
                    default: ''
                },
                deprecated: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.deprecated',
                        "Optional message to mark this debug type as being deprecated."
                    ))),
                    type: 'string',
                    default: ''
                },
                windows: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.windows',
                        "Windows specific settings."
                    ))),
                    type: 'object',
                    properties: {
                        runtime: {
                            description: ( (localize(
                                'vscode.extension.contributes.debuggers.windows.runtime',
                                "Runtime used for Windows."
                            ))),
                            type: 'string'
                        }
                    }
                },
                osx: {
                    description: ( (localize('vscode.extension.contributes.debuggers.osx', "macOS specific settings."))),
                    type: 'object',
                    properties: {
                        runtime: {
                            description: ( (localize(
                                'vscode.extension.contributes.debuggers.osx.runtime',
                                "Runtime used for macOS."
                            ))),
                            type: 'string'
                        }
                    }
                },
                linux: {
                    description: ( (localize('vscode.extension.contributes.debuggers.linux', "Linux specific settings."))),
                    type: 'object',
                    properties: {
                        runtime: {
                            description: ( (localize(
                                'vscode.extension.contributes.debuggers.linux.runtime',
                                "Runtime used for Linux."
                            ))),
                            type: 'string'
                        }
                    }
                },
                strings: {
                    description: ( (localize(
                        'vscode.extension.contributes.debuggers.strings',
                        "UI strings contributed by this debug adapter."
                    ))),
                    type: 'object',
                    properties: {
                        unverifiedBreakpoints: {
                            description: ( (localize(
                                'vscode.extension.contributes.debuggers.strings.unverifiedBreakpoints',
                                "When there are unverified breakpoints in a language supported by this debug adapter, this message will appear on the breakpoint hover and in the breakpoints view. Markdown and command links are supported."
                            ))),
                            type: 'string'
                        }
                    }
                }
            }
        }
    }
})));
const breakpointsExtPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'breakpoints',
    jsonSchema: {
        description: ( (localize('vscode.extension.contributes.breakpoints', 'Contributes breakpoints.'))),
        type: 'array',
        defaultSnippets: [{ body: [{ language: '' }] }],
        items: {
            type: 'object',
            additionalProperties: false,
            defaultSnippets: [{ body: { language: '' } }],
            properties: {
                language: {
                    description: ( (localize(
                        'vscode.extension.contributes.breakpoints.language',
                        "Allow breakpoints for this language."
                    ))),
                    type: 'string'
                },
                when: {
                    description: ( (localize(
                        'vscode.extension.contributes.breakpoints.when',
                        "Condition which must be true to enable breakpoints in this language. Consider matching this to the debugger when clause as appropriate."
                    ))),
                    type: 'string',
                    default: ''
                }
            }
        }
    }
})));
const presentationSchema = {
    type: 'object',
    description: ( (localize(
        'presentation',
        "Presentation options on how to show this configuration in the debug configuration dropdown and the command palette."
    ))),
    properties: {
        hidden: {
            type: 'boolean',
            default: false,
            description: ( (localize(
                'presentation.hidden',
                "Controls if this configuration should be shown in the configuration dropdown and the command palette."
            )))
        },
        group: {
            type: 'string',
            default: '',
            description: ( (localize(
                'presentation.group',
                "Group that this configuration belongs to. Used for grouping and sorting in the configuration dropdown and the command palette."
            )))
        },
        order: {
            type: 'number',
            default: 1,
            description: ( (localize(
                'presentation.order',
                "Order of this configuration within a group. Used for grouping and sorting in the configuration dropdown and the command palette."
            )))
        }
    },
    default: {
        hidden: false,
        group: '',
        order: 1
    }
};
const defaultCompound = { name: 'Compound', configurations: [] };
const launchSchema = {
    id: launchSchemaId,
    type: 'object',
    title: ( (localize('app.launch.json.title', "Launch"))),
    allowTrailingCommas: true,
    allowComments: true,
    required: [],
    default: { version: '0.2.0', configurations: [], compounds: [] },
    properties: {
        version: {
            type: 'string',
            description: ( (localize('app.launch.json.version', "Version of this file format."))),
            default: '0.2.0'
        },
        configurations: {
            type: 'array',
            description: ( (localize(
                'app.launch.json.configurations',
                "List of configurations. Add new configurations or edit existing ones by using IntelliSense."
            ))),
            items: {
                defaultSnippets: [],
                'type': 'object',
                oneOf: []
            }
        },
        compounds: {
            type: 'array',
            description: ( (localize(
                'app.launch.json.compounds',
                "List of compounds. Each compound references multiple configurations which will get launched together."
            ))),
            items: {
                type: 'object',
                required: ['name', 'configurations'],
                properties: {
                    name: {
                        type: 'string',
                        description: ( (localize(
                            'app.launch.json.compound.name',
                            "Name of compound. Appears in the launch configuration drop down menu."
                        )))
                    },
                    presentation: presentationSchema,
                    configurations: {
                        type: 'array',
                        default: [],
                        items: {
                            oneOf: [{
                                    enum: [],
                                    description: ( (localize('useUniqueNames', "Please use unique configuration names.")))
                                }, {
                                    type: 'object',
                                    required: ['name'],
                                    properties: {
                                        name: {
                                            enum: [],
                                            description: ( (localize(
                                                'app.launch.json.compound.name',
                                                "Name of compound. Appears in the launch configuration drop down menu."
                                            )))
                                        },
                                        folder: {
                                            enum: [],
                                            description: ( (localize(
                                                'app.launch.json.compound.folder',
                                                "Name of folder in which the compound is located."
                                            )))
                                        }
                                    }
                                }]
                        },
                        description: ( (localize(
                            'app.launch.json.compounds.configurations',
                            "Names of configurations that will be started as part of this compound."
                        )))
                    },
                    stopAll: {
                        type: 'boolean',
                        default: false,
                        description: ( (localize(
                            'app.launch.json.compound.stopAll',
                            "Controls whether manually terminating one session will stop all of the compound sessions."
                        )))
                    },
                    preLaunchTask: {
                        type: 'string',
                        default: '',
                        description: ( (localize(
                            'compoundPrelaunchTask',
                            "Task to run before any of the compound configurations start."
                        )))
                    }
                },
                default: defaultCompound
            },
            default: [
                defaultCompound
            ]
        },
        inputs: inputsSchema.definitions.inputs
    }
};
const taskDefinitionSchema = {
    type: 'object',
    additionalProperties: false,
    properties: {
        type: {
            type: 'string',
            description: ( (localize(
                'TaskDefinition.description',
                'The actual task type. Please note that types starting with a \'$\' are reserved for internal usage.'
            )))
        },
        required: {
            type: 'array',
            items: {
                type: 'string'
            }
        },
        properties: {
            type: 'object',
            description: ( (localize('TaskDefinition.properties', 'Additional properties of the task type'))),
            additionalProperties: {
                $ref: 'http://json-schema.org/draft-07/schema#'
            }
        },
        when: {
            type: 'string',
            markdownDescription: ( (localize(
                'TaskDefinition.when',
                'Condition which must be true to enable this type of task. Consider using `shellExecutionSupported`, `processExecutionSupported`, and `customExecutionSupported` as appropriate for this task definition. See the [API documentation](https://code.visualstudio.com/api/extension-guides/task-provider#when-clause) for more information.'
            ))),
            default: ''
        }
    }
};
var Configuration;
( ((function(Configuration) {
    function from(value, extensionId, messageCollector) {
        if (!value) {
            return undefined;
        }
        const taskType = isString(value.type) ? value.type : undefined;
        if (!taskType || taskType.length === 0) {
            messageCollector.error(( (localize(
                'TaskTypeConfiguration.noType',
                'The task type configuration is missing the required \'taskType\' property'
            ))));
            return undefined;
        }
        const required = [];
        if (Array.isArray(value.required)) {
            for (const element of value.required) {
                if (isString(element)) {
                    required.push(element);
                }
            }
        }
        return {
            extensionId: extensionId.value,
            taskType, required: required,
            properties: value.properties ? deepClone(value.properties) : {},
            when: value.when ? ContextKeyExpr.deserialize(value.when) : undefined
        };
    }
    Configuration.from = from;
})(Configuration || (Configuration = {}))));
const taskDefinitionsExtPoint = ( (ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'taskDefinitions',
    activationEventsGenerator: (contributions, result) => {
        for (const task of contributions) {
            if (task.type) {
                result.push(`onTaskType:${task.type}`);
            }
        }
    },
    jsonSchema: {
        description: ( (localize('TaskDefinitionExtPoint', 'Contributes task kinds'))),
        type: 'array',
        items: taskDefinitionSchema
    }
})));
class TaskDefinitionRegistryImpl {
    constructor() {
        this._onDefinitionsChanged = ( (new Emitter()));
        this.onDefinitionsChanged = this._onDefinitionsChanged.event;
        this.taskTypes = Object.create(null);
        this.readyPromise = ( (new Promise((resolve, reject) => {
            taskDefinitionsExtPoint.setHandler((extensions, delta) => {
                this._schema = undefined;
                try {
                    for (const extension of delta.removed) {
                        const taskTypes = extension.value;
                        for (const taskType of taskTypes) {
                            if (this.taskTypes && taskType.type && this.taskTypes[taskType.type]) {
                                delete this.taskTypes[taskType.type];
                            }
                        }
                    }
                    for (const extension of delta.added) {
                        const taskTypes = extension.value;
                        for (const taskType of taskTypes) {
                            const type = Configuration.from(taskType, extension.description.identifier, extension.collector);
                            if (type) {
                                this.taskTypes[type.taskType] = type;
                            }
                        }
                    }
                    if ((delta.removed.length > 0) || (delta.added.length > 0)) {
                        this._onDefinitionsChanged.fire();
                    }
                }
                catch (error) {
                }
                resolve(undefined);
            });
        })));
    }
    onReady() {
        return this.readyPromise;
    }
    get(key) {
        return this.taskTypes[key];
    }
    all() {
        return (
             (( (Object.keys(this.taskTypes))).map(key => this.taskTypes[key]))
        );
    }
    getJsonSchema() {
        if (this._schema === undefined) {
            const schemas = [];
            for (const definition of this.all()) {
                const schema = {
                    type: 'object',
                    additionalProperties: false
                };
                if (definition.required.length > 0) {
                    schema.required = definition.required.slice(0);
                }
                if (definition.properties !== undefined) {
                    schema.properties = deepClone(definition.properties);
                }
                else {
                    schema.properties = Object.create(null);
                }
                schema.properties.type = {
                    type: 'string',
                    enum: [definition.taskType]
                };
                schemas.push(schema);
            }
            this._schema = { oneOf: schemas };
        }
        return this._schema;
    }
}
const TaskDefinitionRegistry = ( (new TaskDefinitionRegistryImpl()));
const jsonRegistry$1 = ( (Registry.as(Extensions$1.JSONContribution)));
let AdapterManager = class AdapterManager extends Disposable {
    constructor(delegate, editorService, configurationService, quickInputService, instantiationService, commandService, extensionService, contextKeyService, languageService, dialogService, lifecycleService) {
        super();
        this.editorService = editorService;
        this.configurationService = configurationService;
        this.quickInputService = quickInputService;
        this.instantiationService = instantiationService;
        this.commandService = commandService;
        this.extensionService = extensionService;
        this.contextKeyService = contextKeyService;
        this.languageService = languageService;
        this.dialogService = dialogService;
        this.lifecycleService = lifecycleService;
        this.debugAdapterFactories = ( (new Map()));
        this._onDidRegisterDebugger = ( (new Emitter()));
        this._onDidDebuggersExtPointRead = ( (new Emitter()));
        this.breakpointContributions = [];
        this.debuggerWhenKeys = ( (new Set()));
        this.usedDebugTypes = ( (new Set()));
        this.adapterDescriptorFactories = [];
        this.debuggers = [];
        this.registerListeners();
        this.contextKeyService.bufferChangeEvents(() => {
            this.debuggersAvailable = CONTEXT_DEBUGGERS_AVAILABLE.bindTo(contextKeyService);
            this.debugExtensionsAvailable = CONTEXT_DEBUG_EXTENSION_AVAILABLE.bindTo(contextKeyService);
        });
        this._register(this.contextKeyService.onDidChangeContext(e => {
            if (e.affectsSome(this.debuggerWhenKeys)) {
                this.debuggersAvailable.set(this.hasEnabledDebuggers());
                this.updateDebugAdapterSchema();
            }
        }));
        this._register(this.onDidDebuggersExtPointRead(() => {
            this.debugExtensionsAvailable.set(this.debuggers.length > 0);
        }));
        this.lifecycleService.when(4 )
            .then(() => this.debugExtensionsAvailable.set(this.debuggers.length > 0));
        this._register(delegate.onDidNewSession(s => {
            this.usedDebugTypes.add(s.configuration.type);
        }));
    }
    registerListeners() {
        debuggersExtPoint.setHandler((extensions, delta) => {
            delta.added.forEach(added => {
                added.value.forEach(rawAdapter => {
                    if (!rawAdapter.type || (typeof rawAdapter.type !== 'string')) {
                        added.collector.error(( (localize(
                            'debugNoType',
                            "Debugger 'type' can not be omitted and must be of type 'string'."
                        ))));
                    }
                    if (rawAdapter.type !== '*') {
                        const existing = this.getDebugger(rawAdapter.type);
                        if (existing) {
                            existing.merge(rawAdapter, added.description);
                        }
                        else {
                            const dbg = this.instantiationService.createInstance(Debugger, this, rawAdapter, added.description);
                            dbg.when?.keys().forEach(key => this.debuggerWhenKeys.add(key));
                            this.debuggers.push(dbg);
                        }
                    }
                });
            });
            extensions.forEach(extension => {
                extension.value.forEach(rawAdapter => {
                    if (rawAdapter.type === '*') {
                        this.debuggers.forEach(dbg => dbg.merge(rawAdapter, extension.description));
                    }
                });
            });
            delta.removed.forEach(removed => {
                const removedTypes = ( (removed.value.map(rawAdapter => rawAdapter.type)));
                this.debuggers = this.debuggers.filter(d => removedTypes.indexOf(d.type) === -1);
            });
            this.updateDebugAdapterSchema();
            this._onDidDebuggersExtPointRead.fire();
        });
        breakpointsExtPoint.setHandler(extensions => {
            this.breakpointContributions = extensions.flatMap(ext => ( (ext.value.map(
                breakpoint => this.instantiationService.createInstance(Breakpoints, breakpoint)
            ))));
        });
    }
    updateDebugAdapterSchema() {
        const items = launchSchema.properties['configurations'].items;
        const taskSchema = TaskDefinitionRegistry.getJsonSchema();
        const definitions = {
            'common': {
                properties: {
                    'name': {
                        type: 'string',
                        description: ( (localize(
                            'debugName',
                            "Name of configuration; appears in the launch configuration dropdown menu."
                        ))),
                        default: 'Launch'
                    },
                    'debugServer': {
                        type: 'number',
                        description: ( (localize(
                            'debugServer',
                            "For debug extension development only: if a port is specified VS Code tries to connect to a debug adapter running in server mode"
                        ))),
                        default: 4711
                    },
                    'preLaunchTask': {
                        anyOf: [taskSchema, {
                                type: ['string']
                            }],
                        default: '',
                        defaultSnippets: [{ body: { task: '', type: '' } }],
                        description: ( (localize('debugPrelaunchTask', "Task to run before debug session starts.")))
                    },
                    'postDebugTask': {
                        anyOf: [taskSchema, {
                                type: ['string'],
                            }],
                        default: '',
                        defaultSnippets: [{ body: { task: '', type: '' } }],
                        description: ( (localize('debugPostDebugTask', "Task to run after debug session ends.")))
                    },
                    'presentation': presentationSchema,
                    'internalConsoleOptions': INTERNAL_CONSOLE_OPTIONS_SCHEMA,
                    'suppressMultipleSessionWarning': {
                        type: 'boolean',
                        description: ( (localize(
                            'suppressMultipleSessionWarning',
                            "Disable the warning when trying to start the same debug configuration more than once."
                        ))),
                        default: true
                    }
                }
            }
        };
        launchSchema.definitions = definitions;
        items.oneOf = [];
        items.defaultSnippets = [];
        this.debuggers.forEach(adapter => {
            const schemaAttributes = adapter.getSchemaAttributes(definitions);
            if (schemaAttributes && items.oneOf) {
                items.oneOf.push(...schemaAttributes);
            }
            const configurationSnippets = adapter.configurationSnippets;
            if (configurationSnippets && items.defaultSnippets) {
                items.defaultSnippets.push(...configurationSnippets);
            }
        });
        jsonRegistry$1.registerSchema(launchSchemaId, launchSchema);
    }
    registerDebugAdapterFactory(debugTypes, debugAdapterLauncher) {
        debugTypes.forEach(debugType => this.debugAdapterFactories.set(debugType, debugAdapterLauncher));
        this.debuggersAvailable.set(this.hasEnabledDebuggers());
        this._onDidRegisterDebugger.fire();
        return {
            dispose: () => {
                debugTypes.forEach(debugType => this.debugAdapterFactories.delete(debugType));
            }
        };
    }
    hasEnabledDebuggers() {
        for (const [type] of this.debugAdapterFactories) {
            const dbg = this.getDebugger(type);
            if (dbg && dbg.enabled) {
                return true;
            }
        }
        return false;
    }
    createDebugAdapter(session) {
        const factory = this.debugAdapterFactories.get(session.configuration.type);
        if (factory) {
            return factory.createDebugAdapter(session);
        }
        return undefined;
    }
    substituteVariables(debugType, folder, config) {
        const factory = this.debugAdapterFactories.get(debugType);
        if (factory) {
            return factory.substituteVariables(folder, config);
        }
        return Promise.resolve(config);
    }
    runInTerminal(debugType, args, sessionId) {
        const factory = this.debugAdapterFactories.get(debugType);
        if (factory) {
            return factory.runInTerminal(args, sessionId);
        }
        return Promise.resolve(void 0);
    }
    registerDebugAdapterDescriptorFactory(debugAdapterProvider) {
        this.adapterDescriptorFactories.push(debugAdapterProvider);
        return {
            dispose: () => {
                this.unregisterDebugAdapterDescriptorFactory(debugAdapterProvider);
            }
        };
    }
    unregisterDebugAdapterDescriptorFactory(debugAdapterProvider) {
        const ix = this.adapterDescriptorFactories.indexOf(debugAdapterProvider);
        if (ix >= 0) {
            this.adapterDescriptorFactories.splice(ix, 1);
        }
    }
    getDebugAdapterDescriptor(session) {
        const config = session.configuration;
        const providers = this.adapterDescriptorFactories.filter(p => p.type === config.type && p.createDebugAdapterDescriptor);
        if (providers.length === 1) {
            return providers[0].createDebugAdapterDescriptor(session);
        }
        return Promise.resolve(undefined);
    }
    getDebuggerLabel(type) {
        const dbgr = this.getDebugger(type);
        if (dbgr) {
            return dbgr.label;
        }
        return undefined;
    }
    get onDidRegisterDebugger() {
        return this._onDidRegisterDebugger.event;
    }
    get onDidDebuggersExtPointRead() {
        return this._onDidDebuggersExtPointRead.event;
    }
    canSetBreakpointsIn(model) {
        const languageId = model.getLanguageId();
        if (!languageId || languageId === 'jsonc' || languageId === 'log') {
            return false;
        }
        if (this.configurationService.getValue('debug').allowBreakpointsEverywhere) {
            return true;
        }
        return this.breakpointContributions.some(breakpoints => breakpoints.language === languageId && breakpoints.enabled);
    }
    getDebugger(type) {
        return this.debuggers.find(dbg => equalsIgnoreCase(dbg.type, type));
    }
    getEnabledDebugger(type) {
        const adapter = this.getDebugger(type);
        return adapter && adapter.enabled ? adapter : undefined;
    }
    someDebuggerInterestedInLanguage(languageId) {
        return !!this.debuggers
            .filter(d => d.enabled)
            .find(a => a.interestedInLanguage(languageId));
    }
    async guessDebugger(gettingConfigurations) {
        const activeTextEditorControl = this.editorService.activeTextEditorControl;
        let candidates = [];
        let languageLabel = null;
        let model = null;
        if (isCodeEditor(activeTextEditorControl)) {
            model = activeTextEditorControl.getModel();
            const language = model ? model.getLanguageId() : undefined;
            if (language) {
                languageLabel = this.languageService.getLanguageName(language);
            }
            const adapters = this.debuggers
                .filter(a => a.enabled)
                .filter(a => language && a.interestedInLanguage(language));
            if (adapters.length === 1) {
                return adapters[0];
            }
            if (adapters.length > 1) {
                candidates = adapters;
            }
        }
        if ((!languageLabel || gettingConfigurations || (model && this.canSetBreakpointsIn(model))) && candidates.length === 0) {
            await this.activateDebuggers('onDebugInitialConfigurations');
            candidates = this.debuggers
                .filter(a => a.enabled)
                .filter(dbg => dbg.hasInitialConfiguration() || dbg.hasConfigurationProvider());
        }
        if (candidates.length === 0 && languageLabel) {
            if (languageLabel.indexOf(' ') >= 0) {
                languageLabel = `'${languageLabel}'`;
            }
            const { confirmed } = await this.dialogService.confirm({
                type: Severity$1.Warning,
                message: ( (localize(
                    'CouldNotFindLanguage',
                    "You don't have an extension for debugging {0}. Should we find a {0} extension in the Marketplace?",
                    languageLabel
                ))),
                primaryButton: ( (localize(
                    { key: 'findExtension', comment: ['&& denotes a mnemonic'] },
                    "&&Find {0} extension",
                    languageLabel
                )))
            });
            if (confirmed) {
                await this.commandService.executeCommand('debug.installAdditionalDebuggers', languageLabel);
            }
            return undefined;
        }
        this.initExtensionActivationsIfNeeded();
        candidates.sort((first, second) => first.label.localeCompare(second.label));
        const suggestedCandidates = [];
        const otherCandidates = [];
        candidates.forEach(d => {
            const descriptor = d.getMainExtensionDescriptor();
            if (descriptor.id && !!this.earlyActivatedExtensions?.has(descriptor.id)) {
                suggestedCandidates.push(d);
            }
            else if (this.usedDebugTypes.has(d.type)) {
                suggestedCandidates.push(d);
            }
            else {
                otherCandidates.push(d);
            }
        });
        const picks = [];
        if (suggestedCandidates.length > 0) {
            picks.push({ type: 'separator', label: ( (localize('suggestedDebuggers', "Suggested"))) }, ...( (suggestedCandidates.map(c => ({ label: c.label, debugger: c })))));
        }
        if (otherCandidates.length > 0) {
            if (picks.length > 0) {
                picks.push({ type: 'separator', label: '' });
            }
            picks.push(...( (otherCandidates.map(c => ({ label: c.label, debugger: c })))));
        }
        picks.push({ type: 'separator', label: '' }, { label: languageLabel ? ( (localize('installLanguage', "Install an extension for {0}...", languageLabel))) : ( (localize('installExt', "Install extension..."))) });
        const placeHolder = ( (localize('selectDebug', "Select debugger")));
        return this.quickInputService.pick(picks, { activeItem: picks[0], placeHolder })
            .then(picked => {
            if (picked && picked.debugger) {
                return picked.debugger;
            }
            if (picked) {
                this.commandService.executeCommand('debug.installAdditionalDebuggers', languageLabel);
            }
            return undefined;
        });
    }
    initExtensionActivationsIfNeeded() {
        if (!this.earlyActivatedExtensions) {
            this.earlyActivatedExtensions = ( (new Set()));
            const status = this.extensionService.getExtensionsStatus();
            for (const id in status) {
                if (!!status[id].activationTimes) {
                    this.earlyActivatedExtensions.add(id);
                }
            }
        }
    }
    async activateDebuggers(activationEvent, debugType) {
        this.initExtensionActivationsIfNeeded();
        const promises = [
            this.extensionService.activateByEvent(activationEvent),
            this.extensionService.activateByEvent('onDebug')
        ];
        if (debugType) {
            promises.push(this.extensionService.activateByEvent(`${activationEvent}:${debugType}`));
        }
        await Promise.all(promises);
    }
};
AdapterManager = ( (__decorate([
    ( (__param(1, IEditorService))),
    ( (__param(2, IConfigurationService))),
    ( (__param(3, IQuickInputService))),
    ( (__param(4, IInstantiationService))),
    ( (__param(5, ICommandService))),
    ( (__param(6, IExtensionService))),
    ( (__param(7, IContextKeyService))),
    ( (__param(8, ILanguageService))),
    ( (__param(9, IDialogService))),
    ( (__param(10, ILifecycleService)))
], AdapterManager)));
const UNKNOWN_SOURCE_LABEL = ( (localize('unknownSource', "Unknown Source")));
class Source {
    constructor(raw_, sessionId, uriIdentityService, logService) {
        let path;
        if (raw_) {
            this.raw = raw_;
            path = this.raw.path || this.raw.name || '';
            this.available = true;
        }
        else {
            this.raw = { name: UNKNOWN_SOURCE_LABEL };
            this.available = false;
            path = `${DEBUG_SCHEME}:${UNKNOWN_SOURCE_LABEL}`;
        }
        this.uri = getUriFromSource(this.raw, path, sessionId, uriIdentityService, logService);
    }
    get name() {
        return this.raw.name || basenameOrAuthority(this.uri);
    }
    get origin() {
        return this.raw.origin;
    }
    get presentationHint() {
        return this.raw.presentationHint;
    }
    get reference() {
        return this.raw.sourceReference;
    }
    get inMemory() {
        return this.uri.scheme === DEBUG_SCHEME;
    }
    openInEditor(editorService, selection, preserveFocus, sideBySide, pinned) {
        return !this.available ? Promise.resolve(undefined) : editorService.openEditor({
            resource: this.uri,
            description: this.origin,
            options: {
                preserveFocus,
                selection,
                revealIfOpened: true,
                selectionRevealType: 1 ,
                pinned: pinned || (!preserveFocus && !this.inMemory)
            }
        }, sideBySide ? SIDE_GROUP : ACTIVE_GROUP);
    }
    static getEncodedDebugData(modelUri) {
        let path;
        let sourceReference;
        let sessionId;
        switch (modelUri.scheme) {
            case Schemas.file:
                path = normalize(modelUri.fsPath);
                break;
            case DEBUG_SCHEME:
                path = modelUri.path;
                if (modelUri.query) {
                    const keyvalues = modelUri.query.split('&');
                    for (const keyvalue of keyvalues) {
                        const pair = keyvalue.split('=');
                        if (pair.length === 2) {
                            switch (pair[0]) {
                                case 'session':
                                    sessionId = pair[1];
                                    break;
                                case 'ref':
                                    sourceReference = parseInt(pair[1]);
                                    break;
                            }
                        }
                    }
                }
                break;
            default:
                path = ( (modelUri.toString()));
                break;
        }
        return {
            name: basenameOrAuthority(modelUri),
            path,
            sourceReference,
            sessionId
        };
    }
}
function getUriFromSource(raw, path, sessionId, uriIdentityService, logService) {
    const _getUriFromSource = (path) => {
        if (typeof raw.sourceReference === 'number' && raw.sourceReference > 0) {
            return (
                 (URI.from({
                    scheme: DEBUG_SCHEME,
                    path,
                    query: `session=${sessionId}&ref=${raw.sourceReference}`
                }))
            );
        }
        if (path && isUri(path)) {
            return uriIdentityService.asCanonicalUri(( (URI.parse(path))));
        }
        if (path && isAbsolute(path)) {
            return uriIdentityService.asCanonicalUri(URI.file(path));
        }
        return uriIdentityService.asCanonicalUri(( (URI.from({
            scheme: DEBUG_SCHEME,
            path,
            query: `session=${sessionId}`
        }))));
    };
    try {
        return _getUriFromSource(path);
    }
    catch (err) {
        logService.error('Invalid path from debug adapter: ' + path);
        return _getUriFromSource('/invalidDebugSource');
    }
}
class DisassemblyViewInput extends EditorInput {
    constructor() {
        super(...arguments);
        this.resource = undefined;
    }
    get typeId() {
        return DisassemblyViewInput.ID;
    }
    static get instance() {
        if (!DisassemblyViewInput._instance || DisassemblyViewInput._instance.isDisposed()) {
            DisassemblyViewInput._instance = ( (new DisassemblyViewInput()));
        }
        return DisassemblyViewInput._instance;
    }
    getName() {
        return (
             (localize('disassemblyInputName', "Disassembly"))
        );
    }
    matches(other) {
        return other instanceof DisassemblyViewInput;
    }
}
DisassemblyViewInput.ID = 'debug.disassemblyView.input';
class ExpressionContainer {
    constructor(session, threadId, _reference, id, namedVariables = 0, indexedVariables = 0, memoryReference = undefined, startOfVariables = 0, presentationHint = undefined) {
        this.session = session;
        this.threadId = threadId;
        this._reference = _reference;
        this.id = id;
        this.namedVariables = namedVariables;
        this.indexedVariables = indexedVariables;
        this.memoryReference = memoryReference;
        this.startOfVariables = startOfVariables;
        this.presentationHint = presentationHint;
        this.valueChanged = false;
        this._value = '';
    }
    get reference() {
        return this._reference;
    }
    set reference(value) {
        this._reference = value;
        this.children = undefined;
    }
    async evaluateLazy() {
        if (typeof this.reference === 'undefined') {
            return;
        }
        const response = await this.session.variables(this.reference, this.threadId, undefined, undefined, undefined);
        if (!response || !response.body || !response.body.variables || response.body.variables.length !== 1) {
            return;
        }
        const dummyVar = response.body.variables[0];
        this.reference = dummyVar.variablesReference;
        this._value = dummyVar.value;
        this.namedVariables = dummyVar.namedVariables;
        this.indexedVariables = dummyVar.indexedVariables;
        this.memoryReference = dummyVar.memoryReference;
        this.presentationHint = dummyVar.presentationHint;
        this.adoptLazyResponse(dummyVar);
    }
    adoptLazyResponse(response) {
    }
    getChildren() {
        if (!this.children) {
            this.children = this.doGetChildren();
        }
        return this.children;
    }
    async doGetChildren() {
        if (!this.hasChildren) {
            return [];
        }
        if (!this.getChildrenInChunks) {
            return this.fetchVariables(undefined, undefined, undefined);
        }
        const children = this.namedVariables ? await this.fetchVariables(undefined, undefined, 'named') : [];
        let chunkSize = ExpressionContainer.BASE_CHUNK_SIZE;
        while (!!this.indexedVariables && this.indexedVariables > chunkSize * ExpressionContainer.BASE_CHUNK_SIZE) {
            chunkSize *= ExpressionContainer.BASE_CHUNK_SIZE;
        }
        if (!!this.indexedVariables && this.indexedVariables > chunkSize) {
            const numberOfChunks = Math.ceil(this.indexedVariables / chunkSize);
            for (let i = 0; i < numberOfChunks; i++) {
                const start = (this.startOfVariables || 0) + i * chunkSize;
                const count = Math.min(chunkSize, this.indexedVariables - i * chunkSize);
                children.push(( (new Variable(
                    this.session,
                    this.threadId,
                    this,
                    this.reference,
                    `[${start}..${start + count - 1}]`,
                    '',
                    '',
                    undefined,
                    count,
                    undefined,
                    { kind: 'virtual' },
                    undefined,
                    undefined,
                    true,
                    start
                ))));
            }
            return children;
        }
        const variables = await this.fetchVariables(this.startOfVariables, this.indexedVariables, 'indexed');
        return children.concat(variables);
    }
    getId() {
        return this.id;
    }
    getSession() {
        return this.session;
    }
    get value() {
        return this._value;
    }
    get hasChildren() {
        return !!this.reference && this.reference > 0 && !this.presentationHint?.lazy;
    }
    async fetchVariables(start, count, filter) {
        try {
            const response = await this.session.variables(this.reference || 0, this.threadId, filter, start, count);
            if (!response || !response.body || !response.body.variables) {
                return [];
            }
            const nameCount = ( (new Map()));
            const vars = ( (response.body.variables.filter(v => !!v).map((v) => {
                if (isString(v.value) && isString(v.name) && typeof v.variablesReference === 'number') {
                    const count = nameCount.get(v.name) || 0;
                    const idDuplicationIndex = count > 0 ? ( (count.toString())) : '';
                    nameCount.set(v.name, count + 1);
                    return (
                         (new Variable(
                            this.session,
                            this.threadId,
                            this,
                            v.variablesReference,
                            v.name,
                            v.evaluateName,
                            v.value,
                            v.namedVariables,
                            v.indexedVariables,
                            v.memoryReference,
                            v.presentationHint,
                            v.type,
                            v.__vscodeVariableMenuContext,
                            true,
                            0,
                            idDuplicationIndex
                        ))
                    );
                }
                return (
                     (new Variable(
                        this.session,
                        this.threadId,
                        this,
                        0,
                        '',
                        undefined,
                         (localize('invalidVariableAttributes', "Invalid variable attributes")),
                        0,
                        0,
                        undefined,
                        { kind: 'virtual' },
                        undefined,
                        undefined,
                        false
                    ))
                );
            })));
            if (this.session.autoExpandLazyVariables) {
                await Promise.all(( (vars.map(v => v.presentationHint?.lazy && v.evaluateLazy()))));
            }
            return vars;
        }
        catch (e) {
            return [( (new Variable(
                this.session,
                this.threadId,
                this,
                0,
                '',
                undefined,
                e.message,
                0,
                0,
                undefined,
                { kind: 'virtual' },
                undefined,
                undefined,
                false
            )))];
        }
    }
    get getChildrenInChunks() {
        return !!this.indexedVariables;
    }
    set value(value) {
        this._value = value;
        this.valueChanged = !!ExpressionContainer.allValues.get(this.getId()) &&
            ExpressionContainer.allValues.get(this.getId()) !== Expression.DEFAULT_VALUE && ExpressionContainer.allValues.get(this.getId()) !== value;
        ExpressionContainer.allValues.set(this.getId(), value);
    }
    toString() {
        return this.value;
    }
    async evaluateExpression(expression, session, stackFrame, context, keepLazyVars = false) {
        if (!session || (!stackFrame && context !== 'repl')) {
            this.value = context === 'repl' ? ( (localize('startDebugFirst', "Please start a debug session to evaluate expressions"))) : Expression.DEFAULT_VALUE;
            this.reference = 0;
            return false;
        }
        this.session = session;
        try {
            const response = await session.evaluate(expression, stackFrame ? stackFrame.frameId : undefined, context);
            if (response && response.body) {
                this.value = response.body.result || '';
                this.reference = response.body.variablesReference;
                this.namedVariables = response.body.namedVariables;
                this.indexedVariables = response.body.indexedVariables;
                this.memoryReference = response.body.memoryReference;
                this.type = response.body.type || this.type;
                this.presentationHint = response.body.presentationHint;
                if (!keepLazyVars && response.body.presentationHint?.lazy) {
                    await this.evaluateLazy();
                }
                return true;
            }
            return false;
        }
        catch (e) {
            this.value = e.message || '';
            this.reference = 0;
            return false;
        }
    }
}
ExpressionContainer.allValues = ( (new Map()));
ExpressionContainer.BASE_CHUNK_SIZE = 100;
function handleSetResponse(expression, response) {
    if (response && response.body) {
        expression.value = response.body.value || '';
        expression.type = response.body.type || expression.type;
        expression.reference = response.body.variablesReference;
        expression.namedVariables = response.body.namedVariables;
        expression.indexedVariables = response.body.indexedVariables;
    }
}
class Expression extends ExpressionContainer {
    constructor(name, id = generateUuid()) {
        super(undefined, undefined, 0, id);
        this.name = name;
        this.available = false;
        if (name) {
            this.value = Expression.DEFAULT_VALUE;
        }
    }
    async evaluate(session, stackFrame, context, keepLazyVars) {
        this.available = await this.evaluateExpression(this.name, session, stackFrame, context, keepLazyVars);
    }
    toString() {
        return `${this.name}\n${this.value}`;
    }
    async setExpression(value, stackFrame) {
        if (!this.session) {
            return;
        }
        const response = await this.session.setExpression(stackFrame.frameId, this.name, value);
        handleSetResponse(this, response);
    }
}
Expression.DEFAULT_VALUE = ( (localize('notAvailable', "not available")));
class Variable extends ExpressionContainer {
    constructor(session, threadId, parent, reference, name, evaluateName, value, namedVariables, indexedVariables, memoryReference, presentationHint, type = undefined, variableMenuContext = undefined, available = true, startOfVariables = 0, idDuplicationIndex = '') {
        super(session, threadId, reference, `variable:${parent.getId()}:${name}:${idDuplicationIndex}`, namedVariables, indexedVariables, memoryReference, startOfVariables, presentationHint);
        this.parent = parent;
        this.name = name;
        this.evaluateName = evaluateName;
        this.variableMenuContext = variableMenuContext;
        this.available = available;
        this.value = value || '';
        this.type = type;
    }
    async setVariable(value, stackFrame) {
        if (!this.session) {
            return;
        }
        try {
            if (this.session.capabilities.supportsSetExpression && !this.session.capabilities.supportsSetVariable && this.evaluateName) {
                return this.setExpression(value, stackFrame);
            }
            const response = await this.session.setVariable(this.parent.reference, this.name, value);
            handleSetResponse(this, response);
        }
        catch (err) {
            this.errorMessage = err.message;
        }
    }
    async setExpression(value, stackFrame) {
        if (!this.session || !this.evaluateName) {
            return;
        }
        const response = await this.session.setExpression(stackFrame.frameId, this.evaluateName, value);
        handleSetResponse(this, response);
    }
    toString() {
        return this.name ? `${this.name}: ${this.value}` : this.value;
    }
    adoptLazyResponse(response) {
        this.evaluateName = response.evaluateName;
    }
    toDebugProtocolObject() {
        return {
            name: this.name,
            variablesReference: this.reference || 0,
            memoryReference: this.memoryReference,
            value: this.value,
            evaluateName: this.evaluateName
        };
    }
}
class Scope extends ExpressionContainer {
    constructor(stackFrame, id, name, reference, expensive, namedVariables, indexedVariables, range) {
        super(stackFrame.thread.session, stackFrame.thread.threadId, reference, `scope:${name}:${id}`, namedVariables, indexedVariables);
        this.name = name;
        this.expensive = expensive;
        this.range = range;
    }
    toString() {
        return this.name;
    }
    toDebugProtocolObject() {
        return {
            name: this.name,
            variablesReference: this.reference || 0,
            expensive: this.expensive
        };
    }
}
class ErrorScope extends Scope {
    constructor(stackFrame, index, message) {
        super(stackFrame, index, message, 0, false);
    }
    toString() {
        return this.name;
    }
}
class StackFrame {
    constructor(thread, frameId, source, name, presentationHint, range, index, canRestart, instructionPointerReference) {
        this.thread = thread;
        this.frameId = frameId;
        this.source = source;
        this.name = name;
        this.presentationHint = presentationHint;
        this.range = range;
        this.index = index;
        this.canRestart = canRestart;
        this.instructionPointerReference = instructionPointerReference;
    }
    getId() {
        return `stackframe:${this.thread.getId()}:${this.index}:${this.source.name}`;
    }
    getScopes() {
        if (!this.scopes) {
            this.scopes = this.thread.session.scopes(this.frameId, this.thread.threadId).then(response => {
                if (!response || !response.body || !response.body.scopes) {
                    return [];
                }
                const usedIds = ( (new Set()));
                return (
                     (response.body.scopes.map(rs => {
                        let id = 0;
                        do {
                            id = stringHash(`${rs.name}:${rs.line}:${rs.column}`, id);
                        } while (usedIds.has(id));
                        usedIds.add(id);
                        return (
                             (new Scope(
                                this,
                                id,
                                rs.name,
                                rs.variablesReference,
                                rs.expensive,
                                rs.namedVariables,
                                rs.indexedVariables,
                                rs.line && rs.column && rs.endLine && rs.endColumn ? ( (new Range(rs.line, rs.column, rs.endLine, rs.endColumn))) : undefined
                            ))
                        );
                    }))
                );
            }, err => [( (new ErrorScope(this, 0, err.message)))]);
        }
        return this.scopes;
    }
    async getMostSpecificScopes(range) {
        const scopes = await this.getScopes();
        const nonExpensiveScopes = scopes.filter(s => !s.expensive);
        const haveRangeInfo = nonExpensiveScopes.some(s => !!s.range);
        if (!haveRangeInfo) {
            return nonExpensiveScopes;
        }
        const scopesContainingRange = nonExpensiveScopes.filter(scope => scope.range && Range.containsRange(scope.range, range))
            .sort((first, second) => (first.range.endLineNumber - first.range.startLineNumber) - (second.range.endLineNumber - second.range.startLineNumber));
        return scopesContainingRange.length ? scopesContainingRange : nonExpensiveScopes;
    }
    restart() {
        return this.thread.session.restartFrame(this.frameId, this.thread.threadId);
    }
    forgetScopes() {
        this.scopes = undefined;
    }
    toString() {
        const lineNumberToString = typeof this.range.startLineNumber === 'number' ? `:${this.range.startLineNumber}` : '';
        const sourceToString = `${this.source.inMemory ? this.source.name : this.source.uri.fsPath}${lineNumberToString}`;
        return sourceToString === UNKNOWN_SOURCE_LABEL ? this.name : `${this.name} (${sourceToString})`;
    }
    async openInEditor(editorService, preserveFocus, sideBySide, pinned) {
        const threadStopReason = this.thread.stoppedDetails?.reason;
        if (this.instructionPointerReference &&
            (threadStopReason === 'instruction breakpoint' ||
                (threadStopReason === 'step' && this.thread.lastSteppingGranularity === 'instruction'))) {
            return editorService.openEditor(DisassemblyViewInput.instance, { pinned: true });
        }
        if (this.source.available) {
            return this.source.openInEditor(editorService, this.range, preserveFocus, sideBySide, pinned);
        }
        return undefined;
    }
    equals(other) {
        return (this.name === other.name) && (other.thread === this.thread) && (this.frameId === other.frameId) && (other.source === this.source) && (Range.equalsRange(this.range, other.range));
    }
}
class Thread {
    constructor(session, name, threadId) {
        this.session = session;
        this.name = name;
        this.threadId = threadId;
        this.callStackCancellationTokens = [];
        this.reachedEndOfCallStack = false;
        this.callStack = [];
        this.staleCallStack = [];
        this.stopped = false;
    }
    getId() {
        return `thread:${this.session.getId()}:${this.threadId}`;
    }
    clearCallStack() {
        if (this.callStack.length) {
            this.staleCallStack = this.callStack;
        }
        this.callStack = [];
        this.callStackCancellationTokens.forEach(c => c.dispose(true));
        this.callStackCancellationTokens = [];
    }
    getCallStack() {
        return this.callStack;
    }
    getStaleCallStack() {
        return this.staleCallStack;
    }
    getTopStackFrame() {
        const callStack = this.getCallStack();
        const firstAvailableStackFrame = callStack.find(sf => !!(sf &&
            ((this.stoppedDetails?.reason === 'instruction breakpoint' || (this.stoppedDetails?.reason === 'step' && this.lastSteppingGranularity === 'instruction')) && sf.instructionPointerReference) ||
            (sf.source && sf.source.available && sf.source.presentationHint !== 'deemphasize')));
        return firstAvailableStackFrame || (callStack.length > 0 ? callStack[0] : undefined);
    }
    get stateLabel() {
        if (this.stoppedDetails) {
            return this.stoppedDetails.description ||
                (this.stoppedDetails.reason ? ( (localize(
                { key: 'pausedOn', comment: ['indicates reason for program being paused'] },
                "Paused on {0}",
                this.stoppedDetails.reason
            ))) : ( (localize('paused', "Paused"))));
        }
        return (
             (localize({ key: 'running', comment: ['indicates state'] }, "Running"))
        );
    }
    async fetchCallStack(levels = 20) {
        if (this.stopped) {
            const start = this.callStack.length;
            const callStack = await this.getCallStackImpl(start, levels);
            this.reachedEndOfCallStack = callStack.length < levels;
            if (start < this.callStack.length) {
                this.callStack.splice(start, this.callStack.length - start);
            }
            this.callStack = this.callStack.concat(callStack || []);
            if (typeof this.stoppedDetails?.totalFrames === 'number' && this.stoppedDetails.totalFrames === this.callStack.length) {
                this.reachedEndOfCallStack = true;
            }
        }
    }
    async getCallStackImpl(startFrame, levels) {
        try {
            const tokenSource = ( (new CancellationTokenSource()));
            this.callStackCancellationTokens.push(tokenSource);
            const response = await this.session.stackTrace(this.threadId, startFrame, levels, tokenSource.token);
            if (!response || !response.body || tokenSource.token.isCancellationRequested) {
                return [];
            }
            if (this.stoppedDetails) {
                this.stoppedDetails.totalFrames = response.body.totalFrames;
            }
            return (
                 (response.body.stackFrames.map((rsf, index) => {
                    const source = this.session.getSource(rsf.source);
                    return (
                         (new StackFrame(
                            this,
                            rsf.id,
                            source,
                            rsf.name,
                            rsf.presentationHint,
                             (new Range(rsf.line, rsf.column, rsf.endLine || rsf.line, rsf.endColumn || rsf.column)),
                            startFrame + index,
                            typeof rsf.canRestart === 'boolean' ? rsf.canRestart : true,
                            rsf.instructionPointerReference
                        ))
                    );
                }))
            );
        }
        catch (err) {
            if (this.stoppedDetails) {
                this.stoppedDetails.framesErrorMessage = err.message;
            }
            return [];
        }
    }
    get exceptionInfo() {
        if (this.stoppedDetails && this.stoppedDetails.reason === 'exception') {
            if (this.session.capabilities.supportsExceptionInfoRequest) {
                return this.session.exceptionInfo(this.threadId);
            }
            return Promise.resolve({
                description: this.stoppedDetails.text,
                breakMode: null
            });
        }
        return Promise.resolve(undefined);
    }
    next(granularity) {
        return this.session.next(this.threadId, granularity);
    }
    stepIn(granularity) {
        return this.session.stepIn(this.threadId, undefined, granularity);
    }
    stepOut(granularity) {
        return this.session.stepOut(this.threadId, granularity);
    }
    stepBack(granularity) {
        return this.session.stepBack(this.threadId, granularity);
    }
    continue() {
        return this.session.continue(this.threadId);
    }
    pause() {
        return this.session.pause(this.threadId);
    }
    terminate() {
        return this.session.terminateThreads([this.threadId]);
    }
    reverseContinue() {
        return this.session.reverseContinue(this.threadId);
    }
}
const getUriForDebugMemory = (sessionId, memoryReference, range, displayName = 'memory') => {
    return (
         (URI.from({
            scheme: DEBUG_MEMORY_SCHEME,
            authority: sessionId,
            path: '/' + encodeURIComponent(memoryReference) + `/${encodeURIComponent(displayName)}.bin`,
            query: range ? `?range=${range.fromOffset}:${range.toOffset}` : undefined,
        }))
    );
};
class MemoryRegion extends Disposable {
    constructor(memoryReference, session) {
        super();
        this.memoryReference = memoryReference;
        this.session = session;
        this.invalidateEmitter = this._register(( (new Emitter())));
        this.onDidInvalidate = this.invalidateEmitter.event;
        this.writable = !!this.session.capabilities.supportsWriteMemoryRequest;
        this._register(session.onDidInvalidateMemory(e => {
            if (e.body.memoryReference === memoryReference) {
                this.invalidate(e.body.offset, e.body.count - e.body.offset);
            }
        }));
    }
    async read(fromOffset, toOffset) {
        const length = toOffset - fromOffset;
        const offset = fromOffset;
        const result = await this.session.readMemory(this.memoryReference, offset, length);
        if (result === undefined || !result.body?.data) {
            return [{ type: 1 , offset, length }];
        }
        let data;
        try {
            data = decodeBase64(result.body.data);
        }
        catch {
            return [{ type: 2 , offset, length, error: 'Invalid base64 data from debug adapter' }];
        }
        const unreadable = result.body.unreadableBytes || 0;
        const dataLength = length - unreadable;
        if (data.byteLength < dataLength) {
            const pad = VSBuffer.alloc(dataLength - data.byteLength);
            pad.buffer.fill(0);
            data = VSBuffer.concat([data, pad], dataLength);
        }
        else if (data.byteLength > dataLength) {
            data = data.slice(0, dataLength);
        }
        if (!unreadable) {
            return [{ type: 0 , offset, length, data }];
        }
        return [
            { type: 0 , offset, length: dataLength, data },
            { type: 1 , offset: offset + dataLength, length: unreadable },
        ];
    }
    async write(offset, data) {
        const result = await this.session.writeMemory(this.memoryReference, offset, encodeBase64(data), true);
        const written = result?.body?.bytesWritten ?? data.byteLength;
        this.invalidate(offset, offset + written);
        return written;
    }
    dispose() {
        super.dispose();
    }
    invalidate(fromOffset, toOffset) {
        this.invalidateEmitter.fire({ fromOffset, toOffset });
    }
}
class Enablement {
    constructor(enabled, id) {
        this.enabled = enabled;
        this.id = id;
    }
    getId() {
        return this.id;
    }
}
function toBreakpointSessionData(data, capabilities) {
    return mixin({
        supportsConditionalBreakpoints: !!capabilities.supportsConditionalBreakpoints,
        supportsHitConditionalBreakpoints: !!capabilities.supportsHitConditionalBreakpoints,
        supportsLogPoints: !!capabilities.supportsLogPoints,
        supportsFunctionBreakpoints: !!capabilities.supportsFunctionBreakpoints,
        supportsDataBreakpoints: !!capabilities.supportsDataBreakpoints,
        supportsInstructionBreakpoints: !!capabilities.supportsInstructionBreakpoints
    }, data);
}
class BaseBreakpoint extends Enablement {
    constructor(enabled, hitCondition, condition, logMessage, id) {
        super(enabled, id);
        this.hitCondition = hitCondition;
        this.condition = condition;
        this.logMessage = logMessage;
        this.sessionData = ( (new Map()));
        if (enabled === undefined) {
            this.enabled = true;
        }
    }
    setSessionData(sessionId, data) {
        if (!data) {
            this.sessionData.delete(sessionId);
        }
        else {
            data.sessionId = sessionId;
            this.sessionData.set(sessionId, data);
        }
        const allData = Array.from(( (this.sessionData.values())));
        const verifiedData = distinct(allData.filter(d => d.verified), d => `${d.line}:${d.column}`);
        if (verifiedData.length) {
            this.data = verifiedData.length === 1 ? verifiedData[0] : undefined;
        }
        else {
            this.data = allData.length ? allData[0] : undefined;
        }
    }
    get message() {
        if (!this.data) {
            return undefined;
        }
        return this.data.message;
    }
    get verified() {
        return this.data ? this.data.verified : true;
    }
    get sessionsThatVerified() {
        const sessionIds = [];
        for (const [sessionId, data] of this.sessionData) {
            if (data.verified) {
                sessionIds.push(sessionId);
            }
        }
        return sessionIds;
    }
    getIdFromAdapter(sessionId) {
        const data = this.sessionData.get(sessionId);
        return data ? data.id : undefined;
    }
    getDebugProtocolBreakpoint(sessionId) {
        const data = this.sessionData.get(sessionId);
        if (data) {
            const bp = {
                id: data.id,
                verified: data.verified,
                message: data.message,
                source: data.source,
                line: data.line,
                column: data.column,
                endLine: data.endLine,
                endColumn: data.endColumn,
                instructionReference: data.instructionReference,
                offset: data.offset
            };
            return bp;
        }
        return undefined;
    }
    toJSON() {
        const result = Object.create(null);
        result.enabled = this.enabled;
        result.condition = this.condition;
        result.hitCondition = this.hitCondition;
        result.logMessage = this.logMessage;
        return result;
    }
}
class Breakpoint extends BaseBreakpoint {
    constructor(_uri, _lineNumber, _column, enabled, condition, hitCondition, logMessage, _adapterData, textFileService, uriIdentityService, logService, id = generateUuid()) {
        super(enabled, hitCondition, condition, logMessage, id);
        this._uri = _uri;
        this._lineNumber = _lineNumber;
        this._column = _column;
        this._adapterData = _adapterData;
        this.textFileService = textFileService;
        this.uriIdentityService = uriIdentityService;
        this.logService = logService;
    }
    get lineNumber() {
        return this.verified && this.data && typeof this.data.line === 'number' ? this.data.line : this._lineNumber;
    }
    get verified() {
        if (this.data) {
            return this.data.verified && !this.textFileService.isDirty(this._uri);
        }
        return true;
    }
    get uri() {
        return this.verified && this.data && this.data.source ? getUriFromSource(this.data.source, this.data.source.path, this.data.sessionId, this.uriIdentityService, this.logService) : this._uri;
    }
    get column() {
        return this.verified && this.data && typeof this.data.column === 'number' ? this.data.column : this._column;
    }
    get message() {
        if (this.textFileService.isDirty(this.uri)) {
            return (
                 (localize(
                    'breakpointDirtydHover',
                    "Unverified breakpoint. File is modified, please restart debug session."
                ))
            );
        }
        return super.message;
    }
    get adapterData() {
        return this.data && this.data.source && this.data.source.adapterData ? this.data.source.adapterData : this._adapterData;
    }
    get endLineNumber() {
        return this.verified && this.data ? this.data.endLine : undefined;
    }
    get endColumn() {
        return this.verified && this.data ? this.data.endColumn : undefined;
    }
    get sessionAgnosticData() {
        return {
            lineNumber: this._lineNumber,
            column: this._column
        };
    }
    get supported() {
        if (!this.data) {
            return true;
        }
        if (this.logMessage && !this.data.supportsLogPoints) {
            return false;
        }
        if (this.condition && !this.data.supportsConditionalBreakpoints) {
            return false;
        }
        if (this.hitCondition && !this.data.supportsHitConditionalBreakpoints) {
            return false;
        }
        return true;
    }
    setSessionData(sessionId, data) {
        super.setSessionData(sessionId, data);
        if (!this._adapterData) {
            this._adapterData = this.adapterData;
        }
    }
    toJSON() {
        const result = super.toJSON();
        result.uri = this._uri;
        result.lineNumber = this._lineNumber;
        result.column = this._column;
        result.adapterData = this.adapterData;
        return result;
    }
    toString() {
        return `${basenameOrAuthority(this.uri)} ${this.lineNumber}`;
    }
    update(data) {
        if (!isUndefinedOrNull(data.lineNumber)) {
            this._lineNumber = data.lineNumber;
        }
        if (!isUndefinedOrNull(data.column)) {
            this._column = data.column;
        }
        if (!isUndefinedOrNull(data.condition)) {
            this.condition = data.condition;
        }
        if (!isUndefinedOrNull(data.hitCondition)) {
            this.hitCondition = data.hitCondition;
        }
        if (!isUndefinedOrNull(data.logMessage)) {
            this.logMessage = data.logMessage;
        }
    }
}
class FunctionBreakpoint extends BaseBreakpoint {
    constructor(name, enabled, hitCondition, condition, logMessage, id = generateUuid()) {
        super(enabled, hitCondition, condition, logMessage, id);
        this.name = name;
    }
    toJSON() {
        const result = super.toJSON();
        result.name = this.name;
        return result;
    }
    get supported() {
        if (!this.data) {
            return true;
        }
        return this.data.supportsFunctionBreakpoints;
    }
    toString() {
        return this.name;
    }
}
class DataBreakpoint extends BaseBreakpoint {
    constructor(description, dataId, canPersist, enabled, hitCondition, condition, logMessage, accessTypes, accessType, id = generateUuid()) {
        super(enabled, hitCondition, condition, logMessage, id);
        this.description = description;
        this.dataId = dataId;
        this.canPersist = canPersist;
        this.accessTypes = accessTypes;
        this.accessType = accessType;
    }
    toJSON() {
        const result = super.toJSON();
        result.description = this.description;
        result.dataId = this.dataId;
        result.accessTypes = this.accessTypes;
        result.accessType = this.accessType;
        return result;
    }
    get supported() {
        if (!this.data) {
            return true;
        }
        return this.data.supportsDataBreakpoints;
    }
    toString() {
        return this.description;
    }
}
class ExceptionBreakpoint extends BaseBreakpoint {
    constructor(filter, label, enabled, supportsCondition, condition, description, conditionDescription, fallback = false) {
        super(enabled, undefined, condition, undefined, generateUuid());
        this.filter = filter;
        this.label = label;
        this.supportsCondition = supportsCondition;
        this.description = description;
        this.conditionDescription = conditionDescription;
        this.fallback = fallback;
        this.supportedSessions = ( (new Set()));
    }
    toJSON() {
        const result = Object.create(null);
        result.filter = this.filter;
        result.label = this.label;
        result.enabled = this.enabled;
        result.supportsCondition = this.supportsCondition;
        result.conditionDescription = this.conditionDescription;
        result.condition = this.condition;
        result.fallback = this.fallback;
        result.description = this.description;
        return result;
    }
    setSupportedSession(sessionId, supported) {
        if (supported) {
            this.supportedSessions.add(sessionId);
        }
        else {
            this.supportedSessions.delete(sessionId);
        }
    }
    setFallback(isFallback) {
        this.fallback = isFallback;
    }
    get supported() {
        return true;
    }
    isSupportedSession(sessionId) {
        return sessionId ? this.supportedSessions.has(sessionId) : this.fallback;
    }
    matches(filter) {
        return this.filter === filter.filter && this.label === filter.label && this.supportsCondition === !!filter.supportsCondition && this.conditionDescription === filter.conditionDescription && this.description === filter.description;
    }
    toString() {
        return this.label;
    }
}
class InstructionBreakpoint extends BaseBreakpoint {
    constructor(instructionReference, offset, canPersist, enabled, hitCondition, condition, logMessage, id = generateUuid()) {
        super(enabled, hitCondition, condition, logMessage, id);
        this.instructionReference = instructionReference;
        this.offset = offset;
        this.canPersist = canPersist;
    }
    toJSON() {
        const result = super.toJSON();
        result.instructionReference = this.instructionReference;
        result.offset = this.offset;
        return result;
    }
    get supported() {
        if (!this.data) {
            return true;
        }
        return this.data.supportsInstructionBreakpoints;
    }
    toString() {
        return this.instructionReference;
    }
}
let DebugModel = class DebugModel {
    constructor(debugStorage, textFileService, uriIdentityService, logService) {
        this.textFileService = textFileService;
        this.uriIdentityService = uriIdentityService;
        this.logService = logService;
        this.schedulers = ( (new Map()));
        this.breakpointsActivated = true;
        this._onDidChangeBreakpoints = ( (new Emitter()));
        this._onDidChangeCallStack = ( (new Emitter()));
        this._onDidChangeWatchExpressions = ( (new Emitter()));
        this.breakpoints = debugStorage.loadBreakpoints();
        this.functionBreakpoints = debugStorage.loadFunctionBreakpoints();
        this.exceptionBreakpoints = debugStorage.loadExceptionBreakpoints();
        this.dataBreakpoints = debugStorage.loadDataBreakpoints();
        this.watchExpressions = debugStorage.loadWatchExpressions();
        this.instructionBreakpoints = [];
        this.sessions = [];
    }
    getId() {
        return 'root';
    }
    getSession(sessionId, includeInactive = false) {
        if (sessionId) {
            return this.getSessions(includeInactive).find(s => s.getId() === sessionId);
        }
        return undefined;
    }
    getSessions(includeInactive = false) {
        return this.sessions.filter(s => includeInactive || s.state !== 0 );
    }
    addSession(session) {
        this.sessions = this.sessions.filter(s => {
            if (s.getId() === session.getId()) {
                return false;
            }
            if (s.state === 0  && s.configuration.name === session.configuration.name) {
                return false;
            }
            return true;
        });
        let i = 1;
        while (this.sessions.some(s => s.getLabel() === session.getLabel())) {
            session.setName(`${session.configuration.name} ${++i}`);
        }
        let index = -1;
        if (session.parentSession) {
            index = lastIndex(this.sessions, s => s.parentSession === session.parentSession || s === session.parentSession);
        }
        if (index >= 0) {
            this.sessions.splice(index + 1, 0, session);
        }
        else {
            this.sessions.push(session);
        }
        this._onDidChangeCallStack.fire(undefined);
    }
    get onDidChangeBreakpoints() {
        return this._onDidChangeBreakpoints.event;
    }
    get onDidChangeCallStack() {
        return this._onDidChangeCallStack.event;
    }
    get onDidChangeWatchExpressions() {
        return this._onDidChangeWatchExpressions.event;
    }
    rawUpdate(data) {
        const session = this.sessions.find(p => p.getId() === data.sessionId);
        if (session) {
            session.rawUpdate(data);
            this._onDidChangeCallStack.fire(undefined);
        }
    }
    clearThreads(id, removeThreads, reference = undefined) {
        const session = this.sessions.find(p => p.getId() === id);
        this.schedulers.forEach(scheduler => scheduler.dispose());
        this.schedulers.clear();
        if (session) {
            session.clearThreads(removeThreads, reference);
            this._onDidChangeCallStack.fire(undefined);
        }
    }
    async fetchCallstack(thread, levels) {
        if (thread.reachedEndOfCallStack) {
            return;
        }
        const totalFrames = thread.stoppedDetails?.totalFrames;
        const remainingFrames = (typeof totalFrames === 'number') ? (totalFrames - thread.getCallStack().length) : undefined;
        if (!levels || (remainingFrames && levels > remainingFrames)) {
            levels = remainingFrames;
        }
        if (levels && levels > 0) {
            await thread.fetchCallStack(levels);
            this._onDidChangeCallStack.fire();
        }
        return;
    }
    refreshTopOfCallstack(thread) {
        if (thread.session.capabilities.supportsDelayedStackTraceLoading) {
            let topCallStack = Promise.resolve();
            const wholeCallStack = ( (new Promise((c, e) => {
                topCallStack = thread.fetchCallStack(1).then(() => {
                    if (!this.schedulers.has(thread.getId())) {
                        this.schedulers.set(thread.getId(), ( (new RunOnceScheduler(() => {
                            thread.fetchCallStack(19).then(() => {
                                const stale = thread.getStaleCallStack();
                                const current = thread.getCallStack();
                                let bottomOfCallStackChanged = stale.length !== current.length;
                                for (let i = 1; i < stale.length && !bottomOfCallStackChanged; i++) {
                                    bottomOfCallStackChanged = !stale[i].equals(current[i]);
                                }
                                if (bottomOfCallStackChanged) {
                                    this._onDidChangeCallStack.fire();
                                }
                                c();
                            });
                        }, 420))));
                    }
                    this.schedulers.get(thread.getId()).schedule();
                    this._onDidChangeCallStack.fire();
                });
            })));
            return { topCallStack, wholeCallStack };
        }
        const wholeCallStack = thread.fetchCallStack();
        return { wholeCallStack, topCallStack: wholeCallStack };
    }
    getBreakpoints(filter) {
        if (filter) {
            const uriStr = filter.uri ? ( (filter.uri.toString())) : undefined;
            return this.breakpoints.filter(bp => {
                if (uriStr && ( (bp.uri.toString())) !== uriStr) {
                    return false;
                }
                if (filter.lineNumber && bp.lineNumber !== filter.lineNumber) {
                    return false;
                }
                if (filter.column && bp.column !== filter.column) {
                    return false;
                }
                if (filter.enabledOnly && (!this.breakpointsActivated || !bp.enabled)) {
                    return false;
                }
                return true;
            });
        }
        return this.breakpoints;
    }
    getFunctionBreakpoints() {
        return this.functionBreakpoints;
    }
    getDataBreakpoints() {
        return this.dataBreakpoints;
    }
    getExceptionBreakpoints() {
        return this.exceptionBreakpoints;
    }
    getExceptionBreakpointsForSession(sessionId) {
        return this.exceptionBreakpoints.filter(ebp => ebp.isSupportedSession(sessionId));
    }
    getInstructionBreakpoints() {
        return this.instructionBreakpoints;
    }
    setExceptionBreakpointsForSession(sessionId, data) {
        if (data) {
            let didChangeBreakpoints = false;
            data.forEach(d => {
                let ebp = this.exceptionBreakpoints.filter((exbp) => exbp.matches(d)).pop();
                if (!ebp) {
                    didChangeBreakpoints = true;
                    ebp = ( (new ExceptionBreakpoint(
                        d.filter,
                        d.label,
                        !!d.default,
                        !!d.supportsCondition,
                        undefined ,
                        d.description,
                        d.conditionDescription
                    )));
                    this.exceptionBreakpoints.push(ebp);
                }
                ebp.setSupportedSession(sessionId, true);
            });
            if (didChangeBreakpoints) {
                this._onDidChangeBreakpoints.fire(undefined);
            }
        }
    }
    removeExceptionBreakpointsForSession(sessionId) {
        this.exceptionBreakpoints.forEach(ebp => ebp.setSupportedSession(sessionId, false));
    }
    setExceptionBreakpointFallbackSession(sessionId) {
        this.exceptionBreakpoints.forEach(ebp => ebp.setFallback(ebp.isSupportedSession(sessionId)));
    }
    setExceptionBreakpointCondition(exceptionBreakpoint, condition) {
        exceptionBreakpoint.condition = condition;
        this._onDidChangeBreakpoints.fire(undefined);
    }
    areBreakpointsActivated() {
        return this.breakpointsActivated;
    }
    setBreakpointsActivated(activated) {
        this.breakpointsActivated = activated;
        this._onDidChangeBreakpoints.fire(undefined);
    }
    addBreakpoints(uri, rawData, fireEvent = true) {
        const newBreakpoints = ( (rawData.map(rawBp => ( (new Breakpoint(
            uri,
            rawBp.lineNumber,
            rawBp.column,
            rawBp.enabled === false ? false : true,
            rawBp.condition,
            rawBp.hitCondition,
            rawBp.logMessage,
            undefined,
            this.textFileService,
            this.uriIdentityService,
            this.logService,
            rawBp.id
        ))))));
        this.breakpoints = this.breakpoints.concat(newBreakpoints);
        this.breakpointsActivated = true;
        this.sortAndDeDup();
        if (fireEvent) {
            this._onDidChangeBreakpoints.fire({ added: newBreakpoints, sessionOnly: false });
        }
        return newBreakpoints;
    }
    removeBreakpoints(toRemove) {
        this.breakpoints = this.breakpoints.filter(bp => !toRemove.some(toRemove => toRemove.getId() === bp.getId()));
        this._onDidChangeBreakpoints.fire({ removed: toRemove, sessionOnly: false });
    }
    updateBreakpoints(data) {
        const updated = [];
        this.breakpoints.forEach(bp => {
            const bpData = data.get(bp.getId());
            if (bpData) {
                bp.update(bpData);
                updated.push(bp);
            }
        });
        this.sortAndDeDup();
        this._onDidChangeBreakpoints.fire({ changed: updated, sessionOnly: false });
    }
    setBreakpointSessionData(sessionId, capabilites, data) {
        this.breakpoints.forEach(bp => {
            if (!data) {
                bp.setSessionData(sessionId, undefined);
            }
            else {
                const bpData = data.get(bp.getId());
                if (bpData) {
                    bp.setSessionData(sessionId, toBreakpointSessionData(bpData, capabilites));
                }
            }
        });
        this.functionBreakpoints.forEach(fbp => {
            if (!data) {
                fbp.setSessionData(sessionId, undefined);
            }
            else {
                const fbpData = data.get(fbp.getId());
                if (fbpData) {
                    fbp.setSessionData(sessionId, toBreakpointSessionData(fbpData, capabilites));
                }
            }
        });
        this.dataBreakpoints.forEach(dbp => {
            if (!data) {
                dbp.setSessionData(sessionId, undefined);
            }
            else {
                const dbpData = data.get(dbp.getId());
                if (dbpData) {
                    dbp.setSessionData(sessionId, toBreakpointSessionData(dbpData, capabilites));
                }
            }
        });
        this.exceptionBreakpoints.forEach(ebp => {
            if (!data) {
                ebp.setSessionData(sessionId, undefined);
            }
            else {
                const ebpData = data.get(ebp.getId());
                if (ebpData) {
                    ebp.setSessionData(sessionId, toBreakpointSessionData(ebpData, capabilites));
                }
            }
        });
        this.instructionBreakpoints.forEach(ibp => {
            if (!data) {
                ibp.setSessionData(sessionId, undefined);
            }
            else {
                const ibpData = data.get(ibp.getId());
                if (ibpData) {
                    ibp.setSessionData(sessionId, toBreakpointSessionData(ibpData, capabilites));
                }
            }
        });
        this._onDidChangeBreakpoints.fire({
            sessionOnly: true
        });
    }
    getDebugProtocolBreakpoint(breakpointId, sessionId) {
        const bp = this.breakpoints.find(bp => bp.getId() === breakpointId);
        if (bp) {
            return bp.getDebugProtocolBreakpoint(sessionId);
        }
        return undefined;
    }
    sortAndDeDup() {
        this.breakpoints = this.breakpoints.sort((first, second) => {
            if (( (first.uri.toString())) !== ( (second.uri.toString()))) {
                return basenameOrAuthority(first.uri).localeCompare(basenameOrAuthority(second.uri));
            }
            if (first.lineNumber === second.lineNumber) {
                if (first.column && second.column) {
                    return first.column - second.column;
                }
                return 1;
            }
            return first.lineNumber - second.lineNumber;
        });
        this.breakpoints = distinct(this.breakpoints, bp => `${( ( bp.uri.toString()))}:${bp.lineNumber}:${bp.column}`);
    }
    setEnablement(element, enable) {
        if (element instanceof Breakpoint || element instanceof FunctionBreakpoint || element instanceof ExceptionBreakpoint || element instanceof DataBreakpoint || element instanceof InstructionBreakpoint) {
            const changed = [];
            if (element.enabled !== enable && (element instanceof Breakpoint || element instanceof FunctionBreakpoint || element instanceof DataBreakpoint || element instanceof InstructionBreakpoint)) {
                changed.push(element);
            }
            element.enabled = enable;
            if (enable) {
                this.breakpointsActivated = true;
            }
            this._onDidChangeBreakpoints.fire({ changed: changed, sessionOnly: false });
        }
    }
    enableOrDisableAllBreakpoints(enable) {
        const changed = [];
        this.breakpoints.forEach(bp => {
            if (bp.enabled !== enable) {
                changed.push(bp);
            }
            bp.enabled = enable;
        });
        this.functionBreakpoints.forEach(fbp => {
            if (fbp.enabled !== enable) {
                changed.push(fbp);
            }
            fbp.enabled = enable;
        });
        this.dataBreakpoints.forEach(dbp => {
            if (dbp.enabled !== enable) {
                changed.push(dbp);
            }
            dbp.enabled = enable;
        });
        this.instructionBreakpoints.forEach(ibp => {
            if (ibp.enabled !== enable) {
                changed.push(ibp);
            }
            ibp.enabled = enable;
        });
        if (enable) {
            this.breakpointsActivated = true;
        }
        this._onDidChangeBreakpoints.fire({ changed: changed, sessionOnly: false });
    }
    addFunctionBreakpoint(functionName, id) {
        const newFunctionBreakpoint = ( (new FunctionBreakpoint(functionName, true, undefined, undefined, undefined, id)));
        this.functionBreakpoints.push(newFunctionBreakpoint);
        this._onDidChangeBreakpoints.fire({ added: [newFunctionBreakpoint], sessionOnly: false });
        return newFunctionBreakpoint;
    }
    updateFunctionBreakpoint(id, update) {
        const functionBreakpoint = this.functionBreakpoints.find(fbp => fbp.getId() === id);
        if (functionBreakpoint) {
            if (typeof update.name === 'string') {
                functionBreakpoint.name = update.name;
            }
            if (typeof update.condition === 'string') {
                functionBreakpoint.condition = update.condition;
            }
            if (typeof update.hitCondition === 'string') {
                functionBreakpoint.hitCondition = update.hitCondition;
            }
            this._onDidChangeBreakpoints.fire({ changed: [functionBreakpoint], sessionOnly: false });
        }
    }
    removeFunctionBreakpoints(id) {
        let removed;
        if (id) {
            removed = this.functionBreakpoints.filter(fbp => fbp.getId() === id);
            this.functionBreakpoints = this.functionBreakpoints.filter(fbp => fbp.getId() !== id);
        }
        else {
            removed = this.functionBreakpoints;
            this.functionBreakpoints = [];
        }
        this._onDidChangeBreakpoints.fire({ removed, sessionOnly: false });
    }
    addDataBreakpoint(label, dataId, canPersist, accessTypes, accessType) {
        const newDataBreakpoint = ( (new DataBreakpoint(
            label,
            dataId,
            canPersist,
            true,
            undefined,
            undefined,
            undefined,
            accessTypes,
            accessType
        )));
        this.dataBreakpoints.push(newDataBreakpoint);
        this._onDidChangeBreakpoints.fire({ added: [newDataBreakpoint], sessionOnly: false });
    }
    removeDataBreakpoints(id) {
        let removed;
        if (id) {
            removed = this.dataBreakpoints.filter(fbp => fbp.getId() === id);
            this.dataBreakpoints = this.dataBreakpoints.filter(fbp => fbp.getId() !== id);
        }
        else {
            removed = this.dataBreakpoints;
            this.dataBreakpoints = [];
        }
        this._onDidChangeBreakpoints.fire({ removed, sessionOnly: false });
    }
    addInstructionBreakpoint(address, offset, condition, hitCondition) {
        const newInstructionBreakpoint = ( (new InstructionBreakpoint(address, offset, false, true, hitCondition, condition, undefined)));
        this.instructionBreakpoints.push(newInstructionBreakpoint);
        this._onDidChangeBreakpoints.fire({ added: [newInstructionBreakpoint], sessionOnly: true });
    }
    removeInstructionBreakpoints(address) {
        let removed;
        if (address) {
            removed = this.instructionBreakpoints.filter(fbp => fbp.instructionReference === address);
            this.instructionBreakpoints = this.instructionBreakpoints.filter(fbp => fbp.instructionReference !== address);
        }
        else {
            removed = this.instructionBreakpoints;
            this.instructionBreakpoints = [];
        }
        this._onDidChangeBreakpoints.fire({ removed, sessionOnly: false });
    }
    getWatchExpressions() {
        return this.watchExpressions;
    }
    addWatchExpression(name) {
        const we = ( (new Expression(name || '')));
        this.watchExpressions.push(we);
        this._onDidChangeWatchExpressions.fire(we);
        return we;
    }
    renameWatchExpression(id, newName) {
        const filtered = this.watchExpressions.filter(we => we.getId() === id);
        if (filtered.length === 1) {
            filtered[0].name = newName;
            this._onDidChangeWatchExpressions.fire(filtered[0]);
        }
    }
    removeWatchExpressions(id = null) {
        this.watchExpressions = id ? this.watchExpressions.filter(we => we.getId() !== id) : [];
        this._onDidChangeWatchExpressions.fire(undefined);
    }
    moveWatchExpression(id, position) {
        const we = this.watchExpressions.find(we => we.getId() === id);
        if (we) {
            this.watchExpressions = this.watchExpressions.filter(we => we.getId() !== id);
            this.watchExpressions = this.watchExpressions.slice(0, position).concat(we, this.watchExpressions.slice(position));
            this._onDidChangeWatchExpressions.fire(undefined);
        }
    }
    sourceIsNotAvailable(uri) {
        this.sessions.forEach(s => {
            const source = s.getSourceForUri(uri);
            if (source) {
                source.available = false;
            }
        });
        this._onDidChangeCallStack.fire(undefined);
    }
};
DebugModel = ( (__decorate([
    ( (__param(1, ITextFileService))),
    ( (__param(2, IUriIdentityService))),
    ( (__param(3, ILogService)))
], DebugModel)));
var css$7 = ".monaco-pane-view .split-view-view:first-of-type>.pane>.pane-header{border-top:none!important}.monaco-pane-view .split-view-view:first-of-type>.pane{border-left:none!important}.monaco-pane-view .pane>.pane-header{position:relative}.monaco-pane-view .pane>.pane-header>.actions.show{display:initial}.monaco-pane-view .pane>.pane-header>.icon{display:none;height:16px;width:16px}.monaco-pane-view .pane.pane.horizontal:not(.expanded)>.pane-header>.icon{display:inline;margin-top:4px}.monaco-pane-view .pane>.pane-header h3.title{-webkit-margin-before:0;-webkit-margin-after:0;font-size:11px;min-width:3ch;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-pane-view .pane>.pane-header .description{display:block;flex-shrink:100000;font-weight:400;margin-left:10px;opacity:.6;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap}.monaco-pane-view .pane>.pane-header .description .codicon{font-size:9px;margin-left:2px}.monaco-pane-view .pane.horizontal:not(.expanded)>.pane-header .description,.monaco-pane-view .pane.horizontal:not(.expanded)>.pane-header h3.title,.monaco-pane-view .pane>.pane-header:not(.expanded) .description{display:none}.monaco-pane-view .pane .monaco-progress-container{height:2px;left:0;position:absolute;top:-2px;z-index:5}.monaco-pane-view .pane:not(.merged-header) .monaco-progress-container{top:20px}";
n(css$7,{});
var css$6 = ".monaco-pane-view{height:100%;width:100%}.monaco-pane-view .pane{display:flex;flex-direction:column;height:100%;overflow:hidden;width:100%}.monaco-pane-view .pane.horizontal:not(.expanded){flex-direction:row}.monaco-pane-view .pane>.pane-header{align-items:center;box-sizing:border-box;cursor:pointer;display:flex;font-size:11px;font-weight:700;height:22px;overflow:hidden}.monaco-pane-view .pane>.pane-header>.title{text-transform:uppercase}.monaco-pane-view .pane.horizontal:not(.expanded)>.pane-header{flex-direction:column;height:100%;width:22px}.monaco-pane-view .pane>.pane-header>.codicon:first-of-type{margin:0 2px}.monaco-pane-view .pane.horizontal:not(.expanded)>.pane-header>.codicon:first-of-type{margin:2px}.monaco-pane-view .pane>.pane-header>.actions{display:none;margin-left:auto}.monaco-pane-view .pane>.pane-header>.actions .action-item{margin-right:4px}.monaco-pane-view .pane>.pane-header>.actions .action-label{padding:2px}.monaco-pane-view .pane:focus-within>.pane-header.expanded>.actions,.monaco-pane-view .pane:hover>.pane-header.expanded>.actions,.monaco-pane-view .pane>.pane-header.actions-always-visible.expanded>.actions,.monaco-pane-view .pane>.pane-header.focused.expanded>.actions{display:initial}.monaco-pane-view .pane>.pane-header .monaco-action-bar .action-item.select-container{cursor:default}.monaco-pane-view .pane>.pane-header .action-item .monaco-select-box{cursor:pointer;min-height:18px;min-width:110px;padding:2px 23px 2px 8px}.linux .monaco-pane-view .pane>.pane-header .action-item .monaco-select-box,.windows .monaco-pane-view .pane>.pane-header .action-item .monaco-select-box{padding:0 23px 0 8px}.monaco-pane-view:lang(ja) .pane>.pane-header,.monaco-pane-view:lang(ko) .pane>.pane-header,.monaco-pane-view:lang(zh-Hans) .pane>.pane-header,.monaco-pane-view:lang(zh-Hant) .pane>.pane-header{font-weight:400}.monaco-pane-view .pane>.pane-header.hidden{display:none}.monaco-pane-view .pane>.pane-body{flex:1;overflow:hidden}.monaco-pane-view.animated .split-view-view{transition-duration:.15s;transition-timing-function:ease-out}.reduce-motion .monaco-pane-view .split-view-view{transition-duration:0s!important}.monaco-pane-view.animated.vertical .split-view-view{transition-property:height}.monaco-pane-view.animated.horizontal .split-view-view{transition-property:width}#monaco-pane-drop-overlay{box-sizing:border-box;height:100%;left:0;position:absolute;width:100%;z-index:10000}#monaco-pane-drop-overlay>.pane-overlay-indicator{height:100%;min-height:22px;min-width:19px;pointer-events:none;position:absolute;transition:opacity .15s ease-out;width:100%}#monaco-pane-drop-overlay>.pane-overlay-indicator.overlay-move-transition{transition:top 70ms ease-out,left 70ms ease-out,width 70ms ease-out,height 70ms ease-out,opacity .15s ease-out}";
n(css$6,{});
class Pane extends Disposable {
    get ariaHeaderLabel() {
        return this._ariaHeaderLabel;
    }
    set ariaHeaderLabel(newLabel) {
        this._ariaHeaderLabel = newLabel;
        this.header.setAttribute('aria-label', this.ariaHeaderLabel);
    }
    get draggableElement() {
        return this.header;
    }
    get dropTargetElement() {
        return this.element;
    }
    get dropBackground() {
        return this.styles.dropBackground;
    }
    get minimumBodySize() {
        return this._minimumBodySize;
    }
    set minimumBodySize(size) {
        this._minimumBodySize = size;
        this._onDidChange.fire(undefined);
    }
    get maximumBodySize() {
        return this._maximumBodySize;
    }
    set maximumBodySize(size) {
        this._maximumBodySize = size;
        this._onDidChange.fire(undefined);
    }
    get headerSize() {
        return this.headerVisible ? Pane.HEADER_SIZE : 0;
    }
    get minimumSize() {
        const headerSize = this.headerSize;
        const expanded = !this.headerVisible || this.isExpanded();
        const minimumBodySize = expanded ? this.minimumBodySize : 0;
        return headerSize + minimumBodySize;
    }
    get maximumSize() {
        const headerSize = this.headerSize;
        const expanded = !this.headerVisible || this.isExpanded();
        const maximumBodySize = expanded ? this.maximumBodySize : 0;
        return headerSize + maximumBodySize;
    }
    constructor(options) {
        super();
        this.expandedSize = undefined;
        this._headerVisible = true;
        this._bodyRendered = false;
        this.styles = {
            dropBackground: undefined,
            headerBackground: undefined,
            headerBorder: undefined,
            headerForeground: undefined,
            leftBorder: undefined
        };
        this.animationTimer = undefined;
        this._onDidChange = this._register(( (new Emitter())));
        this.onDidChange = this._onDidChange.event;
        this._onDidChangeExpansionState = this._register(( (new Emitter())));
        this.onDidChangeExpansionState = this._onDidChangeExpansionState.event;
        this.orthogonalSize = 0;
        this._expanded = typeof options.expanded === 'undefined' ? true : !!options.expanded;
        this._orientation = typeof options.orientation === 'undefined' ? 0  : options.orientation;
        this._ariaHeaderLabel = ( (localize('viewSection', "{0} Section", options.title)));
        this._minimumBodySize = typeof options.minimumBodySize === 'number' ? options.minimumBodySize : this._orientation === 1  ? 200 : 120;
        this._maximumBodySize = typeof options.maximumBodySize === 'number' ? options.maximumBodySize : Number.POSITIVE_INFINITY;
        this.element = $$7('.pane');
    }
    isExpanded() {
        return this._expanded;
    }
    setExpanded(expanded) {
        if (this._expanded === !!expanded) {
            return false;
        }
        this.element?.classList.toggle('expanded', expanded);
        this._expanded = !!expanded;
        this.updateHeader();
        if (expanded) {
            if (!this._bodyRendered) {
                this.renderBody(this.body);
                this._bodyRendered = true;
            }
            if (typeof this.animationTimer === 'number') {
                clearTimeout(this.animationTimer);
            }
            append(this.element, this.body);
        }
        else {
            this.animationTimer = window.setTimeout(() => {
                this.body.remove();
            }, 200);
        }
        this._onDidChangeExpansionState.fire(expanded);
        this._onDidChange.fire(expanded ? this.expandedSize : undefined);
        return true;
    }
    get headerVisible() {
        return this._headerVisible;
    }
    set headerVisible(visible) {
        if (this._headerVisible === !!visible) {
            return;
        }
        this._headerVisible = !!visible;
        this.updateHeader();
        this._onDidChange.fire(undefined);
    }
    get orientation() {
        return this._orientation;
    }
    set orientation(orientation) {
        if (this._orientation === orientation) {
            return;
        }
        this._orientation = orientation;
        if (this.element) {
            this.element.classList.toggle('horizontal', this.orientation === 1 );
            this.element.classList.toggle('vertical', this.orientation === 0 );
        }
        if (this.header) {
            this.updateHeader();
        }
    }
    render() {
        this.element.classList.toggle('expanded', this.isExpanded());
        this.element.classList.toggle('horizontal', this.orientation === 1 );
        this.element.classList.toggle('vertical', this.orientation === 0 );
        this.header = $$7('.pane-header');
        append(this.element, this.header);
        this.header.setAttribute('tabindex', '0');
        this.header.setAttribute('role', 'button');
        this.header.setAttribute('aria-label', this.ariaHeaderLabel);
        this.renderHeader(this.header);
        const focusTracker = trackFocus(this.header);
        this._register(focusTracker);
        this._register(focusTracker.onDidFocus(() => this.header.classList.add('focused'), null));
        this._register(focusTracker.onDidBlur(() => this.header.classList.remove('focused'), null));
        this.updateHeader();
        const eventDisposables = this._register(( (new DisposableStore())));
        const onKeyDown = this._register(( (new DomEmitter(this.header, 'keydown'))));
        const onHeaderKeyDown = ( (Event.map(
            onKeyDown.event,
            e => ( (new StandardKeyboardEvent(e))),
            eventDisposables
        )));
        this._register(Event.filter(onHeaderKeyDown, e => e.keyCode === 3  || e.keyCode === 10 , eventDisposables)(() => this.setExpanded(!this.isExpanded()), null));
        this._register(Event.filter(onHeaderKeyDown, e => e.keyCode === 15 , eventDisposables)(() => this.setExpanded(false), null));
        this._register(Event.filter(onHeaderKeyDown, e => e.keyCode === 17 , eventDisposables)(() => this.setExpanded(true), null));
        this._register(Gesture.addTarget(this.header));
        [EventType$1.CLICK, EventType$2.Tap].forEach(eventType => {
            this._register(addDisposableListener$1(this.header, eventType, e => {
                if (!e.defaultPrevented) {
                    this.setExpanded(!this.isExpanded());
                }
            }));
        });
        this.body = append(this.element, $$7('.pane-body'));
        if (!this._bodyRendered && this.isExpanded()) {
            this.renderBody(this.body);
            this._bodyRendered = true;
        }
        if (!this.isExpanded()) {
            this.body.remove();
        }
    }
    layout(size) {
        const headerSize = this.headerVisible ? Pane.HEADER_SIZE : 0;
        const width = this._orientation === 0  ? this.orthogonalSize : size;
        const height = this._orientation === 0  ? size - headerSize : this.orthogonalSize - headerSize;
        if (this.isExpanded()) {
            this.body.classList.toggle('wide', width >= 600);
            this.layoutBody(height, width);
            this.expandedSize = size;
        }
    }
    style(styles) {
        this.styles = styles;
        if (!this.header) {
            return;
        }
        this.updateHeader();
    }
    updateHeader() {
        const expanded = !this.headerVisible || this.isExpanded();
        this.header.style.lineHeight = `${this.headerSize}px`;
        this.header.classList.toggle('hidden', !this.headerVisible);
        this.header.classList.toggle('expanded', expanded);
        this.header.setAttribute('aria-expanded', String(expanded));
        this.header.style.color = this.styles.headerForeground ?? '';
        this.header.style.backgroundColor = this.styles.headerBackground ?? '';
        this.header.style.borderTop = this.styles.headerBorder && this.orientation === 0  ? `1px solid ${this.styles.headerBorder}` : '';
        this.element.style.borderLeft = this.styles.leftBorder && this.orientation === 1  ? `1px solid ${this.styles.leftBorder}` : '';
    }
}
Pane.HEADER_SIZE = 22;
class PaneDraggable extends Disposable {
    constructor(pane, dnd, context) {
        super();
        this.pane = pane;
        this.dnd = dnd;
        this.context = context;
        this.dragOverCounter = 0;
        this._onDidDrop = this._register(( (new Emitter())));
        this.onDidDrop = this._onDidDrop.event;
        pane.draggableElement.draggable = true;
        this._register(addDisposableListener$1(pane.draggableElement, 'dragstart', e => this.onDragStart(e)));
        this._register(addDisposableListener$1(pane.dropTargetElement, 'dragenter', e => this.onDragEnter(e)));
        this._register(addDisposableListener$1(pane.dropTargetElement, 'dragleave', e => this.onDragLeave(e)));
        this._register(addDisposableListener$1(pane.dropTargetElement, 'dragend', e => this.onDragEnd(e)));
        this._register(addDisposableListener$1(pane.dropTargetElement, 'drop', e => this.onDrop(e)));
    }
    onDragStart(e) {
        if (!this.dnd.canDrag(this.pane) || !e.dataTransfer) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        e.dataTransfer.effectAllowed = 'move';
        if (isFirefox) {
            e.dataTransfer?.setData(DataTransfers.TEXT, this.pane.draggableElement.textContent || '');
        }
        const dragImage = append(document.body, $$7('.monaco-drag-image', {}, this.pane.draggableElement.textContent || ''));
        e.dataTransfer.setDragImage(dragImage, -10, -10);
        setTimeout(() => document.body.removeChild(dragImage), 0);
        this.context.draggable = this;
    }
    onDragEnter(e) {
        if (!this.context.draggable || this.context.draggable === this) {
            return;
        }
        if (!this.dnd.canDrop(this.context.draggable.pane, this.pane)) {
            return;
        }
        this.dragOverCounter++;
        this.render();
    }
    onDragLeave(e) {
        if (!this.context.draggable || this.context.draggable === this) {
            return;
        }
        if (!this.dnd.canDrop(this.context.draggable.pane, this.pane)) {
            return;
        }
        this.dragOverCounter--;
        if (this.dragOverCounter === 0) {
            this.render();
        }
    }
    onDragEnd(e) {
        if (!this.context.draggable) {
            return;
        }
        this.dragOverCounter = 0;
        this.render();
        this.context.draggable = null;
    }
    onDrop(e) {
        if (!this.context.draggable) {
            return;
        }
        EventHelper.stop(e);
        this.dragOverCounter = 0;
        this.render();
        if (this.dnd.canDrop(this.context.draggable.pane, this.pane) && this.context.draggable !== this) {
            this._onDidDrop.fire({ from: this.context.draggable.pane, to: this.pane });
        }
        this.context.draggable = null;
    }
    render() {
        let backgroundColor = null;
        if (this.dragOverCounter > 0) {
            backgroundColor = this.pane.dropBackground ?? ( (PaneDraggable.DefaultDragOverBackgroundColor.toString()));
        }
        this.pane.dropTargetElement.style.backgroundColor = backgroundColor || '';
    }
}
PaneDraggable.DefaultDragOverBackgroundColor = ( (new Color( (new RGBA(128, 128, 128, 0.5)))));
var ProgressIndicatorState;
( ((function(ProgressIndicatorState) {
    ( ((function(Type) {
        Type[Type["None"] = 0] = "None";
        Type[Type["Done"] = 1] = "Done";
        Type[Type["Infinite"] = 2] = "Infinite";
        Type[Type["While"] = 3] = "While";
        Type[Type["Work"] = 4] = "Work";
    })(ProgressIndicatorState.Type || (ProgressIndicatorState.Type = {}))));
    ProgressIndicatorState.None = { type: 0  };
    ProgressIndicatorState.Done = { type: 1  };
    ProgressIndicatorState.Infinite = { type: 2  };
    class While {
        constructor(whilePromise, whileStart, whileDelay) {
            this.whilePromise = whilePromise;
            this.whileStart = whileStart;
            this.whileDelay = whileDelay;
            this.type = 3 ;
        }
    }
    ProgressIndicatorState.While = While;
    class Work {
        constructor(total, worked) {
            this.total = total;
            this.worked = worked;
            this.type = 4 ;
        }
    }
    ProgressIndicatorState.Work = Work;
})(ProgressIndicatorState || (ProgressIndicatorState = {}))));
class ScopedProgressIndicator extends Disposable {
    constructor(progressBar, scope) {
        super();
        this.progressBar = progressBar;
        this.scope = scope;
        this.progressState = ProgressIndicatorState.None;
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.scope.onDidChangeActive(() => {
            if (this.scope.isActive) {
                this.onDidScopeActivate();
            }
            else {
                this.onDidScopeDeactivate();
            }
        }));
    }
    onDidScopeActivate() {
        if (this.progressState.type === ProgressIndicatorState.Done.type) {
            return;
        }
        if (this.progressState.type === 3 ) {
            let delay;
            if (this.progressState.whileDelay > 0) {
                const remainingDelay = this.progressState.whileDelay - (Date.now() - this.progressState.whileStart);
                if (remainingDelay > 0) {
                    delay = remainingDelay;
                }
            }
            this.doShowWhile(delay);
        }
        else if (this.progressState.type === 2 ) {
            this.progressBar.infinite().show();
        }
        else if (this.progressState.type === 4 ) {
            if (this.progressState.total) {
                this.progressBar.total(this.progressState.total).show();
            }
            if (this.progressState.worked) {
                this.progressBar.worked(this.progressState.worked).show();
            }
        }
    }
    onDidScopeDeactivate() {
        this.progressBar.stop().hide();
    }
    show(infiniteOrTotal, delay) {
        if (typeof infiniteOrTotal === 'boolean') {
            this.progressState = ProgressIndicatorState.Infinite;
        }
        else {
            this.progressState = new ProgressIndicatorState.Work(infiniteOrTotal, undefined);
        }
        if (this.scope.isActive) {
            if (this.progressState.type === 2 ) {
                this.progressBar.infinite().show(delay);
            }
            else if (this.progressState.type === 4  && typeof this.progressState.total === 'number') {
                this.progressBar.total(this.progressState.total).show(delay);
            }
        }
        return {
            total: (total) => {
                this.progressState = new ProgressIndicatorState.Work(total, this.progressState.type === 4  ? this.progressState.worked : undefined);
                if (this.scope.isActive) {
                    this.progressBar.total(total);
                }
            },
            worked: (worked) => {
                if (!this.scope.isActive || this.progressBar.hasTotal()) {
                    this.progressState = new ProgressIndicatorState.Work(this.progressState.type === 4  ? this.progressState.total : undefined, this.progressState.type === 4  && typeof this.progressState.worked === 'number' ? this.progressState.worked + worked : worked);
                    if (this.scope.isActive) {
                        this.progressBar.worked(worked);
                    }
                }
                else {
                    this.progressState = ProgressIndicatorState.Infinite;
                    this.progressBar.infinite().show();
                }
            },
            done: () => {
                this.progressState = ProgressIndicatorState.Done;
                if (this.scope.isActive) {
                    this.progressBar.stop().hide();
                }
            }
        };
    }
    async showWhile(promise, delay) {
        if (this.progressState.type === 3 ) {
            promise = Promise.all([promise, this.progressState.whilePromise]);
        }
        this.progressState = new ProgressIndicatorState.While(promise, delay || 0, Date.now());
        try {
            this.doShowWhile(delay);
            await promise;
        }
        catch (error) {
        }
        finally {
            if (this.progressState.type !== 3  || this.progressState.whilePromise === promise) {
                this.progressState = ProgressIndicatorState.None;
                if (this.scope.isActive) {
                    this.progressBar.stop().hide();
                }
            }
        }
    }
    doShowWhile(delay) {
        if (this.scope.isActive) {
            this.progressBar.infinite().show(delay);
        }
    }
}
class AbstractProgressScope extends Disposable {
    get isActive() { return this._isActive; }
    constructor(scopeId, _isActive) {
        super();
        this.scopeId = scopeId;
        this._isActive = _isActive;
        this._onDidChangeActive = this._register(( (new Emitter())));
        this.onDidChangeActive = this._onDidChangeActive.event;
    }
    onScopeOpened(scopeId) {
        if (scopeId === this.scopeId) {
            if (!this._isActive) {
                this._isActive = true;
                this._onDidChangeActive.fire();
            }
        }
    }
    onScopeClosed(scopeId) {
        if (scopeId === this.scopeId) {
            if (this._isActive) {
                this._isActive = false;
                this._onDidChangeActive.fire();
            }
        }
    }
}
class MenuActions extends Disposable {
    get primaryActions() { return this._primaryActions; }
    get secondaryActions() { return this._secondaryActions; }
    constructor(menuId, options, menuService, contextKeyService) {
        super();
        this.options = options;
        this.menuService = menuService;
        this.contextKeyService = contextKeyService;
        this._primaryActions = [];
        this._secondaryActions = [];
        this._onDidChange = this._register(( (new Emitter())));
        this.onDidChange = this._onDidChange.event;
        this.disposables = this._register(( (new DisposableStore())));
        this.menu = this._register(menuService.createMenu(menuId, contextKeyService));
        this._register(this.menu.onDidChange(() => this.updateActions()));
        this.updateActions();
    }
    updateActions() {
        this.disposables.clear();
        this._primaryActions = [];
        this._secondaryActions = [];
        createAndFillInActionBarActions(this.menu, this.options, { primary: this._primaryActions, secondary: this._secondaryActions });
        this.disposables.add(this.updateSubmenus([...this._primaryActions, ...this._secondaryActions], {}));
        this._onDidChange.fire();
    }
    updateSubmenus(actions, submenus) {
        const disposables = ( (new DisposableStore()));
        for (const action of actions) {
            if (action instanceof SubmenuItemAction && !submenus[action.item.submenu.id]) {
                const menu = submenus[action.item.submenu.id] = disposables.add(this.menuService.createMenu(action.item.submenu, this.contextKeyService));
                disposables.add(menu.onDidChange(() => this.updateActions()));
                disposables.add(this.updateSubmenus(action.actions, submenus));
            }
        }
        return disposables;
    }
}
let CompositeMenuActions = class CompositeMenuActions extends Disposable {
    constructor(menuId, contextMenuId, options, contextKeyService, menuService) {
        super();
        this.menuId = menuId;
        this.contextMenuId = contextMenuId;
        this.options = options;
        this.contextKeyService = contextKeyService;
        this.menuService = menuService;
        this._onDidChange = this._register(( (new Emitter())));
        this.onDidChange = this._onDidChange.event;
        this.menuActions = this._register(( (new MenuActions(menuId, this.options, menuService, contextKeyService))));
        this._register(this.menuActions.onDidChange(() => this._onDidChange.fire()));
    }
    getPrimaryActions() {
        return this.menuActions.primaryActions;
    }
    getSecondaryActions() {
        return this.menuActions.secondaryActions;
    }
    getContextMenuActions() {
        const actions = [];
        if (this.contextMenuId) {
            const menu = this.menuService.createMenu(this.contextMenuId, this.contextKeyService);
            createAndFillInActionBarActions(menu, this.options, { primary: [], secondary: actions });
            menu.dispose();
        }
        return actions;
    }
};
CompositeMenuActions = ( (__decorate([
    ( (__param(3, IContextKeyService))),
    ( (__param(4, IMenuService)))
], CompositeMenuActions)));
const VIEWPANE_FILTER_ACTION = ( (new Action('viewpane.action.filter')));
const viewPaneContainerExpandedIcon = ( (registerIcon(
    'view-pane-container-expanded',
    Codicon.chevronDown,
     (localize(
        'viewPaneContainerExpandedIcon',
        'Icon for an expanded view pane container.'
    ))
)));
const viewPaneContainerCollapsedIcon = ( (registerIcon(
    'view-pane-container-collapsed',
    Codicon.chevronRight,
     (localize(
        'viewPaneContainerCollapsedIcon',
        'Icon for a collapsed view pane container.'
    ))
)));
const viewsRegistry = ( (Registry.as(Extensions$3.ViewsRegistry)));
let ViewWelcomeController = class ViewWelcomeController {
    get contents() {
        const visibleItems = this.items.filter(v => v.visible);
        if (visibleItems.length === 0 && this.defaultItem) {
            return [this.defaultItem.descriptor];
        }
        return (
             (visibleItems.map(v => v.descriptor))
        );
    }
    constructor(id, contextKeyService) {
        this.id = id;
        this.contextKeyService = contextKeyService;
        this._onDidChange = ( (new Emitter()));
        this.onDidChange = this._onDidChange.event;
        this.items = [];
        this.disposables = ( (new DisposableStore()));
        contextKeyService.onDidChangeContext(this.onDidChangeContext, this, this.disposables);
        Event.filter(viewsRegistry.onDidChangeViewWelcomeContent, id => id === this.id)(this.onDidChangeViewWelcomeContent, this, this.disposables);
        this.onDidChangeViewWelcomeContent();
    }
    onDidChangeViewWelcomeContent() {
        const descriptors = viewsRegistry.getViewWelcomeContent(this.id);
        this.items = [];
        for (const descriptor of descriptors) {
            if (descriptor.when === 'default') {
                this.defaultItem = { descriptor, visible: true };
            }
            else {
                const visible = descriptor.when ? this.contextKeyService.contextMatchesRules(descriptor.when) : true;
                this.items.push({ descriptor, visible });
            }
        }
        this._onDidChange.fire();
    }
    onDidChangeContext() {
        let didChange = false;
        for (const item of this.items) {
            if (!item.descriptor.when || item.descriptor.when === 'default') {
                continue;
            }
            const visible = this.contextKeyService.contextMatchesRules(item.descriptor.when);
            if (item.visible === visible) {
                continue;
            }
            item.visible = visible;
            didChange = true;
        }
        if (didChange) {
            this._onDidChange.fire();
        }
    }
    dispose() {
        this.disposables.dispose();
    }
};
ViewWelcomeController = ( (__decorate([
    ( (__param(1, IContextKeyService)))
], ViewWelcomeController)));
let ViewPane = class ViewPane extends Pane {
    get title() {
        return this._title;
    }
    get titleDescription() {
        return this._titleDescription;
    }
    constructor(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService) {
        super({ ...options, ...{ orientation: viewDescriptorService.getViewLocationById(options.id) === 1  ? 1  : 0  } });
        this.keybindingService = keybindingService;
        this.contextMenuService = contextMenuService;
        this.configurationService = configurationService;
        this.contextKeyService = contextKeyService;
        this.viewDescriptorService = viewDescriptorService;
        this.instantiationService = instantiationService;
        this.openerService = openerService;
        this.themeService = themeService;
        this.telemetryService = telemetryService;
        this._onDidFocus = this._register(( (new Emitter())));
        this.onDidFocus = this._onDidFocus.event;
        this._onDidBlur = this._register(( (new Emitter())));
        this.onDidBlur = this._onDidBlur.event;
        this._onDidChangeBodyVisibility = this._register(( (new Emitter())));
        this.onDidChangeBodyVisibility = this._onDidChangeBodyVisibility.event;
        this._onDidChangeTitleArea = this._register(( (new Emitter())));
        this.onDidChangeTitleArea = this._onDidChangeTitleArea.event;
        this._onDidChangeViewWelcomeState = this._register(( (new Emitter())));
        this.onDidChangeViewWelcomeState = this._onDidChangeViewWelcomeState.event;
        this._isVisible = false;
        this.showActionsAlways = false;
        this.viewWelcomeDisposable = Disposable.None;
        this.id = options.id;
        this._title = options.title;
        this._titleDescription = options.titleDescription;
        this.showActionsAlways = !!options.showActionsAlways;
        this.scopedContextKeyService = this._register(contextKeyService.createScoped(this.element));
        this.scopedContextKeyService.createKey('view', this.id);
        const viewLocationKey = this.scopedContextKeyService.createKey('viewLocation', ViewContainerLocationToString(viewDescriptorService.getViewLocationById(this.id)));
        this._register(Event.filter(viewDescriptorService.onDidChangeLocation, e => e.views.some(view => view.id === this.id))(() => viewLocationKey.set(ViewContainerLocationToString(viewDescriptorService.getViewLocationById(this.id)))));
        this.menuActions = this._register(this.instantiationService.createChild(( (new ServiceCollection([IContextKeyService, this.scopedContextKeyService])))).createInstance(CompositeMenuActions, options.titleMenuId ?? MenuId.ViewTitle, MenuId.ViewTitleContext, { shouldForwardArgs: !options.donotForwardArgs }));
        this._register(this.menuActions.onDidChange(() => this.updateActions()));
        this.viewWelcomeController = ( (new ViewWelcomeController(this.id, contextKeyService)));
    }
    get headerVisible() {
        return super.headerVisible;
    }
    set headerVisible(visible) {
        super.headerVisible = visible;
        this.element.classList.toggle('merged-header', !visible);
    }
    setVisible(visible) {
        if (this._isVisible !== visible) {
            this._isVisible = visible;
            if (this.isExpanded()) {
                this._onDidChangeBodyVisibility.fire(visible);
            }
        }
    }
    isVisible() {
        return this._isVisible;
    }
    isBodyVisible() {
        return this._isVisible && this.isExpanded();
    }
    setExpanded(expanded) {
        const changed = super.setExpanded(expanded);
        if (changed) {
            this._onDidChangeBodyVisibility.fire(expanded);
        }
        if (this.twistiesContainer) {
            this.twistiesContainer.classList.remove(...ThemeIcon.asClassNameArray(this.getTwistyIcon(!expanded)));
            this.twistiesContainer.classList.add(...ThemeIcon.asClassNameArray(this.getTwistyIcon(expanded)));
        }
        return changed;
    }
    render() {
        super.render();
        const focusTracker = trackFocus(this.element);
        this._register(focusTracker);
        this._register(focusTracker.onDidFocus(() => this._onDidFocus.fire()));
        this._register(focusTracker.onDidBlur(() => this._onDidBlur.fire()));
    }
    renderHeader(container) {
        this.headerContainer = container;
        this.twistiesContainer = append(container, $$7(ThemeIcon.asCSSSelector(this.getTwistyIcon(this.isExpanded()))));
        this.renderHeaderTitle(container, this.title);
        const actions = append(container, $$7('.actions'));
        actions.classList.toggle('show', this.showActionsAlways);
        this.toolbar = this.instantiationService.createInstance(WorkbenchToolBar, actions, {
            orientation: 0 ,
            actionViewItemProvider: action => this.getActionViewItem(action),
            ariaLabel: ( (localize('viewToolbarAriaLabel', "{0} actions", this.title))),
            getKeyBinding: action => this.keybindingService.lookupKeybinding(action.id),
            renderDropdownAsChildElement: true,
            actionRunner: this.getActionRunner(),
            resetMenu: this.menuActions.menuId
        });
        this._register(this.toolbar);
        this.setActions();
        this._register(addDisposableListener$1(actions, EventType$1.CLICK, e => e.preventDefault()));
        const viewContainerModel = this.viewDescriptorService.getViewContainerByViewId(this.id);
        if (viewContainerModel) {
            this._register(this.viewDescriptorService.getViewContainerModel(viewContainerModel).onDidChangeContainerInfo(({ title }) => this.updateTitle(this.title)));
        }
        else {
            console.error(`View container model not found for view ${this.id}`);
        }
        const onDidRelevantConfigurationChange = Event.filter(this.configurationService.onDidChangeConfiguration, e => e.affectsConfiguration(ViewPane.AlwaysShowActionsConfig));
        this._register(onDidRelevantConfigurationChange(this.updateActionsVisibility, this));
        this.updateActionsVisibility();
    }
    getTwistyIcon(expanded) {
        return expanded ? viewPaneContainerExpandedIcon : viewPaneContainerCollapsedIcon;
    }
    style(styles) {
        super.style(styles);
        const icon = this.getIcon();
        if (this.iconContainer) {
            const fgColor = asCssValueWithDefault(styles.headerForeground, asCssVariable(foreground));
            if (URI.isUri(icon)) {
                this.iconContainer.style.backgroundColor = fgColor;
                this.iconContainer.style.color = '';
            }
            else {
                this.iconContainer.style.color = fgColor;
                this.iconContainer.style.backgroundColor = '';
            }
        }
    }
    getIcon() {
        return this.viewDescriptorService.getViewDescriptorById(this.id)?.containerIcon || defaultViewIcon;
    }
    renderHeaderTitle(container, title) {
        this.iconContainer = append(container, $$7('.icon', undefined));
        const icon = this.getIcon();
        let cssClass = undefined;
        if (URI.isUri(icon)) {
            cssClass = `view-${this.id.replace(/[\.\:]/g, '-')}`;
            const iconClass = `.pane-header .icon.${cssClass}`;
            createCSSRule(iconClass, `
				mask: ${asCSSUrl(icon)} no-repeat 50% 50%;
				mask-size: 24px;
				-webkit-mask: ${asCSSUrl(icon)} no-repeat 50% 50%;
				-webkit-mask-size: 16px;
			`);
        }
        else if (ThemeIcon.isThemeIcon(icon)) {
            cssClass = ThemeIcon.asClassName(icon);
        }
        if (cssClass) {
            this.iconContainer.classList.add(...cssClass.split(' '));
        }
        const calculatedTitle = this.calculateTitle(title);
        this.titleContainer = append(container, $$7('h3.title', { title: calculatedTitle }, calculatedTitle));
        if (this._titleDescription) {
            this.setTitleDescription(this._titleDescription);
        }
        this.iconContainer.title = calculatedTitle;
        this.iconContainer.setAttribute('aria-label', calculatedTitle);
    }
    updateTitle(title) {
        const calculatedTitle = this.calculateTitle(title);
        if (this.titleContainer) {
            this.titleContainer.textContent = calculatedTitle;
            this.titleContainer.setAttribute('title', calculatedTitle);
        }
        if (this.iconContainer) {
            this.iconContainer.title = calculatedTitle;
            this.iconContainer.setAttribute('aria-label', calculatedTitle);
        }
        this._title = title;
        this._onDidChangeTitleArea.fire();
    }
    setTitleDescription(description) {
        if (this.titleDescriptionContainer) {
            this.titleDescriptionContainer.textContent = description ?? '';
            this.titleDescriptionContainer.setAttribute('title', description ?? '');
        }
        else if (description && this.titleContainer) {
            this.titleDescriptionContainer = after(this.titleContainer, $$7('span.description', { title: description }, description));
        }
    }
    updateTitleDescription(description) {
        this.setTitleDescription(description);
        this._titleDescription = description;
        this._onDidChangeTitleArea.fire();
    }
    calculateTitle(title) {
        const viewContainer = this.viewDescriptorService.getViewContainerByViewId(this.id);
        const model = this.viewDescriptorService.getViewContainerModel(viewContainer);
        const viewDescriptor = this.viewDescriptorService.getViewDescriptorById(this.id);
        const isDefault = this.viewDescriptorService.getDefaultContainerById(this.id) === viewContainer;
        if (!isDefault && viewDescriptor?.containerTitle && model.title !== viewDescriptor.containerTitle) {
            return `${viewDescriptor.containerTitle}: ${title}`;
        }
        return title;
    }
    renderBody(container) {
        this.bodyContainer = container;
        const viewWelcomeContainer = append(container, $$7('.welcome-view'));
        this.viewWelcomeContainer = $$7('.welcome-view-content', { tabIndex: 0 });
        this.scrollableElement = this._register(( (new DomScrollableElement(this.viewWelcomeContainer, {
            alwaysConsumeMouseWheel: true,
            horizontal: 2 ,
            vertical: 3 ,
        }))));
        append(viewWelcomeContainer, this.scrollableElement.getDomNode());
        const onViewWelcomeChange = Event.any(this.viewWelcomeController.onDidChange, this.onDidChangeViewWelcomeState);
        this._register(onViewWelcomeChange(this.updateViewWelcome, this));
        this.updateViewWelcome();
    }
    layoutBody(height, width) {
        this.viewWelcomeContainer.style.height = `${height}px`;
        this.viewWelcomeContainer.style.width = `${width}px`;
        this.viewWelcomeContainer.classList.toggle('wide', width > 640);
        this.scrollableElement.scanDomNode();
    }
    onDidScrollRoot() {
    }
    getProgressIndicator() {
        if (this.progressBar === undefined) {
            this.progressBar = this._register(( (new ProgressBar(this.element, defaultProgressBarStyles))));
            this.progressBar.hide();
        }
        if (this.progressIndicator === undefined) {
            const that = this;
            this.progressIndicator = ( (new ScopedProgressIndicator(
                assertIsDefined(this.progressBar),
                new (class extends AbstractProgressScope {
                    constructor() {
                        super(that.id, that.isBodyVisible());
                        this._register(that.onDidChangeBodyVisibility(isVisible => isVisible ? this.onScopeOpened(that.id) : this.onScopeClosed(that.id)));
                    }
                })()
            )));
        }
        return this.progressIndicator;
    }
    getProgressLocation() {
        return this.viewDescriptorService.getViewContainerByViewId(this.id).id;
    }
    getBackgroundColor() {
        switch (this.viewDescriptorService.getViewLocationById(this.id)) {
            case 1 :
                return PANEL_BACKGROUND;
            case 0 :
            case 2 :
                return SIDE_BAR_BACKGROUND;
        }
        return SIDE_BAR_BACKGROUND;
    }
    focus() {
        if (this.shouldShowWelcome()) {
            this.viewWelcomeContainer.focus();
        }
        else if (this.element) {
            this.element.focus();
            this._onDidFocus.fire();
        }
    }
    setActions() {
        if (this.toolbar) {
            const primaryActions = [...this.menuActions.getPrimaryActions()];
            if (this.shouldShowFilterInHeader()) {
                primaryActions.unshift(VIEWPANE_FILTER_ACTION);
            }
            this.toolbar.setActions(prepareActions(primaryActions), prepareActions(this.menuActions.getSecondaryActions()));
            this.toolbar.context = this.getActionsContext();
        }
    }
    updateActionsVisibility() {
        if (!this.headerContainer) {
            return;
        }
        const shouldAlwaysShowActions = this.configurationService.getValue('workbench.view.alwaysShowHeaderActions');
        this.headerContainer.classList.toggle('actions-always-visible', shouldAlwaysShowActions);
    }
    updateActions() {
        this.setActions();
        this._onDidChangeTitleArea.fire();
    }
    getActionViewItem(action, options) {
        if (action.id === VIEWPANE_FILTER_ACTION.id) {
            const that = this;
            return new (class extends BaseActionViewItem {
                constructor() { super(null, action); }
                setFocusable() { }
                get trapsArrowNavigation() { return true; }
                render(container) {
                    container.classList.add('viewpane-filter-container');
                    append(container, that.getFilterWidget().element);
                }
            });
        }
        return createActionViewItem(this.instantiationService, action, { ...options, ...{ menuAsChild: action instanceof SubmenuItemAction } });
    }
    getActionsContext() {
        return undefined;
    }
    getActionRunner() {
        return undefined;
    }
    getOptimalWidth() {
        return 0;
    }
    saveState() {
    }
    updateViewWelcome() {
        this.viewWelcomeDisposable.dispose();
        if (!this.shouldShowWelcome()) {
            this.bodyContainer.classList.remove('welcome');
            this.viewWelcomeContainer.innerText = '';
            this.scrollableElement.scanDomNode();
            return;
        }
        const contents = this.viewWelcomeController.contents;
        if (contents.length === 0) {
            this.bodyContainer.classList.remove('welcome');
            this.viewWelcomeContainer.innerText = '';
            this.scrollableElement.scanDomNode();
            return;
        }
        const disposables = ( (new DisposableStore()));
        this.bodyContainer.classList.add('welcome');
        this.viewWelcomeContainer.innerText = '';
        for (const { content, precondition } of contents) {
            const lines = content.split('\n');
            for (let line of lines) {
                line = line.trim();
                if (!line) {
                    continue;
                }
                const linkedText = parseLinkedText(line);
                if (linkedText.nodes.length === 1 && typeof linkedText.nodes[0] !== 'string') {
                    const node = linkedText.nodes[0];
                    const buttonContainer = append(this.viewWelcomeContainer, $$7('.button-container'));
                    const button = ( (new Button(
                        buttonContainer,
                        { title: node.title, supportIcons: true, ...defaultButtonStyles }
                    )));
                    button.label = node.label;
                    button.onDidClick(_ => {
                        this.telemetryService.publicLog2('views.welcomeAction', { viewId: this.id, uri: node.href });
                        this.openerService.open(node.href, { allowCommands: true });
                    }, null, disposables);
                    disposables.add(button);
                    if (precondition) {
                        const updateEnablement = () => button.enabled = this.contextKeyService.contextMatchesRules(precondition);
                        updateEnablement();
                        const keys = ( (new Set()));
                        ( (precondition.keys())).forEach(key => keys.add(key));
                        const onDidChangeContext = Event.filter(this.contextKeyService.onDidChangeContext, e => e.affectsSome(keys));
                        onDidChangeContext(updateEnablement, null, disposables);
                    }
                }
                else {
                    const p = append(this.viewWelcomeContainer, $$7('p'));
                    for (const node of linkedText.nodes) {
                        if (typeof node === 'string') {
                            append(p, document.createTextNode(node));
                        }
                        else {
                            const link = disposables.add(this.instantiationService.createInstance(Link, p, node, {}));
                            if (precondition && node.href.startsWith('command:')) {
                                const updateEnablement = () => link.enabled = this.contextKeyService.contextMatchesRules(precondition);
                                updateEnablement();
                                const keys = ( (new Set()));
                                ( (precondition.keys())).forEach(key => keys.add(key));
                                const onDidChangeContext = Event.filter(this.contextKeyService.onDidChangeContext, e => e.affectsSome(keys));
                                onDidChangeContext(updateEnablement, null, disposables);
                            }
                        }
                    }
                }
            }
        }
        this.scrollableElement.scanDomNode();
        this.viewWelcomeDisposable = disposables;
    }
    shouldShowWelcome() {
        return false;
    }
    getFilterWidget() {
        return undefined;
    }
    shouldShowFilterInHeader() {
        return false;
    }
};
ViewPane.AlwaysShowActionsConfig = 'workbench.view.alwaysShowHeaderActions';
ViewPane = ( (__decorate([
    ( (__param(1, IKeybindingService))),
    ( (__param(2, IContextMenuService))),
    ( (__param(3, IConfigurationService))),
    ( (__param(4, IContextKeyService))),
    ( (__param(5, IViewDescriptorService))),
    ( (__param(6, IInstantiationService))),
    ( (__param(7, IOpenerService))),
    ( (__param(8, IThemeService))),
    ( (__param(9, ITelemetryService)))
], ViewPane)));
class ViewAction extends Action2 {
    constructor(desc) {
        super(desc);
        this.desc = desc;
    }
    run(accessor, ...args) {
        const view = accessor.get(IViewsService).getActiveViewWithId(this.desc.viewId);
        if (view) {
            return this.runInView(accessor, view, ...args);
        }
    }
}
const breakpoint = {
    regular: ( (registerIcon(
        'debug-breakpoint',
        Codicon.debugBreakpoint,
         (localize('debugBreakpoint', 'Icon for breakpoints.'))
    ))),
    disabled: ( (registerIcon(
        'debug-breakpoint-disabled',
        Codicon.debugBreakpointDisabled,
         (localize('debugBreakpointDisabled', 'Icon for disabled breakpoints.'))
    ))),
    unverified: ( (registerIcon(
        'debug-breakpoint-unverified',
        Codicon.debugBreakpointUnverified,
         (localize('debugBreakpointUnverified', 'Icon for unverified breakpoints.'))
    )))
};
const functionBreakpoint = {
    regular: ( (registerIcon(
        'debug-breakpoint-function',
        Codicon.debugBreakpointFunction,
         (localize('debugBreakpointFunction', 'Icon for function breakpoints.'))
    ))),
    disabled: ( (registerIcon(
        'debug-breakpoint-function-disabled',
        Codicon.debugBreakpointFunctionDisabled,
         (localize(
            'debugBreakpointFunctionDisabled',
            'Icon for disabled function breakpoints.'
        ))
    ))),
    unverified: ( (registerIcon(
        'debug-breakpoint-function-unverified',
        Codicon.debugBreakpointFunctionUnverified,
         (localize(
            'debugBreakpointFunctionUnverified',
            'Icon for unverified function breakpoints.'
        ))
    )))
};
const conditionalBreakpoint = {
    regular: ( (registerIcon(
        'debug-breakpoint-conditional',
        Codicon.debugBreakpointConditional,
         (localize('debugBreakpointConditional', 'Icon for conditional breakpoints.'))
    ))),
    disabled: ( (registerIcon(
        'debug-breakpoint-conditional-disabled',
        Codicon.debugBreakpointConditionalDisabled,
         (localize(
            'debugBreakpointConditionalDisabled',
            'Icon for disabled conditional breakpoints.'
        ))
    ))),
    unverified: ( (registerIcon(
        'debug-breakpoint-conditional-unverified',
        Codicon.debugBreakpointConditionalUnverified,
         (localize(
            'debugBreakpointConditionalUnverified',
            'Icon for unverified conditional breakpoints.'
        ))
    )))
};
const dataBreakpoint = {
    regular: ( (registerIcon(
        'debug-breakpoint-data',
        Codicon.debugBreakpointData,
         (localize('debugBreakpointData', 'Icon for data breakpoints.'))
    ))),
    disabled: ( (registerIcon(
        'debug-breakpoint-data-disabled',
        Codicon.debugBreakpointDataDisabled,
         (localize('debugBreakpointDataDisabled', 'Icon for disabled data breakpoints.'))
    ))),
    unverified: ( (registerIcon(
        'debug-breakpoint-data-unverified',
        Codicon.debugBreakpointDataUnverified,
         (localize('debugBreakpointDataUnverified', 'Icon for unverified data breakpoints.'))
    ))),
};
const logBreakpoint = {
    regular: ( (registerIcon(
        'debug-breakpoint-log',
        Codicon.debugBreakpointLog,
         (localize('debugBreakpointLog', 'Icon for log breakpoints.'))
    ))),
    disabled: ( (registerIcon(
        'debug-breakpoint-log-disabled',
        Codicon.debugBreakpointLogDisabled,
         (localize('debugBreakpointLogDisabled', 'Icon for disabled log breakpoint.'))
    ))),
    unverified: ( (registerIcon(
        'debug-breakpoint-log-unverified',
        Codicon.debugBreakpointLogUnverified,
         (localize('debugBreakpointLogUnverified', 'Icon for unverified log breakpoints.'))
    ))),
};
const debugBreakpointHint = ( (registerIcon('debug-hint', Codicon.debugHint,  (localize(
    'debugBreakpointHint',
    'Icon for breakpoint hints shown on hover in editor glyph margin.'
)))));
const debugBreakpointUnsupported = ( (registerIcon(
    'debug-breakpoint-unsupported',
    Codicon.debugBreakpointUnsupported,
     (localize('debugBreakpointUnsupported', 'Icon for unsupported breakpoints.'))
)));
const allBreakpoints = [breakpoint, functionBreakpoint, conditionalBreakpoint, dataBreakpoint, logBreakpoint];
const debugStackframe = ( (registerIcon('debug-stackframe', Codicon.debugStackframe,  (localize(
    'debugStackframe',
    'Icon for a stackframe shown in the editor glyph margin.'
)))));
const debugStackframeFocused = ( (registerIcon(
    'debug-stackframe-focused',
    Codicon.debugStackframeFocused,
     (localize(
        'debugStackframeFocused',
        'Icon for a focused stackframe  shown in the editor glyph margin.'
    ))
)));
const debugGripper = ( (registerIcon(
    'debug-gripper',
    Codicon.gripper,
     (localize('debugGripper', 'Icon for the debug bar gripper.'))
)));
const debugRestartFrame = ( (registerIcon(
    'debug-restart-frame',
    Codicon.debugRestartFrame,
     (localize('debugRestartFrame', 'Icon for the debug restart frame action.'))
)));
const debugStop = ( (registerIcon(
    'debug-stop',
    Codicon.debugStop,
     (localize('debugStop', 'Icon for the debug stop action.'))
)));
const debugDisconnect = ( (registerIcon(
    'debug-disconnect',
    Codicon.debugDisconnect,
     (localize('debugDisconnect', 'Icon for the debug disconnect action.'))
)));
const debugRestart = ( (registerIcon(
    'debug-restart',
    Codicon.debugRestart,
     (localize('debugRestart', 'Icon for the debug restart action.'))
)));
const debugStepOver = ( (registerIcon(
    'debug-step-over',
    Codicon.debugStepOver,
     (localize('debugStepOver', 'Icon for the debug step over action.'))
)));
const debugStepInto = ( (registerIcon(
    'debug-step-into',
    Codicon.debugStepInto,
     (localize('debugStepInto', 'Icon for the debug step into action.'))
)));
const debugStepOut = ( (registerIcon(
    'debug-step-out',
    Codicon.debugStepOut,
     (localize('debugStepOut', 'Icon for the debug step out action.'))
)));
const debugStepBack = ( (registerIcon(
    'debug-step-back',
    Codicon.debugStepBack,
     (localize('debugStepBack', 'Icon for the debug step back action.'))
)));
const debugPause = ( (registerIcon(
    'debug-pause',
    Codicon.debugPause,
     (localize('debugPause', 'Icon for the debug pause action.'))
)));
const debugContinue = ( (registerIcon(
    'debug-continue',
    Codicon.debugContinue,
     (localize('debugContinue', 'Icon for the debug continue action.'))
)));
const debugReverseContinue = ( (registerIcon(
    'debug-reverse-continue',
    Codicon.debugReverseContinue,
     (localize('debugReverseContinue', 'Icon for the debug reverse continue action.'))
)));
const debugRun = ( (registerIcon(
    'debug-run',
    Codicon.run,
     (localize('debugRun', 'Icon for the run or debug action.'))
)));
const debugStart = ( (registerIcon(
    'debug-start',
    Codicon.debugStart,
     (localize('debugStart', 'Icon for the debug start action.'))
)));
const debugConfigure = ( (registerIcon(
    'debug-configure',
    Codicon.gear,
     (localize('debugConfigure', 'Icon for the debug configure action.'))
)));
const debugRemoveConfig = ( (registerIcon(
    'debug-remove-config',
    Codicon.trash,
     (localize('debugRemoveConfig', 'Icon for removing debug configurations.'))
)));
const watchExpressionsAddFuncBreakpoint = ( (registerIcon(
    'watch-expressions-add-function-breakpoint',
    Codicon.add,
     (localize(
        'watchExpressionsAddFuncBreakpoint',
        'Icon for the add function breakpoint action in the watch view.'
    ))
)));
const breakpointsRemoveAll = ( (registerIcon('breakpoints-remove-all', Codicon.closeAll,  (localize(
    'breakpointsRemoveAll',
    'Icon for the Remove All action in the breakpoints view.'
)))));
const breakpointsActivate = ( (registerIcon(
    'breakpoints-activate',
    Codicon.activateBreakpoints,
     (localize(
        'breakpointsActivate',
        'Icon for the activate action in the breakpoints view.'
    ))
)));
const $$6 = $$7;
function createCheckbox(disposables) {
    const checkbox = $$6('input');
    checkbox.type = 'checkbox';
    checkbox.tabIndex = -1;
    disposables.push(Gesture.ignoreTarget(checkbox));
    return checkbox;
}
const breakpointIdToActionBarDomeNode = ( (new Map()));
let BreakpointsRenderer = class BreakpointsRenderer {
    constructor(menu, breakpointSupportsCondition, breakpointItemType, debugService, labelService) {
        this.menu = menu;
        this.breakpointSupportsCondition = breakpointSupportsCondition;
        this.breakpointItemType = breakpointItemType;
        this.debugService = debugService;
        this.labelService = labelService;
    }
    get templateId() {
        return BreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = append(container, $$6('.breakpoint'));
        data.icon = $$6('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        append(data.breakpoint, data.icon);
        append(data.breakpoint, data.checkbox);
        data.name = append(data.breakpoint, $$6('span.name'));
        data.filePath = append(data.breakpoint, $$6('span.file-path'));
        data.actionBar = ( (new ActionBar(data.breakpoint)));
        data.toDispose.push(data.actionBar);
        const lineNumberContainer = append(data.breakpoint, $$6('.line-number-container'));
        data.lineNumber = append(lineNumberContainer, $$6('span.line-number.monaco-count-badge'));
        return data;
    }
    renderElement(breakpoint, index, data) {
        data.context = breakpoint;
        data.breakpoint.classList.toggle('disabled', !this.debugService.getModel().areBreakpointsActivated());
        data.name.textContent = basenameOrAuthority(breakpoint.uri);
        data.lineNumber.textContent = ( (breakpoint.lineNumber.toString()));
        if (breakpoint.column) {
            data.lineNumber.textContent += `:${breakpoint.column}`;
        }
        data.filePath.textContent = this.labelService.getUriLabel(dirname(breakpoint.uri), { relative: true });
        data.checkbox.checked = breakpoint.enabled;
        const { message, icon } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), breakpoint, this.labelService);
        data.icon.className = ThemeIcon.asClassName(icon);
        data.breakpoint.title = breakpoint.message || message || '';
        const debugActive = this.debugService.state === 3  || this.debugService.state === 2 ;
        if (debugActive && !breakpoint.verified) {
            data.breakpoint.classList.add('disabled');
        }
        const primary = [];
        const session = this.debugService.getViewModel().focusedSession;
        this.breakpointSupportsCondition.set(!session || !!session.capabilities.supportsConditionalBreakpoints);
        this.breakpointItemType.set('breakpoint');
        createAndFillInActionBarActions(this.menu, { arg: breakpoint, shouldForwardArgs: true }, { primary, secondary: [] }, 'inline');
        data.actionBar.clear();
        data.actionBar.push(primary, { icon: true, label: false });
        breakpointIdToActionBarDomeNode.set(breakpoint.getId(), data.actionBar.domNode);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
BreakpointsRenderer.ID = 'breakpoints';
BreakpointsRenderer = ( (__decorate([
    ( (__param(3, IDebugService))),
    ( (__param(4, ILabelService)))
], BreakpointsRenderer)));
let FunctionBreakpointsRenderer = class FunctionBreakpointsRenderer {
    constructor(menu, breakpointSupportsCondition, breakpointItemType, debugService, labelService) {
        this.menu = menu;
        this.breakpointSupportsCondition = breakpointSupportsCondition;
        this.breakpointItemType = breakpointItemType;
        this.debugService = debugService;
        this.labelService = labelService;
    }
    get templateId() {
        return FunctionBreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = append(container, $$6('.breakpoint'));
        data.icon = $$6('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        append(data.breakpoint, data.icon);
        append(data.breakpoint, data.checkbox);
        data.name = append(data.breakpoint, $$6('span.name'));
        data.condition = append(data.breakpoint, $$6('span.condition'));
        data.actionBar = ( (new ActionBar(data.breakpoint)));
        data.toDispose.push(data.actionBar);
        return data;
    }
    renderElement(functionBreakpoint, _index, data) {
        data.context = functionBreakpoint;
        data.name.textContent = functionBreakpoint.name;
        const { icon, message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), functionBreakpoint, this.labelService);
        data.icon.className = ThemeIcon.asClassName(icon);
        data.icon.title = message ? message : '';
        data.checkbox.checked = functionBreakpoint.enabled;
        data.breakpoint.title = message ? message : '';
        if (functionBreakpoint.condition && functionBreakpoint.hitCondition) {
            data.condition.textContent = ( (localize(
                'expressionAndHitCount',
                "Expression: {0} | Hit Count: {1}",
                functionBreakpoint.condition,
                functionBreakpoint.hitCondition
            )));
        }
        else {
            data.condition.textContent = functionBreakpoint.condition || functionBreakpoint.hitCondition || '';
        }
        const session = this.debugService.getViewModel().focusedSession;
        data.breakpoint.classList.toggle('disabled', (session && !session.capabilities.supportsFunctionBreakpoints) || !this.debugService.getModel().areBreakpointsActivated());
        if (session && !session.capabilities.supportsFunctionBreakpoints) {
            data.breakpoint.title = ( (localize(
                'functionBreakpointsNotSupported',
                "Function breakpoints are not supported by this debug type"
            )));
        }
        const primary = [];
        this.breakpointSupportsCondition.set(!session || !!session.capabilities.supportsConditionalBreakpoints);
        this.breakpointItemType.set('functionBreakpoint');
        createAndFillInActionBarActions(this.menu, { arg: functionBreakpoint, shouldForwardArgs: true }, { primary, secondary: [] }, 'inline');
        data.actionBar.clear();
        data.actionBar.push(primary, { icon: true, label: false });
        breakpointIdToActionBarDomeNode.set(functionBreakpoint.getId(), data.actionBar.domNode);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
FunctionBreakpointsRenderer.ID = 'functionbreakpoints';
FunctionBreakpointsRenderer = ( (__decorate([
    ( (__param(3, IDebugService))),
    ( (__param(4, ILabelService)))
], FunctionBreakpointsRenderer)));
let DataBreakpointsRenderer = class DataBreakpointsRenderer {
    constructor(debugService, labelService) {
        this.debugService = debugService;
        this.labelService = labelService;
    }
    get templateId() {
        return DataBreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.breakpoint = append(container, $$6('.breakpoint'));
        data.toDispose = [];
        data.icon = $$6('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        append(data.breakpoint, data.icon);
        append(data.breakpoint, data.checkbox);
        data.name = append(data.breakpoint, $$6('span.name'));
        data.accessType = append(data.breakpoint, $$6('span.access-type'));
        return data;
    }
    renderElement(dataBreakpoint, _index, data) {
        data.context = dataBreakpoint;
        data.name.textContent = dataBreakpoint.description;
        const { icon, message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), dataBreakpoint, this.labelService);
        data.icon.className = ThemeIcon.asClassName(icon);
        data.icon.title = message ? message : '';
        data.checkbox.checked = dataBreakpoint.enabled;
        data.breakpoint.title = message ? message : '';
        const session = this.debugService.getViewModel().focusedSession;
        data.breakpoint.classList.toggle('disabled', (session && !session.capabilities.supportsDataBreakpoints) || !this.debugService.getModel().areBreakpointsActivated());
        if (session && !session.capabilities.supportsDataBreakpoints) {
            data.breakpoint.title = ( (localize(
                'dataBreakpointsNotSupported',
                "Data breakpoints are not supported by this debug type"
            )));
        }
        if (dataBreakpoint.accessType) {
            const accessType = dataBreakpoint.accessType === 'read' ? ( (localize('read', "Read"))) : dataBreakpoint.accessType === 'write' ? ( (localize('write', "Write"))) : ( (localize('access', "Access")));
            data.accessType.textContent = accessType;
        }
        else {
            data.accessType.textContent = '';
        }
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
DataBreakpointsRenderer.ID = 'databreakpoints';
DataBreakpointsRenderer = ( (__decorate([
    ( (__param(0, IDebugService))),
    ( (__param(1, ILabelService)))
], DataBreakpointsRenderer)));
let InstructionBreakpointsRenderer = class InstructionBreakpointsRenderer {
    constructor(debugService, labelService) {
        this.debugService = debugService;
        this.labelService = labelService;
    }
    get templateId() {
        return InstructionBreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = append(container, $$6('.breakpoint'));
        data.icon = $$6('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        append(data.breakpoint, data.icon);
        append(data.breakpoint, data.checkbox);
        data.name = append(data.breakpoint, $$6('span.name'));
        data.address = append(data.breakpoint, $$6('span.file-path'));
        data.actionBar = ( (new ActionBar(data.breakpoint)));
        data.toDispose.push(data.actionBar);
        return data;
    }
    renderElement(breakpoint, index, data) {
        data.context = breakpoint;
        data.breakpoint.classList.toggle('disabled', !this.debugService.getModel().areBreakpointsActivated());
        data.name.textContent = breakpoint.instructionReference;
        data.checkbox.checked = breakpoint.enabled;
        const { message, icon } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), breakpoint, this.labelService);
        data.icon.className = ThemeIcon.asClassName(icon);
        data.breakpoint.title = breakpoint.message || message || '';
        const debugActive = this.debugService.state === 3  || this.debugService.state === 2 ;
        if (debugActive && !breakpoint.verified) {
            data.breakpoint.classList.add('disabled');
        }
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
InstructionBreakpointsRenderer.ID = 'instructionBreakpoints';
InstructionBreakpointsRenderer = ( (__decorate([
    ( (__param(0, IDebugService))),
    ( (__param(1, ILabelService)))
], InstructionBreakpointsRenderer)));
function openBreakpointSource(breakpoint, sideBySide, preserveFocus, pinned, debugService, editorService) {
    if (breakpoint.uri.scheme === DEBUG_SCHEME && debugService.state === 0 ) {
        return Promise.resolve(undefined);
    }
    const selection = breakpoint.endLineNumber ? {
        startLineNumber: breakpoint.lineNumber,
        endLineNumber: breakpoint.endLineNumber,
        startColumn: breakpoint.column || 1,
        endColumn: breakpoint.endColumn || 1073741824
    } : {
        startLineNumber: breakpoint.lineNumber,
        startColumn: breakpoint.column || 1,
        endLineNumber: breakpoint.lineNumber,
        endColumn: breakpoint.column || 1073741824
    };
    return editorService.openEditor({
        resource: breakpoint.uri,
        options: {
            preserveFocus,
            selection,
            revealIfOpened: true,
            selectionRevealType: 1 ,
            pinned
        }
    }, sideBySide ? SIDE_GROUP : ACTIVE_GROUP);
}
function getBreakpointMessageAndIcon(state, breakpointsActivated, breakpoint$1, labelService) {
    const debugActive = state === 3  || state === 2 ;
    const breakpointIcon = breakpoint$1 instanceof DataBreakpoint ? dataBreakpoint : breakpoint$1 instanceof FunctionBreakpoint ? functionBreakpoint : breakpoint$1.logMessage ? logBreakpoint : breakpoint;
    if (!breakpoint$1.enabled || !breakpointsActivated) {
        return {
            icon: breakpointIcon.disabled,
            message: breakpoint$1.logMessage ? ( (localize('disabledLogpoint', "Disabled Logpoint"))) : ( (localize('disabledBreakpoint', "Disabled Breakpoint"))),
        };
    }
    const appendMessage = (text) => {
        return ('message' in breakpoint$1 && breakpoint$1.message) ? text.concat(', ' + breakpoint$1.message) : text;
    };
    if (debugActive && !breakpoint$1.verified) {
        return {
            icon: breakpointIcon.unverified,
            message: ('message' in breakpoint$1 && breakpoint$1.message) ? breakpoint$1.message : (breakpoint$1.logMessage ? ( (localize('unverifiedLogpoint', "Unverified Logpoint"))) : ( (localize('unverifiedBreakpoint', "Unverified Breakpoint")))),
            showAdapterUnverifiedMessage: true
        };
    }
    if (breakpoint$1 instanceof DataBreakpoint) {
        if (!breakpoint$1.supported) {
            return {
                icon: breakpointIcon.unverified,
                message: ( (localize(
                    'dataBreakpointUnsupported',
                    "Data breakpoints not supported by this debug type"
                ))),
            };
        }
        return {
            icon: breakpointIcon.regular,
            message: breakpoint$1.message || ( (localize('dataBreakpoint', "Data Breakpoint")))
        };
    }
    if (breakpoint$1 instanceof FunctionBreakpoint) {
        if (!breakpoint$1.supported) {
            return {
                icon: breakpointIcon.unverified,
                message: ( (localize(
                    'functionBreakpointUnsupported',
                    "Function breakpoints not supported by this debug type"
                ))),
            };
        }
        const messages = [];
        messages.push(breakpoint$1.message || ( (localize('functionBreakpoint', "Function Breakpoint"))));
        if (breakpoint$1.condition) {
            messages.push(( (localize('expression', "Expression condition: {0}", breakpoint$1.condition))));
        }
        if (breakpoint$1.hitCondition) {
            messages.push(( (localize('hitCount', "Hit Count: {0}", breakpoint$1.hitCondition))));
        }
        return {
            icon: breakpointIcon.regular,
            message: appendMessage(messages.join('\n'))
        };
    }
    if (breakpoint$1 instanceof InstructionBreakpoint) {
        if (!breakpoint$1.supported) {
            return {
                icon: breakpointIcon.unverified,
                message: ( (localize(
                    'instructionBreakpointUnsupported',
                    "Instruction breakpoints not supported by this debug type"
                ))),
            };
        }
        const messages = [];
        if (breakpoint$1.message) {
            messages.push(breakpoint$1.message);
        }
        else if (breakpoint$1.instructionReference) {
            messages.push(( (localize(
                'instructionBreakpointAtAddress',
                "Instruction breakpoint at address {0}",
                breakpoint$1.instructionReference
            ))));
        }
        else {
            messages.push(( (localize('instructionBreakpoint', "Instruction breakpoint"))));
        }
        if (breakpoint$1.hitCondition) {
            messages.push(( (localize('hitCount', "Hit Count: {0}", breakpoint$1.hitCondition))));
        }
        return {
            icon: breakpointIcon.regular,
            message: appendMessage(messages.join('\n'))
        };
    }
    if (breakpoint$1.logMessage || breakpoint$1.condition || breakpoint$1.hitCondition) {
        const messages = [];
        if (!breakpoint$1.supported) {
            return {
                icon: debugBreakpointUnsupported,
                message: ( (localize(
                    'breakpointUnsupported',
                    "Breakpoints of this type are not supported by the debugger"
                ))),
            };
        }
        if (breakpoint$1.logMessage) {
            messages.push(( (localize('logMessage', "Log Message: {0}", breakpoint$1.logMessage))));
        }
        if (breakpoint$1.condition) {
            messages.push(( (localize('expression', "Expression condition: {0}", breakpoint$1.condition))));
        }
        if (breakpoint$1.hitCondition) {
            messages.push(( (localize('hitCount', "Hit Count: {0}", breakpoint$1.hitCondition))));
        }
        return {
            icon: breakpoint$1.logMessage ? logBreakpoint.regular : conditionalBreakpoint.regular,
            message: appendMessage(messages.join('\n'))
        };
    }
    const message = ('message' in breakpoint$1 && breakpoint$1.message) ? breakpoint$1.message : breakpoint$1 instanceof Breakpoint && labelService ? labelService.getUriLabel(breakpoint$1.uri) : ( (localize('breakpoint', "Breakpoint")));
    return {
        icon: breakpointIcon.regular,
        message
    };
}
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.addFunctionBreakpointAction',
            title: {
                value: ( (localize('addFunctionBreakpoint', "Add Function Breakpoint"))),
                original: 'Add Function Breakpoint',
                mnemonicTitle: ( (localize(
                    { key: 'miFunctionBreakpoint', comment: ['&& denotes a mnemonic'] },
                    "&&Function Breakpoint..."
                )))
            },
            f1: true,
            icon: watchExpressionsAddFuncBreakpoint,
            menu: [{
                    id: MenuId.ViewTitle,
                    group: 'navigation',
                    order: 10,
                    when: ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID)
                }, {
                    id: MenuId.MenubarNewBreakpointMenu,
                    group: '1_breakpoints',
                    order: 3,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    run(accessor) {
        const debugService = accessor.get(IDebugService);
        debugService.addFunctionBreakpoint();
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.toggleBreakpointsActivatedAction',
            title: { value: ( (localize('activateBreakpoints', "Toggle Activate Breakpoints"))), original: 'Toggle Activate Breakpoints' },
            f1: true,
            icon: breakpointsActivate,
            menu: {
                id: MenuId.ViewTitle,
                group: 'navigation',
                order: 20,
                when: ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID)
            }
        });
    }
    run(accessor) {
        const debugService = accessor.get(IDebugService);
        debugService.setBreakpointsActivated(!debugService.getModel().areBreakpointsActivated());
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.removeBreakpoint',
            title: ( (localize('removeBreakpoint', "Remove Breakpoint"))),
            icon: Codicon.removeClose,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: '3_modification',
                    order: 10,
                    when: ( (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint')))
                }, {
                    id: MenuId.DebugBreakpointsContext,
                    group: 'inline',
                    order: 20,
                    when: ( (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint')))
                }]
        });
    }
    async run(accessor, breakpoint) {
        const debugService = accessor.get(IDebugService);
        if (breakpoint instanceof Breakpoint) {
            await debugService.removeBreakpoints(breakpoint.getId());
        }
        else if (breakpoint instanceof FunctionBreakpoint) {
            await debugService.removeFunctionBreakpoints(breakpoint.getId());
        }
        else if (breakpoint instanceof DataBreakpoint) {
            await debugService.removeDataBreakpoints(breakpoint.getId());
        }
        else if (breakpoint instanceof InstructionBreakpoint) {
            await debugService.removeInstructionBreakpoints(breakpoint.instructionReference);
        }
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.removeAllBreakpoints',
            title: {
                original: 'Remove All Breakpoints',
                value: ( (localize('removeAllBreakpoints', "Remove All Breakpoints"))),
                mnemonicTitle: ( (localize(
                    { key: 'miRemoveAllBreakpoints', comment: ['&& denotes a mnemonic'] },
                    "Remove &&All Breakpoints"
                )))
            },
            f1: true,
            icon: breakpointsRemoveAll,
            menu: [{
                    id: MenuId.ViewTitle,
                    group: 'navigation',
                    order: 30,
                    when: ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID)
                }, {
                    id: MenuId.DebugBreakpointsContext,
                    group: '3_modification',
                    order: 20,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_BREAKPOINTS_EXIST,
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                    )))
                }, {
                    id: MenuId.MenubarDebugMenu,
                    group: '5_breakpoints',
                    order: 3,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    run(accessor) {
        const debugService = accessor.get(IDebugService);
        debugService.removeBreakpoints();
        debugService.removeFunctionBreakpoints();
        debugService.removeDataBreakpoints();
        debugService.removeInstructionBreakpoints();
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.enableAllBreakpoints',
            title: {
                original: 'Enable All Breakpoints',
                value: ( (localize('enableAllBreakpoints', "Enable All Breakpoints"))),
                mnemonicTitle: ( (localize(
                    { key: 'miEnableAllBreakpoints', comment: ['&& denotes a mnemonic'] },
                    "&&Enable All Breakpoints"
                ))),
            },
            f1: true,
            precondition: CONTEXT_DEBUGGERS_AVAILABLE,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'z_commands',
                    order: 10,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_BREAKPOINTS_EXIST,
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                    )))
                }, {
                    id: MenuId.MenubarDebugMenu,
                    group: '5_breakpoints',
                    order: 1,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    async run(accessor) {
        const debugService = accessor.get(IDebugService);
        await debugService.enableOrDisableBreakpoints(true);
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.disableAllBreakpoints',
            title: {
                original: 'Disable All Breakpoints',
                value: ( (localize('disableAllBreakpoints', "Disable All Breakpoints"))),
                mnemonicTitle: ( (localize(
                    { key: 'miDisableAllBreakpoints', comment: ['&& denotes a mnemonic'] },
                    "Disable A&&ll Breakpoints"
                )))
            },
            f1: true,
            precondition: CONTEXT_DEBUGGERS_AVAILABLE,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'z_commands',
                    order: 20,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_BREAKPOINTS_EXIST,
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                    )))
                }, {
                    id: MenuId.MenubarDebugMenu,
                    group: '5_breakpoints',
                    order: 2,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    async run(accessor) {
        const debugService = accessor.get(IDebugService);
        await debugService.enableOrDisableBreakpoints(false);
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.reapplyBreakpointsAction',
            title: { value: ( (localize('reapplyAllBreakpoints', "Reapply All Breakpoints"))), original: 'Reapply All Breakpoints' },
            f1: true,
            precondition: CONTEXT_IN_DEBUG_MODE,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'z_commands',
                    order: 30,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_BREAKPOINTS_EXIST,
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                    )))
                }]
        });
    }
    async run(accessor) {
        const debugService = accessor.get(IDebugService);
        await debugService.setBreakpointsActivated(true);
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editBreakpoint',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( (localize('editCondition', "Edit Condition..."))),
            icon: Codicon.edit,
            precondition: CONTEXT_BREAKPOINT_SUPPORTS_CONDITION,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'navigation',
                    order: 10
                }, {
                    id: MenuId.DebugBreakpointsContext,
                    group: 'inline',
                    order: 10
                }]
        });
    }
    async runInView(accessor, view, breakpoint) {
        const debugService = accessor.get(IDebugService);
        const editorService = accessor.get(IEditorService);
        if (breakpoint instanceof Breakpoint) {
            const editor = await openBreakpointSource(breakpoint, false, false, true, debugService, editorService);
            if (editor) {
                const codeEditor = editor.getControl();
                if (isCodeEditor(codeEditor)) {
                    codeEditor.getContribution(BREAKPOINT_EDITOR_CONTRIBUTION_ID)?.showBreakpointWidget(breakpoint.lineNumber, breakpoint.column);
                }
            }
        }
        else if (breakpoint instanceof FunctionBreakpoint) {
            const contextMenuService = accessor.get(IContextMenuService);
            const actions = [( (new Action(
                'breakpoint.editCondition',
                 (localize('editCondition', "Edit Condition...")),
                undefined,
                true,
                async () => view.renderInputBox({ breakpoint, type: 'condition' })
            ))),
                ( (new Action(
                'breakpoint.editCondition',
                 (localize('editHitCount', "Edit Hit Count...")),
                undefined,
                true,
                async () => view.renderInputBox({ breakpoint, type: 'hitCount' })
            )))];
            const domNode = breakpointIdToActionBarDomeNode.get(breakpoint.getId());
            if (domNode) {
                contextMenuService.showContextMenu({
                    getActions: () => actions,
                    getAnchor: () => domNode,
                    onHide: () => dispose(actions)
                });
            }
        }
        else {
            view.renderInputBox({ breakpoint, type: 'condition' });
        }
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editFunctionBreakpoint',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( (localize('editBreakpoint', "Edit Function Breakpoint..."))),
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: '1_breakpoints',
                    order: 10,
                    when: ( (CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('functionBreakpoint')))
                }]
        });
    }
    runInView(_accessor, view, breakpoint) {
        view.renderInputBox({ breakpoint, type: 'name' });
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editFunctionBreakpointHitCount',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( (localize('editHitCount', "Edit Hit Count..."))),
            precondition: CONTEXT_BREAKPOINT_SUPPORTS_CONDITION,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'navigation',
                    order: 20,
                    when: ( (CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('functionBreakpoint')))
                }]
        });
    }
    runInView(_accessor, view, breakpoint) {
        view.renderInputBox({ breakpoint, type: 'hitCount' });
    }
});
async function showLoadedScriptMenu(accessor) {
    const quickInputService = accessor.get(IQuickInputService);
    const debugService = accessor.get(IDebugService);
    const editorService = accessor.get(IEditorService);
    const sessions = debugService.getModel().getSessions(false);
    const modelService = accessor.get(IModelService);
    const languageService = accessor.get(ILanguageService);
    const labelService = accessor.get(ILabelService);
    const localDisposableStore = ( (new DisposableStore()));
    const quickPick = quickInputService.createQuickPick();
    localDisposableStore.add(quickPick);
    quickPick.matchOnLabel = quickPick.matchOnDescription = quickPick.matchOnDetail = quickPick.sortByLabel = false;
    quickPick.placeholder = ( (localize('moveFocusedView.selectView', "Search loaded scripts by name")));
    quickPick.items = await _getPicks(quickPick.value, sessions, editorService, modelService, languageService, labelService);
    localDisposableStore.add(quickPick.onDidChangeValue(async () => {
        quickPick.items = await _getPicks(quickPick.value, sessions, editorService, modelService, languageService, labelService);
    }));
    localDisposableStore.add(quickPick.onDidAccept(() => {
        const selectedItem = quickPick.selectedItems[0];
        selectedItem.accept();
        quickPick.hide();
        localDisposableStore.dispose();
    }));
    quickPick.show();
}
async function _getPicksFromSession(session, filter, editorService, modelService, languageService, labelService) {
    const items = [];
    items.push({ type: 'separator', label: session.name });
    const sources = await session.getLoadedSources();
    sources.forEach((element) => {
        const pick = _createPick$1(element, filter, editorService, modelService, languageService, labelService);
        if (pick) {
            items.push(pick);
        }
    });
    return items;
}
async function _getPicks(filter, sessions, editorService, modelService, languageService, labelService) {
    const loadedScriptPicks = [];
    const picks = await Promise.all(( (sessions.map(
        (session) => _getPicksFromSession(session, filter, editorService, modelService, languageService, labelService)
    ))));
    for (const row of picks) {
        for (const elem of row) {
            loadedScriptPicks.push(elem);
        }
    }
    return loadedScriptPicks;
}
function _createPick$1(source, filter, editorService, modelService, languageService, labelService) {
    const label = labelService.getUriBasenameLabel(source.uri);
    const desc = labelService.getUriLabel(dirname(source.uri));
    const labelHighlights = matchesFuzzy(filter, label, true);
    const descHighlights = matchesFuzzy(filter, desc, true);
    if (labelHighlights || descHighlights) {
        return {
            label,
            description: desc === '.' ? undefined : desc,
            highlights: { label: labelHighlights ?? undefined, description: descHighlights ?? undefined },
            iconClasses: getIconClasses(modelService, languageService, source.uri),
            accept: () => {
                if (source.available) {
                    source.openInEditor(editorService, { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 });
                }
            }
        };
    }
    return undefined;
}
async function showDebugSessionMenu(accessor, selectAndStartID) {
    const quickInputService = accessor.get(IQuickInputService);
    const debugService = accessor.get(IDebugService);
    const viewsService = accessor.get(IViewsService);
    const commandService = accessor.get(ICommandService);
    const localDisposableStore = ( (new DisposableStore()));
    const quickPick = quickInputService.createQuickPick();
    localDisposableStore.add(quickPick);
    quickPick.matchOnLabel = quickPick.matchOnDescription = quickPick.matchOnDetail = quickPick.sortByLabel = false;
    quickPick.placeholder = ( (localize('moveFocusedView.selectView', 'Search debug sessions by name')));
    const pickItems = _getPicksAndActiveItem(quickPick.value, selectAndStartID, debugService, viewsService, commandService);
    quickPick.items = pickItems.picks;
    quickPick.activeItems = pickItems.activeItems;
    localDisposableStore.add(quickPick.onDidChangeValue(async () => {
        quickPick.items = _getPicksAndActiveItem(quickPick.value, selectAndStartID, debugService, viewsService, commandService).picks;
    }));
    localDisposableStore.add(quickPick.onDidAccept(() => {
        const selectedItem = quickPick.selectedItems[0];
        selectedItem.accept();
        quickPick.hide();
        localDisposableStore.dispose();
    }));
    quickPick.show();
}
function _getPicksAndActiveItem(filter, selectAndStartID, debugService, viewsService, commandService) {
    const debugConsolePicks = [];
    const headerSessions = [];
    const currSession = debugService.getViewModel().focusedSession;
    const sessions = debugService.getModel().getSessions(false);
    const activeItems = [];
    sessions.forEach((session) => {
        if (session.compact && session.parentSession) {
            headerSessions.push(session.parentSession);
        }
    });
    sessions.forEach((session) => {
        const isHeader = headerSessions.includes(session);
        if (!session.parentSession) {
            debugConsolePicks.push({ type: 'separator', label: isHeader ? session.name : undefined });
        }
        if (!isHeader) {
            const pick = _createPick(session, filter, debugService, viewsService);
            if (pick) {
                debugConsolePicks.push(pick);
                if (session.getId() === currSession?.getId()) {
                    activeItems.push(pick);
                }
            }
        }
    });
    if (debugConsolePicks.length) {
        debugConsolePicks.push({ type: 'separator' });
    }
    const createDebugSessionLabel = ( (localize('workbench.action.debug.startDebug', 'Start a New Debug Session')));
    debugConsolePicks.push({
        label: `$(plus) ${createDebugSessionLabel}`,
        ariaLabel: createDebugSessionLabel,
        accept: () => commandService.executeCommand(selectAndStartID)
    });
    return { picks: debugConsolePicks, activeItems };
}
function _getSessionInfo(session) {
    const label = (!session.configuration.name.length) ? session.name : session.configuration.name;
    const parentName = session.compact ? undefined : session.parentSession?.configuration.name;
    let description = '';
    let ariaLabel = '';
    if (parentName) {
        ariaLabel = ( (localize(
            'workbench.action.debug.spawnFrom',
            'Session {0} spawned from {1}',
            label,
            parentName
        )));
        description = parentName;
    }
    return { label, description, ariaLabel };
}
function _createPick(session, filter, debugService, viewsService, commandService) {
    const pickInfo = _getSessionInfo(session);
    const highlights = matchesFuzzy(filter, pickInfo.label, true);
    if (highlights) {
        return {
            label: pickInfo.label,
            description: pickInfo.description,
            ariaLabel: pickInfo.ariaLabel,
            highlights: { label: highlights },
            accept: () => {
                debugService.focusStackFrame(undefined, undefined, session, { explicit: true });
                if (!viewsService.isViewVisible(REPL_VIEW_ID)) {
                    viewsService.openView(REPL_VIEW_ID, true);
                }
            }
        };
    }
    return undefined;
}
const VIEWLET_ID = 'workbench.view.explorer';
const ExplorerViewletVisibleContext = ( (new RawContextKey(
    'explorerViewletVisible',
    true,
    { type: 'boolean', description: ( (localize('explorerViewletVisible', "True when the EXPLORER viewlet is visible."))) }
)));
const FilesExplorerFocusedContext = ( (new RawContextKey(
    'filesExplorerFocus',
    true,
    { type: 'boolean', description: ( (localize('filesExplorerFocus', "True when the focus is inside the EXPLORER view."))) }
)));
const ExplorerFocusedContext = ( (new RawContextKey(
    'explorerViewletFocus',
    true,
    { type: 'boolean', description: ( (localize(
        'explorerViewletFocus',
        "True when the focus is inside the EXPLORER viewlet."
    ))) }
)));
( (ContextKeyExpr.and(
    ExplorerViewletVisibleContext,
    FilesExplorerFocusedContext,
    ContextKeyExpr.not(InputFocusedContextKey)
)));
( (ContextKeyExpr.and(
    ExplorerViewletVisibleContext,
    ExplorerFocusedContext,
    ContextKeyExpr.not(InputFocusedContextKey)
)));
const ADD_CONFIGURATION_ID = 'debug.addConfiguration';
const TOGGLE_INLINE_BREAKPOINT_ID = 'editor.debug.action.toggleInlineBreakpoint';
const COPY_STACK_TRACE_ID = 'debug.copyStackTrace';
const REVERSE_CONTINUE_ID = 'workbench.action.debug.reverseContinue';
const STEP_BACK_ID = 'workbench.action.debug.stepBack';
const RESTART_SESSION_ID = 'workbench.action.debug.restart';
const TERMINATE_THREAD_ID = 'workbench.action.debug.terminateThread';
const STEP_OVER_ID = 'workbench.action.debug.stepOver';
const STEP_INTO_ID = 'workbench.action.debug.stepInto';
const STEP_INTO_TARGET_ID = 'workbench.action.debug.stepIntoTarget';
const STEP_OUT_ID = 'workbench.action.debug.stepOut';
const PAUSE_ID = 'workbench.action.debug.pause';
const DISCONNECT_ID = 'workbench.action.debug.disconnect';
const DISCONNECT_AND_SUSPEND_ID = 'workbench.action.debug.disconnectAndSuspend';
const STOP_ID = 'workbench.action.debug.stop';
const RESTART_FRAME_ID = 'workbench.action.debug.restartFrame';
const CONTINUE_ID = 'workbench.action.debug.continue';
const FOCUS_REPL_ID = 'workbench.debug.action.focusRepl';
const JUMP_TO_CURSOR_ID = 'debug.jumpToCursor';
const FOCUS_SESSION_ID = 'workbench.action.debug.focusProcess';
const SELECT_AND_START_ID = 'workbench.action.debug.selectandstart';
const SELECT_DEBUG_CONSOLE_ID = 'workbench.action.debug.selectDebugConsole';
const SELECT_DEBUG_SESSION_ID = 'workbench.action.debug.selectDebugSession';
const DEBUG_CONFIGURE_COMMAND_ID = 'workbench.action.debug.configure';
const DEBUG_START_COMMAND_ID = 'workbench.action.debug.start';
const DEBUG_RUN_COMMAND_ID = 'workbench.action.debug.run';
const EDIT_EXPRESSION_COMMAND_ID = 'debug.renameWatchExpression';
const SET_EXPRESSION_COMMAND_ID = 'debug.setWatchExpression';
const REMOVE_EXPRESSION_COMMAND_ID = 'debug.removeWatchExpression';
const SHOW_LOADED_SCRIPTS_ID = 'workbench.action.debug.showLoadedScripts';
const CALLSTACK_TOP_ID = 'workbench.action.debug.callStackTop';
const CALLSTACK_BOTTOM_ID = 'workbench.action.debug.callStackBottom';
const CALLSTACK_UP_ID = 'workbench.action.debug.callStackUp';
const CALLSTACK_DOWN_ID = 'workbench.action.debug.callStackDown';
const DEBUG_COMMAND_CATEGORY = { original: 'Debug', value: ( (localize('debug', 'Debug'))) };
const RESTART_LABEL = { value: ( (localize('restartDebug', "Restart"))), original: 'Restart' };
const STEP_OVER_LABEL = { value: ( (localize('stepOverDebug', "Step Over"))), original: 'Step Over' };
const STEP_INTO_LABEL = { value: ( (localize('stepIntoDebug', "Step Into"))), original: 'Step Into' };
const STEP_OUT_LABEL = { value: ( (localize('stepOutDebug', "Step Out"))), original: 'Step Out' };
const PAUSE_LABEL = { value: ( (localize('pauseDebug', "Pause"))), original: 'Pause' };
const DISCONNECT_LABEL = { value: ( (localize('disconnect', "Disconnect"))), original: 'Disconnect' };
const DISCONNECT_AND_SUSPEND_LABEL = { value: ( (localize('disconnectSuspend', "Disconnect and Suspend"))), original: 'Disconnect and Suspend' };
const STOP_LABEL = { value: ( (localize('stop', "Stop"))), original: 'Stop' };
const CONTINUE_LABEL = { value: ( (localize('continueDebug', "Continue"))), original: 'Continue' };
const FOCUS_SESSION_LABEL = { value: ( (localize('focusSession', "Focus Session"))), original: 'Focus Session' };
const DEBUG_CONFIGURE_LABEL = ( (localize('openLaunchJson', "Open '{0}'", 'launch.json')));
const DEBUG_QUICK_ACCESS_PREFIX = 'debug ';
const DEBUG_CONSOLE_QUICK_ACCESS_PREFIX = 'debug consoles ';
function isThreadContext(obj) {
    return obj && typeof obj.sessionId === 'string' && typeof obj.threadId === 'string';
}
async function getThreadAndRun(accessor, sessionAndThreadId, run) {
    const debugService = accessor.get(IDebugService);
    let thread;
    if (isThreadContext(sessionAndThreadId)) {
        const session = debugService.getModel().getSession(sessionAndThreadId.sessionId);
        if (session) {
            thread = session.getAllThreads().find(t => t.getId() === sessionAndThreadId.threadId);
        }
    }
    else if (isSessionContext(sessionAndThreadId)) {
        const session = debugService.getModel().getSession(sessionAndThreadId.sessionId);
        if (session) {
            const threads = session.getAllThreads();
            thread = threads.length > 0 ? threads[0] : undefined;
        }
    }
    if (!thread) {
        thread = debugService.getViewModel().focusedThread;
        if (!thread) {
            const focusedSession = debugService.getViewModel().focusedSession;
            const threads = focusedSession ? focusedSession.getAllThreads() : undefined;
            thread = threads && threads.length ? threads[0] : undefined;
        }
    }
    if (thread) {
        await run(thread);
    }
}
function isStackFrameContext(obj) {
    return obj && typeof obj.sessionId === 'string' && typeof obj.threadId === 'string' && typeof obj.frameId === 'string';
}
function getFrame(debugService, context) {
    if (isStackFrameContext(context)) {
        const session = debugService.getModel().getSession(context.sessionId);
        if (session) {
            const thread = session.getAllThreads().find(t => t.getId() === context.threadId);
            if (thread) {
                return thread.getCallStack().find(sf => sf.getId() === context.frameId);
            }
        }
    }
    else {
        return debugService.getViewModel().focusedStackFrame;
    }
    return undefined;
}
function isSessionContext(obj) {
    return obj && typeof obj.sessionId === 'string';
}
async function navigateCallStack(debugService, down) {
    const frame = debugService.getViewModel().focusedStackFrame;
    if (frame) {
        let callStack = frame.thread.getCallStack();
        let index = callStack.findIndex(elem => elem.frameId === frame.frameId);
        let nextVisibleFrame;
        if (down) {
            if (index >= callStack.length - 1) {
                if (frame.thread.reachedEndOfCallStack) {
                    goToTopOfCallStack(debugService);
                    return;
                }
                else {
                    await debugService.getModel().fetchCallstack(frame.thread, 20);
                    callStack = frame.thread.getCallStack();
                    index = callStack.findIndex(elem => elem.frameId === frame.frameId);
                }
            }
            nextVisibleFrame = findNextVisibleFrame(true, callStack, index);
        }
        else {
            if (index <= 0) {
                goToBottomOfCallStack(debugService);
                return;
            }
            nextVisibleFrame = findNextVisibleFrame(false, callStack, index);
        }
        if (nextVisibleFrame) {
            debugService.focusStackFrame(nextVisibleFrame);
        }
    }
}
async function goToBottomOfCallStack(debugService) {
    const thread = debugService.getViewModel().focusedThread;
    if (thread) {
        await debugService.getModel().fetchCallstack(thread);
        const callStack = thread.getCallStack();
        if (callStack.length > 0) {
            const nextVisibleFrame = findNextVisibleFrame(false, callStack, 0);
            if (nextVisibleFrame) {
                debugService.focusStackFrame(nextVisibleFrame);
            }
        }
    }
}
function goToTopOfCallStack(debugService) {
    const thread = debugService.getViewModel().focusedThread;
    if (thread) {
        debugService.focusStackFrame(thread.getTopStackFrame());
    }
}
function findNextVisibleFrame(down, callStack, startIndex) {
    if (startIndex >= callStack.length) {
        startIndex = callStack.length - 1;
    }
    else if (startIndex < 0) {
        startIndex = 0;
    }
    let index = startIndex;
    let currFrame;
    do {
        if (down) {
            if (index === callStack.length - 1) {
                index = 0;
            }
            else {
                index++;
            }
        }
        else {
            if (index === 0) {
                index = callStack.length - 1;
            }
            else {
                index--;
            }
        }
        currFrame = callStack[index];
        if (!(currFrame.source.presentationHint === 'deemphasize' || currFrame.presentationHint === 'deemphasize')) {
            return currFrame;
        }
    } while (index !== startIndex);
    return undefined;
}
CommandsRegistry.registerCommand({
    id: COPY_STACK_TRACE_ID,
    handler: async (accessor, _, context) => {
        const textResourcePropertiesService = accessor.get(ITextResourcePropertiesService);
        const clipboardService = accessor.get(IClipboardService);
        const debugService = accessor.get(IDebugService);
        const frame = getFrame(debugService, context);
        if (frame) {
            const eol = textResourcePropertiesService.getEOL(frame.source.uri);
            await clipboardService.writeText(( (frame.thread.getCallStack().map(sf => ( (sf.toString()))))).join(eol));
        }
    }
});
CommandsRegistry.registerCommand({
    id: REVERSE_CONTINUE_ID,
    handler: async (accessor, _, context) => {
        await getThreadAndRun(accessor, context, thread => thread.reverseContinue());
    }
});
CommandsRegistry.registerCommand({
    id: STEP_BACK_ID,
    handler: async (accessor, _, context) => {
        const contextKeyService = accessor.get(IContextKeyService);
        if (CONTEXT_DISASSEMBLY_VIEW_FOCUS.getValue(contextKeyService)) {
            await getThreadAndRun(accessor, context, (thread) => thread.stepBack('instruction'));
        }
        else {
            await getThreadAndRun(accessor, context, (thread) => thread.stepBack());
        }
    }
});
CommandsRegistry.registerCommand({
    id: TERMINATE_THREAD_ID,
    handler: async (accessor, _, context) => {
        await getThreadAndRun(accessor, context, thread => thread.terminate());
    }
});
CommandsRegistry.registerCommand({
    id: JUMP_TO_CURSOR_ID,
    handler: async (accessor) => {
        const debugService = accessor.get(IDebugService);
        const stackFrame = debugService.getViewModel().focusedStackFrame;
        const editorService = accessor.get(IEditorService);
        const activeEditorControl = editorService.activeTextEditorControl;
        const notificationService = accessor.get(INotificationService);
        const quickInputService = accessor.get(IQuickInputService);
        if (stackFrame && isCodeEditor(activeEditorControl) && activeEditorControl.hasModel()) {
            const position = activeEditorControl.getPosition();
            const resource = activeEditorControl.getModel().uri;
            const source = stackFrame.thread.session.getSourceForUri(resource);
            if (source) {
                const response = await stackFrame.thread.session.gotoTargets(source.raw, position.lineNumber, position.column);
                const targets = response?.body.targets;
                if (targets && targets.length) {
                    let id = targets[0].id;
                    if (targets.length > 1) {
                        const picks = ( (targets.map(t => ({ label: t.label, _id: t.id }))));
                        const pick = await quickInputService.pick(picks, { placeHolder: ( (localize('chooseLocation', "Choose the specific location"))) });
                        if (!pick) {
                            return;
                        }
                        id = pick._id;
                    }
                    return await stackFrame.thread.session.goto(stackFrame.thread.threadId, id).catch(e => notificationService.warn(e));
                }
            }
        }
        return notificationService.warn(( (localize(
            'noExecutableCode',
            "No executable code is associated at the current cursor position."
        ))));
    }
});
CommandsRegistry.registerCommand({
    id: CALLSTACK_TOP_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        goToTopOfCallStack(debugService);
    }
});
CommandsRegistry.registerCommand({
    id: CALLSTACK_BOTTOM_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        await goToBottomOfCallStack(debugService);
    }
});
CommandsRegistry.registerCommand({
    id: CALLSTACK_UP_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        navigateCallStack(debugService, false);
    }
});
CommandsRegistry.registerCommand({
    id: CALLSTACK_DOWN_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        navigateCallStack(debugService, true);
    }
});
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
    command: {
        id: JUMP_TO_CURSOR_ID,
        title: ( (localize('jumpToCursor', "Jump to Cursor"))),
        category: DEBUG_COMMAND_CATEGORY
    },
    when: ( (ContextKeyExpr.and(CONTEXT_JUMP_TO_CURSOR_SUPPORTED, EditorContextKeys.editorTextFocus))),
    group: 'debug',
    order: 3
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: RESTART_SESSION_ID,
    weight: 200 ,
    primary: 1024  | 2048  | 63 ,
    when: CONTEXT_IN_DEBUG_MODE,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        const configurationService = accessor.get(IConfigurationService);
        let session;
        if (isSessionContext(context)) {
            session = debugService.getModel().getSession(context.sessionId);
        }
        else {
            session = debugService.getViewModel().focusedSession;
        }
        if (!session) {
            const { launch, name } = debugService.getConfigurationManager().selectedConfiguration;
            await debugService.startDebugging(launch, name, { noDebug: false, startedByUser: true });
        }
        else {
            const showSubSessions = configurationService.getValue('debug').showSubSessionsInToolBar;
            while (!showSubSessions && session.lifecycleManagedByParent && session.parentSession) {
                session = session.parentSession;
            }
            session.removeReplExpressions();
            await debugService.restartSession(session);
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STEP_OVER_ID,
    weight: 200 ,
    primary: isWeb ? ((512  | 68) ) : 68 ,
    when: ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))),
    handler: async (accessor, _, context) => {
        const contextKeyService = accessor.get(IContextKeyService);
        if (CONTEXT_DISASSEMBLY_VIEW_FOCUS.getValue(contextKeyService)) {
            await getThreadAndRun(accessor, context, (thread) => thread.next('instruction'));
        }
        else {
            await getThreadAndRun(accessor, context, (thread) => thread.next());
        }
    }
});
const STEP_INTO_KEYBINDING = (isWeb && isWindows) ? ((512  | 69) ) : 69 ;
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STEP_INTO_ID,
    weight: 200  + 10,
    primary: STEP_INTO_KEYBINDING,
    when: ( (CONTEXT_DEBUG_STATE.notEqualsTo('inactive'))),
    handler: async (accessor, _, context) => {
        const contextKeyService = accessor.get(IContextKeyService);
        if (CONTEXT_DISASSEMBLY_VIEW_FOCUS.getValue(contextKeyService)) {
            await getThreadAndRun(accessor, context, (thread) => thread.stepIn('instruction'));
        }
        else {
            await getThreadAndRun(accessor, context, (thread) => thread.stepIn());
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STEP_OUT_ID,
    weight: 200 ,
    primary: 1024  | 69 ,
    when: ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))),
    handler: async (accessor, _, context) => {
        const contextKeyService = accessor.get(IContextKeyService);
        if (CONTEXT_DISASSEMBLY_VIEW_FOCUS.getValue(contextKeyService)) {
            await getThreadAndRun(accessor, context, (thread) => thread.stepOut('instruction'));
        }
        else {
            await getThreadAndRun(accessor, context, (thread) => thread.stepOut());
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: PAUSE_ID,
    weight: 200  + 2,
    primary: 64 ,
    when: ( (CONTEXT_DEBUG_STATE.isEqualTo('running'))),
    handler: async (accessor, _, context) => {
        await getThreadAndRun(accessor, context, thread => thread.pause());
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STEP_INTO_TARGET_ID,
    primary: STEP_INTO_KEYBINDING | 2048 ,
    when: ( (ContextKeyExpr.and(
        CONTEXT_STEP_INTO_TARGETS_SUPPORTED,
        CONTEXT_IN_DEBUG_MODE,
         (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))
    ))),
    weight: 200 ,
    handler: async (accessor, _, context) => {
        const quickInputService = accessor.get(IQuickInputService);
        const debugService = accessor.get(IDebugService);
        const session = debugService.getViewModel().focusedSession;
        const frame = debugService.getViewModel().focusedStackFrame;
        if (!frame || !session) {
            return;
        }
        const editor = await accessor.get(IEditorService).openEditor({
            resource: frame.source.uri,
            options: { revealIfOpened: true }
        });
        let codeEditor;
        if (editor) {
            const ctrl = editor?.getControl();
            if (isCodeEditor(ctrl)) {
                codeEditor = ctrl;
            }
        }
        const qp = quickInputService.createQuickPick();
        qp.busy = true;
        qp.show();
        qp.onDidChangeActive(([item]) => {
            if (codeEditor && item && item.target.line !== undefined) {
                codeEditor.revealLineInCenterIfOutsideViewport(item.target.line);
                codeEditor.setSelection({
                    startLineNumber: item.target.line,
                    startColumn: item.target.column || 1,
                    endLineNumber: item.target.endLine || item.target.line,
                    endColumn: item.target.endColumn || item.target.column || 1,
                });
            }
        });
        qp.onDidAccept(() => {
            if (qp.activeItems.length) {
                session.stepIn(frame.thread.threadId, qp.activeItems[0].target.id);
            }
        });
        qp.onDidHide(() => qp.dispose());
        session.stepInTargets(frame.frameId).then(targets => {
            qp.busy = false;
            if (targets?.length) {
                qp.items = targets?.map(target => ({ target, label: target.label }));
            }
            else {
                qp.placeholder = ( (localize('editor.debug.action.stepIntoTargets.none', "No step targets available")));
            }
        });
    }
});
async function stopHandler(accessor, _, context, disconnect, suspend) {
    const debugService = accessor.get(IDebugService);
    let session;
    if (isSessionContext(context)) {
        session = debugService.getModel().getSession(context.sessionId);
    }
    else {
        session = debugService.getViewModel().focusedSession;
    }
    const configurationService = accessor.get(IConfigurationService);
    const showSubSessions = configurationService.getValue('debug').showSubSessionsInToolBar;
    while (!showSubSessions && session && session.lifecycleManagedByParent && session.parentSession) {
        session = session.parentSession;
    }
    await debugService.stopSession(session, disconnect, suspend);
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: DISCONNECT_ID,
    weight: 200 ,
    primary: 1024  | 63 ,
    when: ( (ContextKeyExpr.and(CONTEXT_FOCUSED_SESSION_IS_ATTACH, CONTEXT_IN_DEBUG_MODE))),
    handler: (accessor, _, context) => stopHandler(accessor, _, context, true)
});
CommandsRegistry.registerCommand({
    id: DISCONNECT_AND_SUSPEND_ID,
    handler: (accessor, _, context) => stopHandler(accessor, _, context, true, true)
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: STOP_ID,
    weight: 200 ,
    primary: 1024  | 63 ,
    when: ( (ContextKeyExpr.and(
         (CONTEXT_FOCUSED_SESSION_IS_ATTACH.toNegated()),
        CONTEXT_IN_DEBUG_MODE
    ))),
    handler: (accessor, _, context) => stopHandler(accessor, _, context, false)
});
CommandsRegistry.registerCommand({
    id: RESTART_FRAME_ID,
    handler: async (accessor, _, context) => {
        const debugService = accessor.get(IDebugService);
        const notificationService = accessor.get(INotificationService);
        const frame = getFrame(debugService, context);
        if (frame) {
            try {
                await frame.restart();
            }
            catch (e) {
                notificationService.error(e);
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: CONTINUE_ID,
    weight: 200  + 10,
    primary: 63 ,
    when: ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))),
    handler: async (accessor, _, context) => {
        await getThreadAndRun(accessor, context, thread => thread.continue());
    }
});
CommandsRegistry.registerCommand({
    id: SHOW_LOADED_SCRIPTS_ID,
    handler: async (accessor) => {
        await showLoadedScriptMenu(accessor);
    }
});
CommandsRegistry.registerCommand({
    id: FOCUS_REPL_ID,
    handler: async (accessor) => {
        const viewsService = accessor.get(IViewsService);
        await viewsService.openView(REPL_VIEW_ID, true);
    }
});
CommandsRegistry.registerCommand({
    id: 'debug.startFromConfig',
    handler: async (accessor, config) => {
        const debugService = accessor.get(IDebugService);
        await debugService.startDebugging(undefined, config);
    }
});
CommandsRegistry.registerCommand({
    id: FOCUS_SESSION_ID,
    handler: async (accessor, session) => {
        const debugService = accessor.get(IDebugService);
        const editorService = accessor.get(IEditorService);
        const stoppedChildSession = debugService.getModel().getSessions().find(s => s.parentSession === session && s.state === 2 );
        if (stoppedChildSession && session.state !== 2 ) {
            session = stoppedChildSession;
        }
        await debugService.focusStackFrame(undefined, undefined, session, { explicit: true });
        const stackFrame = debugService.getViewModel().focusedStackFrame;
        if (stackFrame) {
            await stackFrame.openInEditor(editorService, true);
        }
    }
});
CommandsRegistry.registerCommand({
    id: SELECT_AND_START_ID,
    handler: async (accessor) => {
        const quickInputService = accessor.get(IQuickInputService);
        quickInputService.quickAccess.show(DEBUG_QUICK_ACCESS_PREFIX);
    }
});
CommandsRegistry.registerCommand({
    id: SELECT_DEBUG_CONSOLE_ID,
    handler: async (accessor) => {
        const quickInputService = accessor.get(IQuickInputService);
        quickInputService.quickAccess.show(DEBUG_CONSOLE_QUICK_ACCESS_PREFIX);
    }
});
CommandsRegistry.registerCommand({
    id: SELECT_DEBUG_SESSION_ID,
    handler: async (accessor) => {
        showDebugSessionMenu(accessor, SELECT_AND_START_ID);
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'debug.toggleBreakpoint',
    weight: 200  + 5,
    when: ( (ContextKeyExpr.and(
        CONTEXT_BREAKPOINTS_FOCUSED,
         (InputFocusedContext.toNegated())
    ))),
    primary: 10 ,
    handler: (accessor) => {
        const listService = accessor.get(IListService);
        const debugService = accessor.get(IDebugService);
        const list = listService.lastFocusedList;
        if (list instanceof List) {
            const focused = list.getFocusedElements();
            if (focused && focused.length) {
                debugService.enableOrDisableBreakpoints(!focused[0].enabled, focused[0]);
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'debug.enableOrDisableBreakpoint',
    weight: 200 ,
    primary: undefined,
    when: EditorContextKeys.editorTextFocus,
    handler: (accessor) => {
        const debugService = accessor.get(IDebugService);
        const editorService = accessor.get(IEditorService);
        const control = editorService.activeTextEditorControl;
        if (isCodeEditor(control)) {
            const model = control.getModel();
            if (model) {
                const position = control.getPosition();
                if (position) {
                    const bps = debugService.getModel().getBreakpoints({ uri: model.uri, lineNumber: position.lineNumber });
                    if (bps.length) {
                        debugService.enableOrDisableBreakpoints(!bps[0].enabled, bps[0]);
                    }
                }
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: EDIT_EXPRESSION_COMMAND_ID,
    weight: 200  + 5,
    when: CONTEXT_WATCH_EXPRESSIONS_FOCUSED,
    primary: 60 ,
    mac: { primary: 3  },
    handler: (accessor, expression) => {
        const debugService = accessor.get(IDebugService);
        if (!(expression instanceof Expression)) {
            const listService = accessor.get(IListService);
            const focused = listService.lastFocusedList;
            if (focused) {
                const elements = focused.getFocus();
                if (Array.isArray(elements) && elements[0] instanceof Expression) {
                    expression = elements[0];
                }
            }
        }
        if (expression instanceof Expression) {
            debugService.getViewModel().setSelectedExpression(expression, false);
        }
    }
});
CommandsRegistry.registerCommand({
    id: SET_EXPRESSION_COMMAND_ID,
    handler: async (accessor, expression) => {
        const debugService = accessor.get(IDebugService);
        if (expression instanceof Expression || expression instanceof Variable) {
            debugService.getViewModel().setSelectedExpression(expression, true);
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'debug.setVariable',
    weight: 200  + 5,
    when: CONTEXT_VARIABLES_FOCUSED,
    primary: 60 ,
    mac: { primary: 3  },
    handler: (accessor) => {
        const listService = accessor.get(IListService);
        const debugService = accessor.get(IDebugService);
        const focused = listService.lastFocusedList;
        if (focused) {
            const elements = focused.getFocus();
            if (Array.isArray(elements) && elements[0] instanceof Variable) {
                debugService.getViewModel().setSelectedExpression(elements[0], false);
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: REMOVE_EXPRESSION_COMMAND_ID,
    weight: 200 ,
    when: ( (ContextKeyExpr.and(
        CONTEXT_WATCH_EXPRESSIONS_FOCUSED,
         (CONTEXT_EXPRESSION_SELECTED.toNegated())
    ))),
    primary: 20 ,
    mac: { primary: 2048  | 1  },
    handler: (accessor, expression) => {
        const debugService = accessor.get(IDebugService);
        if (expression instanceof Expression) {
            debugService.removeWatchExpressions(expression.getId());
            return;
        }
        const listService = accessor.get(IListService);
        const focused = listService.lastFocusedList;
        if (focused) {
            let elements = focused.getFocus();
            if (Array.isArray(elements) && elements[0] instanceof Expression) {
                const selection = focused.getSelection();
                if (selection && selection.indexOf(elements[0]) >= 0) {
                    elements = selection;
                }
                elements.forEach((e) => debugService.removeWatchExpressions(e.getId()));
            }
        }
    }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
    id: 'debug.removeBreakpoint',
    weight: 200 ,
    when: ( (ContextKeyExpr.and(
        CONTEXT_BREAKPOINTS_FOCUSED,
         (CONTEXT_BREAKPOINT_INPUT_FOCUSED.toNegated())
    ))),
    primary: 20 ,
    mac: { primary: 2048  | 1  },
    handler: (accessor) => {
        const listService = accessor.get(IListService);
        const debugService = accessor.get(IDebugService);
        const list = listService.lastFocusedList;
        if (list instanceof List) {
            const focused = list.getFocusedElements();
            const element = focused.length ? focused[0] : undefined;
            if (element instanceof Breakpoint) {
                debugService.removeBreakpoints(element.getId());
            }
            else if (element instanceof FunctionBreakpoint) {
                debugService.removeFunctionBreakpoints(element.getId());
            }
            else if (element instanceof DataBreakpoint) {
                debugService.removeDataBreakpoints(element.getId());
            }
        }
    }
});
const inlineBreakpointHandler = (accessor) => {
    const debugService = accessor.get(IDebugService);
    const editorService = accessor.get(IEditorService);
    const control = editorService.activeTextEditorControl;
    if (isCodeEditor(control)) {
        const position = control.getPosition();
        if (position && control.hasModel() && debugService.canSetBreakpointsIn(control.getModel())) {
            const modelUri = control.getModel().uri;
            const breakpointAlreadySet = debugService.getModel().getBreakpoints({ lineNumber: position.lineNumber, uri: modelUri })
                .some(bp => (bp.sessionAgnosticData.column === position.column || (!bp.column && position.column <= 1)));
            if (!breakpointAlreadySet) {
                debugService.addBreakpoints(modelUri, [{ lineNumber: position.lineNumber, column: position.column > 1 ? position.column : undefined }]);
            }
        }
    }
};
KeybindingsRegistry.registerCommandAndKeybindingRule({
    weight: 200 ,
    primary: 1024  | 67 ,
    when: EditorContextKeys.editorTextFocus,
    id: TOGGLE_INLINE_BREAKPOINT_ID,
    handler: inlineBreakpointHandler
});
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
    command: {
        id: TOGGLE_INLINE_BREAKPOINT_ID,
        title: ( (localize('addInlineBreakpoint', "Add Inline Breakpoint"))),
        category: DEBUG_COMMAND_CATEGORY
    },
    when: ( (ContextKeyExpr.and(
        CONTEXT_IN_DEBUG_MODE,
         (PanelFocusContext.toNegated()),
        EditorContextKeys.editorTextFocus
    ))),
    group: 'debug',
    order: 1
});
const jsonRegistry = ( (Registry.as(Extensions$1.JSONContribution)));
jsonRegistry.registerSchema(launchSchemaId, launchSchema);
const DEBUG_SELECTED_CONFIG_NAME_KEY = 'debug.selectedconfigname';
const DEBUG_SELECTED_ROOT = 'debug.selectedroot';
const DEBUG_SELECTED_TYPE = 'debug.selectedtype';
const DEBUG_RECENT_DYNAMIC_CONFIGURATIONS = 'debug.recentdynamicconfigurations';
let ConfigurationManager = class ConfigurationManager {
    constructor(adapterManager, contextService, configurationService, quickInputService, instantiationService, storageService, extensionService, historyService, uriIdentityService, contextKeyService) {
        this.adapterManager = adapterManager;
        this.contextService = contextService;
        this.configurationService = configurationService;
        this.quickInputService = quickInputService;
        this.instantiationService = instantiationService;
        this.storageService = storageService;
        this.extensionService = extensionService;
        this.historyService = historyService;
        this.uriIdentityService = uriIdentityService;
        this.getSelectedConfig = () => Promise.resolve(undefined);
        this.selectedDynamic = false;
        this._onDidSelectConfigurationName = ( (new Emitter()));
        this.configProviders = [];
        this.toDispose = [];
        this.initLaunches();
        this.registerListeners();
        const previousSelectedRoot = this.storageService.get(DEBUG_SELECTED_ROOT, 1 );
        const previousSelectedType = this.storageService.get(DEBUG_SELECTED_TYPE, 1 );
        const previousSelectedLaunch = this.launches.find(l => ( (l.uri.toString())) === previousSelectedRoot);
        const previousSelectedName = this.storageService.get(DEBUG_SELECTED_CONFIG_NAME_KEY, 1 );
        this.debugConfigurationTypeContext = CONTEXT_DEBUG_CONFIGURATION_TYPE.bindTo(contextKeyService);
        const dynamicConfig = previousSelectedType ? { type: previousSelectedType } : undefined;
        if (previousSelectedLaunch && previousSelectedLaunch.getConfigurationNames().length) {
            this.selectConfiguration(previousSelectedLaunch, previousSelectedName, undefined, dynamicConfig);
        }
        else if (this.launches.length > 0) {
            this.selectConfiguration(undefined, previousSelectedName, undefined, dynamicConfig);
        }
    }
    registerDebugConfigurationProvider(debugConfigurationProvider) {
        this.configProviders.push(debugConfigurationProvider);
        return {
            dispose: () => {
                this.unregisterDebugConfigurationProvider(debugConfigurationProvider);
            }
        };
    }
    unregisterDebugConfigurationProvider(debugConfigurationProvider) {
        const ix = this.configProviders.indexOf(debugConfigurationProvider);
        if (ix >= 0) {
            this.configProviders.splice(ix, 1);
        }
    }
    hasDebugConfigurationProvider(debugType, triggerKind) {
        if (triggerKind === undefined) {
            triggerKind = DebugConfigurationProviderTriggerKind.Initial;
        }
        const provider = this.configProviders.find(p => p.provideDebugConfigurations && (p.type === debugType) && (p.triggerKind === triggerKind));
        return !!provider;
    }
    async resolveConfigurationByProviders(folderUri, type, config, token) {
        const resolveDebugConfigurationForType = async (type, config) => {
            if (type !== '*') {
                await this.adapterManager.activateDebuggers('onDebugResolve', type);
            }
            for (const p of this.configProviders) {
                if (p.type === type && p.resolveDebugConfiguration && config) {
                    config = await p.resolveDebugConfiguration(folderUri, config, token);
                }
            }
            return config;
        };
        let resolvedType = config.type ?? type;
        let result = config;
        for (let seen = ( (new Set())); result && !seen.has(resolvedType);) {
            seen.add(resolvedType);
            result = await resolveDebugConfigurationForType(resolvedType, result);
            result = await resolveDebugConfigurationForType('*', result);
            resolvedType = result?.type ?? type;
        }
        return result;
    }
    async resolveDebugConfigurationWithSubstitutedVariables(folderUri, type, config, token) {
        const providers = this.configProviders.filter(p => p.type === type && p.resolveDebugConfigurationWithSubstitutedVariables)
            .concat(this.configProviders.filter(p => p.type === '*' && p.resolveDebugConfigurationWithSubstitutedVariables));
        let result = config;
        await sequence(( (providers.map(provider => async () => {
            if (result) {
                result = await provider.resolveDebugConfigurationWithSubstitutedVariables(folderUri, result, token);
            }
        }))));
        return result;
    }
    async provideDebugConfigurations(folderUri, type, token) {
        await this.adapterManager.activateDebuggers('onDebugInitialConfigurations');
        const results = await Promise.all(( (this.configProviders.filter(p => p.type === type && p.triggerKind === DebugConfigurationProviderTriggerKind.Initial && p.provideDebugConfigurations).map(p => p.provideDebugConfigurations(folderUri, token)))));
        return results.reduce((first, second) => first.concat(second), []);
    }
    async getDynamicProviders() {
        await this.extensionService.whenInstalledExtensionsRegistered();
        const onDebugDynamicConfigurationsName = 'onDebugDynamicConfigurations';
        const debugDynamicExtensionsTypes = this.extensionService.extensions.reduce((acc, e) => {
            if (!e.activationEvents) {
                return acc;
            }
            const explicitTypes = [];
            let hasGenericEvent = false;
            for (const event of e.activationEvents) {
                if (event === onDebugDynamicConfigurationsName) {
                    hasGenericEvent = true;
                }
                else if (event.startsWith(`${onDebugDynamicConfigurationsName}:`)) {
                    explicitTypes.push(event.slice(onDebugDynamicConfigurationsName.length + 1));
                }
            }
            if (explicitTypes.length) {
                return acc.concat(explicitTypes);
            }
            if (hasGenericEvent) {
                const debuggerType = e.contributes?.debuggers?.[0].type;
                return debuggerType ? acc.concat(debuggerType) : acc;
            }
            return acc;
        }, []);
        return (
             (debugDynamicExtensionsTypes.map(type => {
                return {
                    label: this.adapterManager.getDebuggerLabel(type),
                    getProvider: async () => {
                        await this.adapterManager.activateDebuggers(onDebugDynamicConfigurationsName, type);
                        return this.configProviders.find(p => p.type === type && p.triggerKind === DebugConfigurationProviderTriggerKind.Dynamic && p.provideDebugConfigurations);
                    },
                    type,
                    pick: async () => {
                        await this.adapterManager.activateDebuggers(onDebugDynamicConfigurationsName, type);
                        const disposables = ( (new DisposableStore()));
                        const input = disposables.add(this.quickInputService.createQuickPick());
                        input.busy = true;
                        input.placeholder = ( (localize('selectConfiguration', "Select Launch Configuration")));
                        input.show();
                        const chosenPromise = ( (new Promise(resolve => {
                            disposables.add(input.onDidAccept(() => resolve(input.activeItems[0])));
                            disposables.add(input.onDidTriggerItemButton(async (context) => {
                                resolve(undefined);
                                const { launch, config } = context.item;
                                await launch.openConfigFile({ preserveFocus: false, type: config.type, suppressInitialConfigs: true });
                                await launch.writeConfiguration(config);
                                await this.selectConfiguration(launch, config.name);
                                this.removeRecentDynamicConfigurations(config.name, config.type);
                            }));
                        })));
                        const token = ( (new CancellationTokenSource()));
                        const picks = [];
                        const provider = this.configProviders.find(p => p.type === type && p.triggerKind === DebugConfigurationProviderTriggerKind.Dynamic && p.provideDebugConfigurations);
                        this.getLaunches().forEach(launch => {
                            if (launch.workspace && provider) {
                                picks.push(provider.provideDebugConfigurations(launch.workspace.uri, token.token).then(configurations => ( (configurations.map(config => ({
                                    label: config.name,
                                    description: launch.name,
                                    config,
                                    buttons: [{
                                            iconClass: ThemeIcon.asClassName(debugConfigure),
                                            tooltip: ( (localize('editLaunchConfig', "Edit Debug Configuration in launch.json")))
                                        }],
                                    launch
                                }))))));
                            }
                        });
                        const nestedPicks = await Promise.all(picks);
                        const items = flatten(nestedPicks);
                        input.items = items;
                        input.busy = false;
                        const chosen = await chosenPromise;
                        disposables.dispose();
                        if (!chosen) {
                            token.cancel();
                            return;
                        }
                        return chosen;
                    }
                };
            }))
        );
    }
    getAllConfigurations() {
        const all = [];
        for (const l of this.launches) {
            for (const name of l.getConfigurationNames()) {
                const config = l.getConfiguration(name) || l.getCompound(name);
                if (config) {
                    all.push({ launch: l, name, presentation: config.presentation });
                }
            }
        }
        return getVisibleAndSorted(all);
    }
    removeRecentDynamicConfigurations(name, type) {
        const remaining = this.getRecentDynamicConfigurations().filter(c => c.name !== name || c.type !== type);
        this.storageService.store(DEBUG_RECENT_DYNAMIC_CONFIGURATIONS, JSON.stringify(remaining), 1 , 0 );
        if (this.selectedConfiguration.name === name && this.selectedType === type && this.selectedDynamic) {
            this.selectConfiguration(undefined, undefined);
        }
        else {
            this._onDidSelectConfigurationName.fire();
        }
    }
    getRecentDynamicConfigurations() {
        return JSON.parse(this.storageService.get(DEBUG_RECENT_DYNAMIC_CONFIGURATIONS, 1 , '[]'));
    }
    registerListeners() {
        this.toDispose.push(Event.any(this.contextService.onDidChangeWorkspaceFolders, this.contextService.onDidChangeWorkbenchState)(() => {
            this.initLaunches();
            this.selectConfiguration(undefined);
            this.setCompoundSchemaValues();
        }));
        this.toDispose.push(this.configurationService.onDidChangeConfiguration(async (e) => {
            if (e.affectsConfiguration('launch')) {
                await this.selectConfiguration(undefined);
                this.setCompoundSchemaValues();
            }
        }));
        this.toDispose.push(this.adapterManager.onDidDebuggersExtPointRead(() => {
            this.setCompoundSchemaValues();
        }));
    }
    initLaunches() {
        this.launches = ( (this.contextService.getWorkspace().folders.map(
            folder => this.instantiationService.createInstance(Launch, this, this.adapterManager, folder)
        )));
        if (this.contextService.getWorkbenchState() === 3 ) {
            this.launches.push(this.instantiationService.createInstance(WorkspaceLaunch, this, this.adapterManager));
        }
        this.launches.push(this.instantiationService.createInstance(UserLaunch, this, this.adapterManager));
        if (this.selectedLaunch && this.launches.indexOf(this.selectedLaunch) === -1) {
            this.selectConfiguration(undefined);
        }
    }
    setCompoundSchemaValues() {
        const compoundConfigurationsSchema = launchSchema.properties['compounds'].items.properties['configurations'];
        const launchNames = ( (this.launches.map(l => l.getConfigurationNames(true)))).reduce((first, second) => first.concat(second), []);
        compoundConfigurationsSchema.items.oneOf[0].enum = launchNames;
        compoundConfigurationsSchema.items.oneOf[1].properties.name.enum = launchNames;
        const folderNames = ( (this.contextService.getWorkspace().folders.map(f => f.name)));
        compoundConfigurationsSchema.items.oneOf[1].properties.folder.enum = folderNames;
        jsonRegistry.registerSchema(launchSchemaId, launchSchema);
    }
    getLaunches() {
        return this.launches;
    }
    getLaunch(workspaceUri) {
        if (!URI.isUri(workspaceUri)) {
            return undefined;
        }
        return this.launches.find(l => l.workspace && this.uriIdentityService.extUri.isEqual(l.workspace.uri, workspaceUri));
    }
    get selectedConfiguration() {
        return {
            launch: this.selectedLaunch,
            name: this.selectedName,
            getConfig: this.getSelectedConfig,
            type: this.selectedType
        };
    }
    get onDidSelectConfiguration() {
        return this._onDidSelectConfigurationName.event;
    }
    getWorkspaceLaunch() {
        if (this.contextService.getWorkbenchState() === 3 ) {
            return this.launches[this.launches.length - 1];
        }
        return undefined;
    }
    async selectConfiguration(launch, name, config, dynamicConfig) {
        if (typeof launch === 'undefined') {
            const rootUri = this.historyService.getLastActiveWorkspaceRoot();
            launch = this.getLaunch(rootUri);
            if (!launch || launch.getConfigurationNames().length === 0) {
                launch = this.launches.find(l => !!(l && l.getConfigurationNames().length)) || launch || this.launches[0];
            }
        }
        const previousLaunch = this.selectedLaunch;
        const previousName = this.selectedName;
        const previousSelectedDynamic = this.selectedDynamic;
        this.selectedLaunch = launch;
        if (this.selectedLaunch) {
            this.storageService.store(DEBUG_SELECTED_ROOT, ( (this.selectedLaunch.uri.toString())), 1 , 1 );
        }
        else {
            this.storageService.remove(DEBUG_SELECTED_ROOT, 1 );
        }
        const names = launch ? launch.getConfigurationNames() : [];
        this.getSelectedConfig = () => {
            const selected = this.selectedName ? launch?.getConfiguration(this.selectedName) : undefined;
            return Promise.resolve(selected || config);
        };
        let type = config?.type;
        if (name && names.indexOf(name) >= 0) {
            this.setSelectedLaunchName(name);
        }
        else if (dynamicConfig && dynamicConfig.type) {
            type = dynamicConfig.type;
            if (!config) {
                const providers = (await this.getDynamicProviders()).filter(p => p.type === type);
                this.getSelectedConfig = async () => {
                    const activatedProviders = await Promise.all(( (providers.map(p => p.getProvider()))));
                    const provider = activatedProviders.length > 0 ? activatedProviders[0] : undefined;
                    if (provider && launch && launch.workspace) {
                        const token = ( (new CancellationTokenSource()));
                        const dynamicConfigs = await provider.provideDebugConfigurations(launch.workspace.uri, token.token);
                        const dynamicConfig = dynamicConfigs.find(c => c.name === name);
                        if (dynamicConfig) {
                            return dynamicConfig;
                        }
                    }
                    return undefined;
                };
            }
            this.setSelectedLaunchName(name);
            let recentDynamicProviders = this.getRecentDynamicConfigurations();
            if (name && dynamicConfig.type) {
                recentDynamicProviders.unshift({ name, type: dynamicConfig.type });
                recentDynamicProviders = distinct(recentDynamicProviders, t => `${t.name} : ${t.type}`);
                this.storageService.store(DEBUG_RECENT_DYNAMIC_CONFIGURATIONS, JSON.stringify(recentDynamicProviders), 1 , 0 );
            }
        }
        else if (!this.selectedName || names.indexOf(this.selectedName) === -1) {
            const nameToSet = names.length ? names[0] : undefined;
            this.setSelectedLaunchName(nameToSet);
        }
        if (!config && launch && this.selectedName) {
            config = launch.getConfiguration(this.selectedName);
            type = config?.type;
        }
        this.selectedType = dynamicConfig?.type || config?.type;
        this.selectedDynamic = !!dynamicConfig;
        this.storageService.store(DEBUG_SELECTED_TYPE, dynamicConfig ? this.selectedType : undefined, 1 , 1 );
        if (type) {
            this.debugConfigurationTypeContext.set(type);
        }
        else {
            this.debugConfigurationTypeContext.reset();
        }
        if (this.selectedLaunch !== previousLaunch || this.selectedName !== previousName || previousSelectedDynamic !== this.selectedDynamic) {
            this._onDidSelectConfigurationName.fire();
        }
    }
    setSelectedLaunchName(selectedName) {
        this.selectedName = selectedName;
        if (this.selectedName) {
            this.storageService.store(DEBUG_SELECTED_CONFIG_NAME_KEY, this.selectedName, 1 , 1 );
        }
        else {
            this.storageService.remove(DEBUG_SELECTED_CONFIG_NAME_KEY, 1 );
        }
    }
    dispose() {
        this.toDispose = dispose(this.toDispose);
    }
};
ConfigurationManager = ( (__decorate([
    ( (__param(1, IWorkspaceContextService))),
    ( (__param(2, IConfigurationService))),
    ( (__param(3, IQuickInputService))),
    ( (__param(4, IInstantiationService))),
    ( (__param(5, IStorageService))),
    ( (__param(6, IExtensionService))),
    ( (__param(7, IHistoryService))),
    ( (__param(8, IUriIdentityService))),
    ( (__param(9, IContextKeyService)))
], ConfigurationManager)));
class AbstractLaunch {
    constructor(configurationManager, adapterManager) {
        this.configurationManager = configurationManager;
        this.adapterManager = adapterManager;
    }
    getCompound(name) {
        const config = this.getConfig();
        if (!config || !config.compounds) {
            return undefined;
        }
        return config.compounds.find(compound => compound.name === name);
    }
    getConfigurationNames(ignoreCompoundsAndPresentation = false) {
        const config = this.getConfig();
        if (!config || (!Array.isArray(config.configurations) && !Array.isArray(config.compounds))) {
            return [];
        }
        else {
            const configurations = [];
            if (config.configurations) {
                configurations.push(...config.configurations.filter(cfg => cfg && typeof cfg.name === 'string'));
            }
            if (ignoreCompoundsAndPresentation) {
                return (
                     (configurations.map(c => c.name))
                );
            }
            if (config.compounds) {
                configurations.push(...config.compounds.filter(compound => typeof compound.name === 'string' && compound.configurations && compound.configurations.length));
            }
            return (
                 (getVisibleAndSorted(configurations).map(c => c.name))
            );
        }
    }
    getConfiguration(name) {
        const config = deepClone(this.getConfig());
        if (!config || !config.configurations) {
            return undefined;
        }
        const configuration = config.configurations.find(config => config && config.name === name);
        if (configuration) {
            if (this instanceof UserLaunch) {
                configuration.__configurationTarget = 2 ;
            }
            else if (this instanceof WorkspaceLaunch) {
                configuration.__configurationTarget = 5 ;
            }
            else {
                configuration.__configurationTarget = 6 ;
            }
        }
        return configuration;
    }
    async getInitialConfigurationContent(folderUri, type, useInitialConfigs, token) {
        let content = '';
        const adapter = type ? this.adapterManager.getEnabledDebugger(type) : await this.adapterManager.guessDebugger(true);
        if (adapter) {
            const initialConfigs = useInitialConfigs ?
                await this.configurationManager.provideDebugConfigurations(folderUri, adapter.type, token || CancellationToken.None) :
                [];
            content = await adapter.getInitialConfigurationContent(initialConfigs);
        }
        return content;
    }
    get hidden() {
        return false;
    }
}
let Launch = class Launch extends AbstractLaunch {
    constructor(configurationManager, adapterManager, workspace, fileService, textFileService, editorService, configurationService) {
        super(configurationManager, adapterManager);
        this.workspace = workspace;
        this.fileService = fileService;
        this.textFileService = textFileService;
        this.editorService = editorService;
        this.configurationService = configurationService;
    }
    get uri() {
        return joinPath(this.workspace.uri, '/.vscode/launch.json');
    }
    get name() {
        return this.workspace.name;
    }
    getConfig() {
        return this.configurationService.inspect('launch', { resource: this.workspace.uri }).workspaceFolderValue;
    }
    async openConfigFile({ preserveFocus, type, suppressInitialConfigs }, token) {
        const resource = this.uri;
        let created = false;
        let content = '';
        try {
            const fileContent = await this.fileService.readFile(resource);
            content = ( (fileContent.value.toString()));
        }
        catch {
            content = await this.getInitialConfigurationContent(this.workspace.uri, type, !suppressInitialConfigs, token);
            if (!content) {
                return { editor: null, created: false };
            }
            created = true;
            try {
                await this.textFileService.write(resource, content);
            }
            catch (error) {
                throw new Error(localize('DebugConfig.failed', "Unable to create 'launch.json' file inside the '.vscode' folder ({0}).", error.message));
            }
        }
        const index = content.indexOf(`"${this.configurationManager.selectedConfiguration.name}"`);
        let startLineNumber = 1;
        for (let i = 0; i < index; i++) {
            if (content.charAt(i) === '\n') {
                startLineNumber++;
            }
        }
        const selection = startLineNumber > 1 ? { startLineNumber, startColumn: 4 } : undefined;
        const editor = await this.editorService.openEditor({
            resource,
            options: {
                selection,
                preserveFocus,
                pinned: created,
                revealIfVisible: true
            },
        }, ACTIVE_GROUP);
        return ({
            editor: withUndefinedAsNull(editor),
            created
        });
    }
    async writeConfiguration(configuration) {
        const fullConfig = deepClone(this.getConfig());
        if (!fullConfig.configurations) {
            fullConfig.configurations = [];
        }
        fullConfig.configurations.push(configuration);
        await this.configurationService.updateValue('launch', fullConfig, { resource: this.workspace.uri }, 6 );
    }
};
Launch = ( (__decorate([
    ( (__param(3, IFileService))),
    ( (__param(4, ITextFileService))),
    ( (__param(5, IEditorService))),
    ( (__param(6, IConfigurationService)))
], Launch)));
let WorkspaceLaunch = class WorkspaceLaunch extends AbstractLaunch {
    constructor(configurationManager, adapterManager, editorService, configurationService, contextService) {
        super(configurationManager, adapterManager);
        this.editorService = editorService;
        this.configurationService = configurationService;
        this.contextService = contextService;
    }
    get workspace() {
        return undefined;
    }
    get uri() {
        return this.contextService.getWorkspace().configuration;
    }
    get name() {
        return (
             (localize('workspace', "workspace"))
        );
    }
    getConfig() {
        return this.configurationService.inspect('launch').workspaceValue;
    }
    async openConfigFile({ preserveFocus, type, useInitialConfigs }, token) {
        const launchExistInFile = !!this.getConfig();
        if (!launchExistInFile) {
            const content = await this.getInitialConfigurationContent(undefined, type, useInitialConfigs, token);
            if (content) {
                await this.configurationService.updateValue('launch', parse(content), 5 );
            }
            else {
                return { editor: null, created: false };
            }
        }
        const editor = await this.editorService.openEditor({
            resource: this.contextService.getWorkspace().configuration,
            options: { preserveFocus }
        }, ACTIVE_GROUP);
        return ({
            editor: withUndefinedAsNull(editor),
            created: false
        });
    }
};
WorkspaceLaunch = ( (__decorate([
    ( (__param(2, IEditorService))),
    ( (__param(3, IConfigurationService))),
    ( (__param(4, IWorkspaceContextService)))
], WorkspaceLaunch)));
let UserLaunch = class UserLaunch extends AbstractLaunch {
    constructor(configurationManager, adapterManager, configurationService, preferencesService) {
        super(configurationManager, adapterManager);
        this.configurationService = configurationService;
        this.preferencesService = preferencesService;
    }
    get workspace() {
        return undefined;
    }
    get uri() {
        return this.preferencesService.userSettingsResource;
    }
    get name() {
        return (
             (localize('user settings', "user settings"))
        );
    }
    get hidden() {
        return true;
    }
    getConfig() {
        return this.configurationService.inspect('launch').userValue;
    }
    async openConfigFile({ preserveFocus, type, useInitialContent }) {
        const editor = await this.preferencesService.openUserSettings({ jsonEditor: true, preserveFocus, revealSetting: { key: 'launch' } });
        return ({
            editor: withUndefinedAsNull(editor),
            created: false
        });
    }
};
UserLaunch = ( (__decorate([
    ( (__param(2, IConfigurationService))),
    ( (__param(3, IPreferencesService)))
], UserLaunch)));
const rangeRe = /range=([0-9]+):([0-9]+)/;
class DebugMemoryFileSystemProvider {
    constructor(debugService) {
        this.debugService = debugService;
        this.memoryFdCounter = 0;
        this.fdMemory = ( (new Map()));
        this.changeEmitter = ( (new Emitter()));
        this.onDidChangeCapabilities = Event.None;
        this.onDidChangeFile = this.changeEmitter.event;
        this.capabilities = 0
            | 1024
            | 4 ;
        debugService.onDidEndSession(session => {
            for (const [fd, memory] of this.fdMemory) {
                if (memory.session === session) {
                    this.close(fd);
                }
            }
        });
    }
    watch(resource, opts) {
        if (opts.recursive) {
            return toDisposable(() => { });
        }
        const { session, memoryReference, offset } = this.parseUri(resource);
        const disposable = ( (new DisposableStore()));
        disposable.add(session.onDidChangeState(() => {
            if (session.state === 3  || session.state === 0 ) {
                this.changeEmitter.fire([{ type: 2 , resource }]);
            }
        }));
        disposable.add(session.onDidInvalidateMemory(e => {
            if (e.body.memoryReference !== memoryReference) {
                return;
            }
            if (offset && (e.body.offset >= offset.toOffset || e.body.offset + e.body.count < offset.fromOffset)) {
                return;
            }
            this.changeEmitter.fire([{ resource, type: 0  }]);
        }));
        return disposable;
    }
    stat(file) {
        const { readOnly } = this.parseUri(file);
        return Promise.resolve({
            type: FileType.File,
            mtime: 0,
            ctime: 0,
            size: 0,
            permissions: readOnly ? FilePermission.Readonly : undefined,
        });
    }
    mkdir() {
        throw createFileSystemProviderError(`Not allowed`, FileSystemProviderErrorCode.NoPermissions);
    }
    readdir() {
        throw createFileSystemProviderError(`Not allowed`, FileSystemProviderErrorCode.NoPermissions);
    }
    delete() {
        throw createFileSystemProviderError(`Not allowed`, FileSystemProviderErrorCode.NoPermissions);
    }
    rename() {
        throw createFileSystemProviderError(`Not allowed`, FileSystemProviderErrorCode.NoPermissions);
    }
    open(resource, _opts) {
        const { session, memoryReference, offset } = this.parseUri(resource);
        const fd = this.memoryFdCounter++;
        let region = session.getMemory(memoryReference);
        if (offset) {
            region = ( (new MemoryRegionView(region, offset)));
        }
        this.fdMemory.set(fd, { session, region });
        return Promise.resolve(fd);
    }
    close(fd) {
        this.fdMemory.get(fd)?.region.dispose();
        this.fdMemory.delete(fd);
        return Promise.resolve();
    }
    async writeFile(resource, content) {
        const { offset } = this.parseUri(resource);
        if (!offset) {
            throw createFileSystemProviderError(`Range must be present to read a file`, FileSystemProviderErrorCode.FileNotFound);
        }
        const fd = await this.open(resource, { create: false });
        try {
            await this.write(fd, offset.fromOffset, content, 0, content.length);
        }
        finally {
            this.close(fd);
        }
    }
    async readFile(resource) {
        const { offset } = this.parseUri(resource);
        if (!offset) {
            throw createFileSystemProviderError(`Range must be present to read a file`, FileSystemProviderErrorCode.FileNotFound);
        }
        const data = ( (new Uint8Array(offset.toOffset - offset.fromOffset)));
        const fd = await this.open(resource, { create: false });
        try {
            await this.read(fd, offset.fromOffset, data, 0, data.length);
            return data;
        }
        finally {
            this.close(fd);
        }
    }
    async read(fd, pos, data, offset, length) {
        const memory = this.fdMemory.get(fd);
        if (!memory) {
            throw createFileSystemProviderError(`No file with that descriptor open`, FileSystemProviderErrorCode.Unavailable);
        }
        const ranges = await memory.region.read(pos, length);
        let readSoFar = 0;
        for (const range of ranges) {
            switch (range.type) {
                case 1 :
                    return readSoFar;
                case 2 :
                    if (readSoFar > 0) {
                        return readSoFar;
                    }
                    else {
                        throw createFileSystemProviderError(range.error, FileSystemProviderErrorCode.Unknown);
                    }
                case 0 : {
                    const start = Math.max(0, pos - range.offset);
                    const toWrite = range.data.slice(start, Math.min(range.data.byteLength, start + (length - readSoFar)));
                    data.set(toWrite.buffer, offset + readSoFar);
                    readSoFar += toWrite.byteLength;
                    break;
                }
                default:
                    assertNever(range);
            }
        }
        return readSoFar;
    }
    write(fd, pos, data, offset, length) {
        const memory = this.fdMemory.get(fd);
        if (!memory) {
            throw createFileSystemProviderError(`No file with that descriptor open`, FileSystemProviderErrorCode.Unavailable);
        }
        return memory.region.write(pos, VSBuffer.wrap(data).slice(offset, offset + length));
    }
    parseUri(uri) {
        if (uri.scheme !== DEBUG_MEMORY_SCHEME) {
            throw createFileSystemProviderError(`Cannot open file with scheme ${uri.scheme}`, FileSystemProviderErrorCode.FileNotFound);
        }
        const session = this.debugService.getModel().getSession(uri.authority);
        if (!session) {
            throw createFileSystemProviderError(`Debug session not found`, FileSystemProviderErrorCode.FileNotFound);
        }
        let offset;
        const rangeMatch = rangeRe.exec(uri.query);
        if (rangeMatch) {
            offset = { fromOffset: Number(rangeMatch[1]), toOffset: Number(rangeMatch[2]) };
        }
        const [, memoryReference] = uri.path.split('/');
        return {
            session,
            offset,
            readOnly: !session.capabilities.supportsWriteMemoryRequest,
            sessionId: uri.authority,
            memoryReference: decodeURIComponent(memoryReference),
        };
    }
}
class MemoryRegionView extends Disposable {
    constructor(parent, range) {
        super();
        this.parent = parent;
        this.range = range;
        this.invalidateEmitter = ( (new Emitter()));
        this.onDidInvalidate = this.invalidateEmitter.event;
        this.width = this.range.toOffset - this.range.fromOffset;
        this.writable = parent.writable;
        this._register(parent);
        this._register(parent.onDidInvalidate(e => {
            const fromOffset = clamp(e.fromOffset - range.fromOffset, 0, this.width);
            const toOffset = clamp(e.toOffset - range.fromOffset, 0, this.width);
            if (toOffset > fromOffset) {
                this.invalidateEmitter.fire({ fromOffset, toOffset });
            }
        }));
    }
    read(fromOffset, toOffset) {
        if (fromOffset < 0) {
            throw new RangeError(`Invalid fromOffset: ${fromOffset}`);
        }
        return this.parent.read(this.range.fromOffset + fromOffset, this.range.fromOffset + Math.min(toOffset, this.width));
    }
    write(offset, data) {
        return this.parent.write(this.range.fromOffset + offset, data);
    }
}
let RawDebugSession = class RawDebugSession {
    constructor(debugAdapter, dbgr, sessionId, name, extensionHostDebugService, openerService, notificationService, dialogSerivce) {
        this.dbgr = dbgr;
        this.sessionId = sessionId;
        this.name = name;
        this.extensionHostDebugService = extensionHostDebugService;
        this.openerService = openerService;
        this.notificationService = notificationService;
        this.dialogSerivce = dialogSerivce;
        this.allThreadsContinued = true;
        this._readyForBreakpoints = false;
        this.debugAdapterStopped = false;
        this.inShutdown = false;
        this.terminated = false;
        this.firedAdapterExitEvent = false;
        this.startTime = 0;
        this.didReceiveStoppedEvent = false;
        this._onDidInitialize = ( (new Emitter()));
        this._onDidStop = ( (new Emitter()));
        this._onDidContinued = ( (new Emitter()));
        this._onDidTerminateDebugee = ( (new Emitter()));
        this._onDidExitDebugee = ( (new Emitter()));
        this._onDidThread = ( (new Emitter()));
        this._onDidOutput = ( (new Emitter()));
        this._onDidBreakpoint = ( (new Emitter()));
        this._onDidLoadedSource = ( (new Emitter()));
        this._onDidProgressStart = ( (new Emitter()));
        this._onDidProgressUpdate = ( (new Emitter()));
        this._onDidProgressEnd = ( (new Emitter()));
        this._onDidInvalidated = ( (new Emitter()));
        this._onDidInvalidateMemory = ( (new Emitter()));
        this._onDidCustomEvent = ( (new Emitter()));
        this._onDidEvent = ( (new Emitter()));
        this._onDidExitAdapter = ( (new Emitter()));
        this.toDispose = [];
        this.debugAdapter = debugAdapter;
        this._capabilities = Object.create(null);
        this.toDispose.push(this.debugAdapter.onError(err => {
            this.shutdown(err);
        }));
        this.toDispose.push(this.debugAdapter.onExit(code => {
            if (code !== 0) {
                this.shutdown(( (new Error(`exit code: ${code}`))));
            }
            else {
                this.shutdown();
            }
        }));
        this.debugAdapter.onEvent(event => {
            switch (event.event) {
                case 'initialized':
                    this._readyForBreakpoints = true;
                    this._onDidInitialize.fire(event);
                    break;
                case 'loadedSource':
                    this._onDidLoadedSource.fire(event);
                    break;
                case 'capabilities':
                    if (event.body) {
                        const capabilities = event.body.capabilities;
                        this.mergeCapabilities(capabilities);
                    }
                    break;
                case 'stopped':
                    this.didReceiveStoppedEvent = true;
                    this._onDidStop.fire(event);
                    break;
                case 'continued':
                    this.allThreadsContinued = event.body.allThreadsContinued === false ? false : true;
                    this._onDidContinued.fire(event);
                    break;
                case 'thread':
                    this._onDidThread.fire(event);
                    break;
                case 'output':
                    this._onDidOutput.fire(event);
                    break;
                case 'breakpoint':
                    this._onDidBreakpoint.fire(event);
                    break;
                case 'terminated':
                    this._onDidTerminateDebugee.fire(event);
                    break;
                case 'exit':
                    this._onDidExitDebugee.fire(event);
                    break;
                case 'progressStart':
                    this._onDidProgressStart.fire(event);
                    break;
                case 'progressUpdate':
                    this._onDidProgressUpdate.fire(event);
                    break;
                case 'progressEnd':
                    this._onDidProgressEnd.fire(event);
                    break;
                case 'invalidated':
                    this._onDidInvalidated.fire(event);
                    break;
                case 'memory':
                    this._onDidInvalidateMemory.fire(event);
                    break;
                case 'process':
                    break;
                case 'module':
                    break;
                default:
                    this._onDidCustomEvent.fire(event);
                    break;
            }
            this._onDidEvent.fire(event);
        });
        this.debugAdapter.onRequest(request => this.dispatchRequest(request));
    }
    get onDidExitAdapter() {
        return this._onDidExitAdapter.event;
    }
    get capabilities() {
        return this._capabilities;
    }
    get readyForBreakpoints() {
        return this._readyForBreakpoints;
    }
    get onDidInitialize() {
        return this._onDidInitialize.event;
    }
    get onDidStop() {
        return this._onDidStop.event;
    }
    get onDidContinued() {
        return this._onDidContinued.event;
    }
    get onDidTerminateDebugee() {
        return this._onDidTerminateDebugee.event;
    }
    get onDidExitDebugee() {
        return this._onDidExitDebugee.event;
    }
    get onDidThread() {
        return this._onDidThread.event;
    }
    get onDidOutput() {
        return this._onDidOutput.event;
    }
    get onDidBreakpoint() {
        return this._onDidBreakpoint.event;
    }
    get onDidLoadedSource() {
        return this._onDidLoadedSource.event;
    }
    get onDidCustomEvent() {
        return this._onDidCustomEvent.event;
    }
    get onDidProgressStart() {
        return this._onDidProgressStart.event;
    }
    get onDidProgressUpdate() {
        return this._onDidProgressUpdate.event;
    }
    get onDidProgressEnd() {
        return this._onDidProgressEnd.event;
    }
    get onDidInvalidated() {
        return this._onDidInvalidated.event;
    }
    get onDidInvalidateMemory() {
        return this._onDidInvalidateMemory.event;
    }
    get onDidEvent() {
        return this._onDidEvent.event;
    }
    async start() {
        if (!this.debugAdapter) {
            return Promise.reject(( (new Error(
                 (localize('noDebugAdapterStart', "No debug adapter, can not start debug session."))
            ))));
        }
        await this.debugAdapter.startSession();
        this.startTime = ( (new Date())).getTime();
    }
    async initialize(args) {
        const response = await this.send('initialize', args, undefined, undefined, false);
        if (response) {
            this.mergeCapabilities(response.body);
        }
        return response;
    }
    disconnect(args) {
        const terminateDebuggee = this.capabilities.supportTerminateDebuggee ? args.terminateDebuggee : undefined;
        const suspendDebuggee = this.capabilities.supportTerminateDebuggee && this.capabilities.supportSuspendDebuggee ? args.suspendDebuggee : undefined;
        return this.shutdown(undefined, args.restart, terminateDebuggee, suspendDebuggee);
    }
    async launchOrAttach(config) {
        const response = await this.send(config.request, config, undefined, undefined, false);
        if (response) {
            this.mergeCapabilities(response.body);
        }
        return response;
    }
    terminate(restart = false) {
        if (this.capabilities.supportsTerminateRequest) {
            if (!this.terminated) {
                this.terminated = true;
                return this.send('terminate', { restart }, undefined, 2000);
            }
            return this.disconnect({ terminateDebuggee: true, restart });
        }
        return Promise.reject(( (new Error('terminated not supported'))));
    }
    restart(args) {
        if (this.capabilities.supportsRestartRequest) {
            return this.send('restart', args);
        }
        return Promise.reject(( (new Error('restart not supported'))));
    }
    async next(args) {
        const response = await this.send('next', args);
        this.fireSimulatedContinuedEvent(args.threadId);
        return response;
    }
    async stepIn(args) {
        const response = await this.send('stepIn', args);
        this.fireSimulatedContinuedEvent(args.threadId);
        return response;
    }
    async stepOut(args) {
        const response = await this.send('stepOut', args);
        this.fireSimulatedContinuedEvent(args.threadId);
        return response;
    }
    async continue(args) {
        const response = await this.send('continue', args);
        if (response && response.body && response.body.allThreadsContinued !== undefined) {
            this.allThreadsContinued = response.body.allThreadsContinued;
        }
        this.fireSimulatedContinuedEvent(args.threadId, this.allThreadsContinued);
        return response;
    }
    pause(args) {
        return this.send('pause', args);
    }
    terminateThreads(args) {
        if (this.capabilities.supportsTerminateThreadsRequest) {
            return this.send('terminateThreads', args);
        }
        return Promise.reject(( (new Error('terminateThreads not supported'))));
    }
    setVariable(args) {
        if (this.capabilities.supportsSetVariable) {
            return this.send('setVariable', args);
        }
        return Promise.reject(( (new Error('setVariable not supported'))));
    }
    setExpression(args) {
        if (this.capabilities.supportsSetExpression) {
            return this.send('setExpression', args);
        }
        return Promise.reject(( (new Error('setExpression not supported'))));
    }
    async restartFrame(args, threadId) {
        if (this.capabilities.supportsRestartFrame) {
            const response = await this.send('restartFrame', args);
            this.fireSimulatedContinuedEvent(threadId);
            return response;
        }
        return Promise.reject(( (new Error('restartFrame not supported'))));
    }
    stepInTargets(args) {
        if (this.capabilities.supportsStepInTargetsRequest) {
            return this.send('stepInTargets', args);
        }
        return Promise.reject(( (new Error('stepInTargets not supported'))));
    }
    completions(args, token) {
        if (this.capabilities.supportsCompletionsRequest) {
            return this.send('completions', args, token);
        }
        return Promise.reject(( (new Error('completions not supported'))));
    }
    setBreakpoints(args) {
        return this.send('setBreakpoints', args);
    }
    setFunctionBreakpoints(args) {
        if (this.capabilities.supportsFunctionBreakpoints) {
            return this.send('setFunctionBreakpoints', args);
        }
        return Promise.reject(( (new Error('setFunctionBreakpoints not supported'))));
    }
    dataBreakpointInfo(args) {
        if (this.capabilities.supportsDataBreakpoints) {
            return this.send('dataBreakpointInfo', args);
        }
        return Promise.reject(( (new Error('dataBreakpointInfo not supported'))));
    }
    setDataBreakpoints(args) {
        if (this.capabilities.supportsDataBreakpoints) {
            return this.send('setDataBreakpoints', args);
        }
        return Promise.reject(( (new Error('setDataBreakpoints not supported'))));
    }
    setExceptionBreakpoints(args) {
        return this.send('setExceptionBreakpoints', args);
    }
    breakpointLocations(args) {
        if (this.capabilities.supportsBreakpointLocationsRequest) {
            return this.send('breakpointLocations', args);
        }
        return Promise.reject(( (new Error('breakpointLocations is not supported'))));
    }
    configurationDone() {
        if (this.capabilities.supportsConfigurationDoneRequest) {
            return this.send('configurationDone', null);
        }
        return Promise.reject(( (new Error('configurationDone not supported'))));
    }
    stackTrace(args, token) {
        return this.send('stackTrace', args, token);
    }
    exceptionInfo(args) {
        if (this.capabilities.supportsExceptionInfoRequest) {
            return this.send('exceptionInfo', args);
        }
        return Promise.reject(( (new Error('exceptionInfo not supported'))));
    }
    scopes(args, token) {
        return this.send('scopes', args, token);
    }
    variables(args, token) {
        return this.send('variables', args, token);
    }
    source(args) {
        return this.send('source', args);
    }
    loadedSources(args) {
        if (this.capabilities.supportsLoadedSourcesRequest) {
            return this.send('loadedSources', args);
        }
        return Promise.reject(( (new Error('loadedSources not supported'))));
    }
    threads() {
        return this.send('threads', null);
    }
    evaluate(args) {
        return this.send('evaluate', args);
    }
    async stepBack(args) {
        if (this.capabilities.supportsStepBack) {
            const response = await this.send('stepBack', args);
            this.fireSimulatedContinuedEvent(args.threadId);
            return response;
        }
        return Promise.reject(( (new Error('stepBack not supported'))));
    }
    async reverseContinue(args) {
        if (this.capabilities.supportsStepBack) {
            const response = await this.send('reverseContinue', args);
            this.fireSimulatedContinuedEvent(args.threadId);
            return response;
        }
        return Promise.reject(( (new Error('reverseContinue not supported'))));
    }
    gotoTargets(args) {
        if (this.capabilities.supportsGotoTargetsRequest) {
            return this.send('gotoTargets', args);
        }
        return Promise.reject(( (new Error('gotoTargets is not supported'))));
    }
    async goto(args) {
        if (this.capabilities.supportsGotoTargetsRequest) {
            const response = await this.send('goto', args);
            this.fireSimulatedContinuedEvent(args.threadId);
            return response;
        }
        return Promise.reject(( (new Error('goto is not supported'))));
    }
    async setInstructionBreakpoints(args) {
        if (this.capabilities.supportsInstructionBreakpoints) {
            return await this.send('setInstructionBreakpoints', args);
        }
        return Promise.reject(( (new Error('setInstructionBreakpoints is not supported'))));
    }
    async disassemble(args) {
        if (this.capabilities.supportsDisassembleRequest) {
            return await this.send('disassemble', args);
        }
        return Promise.reject(( (new Error('disassemble is not supported'))));
    }
    async readMemory(args) {
        if (this.capabilities.supportsReadMemoryRequest) {
            return await this.send('readMemory', args);
        }
        return Promise.reject(( (new Error('readMemory is not supported'))));
    }
    async writeMemory(args) {
        if (this.capabilities.supportsWriteMemoryRequest) {
            return await this.send('writeMemory', args);
        }
        return Promise.reject(( (new Error('writeMemory is not supported'))));
    }
    cancel(args) {
        return this.send('cancel', args);
    }
    custom(request, args) {
        return this.send(request, args);
    }
    async shutdown(error, restart = false, terminateDebuggee = undefined, suspendDebuggee = undefined) {
        if (!this.inShutdown) {
            this.inShutdown = true;
            if (this.debugAdapter) {
                try {
                    const args = { restart };
                    if (typeof terminateDebuggee === 'boolean') {
                        args.terminateDebuggee = terminateDebuggee;
                    }
                    if (typeof suspendDebuggee === 'boolean') {
                        args.suspendDebuggee = suspendDebuggee;
                    }
                    await this.send('disconnect', args, undefined, 2000);
                }
                catch (e) {
                }
                finally {
                    await this.stopAdapter(error);
                }
            }
            else {
                return this.stopAdapter(error);
            }
        }
    }
    async stopAdapter(error) {
        try {
            if (this.debugAdapter) {
                const da = this.debugAdapter;
                this.debugAdapter = null;
                await da.stopSession();
                this.debugAdapterStopped = true;
            }
        }
        finally {
            this.fireAdapterExitEvent(error);
        }
    }
    fireAdapterExitEvent(error) {
        if (!this.firedAdapterExitEvent) {
            this.firedAdapterExitEvent = true;
            const e = {
                emittedStopped: this.didReceiveStoppedEvent,
                sessionLengthInSeconds: (( (new Date())).getTime() - this.startTime) / 1000
            };
            if (error && !this.debugAdapterStopped) {
                e.error = error;
            }
            this._onDidExitAdapter.fire(e);
        }
    }
    async dispatchRequest(request) {
        const response = {
            type: 'response',
            seq: 0,
            command: request.command,
            request_seq: request.seq,
            success: true
        };
        const safeSendResponse = (response) => this.debugAdapter && this.debugAdapter.sendResponse(response);
        if (request.command === 'launchVSCode') {
            try {
                let result = await this.launchVsCode(request.arguments);
                if (!result.success) {
                    const { confirmed } = await this.dialogSerivce.confirm({
                        type: Severity.Warning,
                        message: ( (localize(
                            'canNotStart',
                            "The debugger needs to open a new tab or window for the debuggee but the browser prevented this. You must give permission to continue."
                        ))),
                        primaryButton: ( (localize({ key: 'continue', comment: ['&& denotes a mnemonic'] }, "&&Continue")))
                    });
                    if (confirmed) {
                        result = await this.launchVsCode(request.arguments);
                    }
                    else {
                        response.success = false;
                        safeSendResponse(response);
                        await this.shutdown();
                    }
                }
                response.body = {
                    rendererDebugPort: result.rendererDebugPort,
                };
                safeSendResponse(response);
            }
            catch (err) {
                response.success = false;
                response.message = err.message;
                safeSendResponse(response);
            }
        }
        else if (request.command === 'runInTerminal') {
            try {
                const shellProcessId = await this.dbgr.runInTerminal(request.arguments, this.sessionId);
                const resp = response;
                resp.body = {};
                if (typeof shellProcessId === 'number') {
                    resp.body.shellProcessId = shellProcessId;
                }
                safeSendResponse(resp);
            }
            catch (err) {
                response.success = false;
                response.message = err.message;
                safeSendResponse(response);
            }
        }
        else if (request.command === 'startDebugging') {
            try {
                const args = request.arguments;
                const config = {
                    ...args.configuration,
                    ...{
                        request: args.request,
                        type: this.dbgr.type,
                        name: args.configuration.name || this.name
                    }
                };
                const success = await this.dbgr.startDebugging(config, this.sessionId);
                if (success) {
                    safeSendResponse(response);
                }
                else {
                    response.success = false;
                    response.message = 'Failed to start debugging';
                    safeSendResponse(response);
                }
            }
            catch (err) {
                response.success = false;
                response.message = err.message;
                safeSendResponse(response);
            }
        }
        else {
            response.success = false;
            response.message = `unknown request '${request.command}'`;
            safeSendResponse(response);
        }
    }
    launchVsCode(vscodeArgs) {
        const args = [];
        for (const arg of vscodeArgs.args) {
            const a2 = (arg.prefix || '') + (arg.path || '');
            const match = /^--(.+)=(.+)$/.exec(a2);
            if (match && match.length === 3) {
                const key = match[1];
                let value = match[2];
                if ((key === 'file-uri' || key === 'folder-uri') && !isUri(arg.path)) {
                    value = isUri(value) ? value : ( (URI.file(value).toString()));
                }
                args.push(`--${key}=${value}`);
            }
            else {
                args.push(a2);
            }
        }
        if (vscodeArgs.env) {
            args.push(`--extensionEnvironment=${JSON.stringify(vscodeArgs.env)}`);
        }
        return this.extensionHostDebugService.openExtensionDevelopmentHostWindow(args, !!vscodeArgs.debugRenderer);
    }
    send(command, args, token, timeout, showErrors = true) {
        return ( (new Promise((completeDispatch, errorDispatch) => {
            if (!this.debugAdapter) {
                if (this.inShutdown) {
                    completeDispatch(undefined);
                }
                else {
                    errorDispatch(( (new Error( (localize(
                        'noDebugAdapter',
                        "No debugger available found. Can not send '{0}'.",
                        command
                    ))))));
                }
                return;
            }
            let cancelationListener;
            const requestId = this.debugAdapter.sendRequest(command, args, (response) => {
                cancelationListener?.dispose();
                if (response.success) {
                    completeDispatch(response);
                }
                else {
                    errorDispatch(response);
                }
            }, timeout);
            if (token) {
                cancelationListener = token.onCancellationRequested(() => {
                    cancelationListener.dispose();
                    if (this.capabilities.supportsCancelRequest) {
                        this.cancel({ requestId });
                    }
                });
            }
        }))).then(undefined, err => Promise.reject(this.handleErrorResponse(err, showErrors)));
    }
    handleErrorResponse(errorResponse, showErrors) {
        if (errorResponse.command === 'canceled' && errorResponse.message === 'canceled') {
            return new CancellationError();
        }
        const error = errorResponse?.body?.error;
        const errorMessage = errorResponse?.message || '';
        const userMessage = error ? formatPII(error.format, false, error.variables) : errorMessage;
        const url = error?.url;
        if (error && url) {
            const label = error.urlLabel ? error.urlLabel : ( (localize('moreInfo', "More Info")));
            const uri = ( (URI.parse(url)));
            const actionId = uri.scheme === Schemas.command ? 'debug.moreInfo.command' : 'debug.moreInfo';
            return createErrorWithActions(userMessage, [toAction({ id: actionId, label, run: () => this.openerService.open(uri, { allowCommands: true }) })]);
        }
        if (showErrors && error && error.format && error.showUser) {
            this.notificationService.error(userMessage);
        }
        const result = new ErrorNoTelemetry(userMessage);
        result.showUser = error?.showUser;
        return result;
    }
    mergeCapabilities(capabilities) {
        if (capabilities) {
            this._capabilities = mixin(this._capabilities, capabilities);
        }
    }
    fireSimulatedContinuedEvent(threadId, allThreadsContinued = false) {
        this._onDidContinued.fire({
            type: 'event',
            event: 'continued',
            body: {
                threadId,
                allThreadsContinued
            },
            seq: undefined
        });
    }
    dispose() {
        dispose(this.toDispose);
    }
};
RawDebugSession = ( (__decorate([
    ( (__param(4, IExtensionHostDebugService))),
    ( (__param(5, IOpenerService))),
    ( (__param(6, INotificationService))),
    ( (__param(7, IDialogService)))
], RawDebugSession)));
const MAX_REPL_LENGTH = 10000;
let topReplElementCounter = 0;
const getUniqueId = () => `topReplElement:${topReplElementCounter++}`;
class ReplOutputElement {
    constructor(session, id, value, severity, sourceData, expression) {
        this.session = session;
        this.id = id;
        this.value = value;
        this.severity = severity;
        this.sourceData = sourceData;
        this.expression = expression;
        this._count = 1;
        this._onDidChangeCount = ( (new Emitter()));
    }
    toString(includeSource = false) {
        let valueRespectCount = this.value;
        for (let i = 1; i < this.count; i++) {
            valueRespectCount += (valueRespectCount.endsWith('\n') ? '' : '\n') + this.value;
        }
        const sourceStr = (this.sourceData && includeSource) ? ` ${this.sourceData.source.name}` : '';
        return valueRespectCount + sourceStr;
    }
    getId() {
        return this.id;
    }
    getChildren() {
        return this.expression?.getChildren() || Promise.resolve([]);
    }
    set count(value) {
        this._count = value;
        this._onDidChangeCount.fire();
    }
    get count() {
        return this._count;
    }
    get onDidChangeCount() {
        return this._onDidChangeCount.event;
    }
    get hasChildren() {
        return !!this.expression?.hasChildren;
    }
}
class ReplVariableElement {
    constructor(expr, severity, sourceData) {
        this.expr = expr;
        this.severity = severity;
        this.sourceData = sourceData;
        this.id = generateUuid();
        this.hasChildren = expr.hasChildren;
    }
    getChildren() {
        return this.expr.getChildren();
    }
    toString() {
        return (
             (this.expr.toString())
        );
    }
    getId() {
        return this.id;
    }
}
class ReplEvaluationInput {
    constructor(value) {
        this.value = value;
        this.id = generateUuid();
    }
    toString() {
        return this.value;
    }
    getId() {
        return this.id;
    }
}
class ReplEvaluationResult extends ExpressionContainer {
    get available() {
        return this._available;
    }
    constructor() {
        super(undefined, undefined, 0, generateUuid());
        this._available = true;
    }
    async evaluateExpression(expression, session, stackFrame, context) {
        const result = await super.evaluateExpression(expression, session, stackFrame, context);
        this._available = result;
        return result;
    }
    toString() {
        return `${this.value}`;
    }
}
class ReplGroup {
    constructor(name, autoExpand, sourceData) {
        this.name = name;
        this.autoExpand = autoExpand;
        this.sourceData = sourceData;
        this.children = [];
        this.ended = false;
        this.id = `replGroup:${ReplGroup.COUNTER++}`;
    }
    get hasChildren() {
        return true;
    }
    getId() {
        return this.id;
    }
    toString(includeSource = false) {
        const sourceStr = (includeSource && this.sourceData) ? ` ${this.sourceData.source.name}` : '';
        return this.name + sourceStr;
    }
    addChild(child) {
        const lastElement = this.children.length ? this.children[this.children.length - 1] : undefined;
        if (lastElement instanceof ReplGroup && !lastElement.hasEnded) {
            lastElement.addChild(child);
        }
        else {
            this.children.push(child);
        }
    }
    getChildren() {
        return this.children;
    }
    end() {
        const lastElement = this.children.length ? this.children[this.children.length - 1] : undefined;
        if (lastElement instanceof ReplGroup && !lastElement.hasEnded) {
            lastElement.end();
        }
        else {
            this.ended = true;
        }
    }
    get hasEnded() {
        return this.ended;
    }
}
ReplGroup.COUNTER = 0;
function areSourcesEqual(first, second) {
    if (!first && !second) {
        return true;
    }
    if (first && second) {
        return first.column === second.column && first.lineNumber === second.lineNumber && ( (first.source.uri.toString())) === ( (second.source.uri.toString()));
    }
    return false;
}
class ReplModel {
    constructor(configurationService) {
        this.configurationService = configurationService;
        this.replElements = [];
        this._onDidChangeElements = ( (new Emitter()));
        this.onDidChangeElements = this._onDidChangeElements.event;
    }
    getReplElements() {
        return this.replElements;
    }
    async addReplExpression(session, stackFrame, name) {
        this.addReplElement(( (new ReplEvaluationInput(name))));
        const result = ( (new ReplEvaluationResult()));
        await result.evaluateExpression(name, session, stackFrame, 'repl');
        this.addReplElement(result);
    }
    appendToRepl(session, { output, expression, sev, source }) {
        const clearAnsiSequence = '\u001b[2J';
        const clearAnsiIndex = output.lastIndexOf(clearAnsiSequence);
        if (clearAnsiIndex !== -1) {
            this.removeReplExpressions();
            this.appendToRepl(session, { output: ( (localize('consoleCleared', "Console was cleared"))), sev: Severity$1.Ignore });
            output = output.substring(clearAnsiIndex + clearAnsiSequence.length);
        }
        if (expression) {
            this.addReplElement(output
                ? ( (new ReplOutputElement(session, getUniqueId(), output, sev, source, expression)))
                : ( (new ReplVariableElement(expression, sev, source))));
            return;
        }
        const previousElement = this.replElements.length ? this.replElements[this.replElements.length - 1] : undefined;
        if (previousElement instanceof ReplOutputElement && previousElement.severity === sev) {
            const config = this.configurationService.getValue('debug');
            if (previousElement.value === output && areSourcesEqual(previousElement.sourceData, source) && config.console.collapseIdenticalLines) {
                previousElement.count++;
                return;
            }
            if (!previousElement.value.endsWith('\n') && !previousElement.value.endsWith('\r\n') && previousElement.count === 1) {
                this.replElements[this.replElements.length - 1] = ( (new ReplOutputElement(session, getUniqueId(), previousElement.value + output, sev, source)));
                this._onDidChangeElements.fire();
                return;
            }
        }
        const element = ( (new ReplOutputElement(session, getUniqueId(), output, sev, source)));
        this.addReplElement(element);
    }
    startGroup(name, autoExpand, sourceData) {
        const group = ( (new ReplGroup(name, autoExpand, sourceData)));
        this.addReplElement(group);
    }
    endGroup() {
        const lastElement = this.replElements[this.replElements.length - 1];
        if (lastElement instanceof ReplGroup) {
            lastElement.end();
        }
    }
    addReplElement(newElement) {
        const lastElement = this.replElements.length ? this.replElements[this.replElements.length - 1] : undefined;
        if (lastElement instanceof ReplGroup && !lastElement.hasEnded) {
            lastElement.addChild(newElement);
        }
        else {
            this.replElements.push(newElement);
            if (this.replElements.length > MAX_REPL_LENGTH) {
                this.replElements.splice(0, this.replElements.length - MAX_REPL_LENGTH);
            }
        }
        this._onDidChangeElements.fire();
    }
    removeReplExpressions() {
        if (this.replElements.length > 0) {
            this.replElements = [];
            this._onDidChangeElements.fire();
        }
    }
    clone() {
        const newRepl = ( (new ReplModel(this.configurationService)));
        newRepl.replElements = this.replElements.slice();
        return newRepl;
    }
}
let DebugSession = class DebugSession {
    constructor(id, _configuration, root, model, options, debugService, telemetryService, hostService, configurationService, paneCompositeService, workspaceContextService, productService, notificationService, lifecycleService, uriIdentityService, instantiationService, customEndpointTelemetryService, workbenchEnvironmentService, logService) {
        this.id = id;
        this._configuration = _configuration;
        this.root = root;
        this.model = model;
        this.debugService = debugService;
        this.telemetryService = telemetryService;
        this.hostService = hostService;
        this.configurationService = configurationService;
        this.paneCompositeService = paneCompositeService;
        this.workspaceContextService = workspaceContextService;
        this.productService = productService;
        this.notificationService = notificationService;
        this.uriIdentityService = uriIdentityService;
        this.instantiationService = instantiationService;
        this.customEndpointTelemetryService = customEndpointTelemetryService;
        this.workbenchEnvironmentService = workbenchEnvironmentService;
        this.logService = logService;
        this.initialized = false;
        this.sources = ( (new Map()));
        this.threads = ( (new Map()));
        this.threadIds = [];
        this.cancellationMap = ( (new Map()));
        this.rawListeners = [];
        this.stoppedDetails = [];
        this._onDidChangeState = ( (new Emitter()));
        this._onDidEndAdapter = ( (new Emitter()));
        this._onDidLoadedSource = ( (new Emitter()));
        this._onDidCustomEvent = ( (new Emitter()));
        this._onDidProgressStart = ( (new Emitter()));
        this._onDidProgressUpdate = ( (new Emitter()));
        this._onDidProgressEnd = ( (new Emitter()));
        this._onDidInvalidMemory = ( (new Emitter()));
        this._onDidChangeREPLElements = ( (new Emitter()));
        this._onDidChangeName = ( (new Emitter()));
        this._options = options || {};
        this.parentSession = this._options.parentSession;
        if (this.hasSeparateRepl()) {
            this.repl = ( (new ReplModel(this.configurationService)));
        }
        else {
            this.repl = this.parentSession.repl;
        }
        const toDispose = ( (new DisposableStore()));
        const replListener = toDispose.add(( (new MutableDisposable())));
        replListener.value = this.repl.onDidChangeElements(() => this._onDidChangeREPLElements.fire());
        if (lifecycleService) {
            toDispose.add(lifecycleService.onWillShutdown(() => {
                this.shutdown();
                dispose(toDispose);
            }));
        }
        const compoundRoot = this._options.compoundRoot;
        if (compoundRoot) {
            toDispose.add(compoundRoot.onDidSessionStop(() => this.terminate()));
        }
        this.passFocusScheduler = ( (new RunOnceScheduler(() => {
            if (this.debugService.getModel().getSessions().some(s => s.state === 2 ) || this.getAllThreads().some(t => t.stopped)) {
                if (typeof this.lastContinuedThreadId === 'number') {
                    const thread = this.debugService.getViewModel().focusedThread;
                    if (thread && thread.threadId === this.lastContinuedThreadId && !thread.stopped) {
                        const toFocusThreadId = this.getStoppedDetails()?.threadId;
                        const toFocusThread = typeof toFocusThreadId === 'number' ? this.getThread(toFocusThreadId) : undefined;
                        this.debugService.focusStackFrame(undefined, toFocusThread);
                    }
                }
                else {
                    const session = this.debugService.getViewModel().focusedSession;
                    if (session && session.getId() === this.getId() && session.state !== 2 ) {
                        this.debugService.focusStackFrame(undefined);
                    }
                }
            }
        }, 800)));
        const parent = this._options.parentSession;
        if (parent) {
            toDispose.add(parent.onDidEndAdapter(() => {
                if (!this.hasSeparateRepl()) {
                    this.repl = this.repl.clone();
                    replListener.value = this.repl.onDidChangeElements(() => this._onDidChangeREPLElements.fire());
                }
                this.parentSession = undefined;
            }));
        }
    }
    getId() {
        return this.id;
    }
    setSubId(subId) {
        this._subId = subId;
    }
    getMemory(memoryReference) {
        return (
             (new MemoryRegion(memoryReference, this))
        );
    }
    get subId() {
        return this._subId;
    }
    get configuration() {
        return this._configuration.resolved;
    }
    get unresolvedConfiguration() {
        return this._configuration.unresolved;
    }
    get lifecycleManagedByParent() {
        return !!this._options.lifecycleManagedByParent;
    }
    get compact() {
        return !!this._options.compact;
    }
    get saveBeforeRestart() {
        return this._options.saveBeforeRestart ?? !this._options?.parentSession;
    }
    get compoundRoot() {
        return this._options.compoundRoot;
    }
    get suppressDebugStatusbar() {
        return this._options.suppressDebugStatusbar ?? false;
    }
    get suppressDebugToolbar() {
        return this._options.suppressDebugToolbar ?? false;
    }
    get suppressDebugView() {
        return this._options.suppressDebugView ?? false;
    }
    get autoExpandLazyVariables() {
        return this.configurationService.getValue('debug').autoExpandLazyVariables;
    }
    setConfiguration(configuration) {
        this._configuration = configuration;
    }
    getLabel() {
        const includeRoot = this.workspaceContextService.getWorkspace().folders.length > 1;
        return includeRoot && this.root ? `${this.name} (${basenameOrAuthority(this.root.uri)})` : this.name;
    }
    setName(name) {
        this._name = name;
        this._onDidChangeName.fire(name);
    }
    get name() {
        return this._name || this.configuration.name;
    }
    get state() {
        if (!this.initialized) {
            return 1 ;
        }
        if (!this.raw) {
            return 0 ;
        }
        const focusedThread = this.debugService.getViewModel().focusedThread;
        if (focusedThread && focusedThread.session === this) {
            return focusedThread.stopped ? 2  : 3 ;
        }
        if (this.getAllThreads().some(t => t.stopped)) {
            return 2 ;
        }
        return 3 ;
    }
    get capabilities() {
        return this.raw ? this.raw.capabilities : Object.create(null);
    }
    get onDidChangeState() {
        return this._onDidChangeState.event;
    }
    get onDidEndAdapter() {
        return this._onDidEndAdapter.event;
    }
    get onDidChangeReplElements() {
        return this._onDidChangeREPLElements.event;
    }
    get onDidChangeName() {
        return this._onDidChangeName.event;
    }
    get onDidCustomEvent() {
        return this._onDidCustomEvent.event;
    }
    get onDidLoadedSource() {
        return this._onDidLoadedSource.event;
    }
    get onDidProgressStart() {
        return this._onDidProgressStart.event;
    }
    get onDidProgressUpdate() {
        return this._onDidProgressUpdate.event;
    }
    get onDidProgressEnd() {
        return this._onDidProgressEnd.event;
    }
    get onDidInvalidateMemory() {
        return this._onDidInvalidMemory.event;
    }
    async initialize(dbgr) {
        if (this.raw) {
            await this.shutdown();
        }
        try {
            const debugAdapter = await dbgr.createDebugAdapter(this);
            this.raw = this.instantiationService.createInstance(RawDebugSession, debugAdapter, dbgr, this.id, this.configuration.name);
            await this.raw.start();
            this.registerListeners();
            await this.raw.initialize({
                clientID: 'vscode',
                clientName: this.productService.nameLong,
                adapterID: this.configuration.type,
                pathFormat: 'path',
                linesStartAt1: true,
                columnsStartAt1: true,
                supportsVariableType: true,
                supportsVariablePaging: true,
                supportsRunInTerminalRequest: true,
                locale: language,
                supportsProgressReporting: true,
                supportsInvalidatedEvent: true,
                supportsMemoryReferences: true,
                supportsArgsCanBeInterpretedByShell: true,
                supportsMemoryEvent: true,
                supportsStartDebuggingRequest: true
            });
            this.initialized = true;
            this._onDidChangeState.fire();
            this.debugService.setExceptionBreakpointsForSession(this, (this.raw && this.raw.capabilities.exceptionBreakpointFilters) || []);
        }
        catch (err) {
            this.initialized = true;
            this._onDidChangeState.fire();
            await this.shutdown();
            throw err;
        }
    }
    async launchOrAttach(config) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'launch or attach'));
        }
        if (this.parentSession && this.parentSession.state === 0 ) {
            throw canceled();
        }
        config.__sessionId = this.getId();
        try {
            await this.raw.launchOrAttach(config);
        }
        catch (err) {
            this.shutdown();
            throw err;
        }
    }
    async terminate(restart = false) {
        if (!this.raw) {
            this.onDidExitAdapter();
        }
        this.cancelAllRequests();
        if (this._options.lifecycleManagedByParent && this.parentSession) {
            await this.parentSession.terminate(restart);
        }
        else if (this.raw) {
            if (this.raw.capabilities.supportsTerminateRequest && this._configuration.resolved.request === 'launch') {
                await this.raw.terminate(restart);
            }
            else {
                await this.raw.disconnect({ restart, terminateDebuggee: true });
            }
        }
        if (!restart) {
            this._options.compoundRoot?.sessionStopped();
        }
    }
    async disconnect(restart = false, suspend = false) {
        if (!this.raw) {
            this.onDidExitAdapter();
        }
        this.cancelAllRequests();
        if (this._options.lifecycleManagedByParent && this.parentSession) {
            await this.parentSession.disconnect(restart, suspend);
        }
        else if (this.raw) {
            await this.raw.disconnect({ restart, terminateDebuggee: false, suspendDebuggee: suspend });
        }
        if (!restart) {
            this._options.compoundRoot?.sessionStopped();
        }
    }
    async restart() {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'restart'));
        }
        this.cancelAllRequests();
        if (this._options.lifecycleManagedByParent && this.parentSession) {
            await this.parentSession.restart();
        }
        else {
            await this.raw.restart({ arguments: this.configuration });
        }
    }
    async sendBreakpoints(modelUri, breakpointsToSend, sourceModified) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'breakpoints'));
        }
        if (!this.raw.readyForBreakpoints) {
            return Promise.resolve(undefined);
        }
        const rawSource = this.getRawSource(modelUri);
        if (breakpointsToSend.length && !rawSource.adapterData) {
            rawSource.adapterData = breakpointsToSend[0].adapterData;
        }
        if (rawSource.path) {
            rawSource.path = normalizeDriveLetter(rawSource.path);
        }
        const response = await this.raw.setBreakpoints({
            source: rawSource,
            lines: ( (breakpointsToSend.map(bp => bp.sessionAgnosticData.lineNumber))),
            breakpoints: ( (breakpointsToSend.map(
                bp => ({ line: bp.sessionAgnosticData.lineNumber, column: bp.sessionAgnosticData.column, condition: bp.condition, hitCondition: bp.hitCondition, logMessage: bp.logMessage })
            ))),
            sourceModified
        });
        if (response && response.body) {
            const data = ( (new Map()));
            for (let i = 0; i < breakpointsToSend.length; i++) {
                data.set(breakpointsToSend[i].getId(), response.body.breakpoints[i]);
            }
            this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
        }
    }
    async sendFunctionBreakpoints(fbpts) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'function breakpoints'));
        }
        if (this.raw.readyForBreakpoints) {
            const response = await this.raw.setFunctionBreakpoints({ breakpoints: fbpts });
            if (response && response.body) {
                const data = ( (new Map()));
                for (let i = 0; i < fbpts.length; i++) {
                    data.set(fbpts[i].getId(), response.body.breakpoints[i]);
                }
                this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
            }
        }
    }
    async sendExceptionBreakpoints(exbpts) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'exception breakpoints'));
        }
        if (this.raw.readyForBreakpoints) {
            const args = this.capabilities.supportsExceptionFilterOptions ? {
                filters: [],
                filterOptions: ( (exbpts.map(exb => {
                    if (exb.condition) {
                        return { filterId: exb.filter, condition: exb.condition };
                    }
                    return { filterId: exb.filter };
                })))
            } : { filters: ( (exbpts.map(exb => exb.filter))) };
            const response = await this.raw.setExceptionBreakpoints(args);
            if (response && response.body && response.body.breakpoints) {
                const data = ( (new Map()));
                for (let i = 0; i < exbpts.length; i++) {
                    data.set(exbpts[i].getId(), response.body.breakpoints[i]);
                }
                this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
            }
        }
    }
    async dataBreakpointInfo(name, variablesReference) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'data breakpoints info'));
        }
        if (!this.raw.readyForBreakpoints) {
            throw new Error(localize('sessionNotReadyForBreakpoints', "Session is not ready for breakpoints"));
        }
        const response = await this.raw.dataBreakpointInfo({ name, variablesReference });
        return response?.body;
    }
    async sendDataBreakpoints(dataBreakpoints) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'data breakpoints'));
        }
        if (this.raw.readyForBreakpoints) {
            const response = await this.raw.setDataBreakpoints({ breakpoints: dataBreakpoints });
            if (response && response.body) {
                const data = ( (new Map()));
                for (let i = 0; i < dataBreakpoints.length; i++) {
                    data.set(dataBreakpoints[i].getId(), response.body.breakpoints[i]);
                }
                this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
            }
        }
    }
    async sendInstructionBreakpoints(instructionBreakpoints) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'instruction breakpoints'));
        }
        if (this.raw.readyForBreakpoints) {
            const response = await this.raw.setInstructionBreakpoints({ breakpoints: instructionBreakpoints });
            if (response && response.body) {
                const data = ( (new Map()));
                for (let i = 0; i < instructionBreakpoints.length; i++) {
                    data.set(instructionBreakpoints[i].getId(), response.body.breakpoints[i]);
                }
                this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
            }
        }
    }
    async breakpointsLocations(uri, lineNumber) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'breakpoints locations'));
        }
        const source = this.getRawSource(uri);
        const response = await this.raw.breakpointLocations({ source, line: lineNumber });
        if (!response || !response.body || !response.body.breakpoints) {
            return [];
        }
        const positions = ( (response.body.breakpoints.map(bp => ({ lineNumber: bp.line, column: bp.column || 1 }))));
        return distinct(positions, p => `${p.lineNumber}:${p.column}`);
    }
    getDebugProtocolBreakpoint(breakpointId) {
        return this.model.getDebugProtocolBreakpoint(breakpointId, this.getId());
    }
    customRequest(request, args) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", request));
        }
        return this.raw.custom(request, args);
    }
    stackTrace(threadId, startFrame, levels, token) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'stackTrace'));
        }
        const sessionToken = this.getNewCancellationToken(threadId, token);
        return this.raw.stackTrace({ threadId, startFrame, levels }, sessionToken);
    }
    async exceptionInfo(threadId) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'exceptionInfo'));
        }
        const response = await this.raw.exceptionInfo({ threadId });
        if (response) {
            return {
                id: response.body.exceptionId,
                description: response.body.description,
                breakMode: response.body.breakMode,
                details: response.body.details
            };
        }
        return undefined;
    }
    scopes(frameId, threadId) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'scopes'));
        }
        const token = this.getNewCancellationToken(threadId);
        return this.raw.scopes({ frameId }, token);
    }
    variables(variablesReference, threadId, filter, start, count) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'variables'));
        }
        const token = threadId ? this.getNewCancellationToken(threadId) : undefined;
        return this.raw.variables({ variablesReference, filter, start, count }, token);
    }
    evaluate(expression, frameId, context) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'evaluate'));
        }
        return this.raw.evaluate({ expression, frameId, context });
    }
    async restartFrame(frameId, threadId) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'restartFrame'));
        }
        await this.raw.restartFrame({ frameId }, threadId);
    }
    setLastSteppingGranularity(threadId, granularity) {
        const thread = this.getThread(threadId);
        if (thread) {
            thread.lastSteppingGranularity = granularity;
        }
    }
    async next(threadId, granularity) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'next'));
        }
        this.setLastSteppingGranularity(threadId, granularity);
        await this.raw.next({ threadId, granularity });
    }
    async stepIn(threadId, targetId, granularity) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'stepIn'));
        }
        this.setLastSteppingGranularity(threadId, granularity);
        await this.raw.stepIn({ threadId, targetId, granularity });
    }
    async stepOut(threadId, granularity) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'stepOut'));
        }
        this.setLastSteppingGranularity(threadId, granularity);
        await this.raw.stepOut({ threadId, granularity });
    }
    async stepBack(threadId, granularity) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'stepBack'));
        }
        this.setLastSteppingGranularity(threadId, granularity);
        await this.raw.stepBack({ threadId, granularity });
    }
    async continue(threadId) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'continue'));
        }
        await this.raw.continue({ threadId });
    }
    async reverseContinue(threadId) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'reverse continue'));
        }
        await this.raw.reverseContinue({ threadId });
    }
    async pause(threadId) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'pause'));
        }
        await this.raw.pause({ threadId });
    }
    async terminateThreads(threadIds) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'terminateThreads'));
        }
        await this.raw.terminateThreads({ threadIds });
    }
    setVariable(variablesReference, name, value) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'setVariable'));
        }
        return this.raw.setVariable({ variablesReference, name, value });
    }
    setExpression(frameId, expression, value) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'setExpression'));
        }
        return this.raw.setExpression({ expression, value, frameId });
    }
    gotoTargets(source, line, column) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'gotoTargets'));
        }
        return this.raw.gotoTargets({ source, line, column });
    }
    goto(threadId, targetId) {
        if (!this.raw) {
            throw new Error(localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'goto'));
        }
        return this.raw.goto({ threadId, targetId });
    }
    loadSource(resource) {
        if (!this.raw) {
            return Promise.reject(( (new Error( (localize(
                'noDebugAdapter',
                "No debugger available, can not send '{0}'",
                'loadSource'
            ))))));
        }
        const source = this.getSourceForUri(resource);
        let rawSource;
        if (source) {
            rawSource = source.raw;
        }
        else {
            const data = Source.getEncodedDebugData(resource);
            rawSource = { path: data.path, sourceReference: data.sourceReference };
        }
        return this.raw.source({ sourceReference: rawSource.sourceReference || 0, source: rawSource });
    }
    async getLoadedSources() {
        if (!this.raw) {
            return Promise.reject(( (new Error( (localize(
                'noDebugAdapter',
                "No debugger available, can not send '{0}'",
                'getLoadedSources'
            ))))));
        }
        const response = await this.raw.loadedSources({});
        if (response && response.body && response.body.sources) {
            return (
                 (response.body.sources.map(src => this.getSource(src)))
            );
        }
        else {
            return [];
        }
    }
    async completions(frameId, threadId, text, position, overwriteBefore, token) {
        if (!this.raw) {
            return Promise.reject(( (new Error( (localize(
                'noDebugAdapter',
                "No debugger available, can not send '{0}'",
                'completions'
            ))))));
        }
        const sessionCancelationToken = this.getNewCancellationToken(threadId, token);
        return this.raw.completions({
            frameId,
            text,
            column: position.column,
            line: position.lineNumber,
        }, sessionCancelationToken);
    }
    async stepInTargets(frameId) {
        if (!this.raw) {
            return Promise.reject(( (new Error( (localize(
                'noDebugAdapter',
                "No debugger available, can not send '{0}'",
                'stepInTargets'
            ))))));
        }
        const response = await this.raw.stepInTargets({ frameId });
        return response?.body.targets;
    }
    async cancel(progressId) {
        if (!this.raw) {
            return Promise.reject(( (new Error(
                 (localize('noDebugAdapter', "No debugger available, can not send '{0}'", 'cancel'))
            ))));
        }
        return this.raw.cancel({ progressId });
    }
    async disassemble(memoryReference, offset, instructionOffset, instructionCount) {
        if (!this.raw) {
            return Promise.reject(( (new Error( (localize(
                'noDebugAdapter',
                "No debugger available, can not send '{0}'",
                'disassemble'
            ))))));
        }
        const response = await this.raw.disassemble({ memoryReference, offset, instructionOffset, instructionCount, resolveSymbols: true });
        return response?.body?.instructions;
    }
    readMemory(memoryReference, offset, count) {
        if (!this.raw) {
            return Promise.reject(( (new Error( (localize(
                'noDebugAdapter',
                "No debugger available, can not send '{0}'",
                'readMemory'
            ))))));
        }
        return this.raw.readMemory({ count, memoryReference, offset });
    }
    writeMemory(memoryReference, offset, data, allowPartial) {
        if (!this.raw) {
            return Promise.reject(( (new Error( (localize(
                'noDebugAdapter',
                "No debugger available, can not send '{0}'",
                'disassemble'
            ))))));
        }
        return this.raw.writeMemory({ memoryReference, offset, allowPartial, data });
    }
    getThread(threadId) {
        return this.threads.get(threadId);
    }
    getAllThreads() {
        const result = [];
        this.threadIds.forEach((threadId) => {
            const thread = this.threads.get(threadId);
            if (thread) {
                result.push(thread);
            }
        });
        return result;
    }
    clearThreads(removeThreads, reference = undefined) {
        if (reference !== undefined && reference !== null) {
            const thread = this.threads.get(reference);
            if (thread) {
                thread.clearCallStack();
                thread.stoppedDetails = undefined;
                thread.stopped = false;
                if (removeThreads) {
                    this.threads.delete(reference);
                }
            }
        }
        else {
            this.threads.forEach(thread => {
                thread.clearCallStack();
                thread.stoppedDetails = undefined;
                thread.stopped = false;
            });
            if (removeThreads) {
                this.threads.clear();
                this.threadIds = [];
                ExpressionContainer.allValues.clear();
            }
        }
    }
    getStoppedDetails() {
        return this.stoppedDetails.length >= 1 ? this.stoppedDetails[0] : undefined;
    }
    rawUpdate(data) {
        this.threadIds = [];
        data.threads.forEach(thread => {
            this.threadIds.push(thread.id);
            if (!this.threads.has(thread.id)) {
                this.threads.set(thread.id, ( (new Thread(this, thread.name, thread.id))));
            }
            else if (thread.name) {
                const oldThread = this.threads.get(thread.id);
                if (oldThread) {
                    oldThread.name = thread.name;
                }
            }
        });
        this.threads.forEach(t => {
            if (this.threadIds.indexOf(t.threadId) === -1) {
                this.threads.delete(t.threadId);
            }
        });
        const stoppedDetails = data.stoppedDetails;
        if (stoppedDetails) {
            if (stoppedDetails.allThreadsStopped) {
                this.threads.forEach(thread => {
                    thread.stoppedDetails = thread.threadId === stoppedDetails.threadId ? stoppedDetails : { reason: thread.stoppedDetails?.reason };
                    thread.stopped = true;
                    thread.clearCallStack();
                });
            }
            else {
                const thread = typeof stoppedDetails.threadId === 'number' ? this.threads.get(stoppedDetails.threadId) : undefined;
                if (thread) {
                    thread.stoppedDetails = stoppedDetails;
                    thread.clearCallStack();
                    thread.stopped = true;
                }
            }
        }
    }
    async fetchThreads(stoppedDetails) {
        if (this.raw) {
            const response = await this.raw.threads();
            if (response && response.body && response.body.threads) {
                this.model.rawUpdate({
                    sessionId: this.getId(),
                    threads: response.body.threads,
                    stoppedDetails
                });
            }
        }
    }
    initializeForTest(raw) {
        this.raw = raw;
        this.registerListeners();
    }
    registerListeners() {
        if (!this.raw) {
            return;
        }
        this.rawListeners.push(this.raw.onDidInitialize(async () => {
            status(( (localize('debuggingStarted', "Debugging started."))));
            const sendConfigurationDone = async () => {
                if (this.raw && this.raw.capabilities.supportsConfigurationDoneRequest) {
                    try {
                        await this.raw.configurationDone();
                    }
                    catch (e) {
                        this.notificationService.error(e);
                        this.raw?.disconnect({});
                    }
                }
                return undefined;
            };
            try {
                await this.debugService.sendAllBreakpoints(this);
            }
            finally {
                await sendConfigurationDone();
                await this.fetchThreads();
            }
        }));
        this.rawListeners.push(this.raw.onDidStop(async (event) => {
            this.passFocusScheduler.cancel();
            this.stoppedDetails.push(event.body);
            await this.fetchThreads(event.body);
            const focusedThread = this.debugService.getViewModel().focusedThread;
            const focusedThreadDoesNotExist = focusedThread !== undefined && focusedThread.session === this && !this.threads.has(focusedThread.threadId);
            if (focusedThreadDoesNotExist) {
                this.debugService.focusStackFrame(undefined, undefined);
            }
            const thread = typeof event.body.threadId === 'number' ? this.getThread(event.body.threadId) : undefined;
            if (thread) {
                const promises = this.model.refreshTopOfCallstack(thread);
                const focus = async () => {
                    if (focusedThreadDoesNotExist || (!event.body.preserveFocusHint && thread.getCallStack().length)) {
                        const focusedStackFrame = this.debugService.getViewModel().focusedStackFrame;
                        if (!focusedStackFrame || focusedStackFrame.thread.session === this) {
                            const preserveFocus = !this.configurationService.getValue('debug').focusEditorOnBreak;
                            await this.debugService.focusStackFrame(undefined, thread, undefined, { preserveFocus });
                        }
                        if (thread.stoppedDetails) {
                            if (thread.stoppedDetails.reason === 'breakpoint' && this.configurationService.getValue('debug').openDebug === 'openOnDebugBreak' && !this.suppressDebugView) {
                                await this.paneCompositeService.openPaneComposite(VIEWLET_ID$1, 0 );
                            }
                            if (this.configurationService.getValue('debug').focusWindowOnBreak && !this.workbenchEnvironmentService.extensionTestsLocationURI) {
                                await this.hostService.focus({ force: true  });
                            }
                        }
                    }
                };
                await promises.topCallStack;
                focus();
                await promises.wholeCallStack;
                const focusedStackFrame = this.debugService.getViewModel().focusedStackFrame;
                if (!focusedStackFrame || !focusedStackFrame.source || focusedStackFrame.source.presentationHint === 'deemphasize' || focusedStackFrame.presentationHint === 'deemphasize') {
                    focus();
                }
            }
            this._onDidChangeState.fire();
        }));
        this.rawListeners.push(this.raw.onDidThread(event => {
            if (event.body.reason === 'started') {
                if (!this.fetchThreadsScheduler) {
                    this.fetchThreadsScheduler = ( (new RunOnceScheduler(() => {
                        this.fetchThreads();
                    }, 100)));
                    this.rawListeners.push(this.fetchThreadsScheduler);
                }
                if (!this.fetchThreadsScheduler.isScheduled()) {
                    this.fetchThreadsScheduler.schedule();
                }
            }
            else if (event.body.reason === 'exited') {
                this.model.clearThreads(this.getId(), true, event.body.threadId);
                const viewModel = this.debugService.getViewModel();
                const focusedThread = viewModel.focusedThread;
                this.passFocusScheduler.cancel();
                if (focusedThread && event.body.threadId === focusedThread.threadId) {
                    this.debugService.focusStackFrame(undefined, undefined, viewModel.focusedSession, { explicit: false });
                }
            }
        }));
        this.rawListeners.push(this.raw.onDidTerminateDebugee(async (event) => {
            status(( (localize('debuggingStopped', "Debugging stopped."))));
            if (event.body && event.body.restart) {
                await this.debugService.restartSession(this, event.body.restart);
            }
            else if (this.raw) {
                await this.raw.disconnect({ terminateDebuggee: false });
            }
        }));
        this.rawListeners.push(this.raw.onDidContinued(event => {
            const threadId = event.body.allThreadsContinued !== false ? undefined : event.body.threadId;
            if (typeof threadId === 'number') {
                this.stoppedDetails = this.stoppedDetails.filter(sd => sd.threadId !== threadId);
                const tokens = this.cancellationMap.get(threadId);
                this.cancellationMap.delete(threadId);
                tokens?.forEach(t => t.cancel());
            }
            else {
                this.stoppedDetails = [];
                this.cancelAllRequests();
            }
            this.lastContinuedThreadId = threadId;
            this.passFocusScheduler.schedule();
            this.model.clearThreads(this.getId(), false, threadId);
            this._onDidChangeState.fire();
        }));
        const outputQueue = ( (new Queue()));
        this.rawListeners.push(this.raw.onDidOutput(async (event) => {
            const outputSeverity = event.body.category === 'stderr' ? Severity$1.Error : event.body.category === 'console' ? Severity$1.Warning : Severity$1.Info;
            if (event.body.variablesReference) {
                const source = event.body.source && event.body.line ? {
                    lineNumber: event.body.line,
                    column: event.body.column ? event.body.column : 1,
                    source: this.getSource(event.body.source)
                } : undefined;
                const container = ( (new ExpressionContainer(this, undefined, event.body.variablesReference, generateUuid())));
                const children = container.getChildren();
                outputQueue.queue(async () => {
                    const resolved = await children;
                    if (resolved.length === 1) {
                        this.appendToRepl({ output: event.body.output, expression: resolved[0], sev: outputSeverity, source }, event.body.category === 'important');
                        return;
                    }
                    resolved.forEach((child) => {
                        child.name = null;
                        this.appendToRepl({ output: '', expression: child, sev: outputSeverity, source }, event.body.category === 'important');
                    });
                });
                return;
            }
            outputQueue.queue(async () => {
                if (!event.body || !this.raw) {
                    return;
                }
                if (event.body.category === 'telemetry') {
                    const telemetryEndpoint = this.raw.dbgr.getCustomTelemetryEndpoint();
                    if (telemetryEndpoint && this.telemetryService.telemetryLevel !== 0 ) {
                        let data = event.body.data;
                        if (!telemetryEndpoint.sendErrorTelemetry && event.body.data) {
                            data = filterExceptionsFromTelemetry(event.body.data);
                        }
                        this.customEndpointTelemetryService.publicLog(telemetryEndpoint, event.body.output, data);
                    }
                    return;
                }
                const source = event.body.source && event.body.line ? {
                    lineNumber: event.body.line,
                    column: event.body.column ? event.body.column : 1,
                    source: this.getSource(event.body.source)
                } : undefined;
                if (event.body.group === 'start' || event.body.group === 'startCollapsed') {
                    const expanded = event.body.group === 'start';
                    this.repl.startGroup(event.body.output || '', expanded, source);
                    return;
                }
                if (event.body.group === 'end') {
                    this.repl.endGroup();
                    if (!event.body.output) {
                        return;
                    }
                }
                if (typeof event.body.output === 'string') {
                    this.appendToRepl({ output: event.body.output, sev: outputSeverity, source }, event.body.category === 'important');
                }
            });
        }));
        this.rawListeners.push(this.raw.onDidBreakpoint(event => {
            const id = event.body && event.body.breakpoint ? event.body.breakpoint.id : undefined;
            const breakpoint = this.model.getBreakpoints().find(bp => bp.getIdFromAdapter(this.getId()) === id);
            const functionBreakpoint = this.model.getFunctionBreakpoints().find(bp => bp.getIdFromAdapter(this.getId()) === id);
            const dataBreakpoint = this.model.getDataBreakpoints().find(dbp => dbp.getIdFromAdapter(this.getId()) === id);
            const exceptionBreakpoint = this.model.getExceptionBreakpoints().find(excbp => excbp.getIdFromAdapter(this.getId()) === id);
            if (event.body.reason === 'new' && event.body.breakpoint.source && event.body.breakpoint.line) {
                const source = this.getSource(event.body.breakpoint.source);
                const bps = this.model.addBreakpoints(source.uri, [{
                        column: event.body.breakpoint.column,
                        enabled: true,
                        lineNumber: event.body.breakpoint.line,
                    }], false);
                if (bps.length === 1) {
                    const data = ( (new Map([[bps[0].getId(), event.body.breakpoint]])));
                    this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
                }
            }
            if (event.body.reason === 'removed') {
                if (breakpoint) {
                    this.model.removeBreakpoints([breakpoint]);
                }
                if (functionBreakpoint) {
                    this.model.removeFunctionBreakpoints(functionBreakpoint.getId());
                }
                if (dataBreakpoint) {
                    this.model.removeDataBreakpoints(dataBreakpoint.getId());
                }
            }
            if (event.body.reason === 'changed') {
                if (breakpoint) {
                    if (!breakpoint.column) {
                        event.body.breakpoint.column = undefined;
                    }
                    const data = ( (new Map([[breakpoint.getId(), event.body.breakpoint]])));
                    this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
                }
                if (functionBreakpoint) {
                    const data = ( (new Map([[functionBreakpoint.getId(), event.body.breakpoint]])));
                    this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
                }
                if (dataBreakpoint) {
                    const data = ( (new Map([[dataBreakpoint.getId(), event.body.breakpoint]])));
                    this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
                }
                if (exceptionBreakpoint) {
                    const data = ( (new Map([[exceptionBreakpoint.getId(), event.body.breakpoint]])));
                    this.model.setBreakpointSessionData(this.getId(), this.capabilities, data);
                }
            }
        }));
        this.rawListeners.push(this.raw.onDidLoadedSource(event => {
            this._onDidLoadedSource.fire({
                reason: event.body.reason,
                source: this.getSource(event.body.source)
            });
        }));
        this.rawListeners.push(this.raw.onDidCustomEvent(event => {
            this._onDidCustomEvent.fire(event);
        }));
        this.rawListeners.push(this.raw.onDidProgressStart(event => {
            this._onDidProgressStart.fire(event);
        }));
        this.rawListeners.push(this.raw.onDidProgressUpdate(event => {
            this._onDidProgressUpdate.fire(event);
        }));
        this.rawListeners.push(this.raw.onDidProgressEnd(event => {
            this._onDidProgressEnd.fire(event);
        }));
        this.rawListeners.push(this.raw.onDidInvalidateMemory(event => {
            this._onDidInvalidMemory.fire(event);
        }));
        this.rawListeners.push(this.raw.onDidInvalidated(async (event) => {
            if (!(event.body.areas && event.body.areas.length === 1 && (event.body.areas[0] === 'variables' || event.body.areas[0] === 'watch'))) {
                this.cancelAllRequests();
                this.model.clearThreads(this.getId(), true);
                await this.fetchThreads(this.getStoppedDetails());
            }
            const viewModel = this.debugService.getViewModel();
            if (viewModel.focusedSession === this) {
                viewModel.updateViews();
            }
        }));
        this.rawListeners.push(this.raw.onDidExitAdapter(event => this.onDidExitAdapter(event)));
    }
    onDidExitAdapter(event) {
        this.initialized = true;
        this.model.setBreakpointSessionData(this.getId(), this.capabilities, undefined);
        this.shutdown();
        this._onDidEndAdapter.fire(event);
    }
    shutdown() {
        dispose(this.rawListeners);
        if (this.raw) {
            this.raw.disconnect({});
            this.raw.dispose();
            this.raw = undefined;
        }
        this.fetchThreadsScheduler?.dispose();
        this.fetchThreadsScheduler = undefined;
        this.passFocusScheduler.cancel();
        this.passFocusScheduler.dispose();
        this.model.clearThreads(this.getId(), true);
        this._onDidChangeState.fire();
    }
    getSourceForUri(uri) {
        return this.sources.get(( (this.uriIdentityService.asCanonicalUri(uri).toString())));
    }
    getSource(raw) {
        let source = ( (new Source(raw, this.getId(), this.uriIdentityService, this.logService)));
        const uriKey = ( (source.uri.toString()));
        const found = this.sources.get(uriKey);
        if (found) {
            source = found;
            source.raw = mixin(source.raw, raw);
            if (source.raw && raw) {
                source.raw.presentationHint = raw.presentationHint;
            }
        }
        else {
            this.sources.set(uriKey, source);
        }
        return source;
    }
    getRawSource(uri) {
        const source = this.getSourceForUri(uri);
        if (source) {
            return source.raw;
        }
        else {
            const data = Source.getEncodedDebugData(uri);
            return { name: data.name, path: data.path, sourceReference: data.sourceReference };
        }
    }
    getNewCancellationToken(threadId, token) {
        const tokenSource = ( (new CancellationTokenSource(token)));
        const tokens = this.cancellationMap.get(threadId) || [];
        tokens.push(tokenSource);
        this.cancellationMap.set(threadId, tokens);
        return tokenSource.token;
    }
    cancelAllRequests() {
        this.cancellationMap.forEach(tokens => tokens.forEach(t => t.cancel()));
        this.cancellationMap.clear();
    }
    getReplElements() {
        return this.repl.getReplElements();
    }
    hasSeparateRepl() {
        return !this.parentSession || this._options.repl !== 'mergeWithParent';
    }
    removeReplExpressions() {
        this.repl.removeReplExpressions();
    }
    async addReplExpression(stackFrame, name) {
        await this.repl.addReplExpression(this, stackFrame, name);
        this.debugService.getViewModel().updateViews();
    }
    appendToRepl(data, isImportant) {
        this.repl.appendToRepl(this, data);
        if (isImportant) {
            this.notificationService.notify({ message: ( (data.toString())), severity: data.sev, source: this.name });
        }
    }
};
DebugSession = ( (__decorate([
    ( (__param(5, IDebugService))),
    ( (__param(6, ITelemetryService))),
    ( (__param(7, IHostService))),
    ( (__param(8, IConfigurationService))),
    ( (__param(9, IPaneCompositePartService))),
    ( (__param(10, IWorkspaceContextService))),
    ( (__param(11, IProductService))),
    ( (__param(12, INotificationService))),
    ( (__param(13, ILifecycleService))),
    ( (__param(14, IUriIdentityService))),
    ( (__param(15, IInstantiationService))),
    ( (__param(16, ICustomEndpointTelemetryService))),
    ( (__param(17, IWorkbenchEnvironmentService))),
    ( (__param(18, ILogService)))
], DebugSession)));
var Markers;
( ((function(Markers) {
    Markers.MARKERS_CONTAINER_ID = 'workbench.panel.markers';
    Markers.MARKERS_VIEW_ID = 'workbench.panel.markers.view';
    Markers.MARKERS_VIEW_STORAGE_ID = 'workbench.panel.markers';
    Markers.MARKER_COPY_ACTION_ID = 'problems.action.copy';
    Markers.MARKER_COPY_MESSAGE_ACTION_ID = 'problems.action.copyMessage';
    Markers.RELATED_INFORMATION_COPY_MESSAGE_ACTION_ID = 'problems.action.copyRelatedInformationMessage';
    Markers.FOCUS_PROBLEMS_FROM_FILTER = 'problems.action.focusProblemsFromFilter';
    Markers.MARKERS_VIEW_FOCUS_FILTER = 'problems.action.focusFilter';
    Markers.MARKERS_VIEW_CLEAR_FILTER_TEXT = 'problems.action.clearFilterText';
    Markers.MARKERS_VIEW_SHOW_MULTILINE_MESSAGE = 'problems.action.showMultilineMessage';
    Markers.MARKERS_VIEW_SHOW_SINGLELINE_MESSAGE = 'problems.action.showSinglelineMessage';
    Markers.MARKER_OPEN_ACTION_ID = 'problems.action.open';
    Markers.MARKER_OPEN_SIDE_ACTION_ID = 'problems.action.openToSide';
    Markers.MARKER_SHOW_PANEL_ID = 'workbench.action.showErrorsWarnings';
    Markers.MARKER_SHOW_QUICK_FIX = 'problems.action.showQuickFixes';
    Markers.TOGGLE_MARKERS_VIEW_ACTION_ID = 'workbench.actions.view.toggleProblems';
})(Markers || (Markers = {}))));
function once(match, event) {
    return (listener, thisArgs = null, disposables) => {
        const result = event(e => {
            if (match(e)) {
                result.dispose();
                return listener.call(thisArgs, e);
            }
        }, null, disposables);
        return result;
    };
}
const DEBUG_TASK_ERROR_CHOICE_KEY = 'debug.taskerrorchoice';
let DebugTaskRunner = class DebugTaskRunner {
    constructor(taskService, markerService, configurationService, viewsService, dialogService, storageService, commandService) {
        this.taskService = taskService;
        this.markerService = markerService;
        this.configurationService = configurationService;
        this.viewsService = viewsService;
        this.dialogService = dialogService;
        this.storageService = storageService;
        this.commandService = commandService;
        this.canceled = false;
    }
    cancel() {
        this.canceled = true;
    }
    async runTaskAndCheckErrors(root, taskId) {
        try {
            this.canceled = false;
            const taskSummary = await this.runTask(root, taskId);
            if (this.canceled || (taskSummary && taskSummary.exitCode === undefined)) {
                return 0 ;
            }
            const errorCount = taskId ? this.markerService.read({ severities: MarkerSeverity.Error, take: 2 }).length : 0;
            const successExitCode = taskSummary && taskSummary.exitCode === 0;
            const failureExitCode = taskSummary && taskSummary.exitCode !== 0;
            const onTaskErrors = this.configurationService.getValue('debug').onTaskErrors;
            if (successExitCode || onTaskErrors === 'debugAnyway' || (errorCount === 0 && !failureExitCode)) {
                return 1 ;
            }
            if (onTaskErrors === 'showErrors') {
                await this.viewsService.openView(Markers.MARKERS_VIEW_ID, true);
                return Promise.resolve(0 );
            }
            if (onTaskErrors === 'abort') {
                return Promise.resolve(0 );
            }
            const taskLabel = typeof taskId === 'string' ? taskId : taskId ? taskId.name : '';
            const message = errorCount > 1
                ? ( (localize(
                'preLaunchTaskErrors',
                "Errors exist after running preLaunchTask '{0}'.",
                taskLabel
            )))
                : errorCount === 1
                    ? ( (localize(
                'preLaunchTaskError',
                "Error exists after running preLaunchTask '{0}'.",
                taskLabel
            )))
                    : taskSummary && typeof taskSummary.exitCode === 'number'
                        ? ( (localize(
                'preLaunchTaskExitCode',
                "The preLaunchTask '{0}' terminated with exit code {1}.",
                taskLabel,
                taskSummary.exitCode
            )))
                        : ( (localize(
                'preLaunchTaskTerminated',
                "The preLaunchTask '{0}' terminated.",
                taskLabel
            )));
            let DebugChoice;
            ( ((function(DebugChoice) {
                DebugChoice[DebugChoice["DebugAnyway"] = 1] = "DebugAnyway";
                DebugChoice[DebugChoice["ShowErrors"] = 2] = "ShowErrors";
                DebugChoice[DebugChoice["Cancel"] = 0] = "Cancel";
            })(DebugChoice || (DebugChoice = {}))));
            const { result, checkboxChecked } = await this.dialogService.prompt({
                type: Severity$1.Warning,
                message,
                buttons: [
                    {
                        label: ( (localize(
                            { key: 'debugAnyway', comment: ['&& denotes a mnemonic'] },
                            "&&Debug Anyway"
                        ))),
                        run: () => DebugChoice.DebugAnyway
                    },
                    {
                        label: ( (localize({ key: 'showErrors', comment: ['&& denotes a mnemonic'] }, "&&Show Errors"))),
                        run: () => DebugChoice.ShowErrors
                    }
                ],
                cancelButton: {
                    label: ( (localize('abort', "Abort"))),
                    run: () => DebugChoice.Cancel
                },
                checkbox: {
                    label: ( (localize('remember', "Remember my choice in user settings"))),
                }
            });
            const debugAnyway = result === DebugChoice.DebugAnyway;
            const abort = result === DebugChoice.Cancel;
            if (checkboxChecked) {
                this.configurationService.updateValue('debug.onTaskErrors', result === DebugChoice.DebugAnyway ? 'debugAnyway' : abort ? 'abort' : 'showErrors');
            }
            if (abort) {
                return Promise.resolve(0 );
            }
            if (debugAnyway) {
                return 1 ;
            }
            await this.viewsService.openView(Markers.MARKERS_VIEW_ID, true);
            return Promise.resolve(0 );
        }
        catch (err) {
            const taskConfigureAction = this.taskService.configureAction();
            const choiceMap = JSON.parse(this.storageService.get(DEBUG_TASK_ERROR_CHOICE_KEY, 1 , '{}'));
            let choice = -1;
            let DebugChoice;
            ( ((function(DebugChoice) {
                DebugChoice[DebugChoice["DebugAnyway"] = 0] = "DebugAnyway";
                DebugChoice[DebugChoice["ConfigureTask"] = 1] = "ConfigureTask";
                DebugChoice[DebugChoice["Cancel"] = 2] = "Cancel";
            })(DebugChoice || (DebugChoice = {}))));
            if (choiceMap[err.message] !== undefined) {
                choice = choiceMap[err.message];
            }
            else {
                const { result, checkboxChecked } = await this.dialogService.prompt({
                    type: Severity$1.Error,
                    message: err.message,
                    buttons: [
                        {
                            label: ( (localize(
                                { key: 'debugAnyway', comment: ['&& denotes a mnemonic'] },
                                "&&Debug Anyway"
                            ))),
                            run: () => DebugChoice.DebugAnyway
                        },
                        {
                            label: taskConfigureAction.label,
                            run: () => DebugChoice.ConfigureTask
                        }
                    ],
                    cancelButton: {
                        run: () => DebugChoice.Cancel
                    },
                    checkbox: {
                        label: ( (localize('rememberTask', "Remember my choice for this task")))
                    }
                });
                choice = result;
                if (checkboxChecked) {
                    choiceMap[err.message] = choice;
                    this.storageService.store(DEBUG_TASK_ERROR_CHOICE_KEY, JSON.stringify(choiceMap), 1 , 0 );
                }
            }
            if (choice === DebugChoice.ConfigureTask) {
                await taskConfigureAction.run();
            }
            return choice === DebugChoice.DebugAnyway ? 1  : 0 ;
        }
    }
    async runTask(root, taskId) {
        if (!taskId) {
            return Promise.resolve(null);
        }
        if (!root) {
            return Promise.reject(( (new Error( (localize(
                'invalidTaskReference',
                "Task '{0}' can not be referenced from a launch configuration that is in a different workspace folder.",
                typeof taskId === 'string' ? taskId : taskId.type
            ))))));
        }
        const task = await this.taskService.getTask(root, taskId);
        if (!task) {
            const errorMessage = typeof taskId === 'string'
                ? ( (localize('DebugTaskNotFoundWithTaskId', "Could not find the task '{0}'.", taskId)))
                : ( (localize('DebugTaskNotFound', "Could not find the specified task.")));
            return Promise.reject(createErrorWithActions(errorMessage, [( (new Action(
                DEBUG_CONFIGURE_COMMAND_ID,
                DEBUG_CONFIGURE_LABEL,
                undefined,
                true,
                () => this.commandService.executeCommand(DEBUG_CONFIGURE_COMMAND_ID)
            )))]));
        }
        let taskStarted = false;
        const inactivePromise = ( (new Promise((c, e) => once(e => {
            return (e.kind === "inactive"
                || (e.kind === "processEnded"  && e.exitCode === undefined))
                && e.taskId === task._id;
        }, this.taskService.onDidStateChange)(e => {
            taskStarted = true;
            c(e.kind === "processEnded"  ? { exitCode: e.exitCode } : null);
        }))));
        const promise = this.taskService.getActiveTasks().then(async (tasks) => {
            if (tasks.find(t => t._id === task._id)) {
                const busyTasks = await this.taskService.getBusyTasks();
                if (busyTasks.find(t => t._id === task._id)) {
                    taskStarted = true;
                    return inactivePromise;
                }
                return Promise.resolve(null);
            }
            once(e => (((e.kind === "active") ) || ((e.kind === "dependsOnStarted") )) && e.taskId === task._id, this.taskService.onDidStateChange)(() => {
                taskStarted = true;
            });
            const taskPromise = this.taskService.run(task);
            if (task.configurationProperties.isBackground) {
                return inactivePromise;
            }
            return taskPromise.then(withUndefinedAsNull);
        });
        return (
             (new Promise((c, e) => {
                const waitForInput = ( (new Promise(
                    resolve => once(e => ((e.kind === "acquiredInput") ) && e.taskId === task._id, this.taskService.onDidStateChange)(() => {
                        resolve();
                    })
                )));
                promise.then(result => {
                    taskStarted = true;
                    c(result);
                }, error => e(error));
                waitForInput.then(() => {
                    const waitTime = task.configurationProperties.isBackground ? 5000 : 10000;
                    setTimeout(() => {
                        if (!taskStarted) {
                            const errorMessage = typeof taskId === 'string'
                                ? ( (localize(
                                'taskNotTrackedWithTaskId',
                                "The task '{0}' cannot be tracked. Make sure to have a problem matcher defined.",
                                taskId
                            )))
                                : ( (localize(
                                'taskNotTracked',
                                "The task '{0}' cannot be tracked. Make sure to have a problem matcher defined.",
                                JSON.stringify(taskId)
                            )));
                            e({ severity: Severity$1.Error, message: errorMessage });
                        }
                    }, waitTime);
                });
            }))
        );
    }
};
DebugTaskRunner = ( (__decorate([
    ( (__param(0, ITaskService))),
    ( (__param(1, IMarkerService))),
    ( (__param(2, IConfigurationService))),
    ( (__param(3, IViewsService))),
    ( (__param(4, IDialogService))),
    ( (__param(5, IStorageService))),
    ( (__param(6, ICommandService)))
], DebugTaskRunner)));
class DebugCompoundRoot {
    constructor() {
        this.stopped = false;
        this.stopEmitter = ( (new Emitter()));
        this.onDidSessionStop = this.stopEmitter.event;
    }
    sessionStopped() {
        if (!this.stopped) {
            this.stopped = true;
            this.stopEmitter.fire();
        }
    }
}
const DEBUG_BREAKPOINTS_KEY = 'debug.breakpoint';
const DEBUG_FUNCTION_BREAKPOINTS_KEY = 'debug.functionbreakpoint';
const DEBUG_DATA_BREAKPOINTS_KEY = 'debug.databreakpoint';
const DEBUG_EXCEPTION_BREAKPOINTS_KEY = 'debug.exceptionbreakpoint';
const DEBUG_WATCH_EXPRESSIONS_KEY = 'debug.watchexpressions';
const DEBUG_CHOSEN_ENVIRONMENTS_KEY = 'debug.chosenenvironment';
const DEBUG_UX_STATE_KEY = 'debug.uxstate';
let DebugStorage = class DebugStorage {
    constructor(storageService, textFileService, uriIdentityService, logService) {
        this.storageService = storageService;
        this.textFileService = textFileService;
        this.uriIdentityService = uriIdentityService;
        this.logService = logService;
    }
    loadDebugUxState() {
        return this.storageService.get(DEBUG_UX_STATE_KEY, 1 , 'default');
    }
    storeDebugUxState(value) {
        this.storageService.store(DEBUG_UX_STATE_KEY, value, 1 , 0 );
    }
    loadBreakpoints() {
        let result;
        try {
            result = ( (JSON.parse(this.storageService.get(DEBUG_BREAKPOINTS_KEY, 1 , '[]')).map((breakpoint) => {
                return (
                     (new Breakpoint(
                         (URI.parse(breakpoint.uri.external || breakpoint.source.uri.external)),
                        breakpoint.lineNumber,
                        breakpoint.column,
                        breakpoint.enabled,
                        breakpoint.condition,
                        breakpoint.hitCondition,
                        breakpoint.logMessage,
                        breakpoint.adapterData,
                        this.textFileService,
                        this.uriIdentityService,
                        this.logService
                    ))
                );
            })));
        }
        catch (e) { }
        return result || [];
    }
    loadFunctionBreakpoints() {
        let result;
        try {
            result = ( (JSON.parse(this.storageService.get(DEBUG_FUNCTION_BREAKPOINTS_KEY, 1 , '[]')).map((fb) => {
                return (
                     (new FunctionBreakpoint(fb.name, fb.enabled, fb.hitCondition, fb.condition, fb.logMessage))
                );
            })));
        }
        catch (e) { }
        return result || [];
    }
    loadExceptionBreakpoints() {
        let result;
        try {
            result = ( (JSON.parse(this.storageService.get(DEBUG_EXCEPTION_BREAKPOINTS_KEY, 1 , '[]')).map((exBreakpoint) => {
                return (
                     (new ExceptionBreakpoint(
                        exBreakpoint.filter,
                        exBreakpoint.label,
                        exBreakpoint.enabled,
                        exBreakpoint.supportsCondition,
                        exBreakpoint.condition,
                        exBreakpoint.description,
                        exBreakpoint.conditionDescription,
                        !!exBreakpoint.fallback
                    ))
                );
            })));
        }
        catch (e) { }
        return result || [];
    }
    loadDataBreakpoints() {
        let result;
        try {
            result = ( (JSON.parse(this.storageService.get(DEBUG_DATA_BREAKPOINTS_KEY, 1 , '[]')).map((dbp) => {
                return (
                     (new DataBreakpoint(
                        dbp.description,
                        dbp.dataId,
                        true,
                        dbp.enabled,
                        dbp.hitCondition,
                        dbp.condition,
                        dbp.logMessage,
                        dbp.accessTypes,
                        dbp.accessType
                    ))
                );
            })));
        }
        catch (e) { }
        return result || [];
    }
    loadWatchExpressions() {
        let result;
        try {
            result = ( (JSON.parse(this.storageService.get(DEBUG_WATCH_EXPRESSIONS_KEY, 1 , '[]')).map((watchStoredData) => {
                return (
                     (new Expression(watchStoredData.name, watchStoredData.id))
                );
            })));
        }
        catch (e) { }
        return result || [];
    }
    loadChosenEnvironments() {
        return JSON.parse(this.storageService.get(DEBUG_CHOSEN_ENVIRONMENTS_KEY, 1 , '{}'));
    }
    storeChosenEnvironments(environments) {
        this.storageService.store(DEBUG_CHOSEN_ENVIRONMENTS_KEY, JSON.stringify(environments), 1 , 0 );
    }
    storeWatchExpressions(watchExpressions) {
        if (watchExpressions.length) {
            this.storageService.store(DEBUG_WATCH_EXPRESSIONS_KEY, JSON.stringify(( (watchExpressions.map(we => ({ name: we.name, id: we.getId() }))))), 1 , 0 );
        }
        else {
            this.storageService.remove(DEBUG_WATCH_EXPRESSIONS_KEY, 1 );
        }
    }
    storeBreakpoints(debugModel) {
        const breakpoints = debugModel.getBreakpoints();
        if (breakpoints.length) {
            this.storageService.store(DEBUG_BREAKPOINTS_KEY, JSON.stringify(breakpoints), 1 , 0 );
        }
        else {
            this.storageService.remove(DEBUG_BREAKPOINTS_KEY, 1 );
        }
        const functionBreakpoints = debugModel.getFunctionBreakpoints();
        if (functionBreakpoints.length) {
            this.storageService.store(DEBUG_FUNCTION_BREAKPOINTS_KEY, JSON.stringify(functionBreakpoints), 1 , 0 );
        }
        else {
            this.storageService.remove(DEBUG_FUNCTION_BREAKPOINTS_KEY, 1 );
        }
        const dataBreakpoints = debugModel.getDataBreakpoints().filter(dbp => dbp.canPersist);
        if (dataBreakpoints.length) {
            this.storageService.store(DEBUG_DATA_BREAKPOINTS_KEY, JSON.stringify(dataBreakpoints), 1 , 0 );
        }
        else {
            this.storageService.remove(DEBUG_DATA_BREAKPOINTS_KEY, 1 );
        }
        const exceptionBreakpoints = debugModel.getExceptionBreakpoints();
        if (exceptionBreakpoints.length) {
            this.storageService.store(DEBUG_EXCEPTION_BREAKPOINTS_KEY, JSON.stringify(exceptionBreakpoints), 1 , 0 );
        }
        else {
            this.storageService.remove(DEBUG_EXCEPTION_BREAKPOINTS_KEY, 1 );
        }
    }
};
DebugStorage = ( (__decorate([
    ( (__param(0, IStorageService))),
    ( (__param(1, ITextFileService))),
    ( (__param(2, IUriIdentityService))),
    ( (__param(3, ILogService)))
], DebugStorage)));
let DebugTelemetry = class DebugTelemetry {
    constructor(model, telemetryService) {
        this.model = model;
        this.telemetryService = telemetryService;
    }
    logDebugSessionStart(dbgr, launchJsonExists) {
        const extension = dbgr.getMainExtensionDescriptor();
        return this.telemetryService.publicLog('debugSessionStart', {
            type: dbgr.type,
            breakpointCount: this.model.getBreakpoints().length,
            exceptionBreakpoints: this.model.getExceptionBreakpoints(),
            watchExpressionsCount: this.model.getWatchExpressions().length,
            extensionName: extension.identifier.value,
            isBuiltin: extension.isBuiltin,
            launchJsonExists
        });
    }
    logDebugSessionStop(session, adapterExitEvent) {
        const breakpoints = this.model.getBreakpoints();
        return this.telemetryService.publicLog('debugSessionStop', {
            type: session && session.configuration.type,
            success: adapterExitEvent.emittedStopped || breakpoints.length === 0,
            sessionLengthInSeconds: adapterExitEvent.sessionLengthInSeconds,
            breakpointCount: breakpoints.length,
            watchExpressionsCount: this.model.getWatchExpressions().length
        });
    }
};
DebugTelemetry = ( (__decorate([
    ( (__param(1, ITelemetryService)))
], DebugTelemetry)));
class ViewModel {
    constructor(contextKeyService) {
        this.contextKeyService = contextKeyService;
        this.firstSessionStart = true;
        this._onDidFocusSession = ( (new Emitter()));
        this._onDidFocusStackFrame = ( (new Emitter()));
        this._onDidSelectExpression = ( (new Emitter()));
        this._onDidEvaluateLazyExpression = ( (new Emitter()));
        this._onWillUpdateViews = ( (new Emitter()));
        contextKeyService.bufferChangeEvents(() => {
            this.expressionSelectedContextKey = CONTEXT_EXPRESSION_SELECTED.bindTo(contextKeyService);
            this.loadedScriptsSupportedContextKey = CONTEXT_LOADED_SCRIPTS_SUPPORTED.bindTo(contextKeyService);
            this.stepBackSupportedContextKey = CONTEXT_STEP_BACK_SUPPORTED.bindTo(contextKeyService);
            this.focusedSessionIsAttach = CONTEXT_FOCUSED_SESSION_IS_ATTACH.bindTo(contextKeyService);
            this.restartFrameSupportedContextKey = CONTEXT_RESTART_FRAME_SUPPORTED.bindTo(contextKeyService);
            this.stepIntoTargetsSupported = CONTEXT_STEP_INTO_TARGETS_SUPPORTED.bindTo(contextKeyService);
            this.jumpToCursorSupported = CONTEXT_JUMP_TO_CURSOR_SUPPORTED.bindTo(contextKeyService);
            this.setVariableSupported = CONTEXT_SET_VARIABLE_SUPPORTED.bindTo(contextKeyService);
            this.setExpressionSupported = CONTEXT_SET_EXPRESSION_SUPPORTED.bindTo(contextKeyService);
            this.multiSessionDebug = CONTEXT_MULTI_SESSION_DEBUG.bindTo(contextKeyService);
            this.terminateDebuggeeSupported = CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED.bindTo(contextKeyService);
            this.suspendDebuggeeSupported = CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED.bindTo(contextKeyService);
            this.disassembleRequestSupported = CONTEXT_DISASSEMBLE_REQUEST_SUPPORTED.bindTo(contextKeyService);
            this.focusedStackFrameHasInstructionPointerReference = CONTEXT_FOCUSED_STACK_FRAME_HAS_INSTRUCTION_POINTER_REFERENCE.bindTo(contextKeyService);
        });
    }
    getId() {
        return 'root';
    }
    get focusedSession() {
        return this._focusedSession;
    }
    get focusedThread() {
        return this._focusedThread;
    }
    get focusedStackFrame() {
        return this._focusedStackFrame;
    }
    setFocus(stackFrame, thread, session, explicit) {
        const shouldEmitForStackFrame = this._focusedStackFrame !== stackFrame;
        const shouldEmitForSession = this._focusedSession !== session;
        this._focusedStackFrame = stackFrame;
        this._focusedThread = thread;
        this._focusedSession = session;
        this.contextKeyService.bufferChangeEvents(() => {
            this.loadedScriptsSupportedContextKey.set(session ? !!session.capabilities.supportsLoadedSourcesRequest : false);
            this.stepBackSupportedContextKey.set(session ? !!session.capabilities.supportsStepBack : false);
            this.restartFrameSupportedContextKey.set(session ? !!session.capabilities.supportsRestartFrame : false);
            this.stepIntoTargetsSupported.set(session ? !!session.capabilities.supportsStepInTargetsRequest : false);
            this.jumpToCursorSupported.set(session ? !!session.capabilities.supportsGotoTargetsRequest : false);
            this.setVariableSupported.set(session ? !!session.capabilities.supportsSetVariable : false);
            this.setExpressionSupported.set(session ? !!session.capabilities.supportsSetExpression : false);
            this.terminateDebuggeeSupported.set(session ? !!session.capabilities.supportTerminateDebuggee : false);
            this.suspendDebuggeeSupported.set(session ? !!session.capabilities.supportSuspendDebuggee : false);
            this.disassembleRequestSupported.set(!!session?.capabilities.supportsDisassembleRequest);
            this.focusedStackFrameHasInstructionPointerReference.set(!!stackFrame?.instructionPointerReference);
            const attach = !!session && isSessionAttach(session);
            this.focusedSessionIsAttach.set(attach);
        });
        if (shouldEmitForSession) {
            this._onDidFocusSession.fire(session);
        }
        if (shouldEmitForStackFrame) {
            this._onDidFocusStackFrame.fire({ stackFrame, explicit });
        }
    }
    get onDidFocusSession() {
        return this._onDidFocusSession.event;
    }
    get onDidFocusStackFrame() {
        return this._onDidFocusStackFrame.event;
    }
    getSelectedExpression() {
        return this.selectedExpression;
    }
    setSelectedExpression(expression, settingWatch) {
        this.selectedExpression = expression ? { expression, settingWatch: settingWatch } : undefined;
        this.expressionSelectedContextKey.set(!!expression);
        this._onDidSelectExpression.fire(this.selectedExpression);
    }
    get onDidSelectExpression() {
        return this._onDidSelectExpression.event;
    }
    get onDidEvaluateLazyExpression() {
        return this._onDidEvaluateLazyExpression.event;
    }
    updateViews() {
        this._onWillUpdateViews.fire();
    }
    get onWillUpdateViews() {
        return this._onWillUpdateViews.event;
    }
    isMultiSessionView() {
        return !!this.multiSessionDebug.get();
    }
    setMultiSessionView(isMultiSessionView) {
        this.multiSessionDebug.set(isMultiSessionView);
    }
    async evaluateLazyExpression(expression) {
        await expression.evaluateLazy();
        this._onDidEvaluateLazyExpression.fire(expression);
    }
}
let DebugService = class DebugService {
    constructor(editorService, paneCompositeService, viewsService, viewDescriptorService, notificationService, dialogService, layoutService, contextService, contextKeyService, lifecycleService, instantiationService, extensionService, fileService, configurationService, extensionHostDebugService, activityService, commandService, quickInputService, workspaceTrustRequestService, uriIdentityService) {
        this.editorService = editorService;
        this.paneCompositeService = paneCompositeService;
        this.viewsService = viewsService;
        this.viewDescriptorService = viewDescriptorService;
        this.notificationService = notificationService;
        this.dialogService = dialogService;
        this.layoutService = layoutService;
        this.contextService = contextService;
        this.contextKeyService = contextKeyService;
        this.lifecycleService = lifecycleService;
        this.instantiationService = instantiationService;
        this.extensionService = extensionService;
        this.fileService = fileService;
        this.configurationService = configurationService;
        this.extensionHostDebugService = extensionHostDebugService;
        this.activityService = activityService;
        this.commandService = commandService;
        this.quickInputService = quickInputService;
        this.workspaceTrustRequestService = workspaceTrustRequestService;
        this.uriIdentityService = uriIdentityService;
        this.disposables = ( (new DisposableStore()));
        this.initializing = false;
        this.sessionCancellationTokens = ( (new Map()));
        this.haveDoneLazySetup = false;
        this.breakpointsToSendOnResourceSaved = ( (new Set()));
        this._onDidChangeState = ( (new Emitter()));
        this._onDidNewSession = ( (new Emitter()));
        this._onWillNewSession = ( (new Emitter()));
        this._onDidEndSession = ( (new Emitter()));
        this.adapterManager = this.instantiationService.createInstance(AdapterManager, { onDidNewSession: this.onDidNewSession });
        this.disposables.add(this.adapterManager);
        this.configurationManager = this.instantiationService.createInstance(ConfigurationManager, this.adapterManager);
        this.disposables.add(this.configurationManager);
        this.debugStorage = this.instantiationService.createInstance(DebugStorage);
        this.chosenEnvironments = this.debugStorage.loadChosenEnvironments();
        this.model = this.instantiationService.createInstance(DebugModel, this.debugStorage);
        this.telemetry = this.instantiationService.createInstance(DebugTelemetry, this.model);
        this.viewModel = ( (new ViewModel(contextKeyService)));
        this.taskRunner = this.instantiationService.createInstance(DebugTaskRunner);
        this.disposables.add(this.fileService.onDidFilesChange(e => this.onFileChanges(e)));
        this.disposables.add(this.lifecycleService.onWillShutdown(this.dispose, this));
        this.disposables.add(this.extensionHostDebugService.onAttachSession(event => {
            const session = this.model.getSession(event.sessionId, true);
            if (session) {
                session.configuration.request = 'attach';
                session.configuration.port = event.port;
                session.setSubId(event.subId);
                this.launchOrAttachToSession(session);
            }
        }));
        this.disposables.add(this.extensionHostDebugService.onTerminateSession(event => {
            const session = this.model.getSession(event.sessionId);
            if (session && session.subId === event.subId) {
                session.disconnect();
            }
        }));
        this.disposables.add(this.viewModel.onDidFocusStackFrame(() => {
            this.onStateChange();
        }));
        this.disposables.add(this.viewModel.onDidFocusSession((session) => {
            this.onStateChange();
            if (session) {
                this.setExceptionBreakpointFallbackSession(session.getId());
            }
        }));
        this.disposables.add(Event.any(this.adapterManager.onDidRegisterDebugger, this.configurationManager.onDidSelectConfiguration)(() => {
            const debugUxValue = (this.state !== 0  || (this.configurationManager.getAllConfigurations().length > 0 && this.adapterManager.hasEnabledDebuggers())) ? 'default' : 'simple';
            this.debugUx.set(debugUxValue);
            this.debugStorage.storeDebugUxState(debugUxValue);
        }));
        this.disposables.add(this.model.onDidChangeCallStack(() => {
            const numberOfSessions = this.model.getSessions().filter(s => !s.parentSession).length;
            this.activity?.dispose();
            if (numberOfSessions > 0) {
                const viewContainer = this.viewDescriptorService.getViewContainerByViewId(CALLSTACK_VIEW_ID);
                if (viewContainer) {
                    this.activity = this.activityService.showViewContainerActivity(viewContainer.id, { badge: ( (new NumberBadge(
                        numberOfSessions,
                        n => n === 1 ? ( (localize('1activeSession', "1 active session"))) : ( (localize('nActiveSessions', "{0} active sessions", n)))
                    ))) });
                }
            }
        }));
        this.disposables.add(editorService.onDidActiveEditorChange(() => {
            this.contextKeyService.bufferChangeEvents(() => {
                if (editorService.activeEditor === DisassemblyViewInput.instance) {
                    this.disassemblyViewFocus.set(true);
                }
                else {
                    this.disassemblyViewFocus?.reset();
                }
            });
        }));
        this.disposables.add(this.lifecycleService.onBeforeShutdown(() => {
            for (const editor of editorService.editors) {
                if (editor.resource?.scheme === DEBUG_MEMORY_SCHEME) {
                    editor.dispose();
                }
            }
        }));
        this.initContextKeys(contextKeyService);
    }
    initContextKeys(contextKeyService) {
        queueMicrotask(() => {
            contextKeyService.bufferChangeEvents(() => {
                this.debugType = CONTEXT_DEBUG_TYPE.bindTo(contextKeyService);
                this.debugState = CONTEXT_DEBUG_STATE.bindTo(contextKeyService);
                this.hasDebugged = CONTEXT_HAS_DEBUGGED.bindTo(contextKeyService);
                this.inDebugMode = CONTEXT_IN_DEBUG_MODE.bindTo(contextKeyService);
                this.debugUx = CONTEXT_DEBUG_UX.bindTo(contextKeyService);
                this.debugUx.set(this.debugStorage.loadDebugUxState());
                this.breakpointsExist = CONTEXT_BREAKPOINTS_EXIST.bindTo(contextKeyService);
                this.disassemblyViewFocus = CONTEXT_DISASSEMBLY_VIEW_FOCUS.bindTo(contextKeyService);
            });
            const setBreakpointsExistContext = () => this.breakpointsExist.set(!!(this.model.getBreakpoints().length || this.model.getDataBreakpoints().length || this.model.getFunctionBreakpoints().length));
            setBreakpointsExistContext();
            this.disposables.add(this.model.onDidChangeBreakpoints(() => setBreakpointsExistContext()));
        });
    }
    getModel() {
        return this.model;
    }
    getViewModel() {
        return this.viewModel;
    }
    getConfigurationManager() {
        return this.configurationManager;
    }
    getAdapterManager() {
        return this.adapterManager;
    }
    sourceIsNotAvailable(uri) {
        this.model.sourceIsNotAvailable(uri);
    }
    dispose() {
        this.disposables.dispose();
    }
    get state() {
        const focusedSession = this.viewModel.focusedSession;
        if (focusedSession) {
            return focusedSession.state;
        }
        return this.initializing ? 1  : 0 ;
    }
    get initializingOptions() {
        return this._initializingOptions;
    }
    startInitializingState(options) {
        if (!this.initializing) {
            this.initializing = true;
            this._initializingOptions = options;
            this.onStateChange();
        }
    }
    endInitializingState() {
        if (this.initializing) {
            this.initializing = false;
            this._initializingOptions = undefined;
            this.onStateChange();
        }
    }
    cancelTokens(id) {
        if (id) {
            const token = this.sessionCancellationTokens.get(id);
            if (token) {
                token.cancel();
                this.sessionCancellationTokens.delete(id);
            }
        }
        else {
            this.sessionCancellationTokens.forEach(t => t.cancel());
            this.sessionCancellationTokens.clear();
        }
    }
    onStateChange() {
        const state = this.state;
        if (this.previousState !== state) {
            this.contextKeyService.bufferChangeEvents(() => {
                this.debugState.set(getStateLabel(state));
                this.inDebugMode.set(state !== 0 );
                const debugUxValue = (((state !== 0  && state !== 1) ) || (this.adapterManager.hasEnabledDebuggers() && this.configurationManager.selectedConfiguration.name)) ? 'default' : 'simple';
                this.debugUx.set(debugUxValue);
                this.debugStorage.storeDebugUxState(debugUxValue);
            });
            this.previousState = state;
            this._onDidChangeState.fire(state);
        }
    }
    get onDidChangeState() {
        return this._onDidChangeState.event;
    }
    get onDidNewSession() {
        return this._onDidNewSession.event;
    }
    get onWillNewSession() {
        return this._onWillNewSession.event;
    }
    get onDidEndSession() {
        return this._onDidEndSession.event;
    }
    lazySetup() {
        if (!this.haveDoneLazySetup) {
            this.disposables.add(this.fileService.registerProvider(DEBUG_MEMORY_SCHEME, ( (new DebugMemoryFileSystemProvider(this)))));
            this.haveDoneLazySetup = true;
        }
    }
    async startDebugging(launch, configOrName, options, saveBeforeStart = !options?.parentSession) {
        const message = options && options.noDebug ? ( (localize(
            'runTrust',
            "Running executes build tasks and program code from your workspace."
        ))) : ( (localize(
            'debugTrust',
            "Debugging executes build tasks and program code from your workspace."
        )));
        const trust = await this.workspaceTrustRequestService.requestWorkspaceTrust({ message });
        if (!trust) {
            return false;
        }
        this.lazySetup();
        this.startInitializingState(options);
        this.hasDebugged.set(true);
        try {
            await this.extensionService.activateByEvent('onDebug');
            if (saveBeforeStart) {
                await saveAllBeforeDebugStart(this.configurationService, this.editorService);
            }
            await this.extensionService.whenInstalledExtensionsRegistered();
            let config;
            let compound;
            if (!configOrName) {
                configOrName = this.configurationManager.selectedConfiguration.name;
            }
            if (typeof configOrName === 'string' && launch) {
                config = launch.getConfiguration(configOrName);
                compound = launch.getCompound(configOrName);
            }
            else if (typeof configOrName !== 'string') {
                config = configOrName;
            }
            if (compound) {
                if (!compound.configurations) {
                    throw new Error(localize({ key: 'compoundMustHaveConfigurations', comment: ['compound indicates a "compounds" configuration item', '"configurations" is an attribute and should not be localized'] }, "Compound must have \"configurations\" attribute set in order to start multiple configurations."));
                }
                if (compound.preLaunchTask) {
                    const taskResult = await this.taskRunner.runTaskAndCheckErrors(launch?.workspace || this.contextService.getWorkspace(), compound.preLaunchTask);
                    if (taskResult === 0 ) {
                        this.endInitializingState();
                        return false;
                    }
                }
                if (compound.stopAll) {
                    options = { ...options, compoundRoot: ( (new DebugCompoundRoot())) };
                }
                const values = await Promise.all(( (compound.configurations.map(configData => {
                    const name = typeof configData === 'string' ? configData : configData.name;
                    if (name === compound.name) {
                        return Promise.resolve(false);
                    }
                    let launchForName;
                    if (typeof configData === 'string') {
                        const launchesContainingName = this.configurationManager.getLaunches().filter(l => !!l.getConfiguration(name));
                        if (launchesContainingName.length === 1) {
                            launchForName = launchesContainingName[0];
                        }
                        else if (launch && launchesContainingName.length > 1 && launchesContainingName.indexOf(launch) >= 0) {
                            launchForName = launch;
                        }
                        else {
                            throw new Error(launchesContainingName.length === 0 ? localize('noConfigurationNameInWorkspace', "Could not find launch configuration '{0}' in the workspace.", name)
                                : localize('multipleConfigurationNamesInWorkspace', "There are multiple launch configurations '{0}' in the workspace. Use folder name to qualify the configuration.", name));
                        }
                    }
                    else if (configData.folder) {
                        const launchesMatchingConfigData = this.configurationManager.getLaunches().filter(l => l.workspace && l.workspace.name === configData.folder && !!l.getConfiguration(configData.name));
                        if (launchesMatchingConfigData.length === 1) {
                            launchForName = launchesMatchingConfigData[0];
                        }
                        else {
                            throw new Error(localize('noFolderWithName', "Can not find folder with name '{0}' for configuration '{1}' in compound '{2}'.", configData.folder, configData.name, compound.name));
                        }
                    }
                    return this.createSession(launchForName, launchForName.getConfiguration(name), options);
                }))));
                const result = values.every(success => !!success);
                this.endInitializingState();
                return result;
            }
            if (configOrName && !config) {
                const message = !!launch ? ( (localize(
                    'configMissing',
                    "Configuration '{0}' is missing in 'launch.json'.",
                    typeof configOrName === 'string' ? configOrName : configOrName.name
                ))) :
                    ( (localize(
                    'launchJsonDoesNotExist',
                    "'launch.json' does not exist for passed workspace folder."
                )));
                throw new Error(message);
            }
            const result = await this.createSession(launch, config, options);
            this.endInitializingState();
            return result;
        }
        catch (err) {
            this.notificationService.error(err);
            this.endInitializingState();
            return Promise.reject(err);
        }
    }
    async createSession(launch, config, options) {
        let type;
        if (config) {
            type = config.type;
        }
        else {
            config = Object.create(null);
        }
        if (options && options.noDebug) {
            config.noDebug = true;
        }
        else if (options && typeof options.noDebug === 'undefined' && options.parentSession && options.parentSession.configuration.noDebug) {
            config.noDebug = true;
        }
        const unresolvedConfig = deepClone(config);
        let guess;
        let activeEditor;
        if (!type) {
            activeEditor = this.editorService.activeEditor;
            if (activeEditor && activeEditor.resource) {
                type = this.chosenEnvironments[( (activeEditor.resource.toString()))];
            }
            if (!type) {
                guess = await this.adapterManager.guessDebugger(false);
                if (guess) {
                    type = guess.type;
                }
            }
        }
        const initCancellationToken = ( (new CancellationTokenSource()));
        const sessionId = generateUuid();
        this.sessionCancellationTokens.set(sessionId, initCancellationToken);
        const configByProviders = await this.configurationManager.resolveConfigurationByProviders(launch && launch.workspace ? launch.workspace.uri : undefined, type, config, initCancellationToken.token);
        if (configByProviders && configByProviders.type) {
            try {
                let resolvedConfig = await this.substituteVariables(launch, configByProviders);
                if (!resolvedConfig) {
                    return false;
                }
                if (initCancellationToken.token.isCancellationRequested) {
                    return false;
                }
                const workspace = launch?.workspace || this.contextService.getWorkspace();
                const taskResult = await this.taskRunner.runTaskAndCheckErrors(workspace, resolvedConfig.preLaunchTask);
                if (taskResult === 0 ) {
                    return false;
                }
                const cfg = await this.configurationManager.resolveDebugConfigurationWithSubstitutedVariables(launch && launch.workspace ? launch.workspace.uri : undefined, type, resolvedConfig, initCancellationToken.token);
                if (!cfg) {
                    if (launch && type && cfg === null && !initCancellationToken.token.isCancellationRequested) {
                        await launch.openConfigFile({ preserveFocus: true, type }, initCancellationToken.token);
                    }
                    return false;
                }
                resolvedConfig = cfg;
                const dbg = this.adapterManager.getDebugger(resolvedConfig.type);
                if (!dbg || (configByProviders.request !== 'attach' && configByProviders.request !== 'launch')) {
                    let message;
                    if (configByProviders.request !== 'attach' && configByProviders.request !== 'launch') {
                        message = configByProviders.request ? ( (localize(
                            'debugRequestNotSupported',
                            "Attribute '{0}' has an unsupported value '{1}' in the chosen debug configuration.",
                            'request',
                            configByProviders.request
                        )))
                            : ( (localize(
                            'debugRequesMissing',
                            "Attribute '{0}' is missing from the chosen debug configuration.",
                            'request'
                        )));
                    }
                    else {
                        message = resolvedConfig.type ? ( (localize(
                            'debugTypeNotSupported',
                            "Configured debug type '{0}' is not supported.",
                            resolvedConfig.type
                        ))) :
                            ( (localize(
                            'debugTypeMissing',
                            "Missing property 'type' for the chosen launch configuration."
                        )));
                    }
                    const actionList = [];
                    actionList.push(( (new Action('installAdditionalDebuggers',  (localize(
                        { key: 'installAdditionalDebuggers', comment: ['Placeholder is the debug type, so for example "node", "python"'] },
                        "Install {0} Extension",
                        resolvedConfig.type
                    )), undefined, true, async () => this.commandService.executeCommand('debug.installAdditionalDebuggers', resolvedConfig?.type)))));
                    await this.showError(message, actionList);
                    return false;
                }
                if (!dbg.enabled) {
                    await this.showError(debuggerDisabledMessage(dbg.type), []);
                    return false;
                }
                const result = await this.doCreateSession(sessionId, launch?.workspace, { resolved: resolvedConfig, unresolved: unresolvedConfig }, options);
                if (result && guess && activeEditor && activeEditor.resource) {
                    this.chosenEnvironments[( (activeEditor.resource.toString()))] = guess.type;
                    this.debugStorage.storeChosenEnvironments(this.chosenEnvironments);
                }
                return result;
            }
            catch (err) {
                if (err && err.message) {
                    await this.showError(err.message);
                }
                else if (this.contextService.getWorkbenchState() === 1 ) {
                    await this.showError(( (localize(
                        'noFolderWorkspaceDebugError',
                        "The active file can not be debugged. Make sure it is saved and that you have a debug extension installed for that file type."
                    ))));
                }
                if (launch && !initCancellationToken.token.isCancellationRequested) {
                    await launch.openConfigFile({ preserveFocus: true }, initCancellationToken.token);
                }
                return false;
            }
        }
        if (launch && type && configByProviders === null && !initCancellationToken.token.isCancellationRequested) {
            await launch.openConfigFile({ preserveFocus: true, type }, initCancellationToken.token);
        }
        return false;
    }
    async doCreateSession(sessionId, root, configuration, options) {
        const session = this.instantiationService.createInstance(DebugSession, sessionId, configuration, root, this.model, options);
        if (options?.startedByUser && this.model.getSessions().some(s => s.getLabel() === session.getLabel()) && configuration.resolved.suppressMultipleSessionWarning !== true) {
            const result = await this.dialogService.confirm({ message: ( (localize(
                'multipleSession',
                "'{0}' is already running. Do you want to start another instance?",
                session.getLabel()
            ))) });
            if (!result.confirmed) {
                return false;
            }
        }
        this.model.addSession(session);
        this.registerSessionListeners(session);
        this._onWillNewSession.fire(session);
        const openDebug = this.configurationService.getValue('debug').openDebug;
        if (!configuration.resolved.noDebug && (openDebug === 'openOnSessionStart' || (openDebug !== 'neverOpen' && this.viewModel.firstSessionStart)) && !session.suppressDebugView) {
            await this.paneCompositeService.openPaneComposite(VIEWLET_ID$1, 0 );
        }
        try {
            await this.launchOrAttachToSession(session);
            const internalConsoleOptions = session.configuration.internalConsoleOptions || this.configurationService.getValue('debug').internalConsoleOptions;
            if (internalConsoleOptions === 'openOnSessionStart' || (this.viewModel.firstSessionStart && internalConsoleOptions === 'openOnFirstSessionStart')) {
                this.viewsService.openView(REPL_VIEW_ID, false);
            }
            this.viewModel.firstSessionStart = false;
            const showSubSessions = this.configurationService.getValue('debug').showSubSessionsInToolBar;
            const sessions = this.model.getSessions();
            const shownSessions = showSubSessions ? sessions : sessions.filter(s => !s.parentSession);
            if (shownSessions.length > 1) {
                this.viewModel.setMultiSessionView(true);
            }
            this._onDidNewSession.fire(session);
            return true;
        }
        catch (error) {
            if (isCancellationError(error)) {
                return false;
            }
            if (session && session.getReplElements().length > 0) {
                this.viewsService.openView(REPL_VIEW_ID, false);
            }
            if (session.configuration && session.configuration.request === 'attach' && session.configuration.__autoAttach) {
                return false;
            }
            const errorMessage = error instanceof Error ? error.message : error;
            if (error.showUser !== false) {
                await this.showError(errorMessage, isErrorWithActions(error) ? error.actions : []);
            }
            return false;
        }
    }
    async launchOrAttachToSession(session, forceFocus = false) {
        const dbgr = this.adapterManager.getDebugger(session.configuration.type);
        try {
            await session.initialize(dbgr);
            await session.launchOrAttach(session.configuration);
            const launchJsonExists = !!session.root && !!this.configurationService.getValue('launch', { resource: session.root.uri });
            await this.telemetry.logDebugSessionStart(dbgr, launchJsonExists);
            if (forceFocus || !this.viewModel.focusedSession || (session.parentSession === this.viewModel.focusedSession && session.compact)) {
                await this.focusStackFrame(undefined, undefined, session);
            }
        }
        catch (err) {
            if (this.viewModel.focusedSession === session) {
                await this.focusStackFrame(undefined);
            }
            return Promise.reject(err);
        }
    }
    registerSessionListeners(session) {
        const sessionRunningScheduler = ( (new RunOnceScheduler(() => {
            if (session.state === 3  && this.viewModel.focusedSession === session) {
                this.viewModel.setFocus(undefined, this.viewModel.focusedThread, session, false);
            }
        }, 200)));
        this.disposables.add(session.onDidChangeState(() => {
            if (session.state === 3  && this.viewModel.focusedSession === session) {
                sessionRunningScheduler.schedule();
            }
            if (session === this.viewModel.focusedSession) {
                this.onStateChange();
            }
        }));
        this.disposables.add(session.onDidEndAdapter(async (adapterExitEvent) => {
            if (adapterExitEvent) {
                if (adapterExitEvent.error) {
                    this.notificationService.error(( (localize(
                        'debugAdapterCrash',
                        "Debug adapter process has terminated unexpectedly ({0})",
                        adapterExitEvent.error.message || ( (adapterExitEvent.error.toString()))
                    ))));
                }
                this.telemetry.logDebugSessionStop(session, adapterExitEvent);
            }
            const extensionDebugSession = getExtensionHostDebugSession(session);
            if (extensionDebugSession && extensionDebugSession.state === 3  && extensionDebugSession.configuration.noDebug) {
                this.extensionHostDebugService.close(extensionDebugSession.getId());
            }
            if (session.configuration.postDebugTask) {
                const root = session.root ?? this.contextService.getWorkspace();
                try {
                    await this.taskRunner.runTask(root, session.configuration.postDebugTask);
                }
                catch (err) {
                    this.notificationService.error(err);
                }
            }
            this.endInitializingState();
            this.cancelTokens(session.getId());
            this._onDidEndSession.fire(session);
            const focusedSession = this.viewModel.focusedSession;
            if (focusedSession && focusedSession.getId() === session.getId()) {
                const { session, thread, stackFrame } = getStackFrameThreadAndSessionToFocus(this.model, undefined, undefined, undefined, focusedSession);
                this.viewModel.setFocus(stackFrame, thread, session, false);
            }
            if (this.model.getSessions().length === 0) {
                this.viewModel.setMultiSessionView(false);
                if (this.layoutService.isVisible("workbench.parts.sidebar" ) && this.configurationService.getValue('debug').openExplorerOnEnd) {
                    this.paneCompositeService.openPaneComposite(VIEWLET_ID, 0 );
                }
                const dataBreakpoints = this.model.getDataBreakpoints().filter(dbp => !dbp.canPersist);
                dataBreakpoints.forEach(dbp => this.model.removeDataBreakpoints(dbp.getId()));
                if (this.configurationService.getValue('debug').console.closeOnEnd) {
                    const debugConsoleContainer = this.viewDescriptorService.getViewContainerByViewId(REPL_VIEW_ID);
                    if (debugConsoleContainer && this.viewsService.isViewContainerVisible(debugConsoleContainer.id)) {
                        this.viewsService.closeViewContainer(debugConsoleContainer.id);
                    }
                }
            }
            this.model.removeExceptionBreakpointsForSession(session.getId());
        }));
    }
    async restartSession(session, restartData) {
        if (session.saveBeforeRestart) {
            await saveAllBeforeDebugStart(this.configurationService, this.editorService);
        }
        const isAutoRestart = !!restartData;
        const runTasks = async () => {
            if (isAutoRestart) {
                return Promise.resolve(1 );
            }
            const root = session.root || this.contextService.getWorkspace();
            await this.taskRunner.runTask(root, session.configuration.preRestartTask);
            await this.taskRunner.runTask(root, session.configuration.postDebugTask);
            const taskResult1 = await this.taskRunner.runTaskAndCheckErrors(root, session.configuration.preLaunchTask);
            if (taskResult1 !== 1 ) {
                return taskResult1;
            }
            return this.taskRunner.runTaskAndCheckErrors(root, session.configuration.postRestartTask);
        };
        const extensionDebugSession = getExtensionHostDebugSession(session);
        if (extensionDebugSession) {
            const taskResult = await runTasks();
            if (taskResult === 1 ) {
                this.extensionHostDebugService.reload(extensionDebugSession.getId());
            }
            return;
        }
        let needsToSubstitute = false;
        let unresolved;
        const launch = session.root ? this.configurationManager.getLaunch(session.root.uri) : undefined;
        if (launch) {
            unresolved = launch.getConfiguration(session.configuration.name);
            if (unresolved && !equals(unresolved, session.unresolvedConfiguration)) {
                unresolved.type = session.configuration.type;
                unresolved.noDebug = session.configuration.noDebug;
                needsToSubstitute = true;
            }
        }
        let resolved = session.configuration;
        if (launch && needsToSubstitute && unresolved) {
            const initCancellationToken = ( (new CancellationTokenSource()));
            this.sessionCancellationTokens.set(session.getId(), initCancellationToken);
            const resolvedByProviders = await this.configurationManager.resolveConfigurationByProviders(launch.workspace ? launch.workspace.uri : undefined, unresolved.type, unresolved, initCancellationToken.token);
            if (resolvedByProviders) {
                resolved = await this.substituteVariables(launch, resolvedByProviders);
                if (resolved && !initCancellationToken.token.isCancellationRequested) {
                    resolved = await this.configurationManager.resolveDebugConfigurationWithSubstitutedVariables(launch && launch.workspace ? launch.workspace.uri : undefined, unresolved.type, resolved, initCancellationToken.token);
                }
            }
            else {
                resolved = resolvedByProviders;
            }
        }
        if (resolved) {
            session.setConfiguration({ resolved, unresolved });
        }
        session.configuration.__restart = restartData;
        if (session.capabilities.supportsRestartRequest) {
            const taskResult = await runTasks();
            if (taskResult === 1 ) {
                await session.restart();
            }
            return;
        }
        const shouldFocus = !!this.viewModel.focusedSession && session.getId() === this.viewModel.focusedSession.getId();
        if (isAutoRestart) {
            await session.disconnect(true);
        }
        else {
            await session.terminate(true);
        }
        return (
             (new Promise((c, e) => {
                setTimeout(async () => {
                    const taskResult = await runTasks();
                    if (taskResult !== 1 ) {
                        return;
                    }
                    if (!resolved) {
                        return c(undefined);
                    }
                    try {
                        await this.launchOrAttachToSession(session, shouldFocus);
                        this._onDidNewSession.fire(session);
                        c(undefined);
                    }
                    catch (error) {
                        e(error);
                    }
                }, 300);
            }))
        );
    }
    async stopSession(session, disconnect = false, suspend = false) {
        if (session) {
            return disconnect ? session.disconnect(undefined, suspend) : session.terminate();
        }
        const sessions = this.model.getSessions();
        if (sessions.length === 0) {
            this.taskRunner.cancel();
            await this.quickInputService.cancel();
            this.endInitializingState();
            this.cancelTokens(undefined);
        }
        return Promise.all(( (sessions.map(s => disconnect ? s.disconnect(undefined, suspend) : s.terminate()))));
    }
    async substituteVariables(launch, config) {
        const dbg = this.adapterManager.getDebugger(config.type);
        if (dbg) {
            let folder = undefined;
            if (launch && launch.workspace) {
                folder = launch.workspace;
            }
            else {
                const folders = this.contextService.getWorkspace().folders;
                if (folders.length === 1) {
                    folder = folders[0];
                }
            }
            try {
                return await dbg.substituteVariables(folder, config);
            }
            catch (err) {
                this.showError(err.message, undefined, !!launch?.getConfiguration(config.name));
                return undefined;
            }
        }
        return Promise.resolve(config);
    }
    async showError(message, errorActions = [], promptLaunchJson = true) {
        const configureAction = ( (new Action(
            DEBUG_CONFIGURE_COMMAND_ID,
            DEBUG_CONFIGURE_LABEL,
            undefined,
            true,
            () => this.commandService.executeCommand(DEBUG_CONFIGURE_COMMAND_ID)
        )));
        const actions = errorActions.filter((action) => action.id.endsWith('.command')).length > 0 ?
            errorActions :
            [...errorActions, ...(promptLaunchJson ? [configureAction] : [])];
        await this.dialogService.prompt({
            type: Severity$1.Error,
            message,
            buttons: ( (actions.map(action => ({
                label: action.label,
                run: () => action.run()
            })))),
            cancelButton: true
        });
    }
    async focusStackFrame(_stackFrame, _thread, _session, options) {
        const { stackFrame, thread, session } = getStackFrameThreadAndSessionToFocus(this.model, _stackFrame, _thread, _session);
        if (stackFrame) {
            const editor = await stackFrame.openInEditor(this.editorService, options?.preserveFocus ?? true, options?.sideBySide, options?.pinned);
            if (editor) {
                if (editor.input === DisassemblyViewInput.instance) ;
                else {
                    const control = editor.getControl();
                    if (stackFrame && isCodeEditor(control) && control.hasModel()) {
                        const model = control.getModel();
                        const lineNumber = stackFrame.range.startLineNumber;
                        if (lineNumber >= 1 && lineNumber <= model.getLineCount()) {
                            const lineContent = control.getModel().getLineContent(lineNumber);
                            alert(( (localize(
                                { key: 'debuggingPaused', comment: ['First placeholder is the file line content, second placeholder is the reason why debugging is stopped, for example "breakpoint", third is the stack frame name, and last is the line number.'] },
                                "{0}, debugging paused {1}, {2}:{3}",
                                lineContent,
                                thread && thread.stoppedDetails ? `, reason ${thread.stoppedDetails.reason}` : '',
                                stackFrame.source ? stackFrame.source.name : '',
                                stackFrame.range.startLineNumber
                            ))));
                        }
                    }
                }
            }
        }
        if (session) {
            this.debugType.set(session.configuration.type);
        }
        else {
            this.debugType.reset();
        }
        this.viewModel.setFocus(stackFrame, thread, session, !!options?.explicit);
    }
    addWatchExpression(name) {
        const we = this.model.addWatchExpression(name);
        if (!name) {
            this.viewModel.setSelectedExpression(we, false);
        }
        this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
    }
    renameWatchExpression(id, newName) {
        this.model.renameWatchExpression(id, newName);
        this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
    }
    moveWatchExpression(id, position) {
        this.model.moveWatchExpression(id, position);
        this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
    }
    removeWatchExpressions(id) {
        this.model.removeWatchExpressions(id);
        this.debugStorage.storeWatchExpressions(this.model.getWatchExpressions());
    }
    canSetBreakpointsIn(model) {
        return this.adapterManager.canSetBreakpointsIn(model);
    }
    async enableOrDisableBreakpoints(enable, breakpoint) {
        if (breakpoint) {
            this.model.setEnablement(breakpoint, enable);
            this.debugStorage.storeBreakpoints(this.model);
            if (breakpoint instanceof Breakpoint) {
                await this.sendBreakpoints(breakpoint.uri);
            }
            else if (breakpoint instanceof FunctionBreakpoint) {
                await this.sendFunctionBreakpoints();
            }
            else if (breakpoint instanceof DataBreakpoint) {
                await this.sendDataBreakpoints();
            }
            else if (breakpoint instanceof InstructionBreakpoint) {
                await this.sendInstructionBreakpoints();
            }
            else {
                await this.sendExceptionBreakpoints();
            }
        }
        else {
            this.model.enableOrDisableAllBreakpoints(enable);
            this.debugStorage.storeBreakpoints(this.model);
            await this.sendAllBreakpoints();
        }
        this.debugStorage.storeBreakpoints(this.model);
    }
    async addBreakpoints(uri, rawBreakpoints, ariaAnnounce = true) {
        const breakpoints = this.model.addBreakpoints(uri, rawBreakpoints);
        if (ariaAnnounce) {
            breakpoints.forEach(bp => status(( (localize(
                'breakpointAdded',
                "Added breakpoint, line {0}, file {1}",
                bp.lineNumber,
                uri.fsPath
            )))));
        }
        this.debugStorage.storeBreakpoints(this.model);
        await this.sendBreakpoints(uri);
        this.debugStorage.storeBreakpoints(this.model);
        return breakpoints;
    }
    async updateBreakpoints(uri, data, sendOnResourceSaved) {
        this.model.updateBreakpoints(data);
        this.debugStorage.storeBreakpoints(this.model);
        if (sendOnResourceSaved) {
            this.breakpointsToSendOnResourceSaved.add(uri);
        }
        else {
            await this.sendBreakpoints(uri);
            this.debugStorage.storeBreakpoints(this.model);
        }
    }
    async removeBreakpoints(id) {
        const toRemove = this.model.getBreakpoints().filter(bp => !id || bp.getId() === id);
        toRemove.forEach(bp => status(( (localize(
            'breakpointRemoved',
            "Removed breakpoint, line {0}, file {1}",
            bp.lineNumber,
            bp.uri.fsPath
        )))));
        const urisToClear = ( (distinct(toRemove, bp => ( (bp.uri.toString()))).map(bp => bp.uri)));
        this.model.removeBreakpoints(toRemove);
        this.debugStorage.storeBreakpoints(this.model);
        await Promise.all(( (urisToClear.map(uri => this.sendBreakpoints(uri)))));
    }
    setBreakpointsActivated(activated) {
        this.model.setBreakpointsActivated(activated);
        return this.sendAllBreakpoints();
    }
    addFunctionBreakpoint(name, id) {
        this.model.addFunctionBreakpoint(name || '', id);
    }
    async updateFunctionBreakpoint(id, update) {
        this.model.updateFunctionBreakpoint(id, update);
        this.debugStorage.storeBreakpoints(this.model);
        await this.sendFunctionBreakpoints();
    }
    async removeFunctionBreakpoints(id) {
        this.model.removeFunctionBreakpoints(id);
        this.debugStorage.storeBreakpoints(this.model);
        await this.sendFunctionBreakpoints();
    }
    async addDataBreakpoint(label, dataId, canPersist, accessTypes, accessType) {
        this.model.addDataBreakpoint(label, dataId, canPersist, accessTypes, accessType);
        this.debugStorage.storeBreakpoints(this.model);
        await this.sendDataBreakpoints();
        this.debugStorage.storeBreakpoints(this.model);
    }
    async removeDataBreakpoints(id) {
        this.model.removeDataBreakpoints(id);
        this.debugStorage.storeBreakpoints(this.model);
        await this.sendDataBreakpoints();
    }
    async addInstructionBreakpoint(address, offset, condition, hitCondition) {
        this.model.addInstructionBreakpoint(address, offset, condition, hitCondition);
        this.debugStorage.storeBreakpoints(this.model);
        await this.sendInstructionBreakpoints();
        this.debugStorage.storeBreakpoints(this.model);
    }
    async removeInstructionBreakpoints(address) {
        this.model.removeInstructionBreakpoints(address);
        this.debugStorage.storeBreakpoints(this.model);
        await this.sendInstructionBreakpoints();
    }
    setExceptionBreakpointFallbackSession(sessionId) {
        this.model.setExceptionBreakpointFallbackSession(sessionId);
        this.debugStorage.storeBreakpoints(this.model);
    }
    setExceptionBreakpointsForSession(session, data) {
        this.model.setExceptionBreakpointsForSession(session.getId(), data);
        this.debugStorage.storeBreakpoints(this.model);
    }
    async setExceptionBreakpointCondition(exceptionBreakpoint, condition) {
        this.model.setExceptionBreakpointCondition(exceptionBreakpoint, condition);
        this.debugStorage.storeBreakpoints(this.model);
        await this.sendExceptionBreakpoints();
    }
    async sendAllBreakpoints(session) {
        const setBreakpointsPromises = ( (distinct(this.model.getBreakpoints(), bp => ( (bp.uri.toString())))
            .map(bp => this.sendBreakpoints(bp.uri, false, session))));
        if (session?.capabilities.supportsConfigurationDoneRequest) {
            await Promise.all([
                ...setBreakpointsPromises,
                this.sendFunctionBreakpoints(session),
                this.sendDataBreakpoints(session),
                this.sendInstructionBreakpoints(session),
                this.sendExceptionBreakpoints(session),
            ]);
        }
        else {
            await Promise.all(setBreakpointsPromises);
            await this.sendFunctionBreakpoints(session);
            await this.sendDataBreakpoints(session);
            await this.sendInstructionBreakpoints(session);
            await this.sendExceptionBreakpoints(session);
        }
    }
    async sendBreakpoints(modelUri, sourceModified = false, session) {
        const breakpointsToSend = this.model.getBreakpoints({ uri: modelUri, enabledOnly: true });
        await sendToOneOrAllSessions(this.model, session, async (s) => {
            if (!s.configuration.noDebug) {
                await s.sendBreakpoints(modelUri, breakpointsToSend, sourceModified);
            }
        });
    }
    async sendFunctionBreakpoints(session) {
        const breakpointsToSend = this.model.getFunctionBreakpoints().filter(fbp => fbp.enabled && this.model.areBreakpointsActivated());
        await sendToOneOrAllSessions(this.model, session, async (s) => {
            if (s.capabilities.supportsFunctionBreakpoints && !s.configuration.noDebug) {
                await s.sendFunctionBreakpoints(breakpointsToSend);
            }
        });
    }
    async sendDataBreakpoints(session) {
        const breakpointsToSend = this.model.getDataBreakpoints().filter(fbp => fbp.enabled && this.model.areBreakpointsActivated());
        await sendToOneOrAllSessions(this.model, session, async (s) => {
            if (s.capabilities.supportsDataBreakpoints && !s.configuration.noDebug) {
                await s.sendDataBreakpoints(breakpointsToSend);
            }
        });
    }
    async sendInstructionBreakpoints(session) {
        const breakpointsToSend = this.model.getInstructionBreakpoints().filter(fbp => fbp.enabled && this.model.areBreakpointsActivated());
        await sendToOneOrAllSessions(this.model, session, async (s) => {
            if (s.capabilities.supportsInstructionBreakpoints && !s.configuration.noDebug) {
                await s.sendInstructionBreakpoints(breakpointsToSend);
            }
        });
    }
    sendExceptionBreakpoints(session) {
        return sendToOneOrAllSessions(this.model, session, async (s) => {
            const enabledExceptionBps = this.model.getExceptionBreakpointsForSession(s.getId()).filter(exb => exb.enabled);
            if (s.capabilities.supportsConfigurationDoneRequest && (!s.capabilities.exceptionBreakpointFilters || s.capabilities.exceptionBreakpointFilters.length === 0)) {
                return;
            }
            if (!s.configuration.noDebug) {
                await s.sendExceptionBreakpoints(enabledExceptionBps);
            }
        });
    }
    onFileChanges(fileChangesEvent) {
        const toRemove = this.model.getBreakpoints().filter(bp => fileChangesEvent.contains(bp.uri, 2 ));
        if (toRemove.length) {
            this.model.removeBreakpoints(toRemove);
        }
        const toSend = [];
        for (const uri of this.breakpointsToSendOnResourceSaved) {
            if (fileChangesEvent.contains(uri, 0 )) {
                toSend.push(uri);
            }
        }
        for (const uri of toSend) {
            this.breakpointsToSendOnResourceSaved.delete(uri);
            this.sendBreakpoints(uri, true);
        }
    }
    async runTo(uri, lineNumber, column) {
        let breakpointToRemove;
        let threadToContinue = this.getViewModel().focusedThread;
        const addTempBreakPoint = async () => {
            const bpExists = !!(this.getModel().getBreakpoints({ column, lineNumber, uri }).length);
            if (!bpExists) {
                const addResult = await this.addAndValidateBreakpoints(uri, lineNumber, column);
                if (addResult.thread) {
                    threadToContinue = addResult.thread;
                }
                if (addResult.breakpoint) {
                    breakpointToRemove = addResult.breakpoint;
                }
            }
            return { threadToContinue, breakpointToRemove };
        };
        const removeTempBreakPoint = (state) => {
            if (state === 2  || state === 0 ) {
                if (breakpointToRemove) {
                    this.removeBreakpoints(breakpointToRemove.getId());
                }
                return true;
            }
            return false;
        };
        await addTempBreakPoint();
        if (this.state === 0 ) {
            const { launch, name, getConfig } = this.getConfigurationManager().selectedConfiguration;
            const config = await getConfig();
            const configOrName = config ? Object.assign(deepClone(config), {}) : name;
            const listener = this.onDidChangeState(state => {
                if (removeTempBreakPoint(state)) {
                    listener.dispose();
                }
            });
            await this.startDebugging(launch, configOrName, undefined, true);
        }
        if (this.state === 2 ) {
            const focusedSession = this.getViewModel().focusedSession;
            if (!focusedSession || !threadToContinue) {
                return;
            }
            const listener = threadToContinue.session.onDidChangeState(() => {
                if (removeTempBreakPoint(focusedSession.state)) {
                    listener.dispose();
                }
            });
            await threadToContinue.continue();
        }
    }
    async addAndValidateBreakpoints(uri, lineNumber, column) {
        const debugModel = this.getModel();
        const viewModel = this.getViewModel();
        const breakpoints = await this.addBreakpoints(uri, [{ lineNumber, column }], false);
        const breakpoint = breakpoints?.[0];
        if (!breakpoint) {
            return { breakpoint: undefined, thread: viewModel.focusedThread };
        }
        if (!breakpoint.verified) {
            let listener;
            await raceTimeout(( (new Promise(resolve => {
                listener = debugModel.onDidChangeBreakpoints(() => {
                    if (breakpoint.verified) {
                        resolve();
                    }
                });
            }))), 2000);
            listener.dispose();
        }
        let bestThread = viewModel.focusedThread;
        let bestScore = 0 ;
        for (const sessionId of breakpoint.sessionsThatVerified) {
            const session = debugModel.getSession(sessionId);
            if (!session) {
                continue;
            }
            const threads = session.getAllThreads().filter(t => t.stopped);
            if (bestScore < 3 ) {
                if (viewModel.focusedThread && threads.includes(viewModel.focusedThread)) {
                    bestThread = viewModel.focusedThread;
                    bestScore = 3 ;
                }
            }
            if (bestScore < 2 ) {
                const pausedInThisFile = threads.find(t => {
                    const top = t.getTopStackFrame();
                    return top && this.uriIdentityService.extUri.isEqual(top.source.uri, uri);
                });
                if (pausedInThisFile) {
                    bestThread = pausedInThisFile;
                    bestScore = 2 ;
                }
            }
            if (bestScore < 1 ) {
                bestThread = threads[0];
                bestScore = 2 ;
            }
        }
        return { thread: bestThread, breakpoint };
    }
};
DebugService = ( (__decorate([
    ( (__param(0, IEditorService))),
    ( (__param(1, IPaneCompositePartService))),
    ( (__param(2, IViewsService))),
    ( (__param(3, IViewDescriptorService))),
    ( (__param(4, INotificationService))),
    ( (__param(5, IDialogService))),
    ( (__param(6, IWorkbenchLayoutService))),
    ( (__param(7, IWorkspaceContextService))),
    ( (__param(8, IContextKeyService))),
    ( (__param(9, ILifecycleService))),
    ( (__param(10, IInstantiationService))),
    ( (__param(11, IExtensionService))),
    ( (__param(12, IFileService))),
    ( (__param(13, IConfigurationService))),
    ( (__param(14, IExtensionHostDebugService))),
    ( (__param(15, IActivityService))),
    ( (__param(16, ICommandService))),
    ( (__param(17, IQuickInputService))),
    ( (__param(18, IWorkspaceTrustRequestService))),
    ( (__param(19, IUriIdentityService)))
], DebugService)));
function getStackFrameThreadAndSessionToFocus(model, stackFrame, thread, session, avoidSession) {
    if (!session) {
        if (stackFrame || thread) {
            session = stackFrame ? stackFrame.thread.session : thread.session;
        }
        else {
            const sessions = model.getSessions();
            const stoppedSession = sessions.find(s => s.state === 2 );
            session = stoppedSession || sessions.find(s => s !== avoidSession && s !== avoidSession?.parentSession) || (sessions.length ? sessions[0] : undefined);
        }
    }
    if (!thread) {
        if (stackFrame) {
            thread = stackFrame.thread;
        }
        else {
            const threads = session ? session.getAllThreads() : undefined;
            const stoppedThread = threads && threads.find(t => t.stopped);
            thread = stoppedThread || (threads && threads.length ? threads[0] : undefined);
        }
    }
    if (!stackFrame && thread) {
        stackFrame = thread.getTopStackFrame();
    }
    return { session, thread, stackFrame };
}
async function sendToOneOrAllSessions(model, session, send) {
    if (session) {
        await send(session);
    }
    else {
        await Promise.all(( (model.getSessions().map(s => send(s)))));
    }
}
class LanguageFeaturesService {
    constructor() {
        this.referenceProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.renameProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.codeActionProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.definitionProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.typeDefinitionProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.declarationProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.implementationProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.documentSymbolProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.inlayHintsProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.colorProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.codeLensProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.documentFormattingEditProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.documentRangeFormattingEditProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.onTypeFormattingEditProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.signatureHelpProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.hoverProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.documentHighlightProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.selectionRangeProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.foldingRangeProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.linkProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.inlineCompletionsProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.completionProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.linkedEditingRangeProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.inlineValuesProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.evaluatableExpressionProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.documentRangeSemanticTokensProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.documentSemanticTokensProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.documentOnDropEditProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
        this.documentPasteEditProvider = ( (new LanguageFeatureRegistry(this._score.bind(this))));
    }
    setNotebookTypeResolver(resolver) {
        this._notebookTypeResolver = resolver;
    }
    _score(uri) {
        return this._notebookTypeResolver?.(uri);
    }
}
class BaseConfigurationResolverService extends AbstractVariableResolverService {
    constructor(context, envVariablesPromise, editorService, configurationService, commandService, workspaceContextService, quickInputService, labelService, pathService, extensionService) {
        super({
            getFolderUri: (folderName) => {
                const folder = workspaceContextService.getWorkspace().folders.filter(f => f.name === folderName).pop();
                return folder ? folder.uri : undefined;
            },
            getWorkspaceFolderCount: () => {
                return workspaceContextService.getWorkspace().folders.length;
            },
            getConfigurationValue: (folderUri, suffix) => {
                return configurationService.getValue(suffix, folderUri ? { resource: folderUri } : {});
            },
            getAppRoot: () => {
                return context.getAppRoot();
            },
            getExecPath: () => {
                return context.getExecPath();
            },
            getFilePath: () => {
                const fileResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, {
                    supportSideBySide: SideBySideEditor.PRIMARY,
                    filterByScheme: [Schemas.file, Schemas.vscodeUserData, this.pathService.defaultUriScheme]
                });
                if (!fileResource) {
                    return undefined;
                }
                return this.labelService.getUriLabel(fileResource, { noPrefix: true });
            },
            getWorkspaceFolderPathForFile: () => {
                const fileResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, {
                    supportSideBySide: SideBySideEditor.PRIMARY,
                    filterByScheme: [Schemas.file, Schemas.vscodeUserData, this.pathService.defaultUriScheme]
                });
                if (!fileResource) {
                    return undefined;
                }
                const wsFolder = workspaceContextService.getWorkspaceFolder(fileResource);
                if (!wsFolder) {
                    return undefined;
                }
                return this.labelService.getUriLabel(wsFolder.uri, { noPrefix: true });
            },
            getSelectedText: () => {
                const activeTextEditorControl = editorService.activeTextEditorControl;
                let activeControl = null;
                if (isCodeEditor(activeTextEditorControl)) {
                    activeControl = activeTextEditorControl;
                }
                else if (isDiffEditor(activeTextEditorControl)) {
                    const original = activeTextEditorControl.getOriginalEditor();
                    const modified = activeTextEditorControl.getModifiedEditor();
                    activeControl = original.hasWidgetFocus() ? original : modified;
                }
                const activeModel = activeControl?.getModel();
                const activeSelection = activeControl?.getSelection();
                if (activeModel && activeSelection) {
                    return activeModel.getValueInRange(activeSelection);
                }
                return undefined;
            },
            getLineNumber: () => {
                const activeTextEditorControl = editorService.activeTextEditorControl;
                if (isCodeEditor(activeTextEditorControl)) {
                    const selection = activeTextEditorControl.getSelection();
                    if (selection) {
                        const lineNumber = selection.positionLineNumber;
                        return String(lineNumber);
                    }
                }
                return undefined;
            },
            getExtension: id => {
                return extensionService.getExtension(id);
            },
        }, labelService, pathService.userHome().then(home => home.path), envVariablesPromise);
        this.configurationService = configurationService;
        this.commandService = commandService;
        this.workspaceContextService = workspaceContextService;
        this.quickInputService = quickInputService;
        this.labelService = labelService;
        this.pathService = pathService;
        this.userInputAccessQueue = ( (new Queue()));
    }
    async resolveWithInteractionReplace(folder, config, section, variables, target) {
        config = await this.resolveAnyAsync(folder, config);
        return this.resolveWithInteraction(folder, config, section, variables, target).then(mapping => {
            if (!mapping) {
                return null;
            }
            else if (mapping.size > 0) {
                return this.resolveAnyAsync(folder, config, Object.fromEntries(mapping));
            }
            else {
                return config;
            }
        });
    }
    async resolveWithInteraction(folder, config, section, variables, target) {
        const resolved = await this.resolveAnyMap(folder, config);
        config = resolved.newConfig;
        const allVariableMapping = resolved.resolvedVariables;
        return this.resolveWithInputAndCommands(folder, config, variables, section, target).then(inputOrCommandMapping => {
            if (this.updateMapping(inputOrCommandMapping, allVariableMapping)) {
                return allVariableMapping;
            }
            return undefined;
        });
    }
    updateMapping(newMapping, fullMapping) {
        if (!newMapping) {
            return false;
        }
        for (const [key, value] of Object.entries(newMapping)) {
            fullMapping.set(key, value);
        }
        return true;
    }
    async resolveWithInputAndCommands(folder, configuration, variableToCommandMap, section, target) {
        if (!configuration) {
            return Promise.resolve(undefined);
        }
        let inputs = [];
        if (this.workspaceContextService.getWorkbenchState() !== 1  && section) {
            const overrides = folder ? { resource: folder.uri } : {};
            const result = this.configurationService.inspect(section, overrides);
            if (result && (result.userValue || result.workspaceValue || result.workspaceFolderValue)) {
                switch (target) {
                    case 2 :
                        inputs = result.userValue?.inputs;
                        break;
                    case 5 :
                        inputs = result.workspaceValue?.inputs;
                        break;
                    default: inputs = result.workspaceFolderValue?.inputs;
                }
            }
            else {
                const valueResult = this.configurationService.getValue(section, overrides);
                if (valueResult) {
                    inputs = valueResult.inputs;
                }
            }
        }
        const variables = [];
        this.findVariables(configuration, variables);
        const variableValues = Object.create(null);
        for (const variable of variables) {
            const [type, name] = variable.split(':', 2);
            let result;
            switch (type) {
                case 'input':
                    result = await this.showUserInput(name, inputs);
                    break;
                case 'command': {
                    const commandId = (variableToCommandMap ? variableToCommandMap[name] : undefined) || name;
                    result = await this.commandService.executeCommand(commandId, configuration);
                    if (typeof result !== 'string' && !isUndefinedOrNull(result)) {
                        throw new Error(localize('commandVariable.noStringType', "Cannot substitute command variable '{0}' because command did not return a result of type string.", commandId));
                    }
                    break;
                }
                default:
                    if (this._contributedVariables.has(variable)) {
                        result = await this._contributedVariables.get(variable)();
                    }
            }
            if (typeof result === 'string') {
                variableValues[variable] = result;
            }
            else {
                return undefined;
            }
        }
        return variableValues;
    }
    findVariables(object, variables) {
        if (typeof object === 'string') {
            let matches;
            while ((matches = BaseConfigurationResolverService.INPUT_OR_COMMAND_VARIABLES_PATTERN.exec(object)) !== null) {
                if (matches.length === 4) {
                    const command = matches[1];
                    if (variables.indexOf(command) < 0) {
                        variables.push(command);
                    }
                }
            }
            for (const contributed of ( (this._contributedVariables.keys()))) {
                if ((variables.indexOf(contributed) < 0) && (object.indexOf('${' + contributed + '}') >= 0)) {
                    variables.push(contributed);
                }
            }
        }
        else if (Array.isArray(object)) {
            for (const value of object) {
                this.findVariables(value, variables);
            }
        }
        else if (object) {
            for (const value of ( (Object.values(object)))) {
                this.findVariables(value, variables);
            }
        }
    }
    showUserInput(variable, inputInfos) {
        if (!inputInfos) {
            return Promise.reject(( (new Error( (localize(
                'inputVariable.noInputSection',
                "Variable '{0}' must be defined in an '{1}' section of the debug or task configuration.",
                variable,
                'input'
            ))))));
        }
        const info = inputInfos.filter(item => item.id === variable).pop();
        if (info) {
            const missingAttribute = (attrName) => {
                throw new Error(localize('inputVariable.missingAttribute', "Input variable '{0}' is of type '{1}' and must include '{2}'.", variable, info.type, attrName));
            };
            switch (info.type) {
                case 'promptString': {
                    if (!isString(info.description)) {
                        missingAttribute('description');
                    }
                    const inputOptions = { prompt: info.description, ignoreFocusLost: true };
                    if (info.default) {
                        inputOptions.value = info.default;
                    }
                    if (info.password) {
                        inputOptions.password = info.password;
                    }
                    return this.userInputAccessQueue.queue(() => this.quickInputService.input(inputOptions)).then(resolvedInput => {
                        return resolvedInput;
                    });
                }
                case 'pickString': {
                    if (!isString(info.description)) {
                        missingAttribute('description');
                    }
                    if (Array.isArray(info.options)) {
                        for (const pickOption of info.options) {
                            if (!isString(pickOption) && !isString(pickOption.value)) {
                                missingAttribute('value');
                            }
                        }
                    }
                    else {
                        missingAttribute('options');
                    }
                    const picks = ( (new Array()));
                    for (const pickOption of info.options) {
                        const value = isString(pickOption) ? pickOption : pickOption.value;
                        const label = isString(pickOption) ? undefined : pickOption.label;
                        const item = {
                            label: label ? `${label}: ${value}` : value,
                            value: value
                        };
                        if (value === info.default) {
                            item.description = ( (localize('inputVariable.defaultInputValue', "(Default)")));
                            picks.unshift(item);
                        }
                        else {
                            picks.push(item);
                        }
                    }
                    const pickOptions = { placeHolder: info.description, matchOnDetail: true, ignoreFocusLost: true };
                    return this.userInputAccessQueue.queue(() => this.quickInputService.pick(picks, pickOptions, undefined)).then(resolvedInput => {
                        if (resolvedInput) {
                            return resolvedInput.value;
                        }
                        return undefined;
                    });
                }
                case 'command': {
                    if (!isString(info.command)) {
                        missingAttribute('command');
                    }
                    return this.userInputAccessQueue.queue(() => this.commandService.executeCommand(info.command, info.args)).then(result => {
                        if (typeof result === 'string' || isUndefinedOrNull(result)) {
                            return result;
                        }
                        throw new Error(localize('inputVariable.command.noStringType', "Cannot substitute input variable '{0}' because command '{1}' did not return a result of type string.", variable, info.command));
                    });
                }
                default:
                    throw new Error(localize('inputVariable.unknownType', "Input variable '{0}' can only be of type 'promptString', 'pickString', or 'command'.", variable));
            }
        }
        return Promise.reject(( (new Error( (localize(
            'inputVariable.undefinedVariable',
            "Undefined input variable '{0}' encountered. Remove or define '{0}' to continue.",
            variable
        ))))));
    }
}
BaseConfigurationResolverService.INPUT_OR_COMMAND_VARIABLES_PATTERN = /\${((input|command):(.*?))}/g;
let ConfigurationResolverService = class ConfigurationResolverService extends BaseConfigurationResolverService {
    constructor(editorService, configurationService, commandService, workspaceContextService, quickInputService, labelService, pathService, extensionService) {
        super({ getAppRoot: () => undefined, getExecPath: () => undefined }, Promise.resolve(Object.create(null)), editorService, configurationService, commandService, workspaceContextService, quickInputService, labelService, pathService, extensionService);
    }
};
ConfigurationResolverService = ( (__decorate([
    ( (__param(0, IEditorService))),
    ( (__param(1, IConfigurationService))),
    ( (__param(2, ICommandService))),
    ( (__param(3, IWorkspaceContextService))),
    ( (__param(4, IQuickInputService))),
    ( (__param(5, ILabelService))),
    ( (__param(6, IPathService))),
    ( (__param(7, IExtensionService)))
], ConfigurationResolverService)));
var css$5 = ".monaco-workbench .debug-toolbar{border-radius:4px;display:flex;height:32px;padding-left:7px;position:absolute;z-index:39}.monaco-workbench .debug-toolbar .monaco-action-bar .action-item{margin-right:4px}.monaco-workbench .debug-toolbar .monaco-action-bar .action-item.select-container{margin-right:7px}.monaco-workbench .debug-toolbar .monaco-action-bar .action-item.select-container .monaco-select-box,.monaco-workbench .start-debug-action-item .select-container .monaco-select-box{padding:0 22px 0 6px}.monaco-workbench .debug-toolbar .drag-area{align-items:center;cursor:grab;display:flex;justify-content:center;opacity:.5;width:16px}.monaco-workbench .debug-toolbar .drag-area.dragged{cursor:grabbing}.monaco-workbench .debug-toolbar .monaco-action-bar .action-item .action-label{align-items:center;background-position:50%;background-repeat:no-repeat;background-size:16px;display:flex;justify-content:center;margin-right:0}";
n(css$5,{});
let DropdownWithPrimaryActionViewItem = class DropdownWithPrimaryActionViewItem extends BaseActionViewItem {
    get onDidChangeDropdownVisibility() {
        return this._dropdown.onDidChangeVisibility;
    }
    constructor(primaryAction, dropdownAction, dropdownMenuActions, className, _contextMenuProvider, _options, _keybindingService, _notificationService, _contextKeyService, _themeService) {
        super(null, primaryAction);
        this._contextMenuProvider = _contextMenuProvider;
        this._options = _options;
        this._container = null;
        this._dropdownContainer = null;
        this._primaryAction = ( (new MenuEntryActionViewItem(
            primaryAction,
            undefined,
            _keybindingService,
            _notificationService,
            _contextKeyService,
            _themeService,
            _contextMenuProvider
        )));
        this._dropdown = ( (new DropdownMenuActionViewItem(dropdownAction, dropdownMenuActions, this._contextMenuProvider, {
            menuAsChild: true,
            classNames: className ? ['codicon', 'codicon-chevron-down', className] : ['codicon', 'codicon-chevron-down'],
            keybindingProvider: this._options?.getKeyBinding
        })));
    }
    setActionContext(newContext) {
        super.setActionContext(newContext);
        this._primaryAction.setActionContext(newContext);
        this._dropdown.setActionContext(newContext);
    }
    render(container) {
        this._container = container;
        super.render(this._container);
        this._container.classList.add('monaco-dropdown-with-primary');
        const primaryContainer = $$7('.action-container');
        this._primaryAction.render(append(this._container, primaryContainer));
        this._dropdownContainer = $$7('.dropdown-action-container');
        this._dropdown.render(append(this._container, this._dropdownContainer));
        this._register(addDisposableListener$1(primaryContainer, EventType$1.KEY_DOWN, (e) => {
            const event = ( (new StandardKeyboardEvent(e)));
            if (event.equals(17 )) {
                this._primaryAction.element.tabIndex = -1;
                this._dropdown.focus();
                event.stopPropagation();
            }
        }));
        this._register(addDisposableListener$1(this._dropdownContainer, EventType$1.KEY_DOWN, (e) => {
            const event = ( (new StandardKeyboardEvent(e)));
            if (event.equals(15 )) {
                this._primaryAction.element.tabIndex = 0;
                this._dropdown.setFocusable(false);
                this._primaryAction.element?.focus();
                event.stopPropagation();
            }
        }));
    }
    focus(fromRight) {
        if (fromRight) {
            this._dropdown.focus();
        }
        else {
            this._primaryAction.element.tabIndex = 0;
            this._primaryAction.element.focus();
        }
    }
    blur() {
        this._primaryAction.element.tabIndex = -1;
        this._dropdown.blur();
        this._container.blur();
    }
    setFocusable(focusable) {
        if (focusable) {
            this._primaryAction.element.tabIndex = 0;
        }
        else {
            this._primaryAction.element.tabIndex = -1;
            this._dropdown.setFocusable(false);
        }
    }
    update(dropdownAction, dropdownMenuActions, dropdownIcon) {
        this._dropdown.dispose();
        this._dropdown = ( (new DropdownMenuActionViewItem(dropdownAction, dropdownMenuActions, this._contextMenuProvider, {
            menuAsChild: true,
            classNames: ['codicon', dropdownIcon || 'codicon-chevron-down']
        })));
        if (this._dropdownContainer) {
            this._dropdown.render(this._dropdownContainer);
        }
    }
    dispose() {
        this._primaryAction.dispose();
        this._dropdown.dispose();
        super.dispose();
    }
};
DropdownWithPrimaryActionViewItem = ( (__decorate([
    ( (__param(6, IKeybindingService))),
    ( (__param(7, INotificationService))),
    ( (__param(8, IContextKeyService))),
    ( (__param(9, IThemeService)))
], DropdownWithPrimaryActionViewItem)));
const $$5 = $$7;
let StartDebugActionViewItem = class StartDebugActionViewItem extends BaseActionViewItem {
    constructor(context, action, debugService, configurationService, commandService, contextService, contextViewService, keybindingService) {
        super(context, action);
        this.context = context;
        this.debugService = debugService;
        this.configurationService = configurationService;
        this.commandService = commandService;
        this.contextService = contextService;
        this.keybindingService = keybindingService;
        this.debugOptions = [];
        this.selected = 0;
        this.providers = [];
        this.toDispose = [];
        this.selectBox = ( (new SelectBox(
            [],
            -1,
            contextViewService,
            defaultSelectBoxStyles,
            { ariaLabel: ( (localize('debugLaunchConfigurations', 'Debug Launch Configurations'))) }
        )));
        this.selectBox.setFocusable(false);
        this.toDispose.push(this.selectBox);
        this.registerListeners();
    }
    registerListeners() {
        this.toDispose.push(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('launch')) {
                this.updateOptions();
            }
        }));
        this.toDispose.push(this.debugService.getConfigurationManager().onDidSelectConfiguration(() => {
            this.updateOptions();
        }));
    }
    render(container) {
        this.container = container;
        container.classList.add('start-debug-action-item');
        this.start = append(container, $$5(ThemeIcon.asCSSSelector(debugStart)));
        const keybinding = this.keybindingService.lookupKeybinding(this.action.id)?.getLabel();
        const keybindingLabel = keybinding ? ` (${keybinding})` : '';
        this.start.title = this.action.label + keybindingLabel;
        this.start.setAttribute('role', 'button');
        this.toDispose.push(addDisposableListener$1(this.start, EventType$1.CLICK, () => {
            this.start.blur();
            if (this.debugService.state !== 1 ) {
                this.actionRunner.run(this.action, this.context);
            }
        }));
        this.toDispose.push(addDisposableListener$1(this.start, EventType$1.MOUSE_DOWN, (e) => {
            if (this.action.enabled && e.button === 0) {
                this.start.classList.add('active');
            }
        }));
        this.toDispose.push(addDisposableListener$1(this.start, EventType$1.MOUSE_UP, () => {
            this.start.classList.remove('active');
        }));
        this.toDispose.push(addDisposableListener$1(this.start, EventType$1.MOUSE_OUT, () => {
            this.start.classList.remove('active');
        }));
        this.toDispose.push(addDisposableListener$1(this.start, EventType$1.KEY_DOWN, (e) => {
            const event = ( (new StandardKeyboardEvent(e)));
            if (event.equals(17 )) {
                this.start.tabIndex = -1;
                this.selectBox.focus();
                event.stopPropagation();
            }
        }));
        this.toDispose.push(this.selectBox.onDidSelect(async (e) => {
            const target = this.debugOptions[e.index];
            const shouldBeSelected = target.handler ? await target.handler() : false;
            if (shouldBeSelected) {
                this.selected = e.index;
            }
            else {
                this.selectBox.select(this.selected);
            }
        }));
        const selectBoxContainer = $$5('.configuration');
        this.selectBox.render(append(container, selectBoxContainer));
        this.toDispose.push(addDisposableListener$1(selectBoxContainer, EventType$1.KEY_DOWN, (e) => {
            const event = ( (new StandardKeyboardEvent(e)));
            if (event.equals(15 )) {
                this.selectBox.setFocusable(false);
                this.start.tabIndex = 0;
                this.start.focus();
                event.stopPropagation();
            }
        }));
        this.container.style.border = `1px solid ${asCssVariable(selectBorder)}`;
        selectBoxContainer.style.borderLeft = `1px solid ${asCssVariable(selectBorder)}`;
        this.container.style.backgroundColor = asCssVariable(selectBackground);
        this.debugService.getConfigurationManager().getDynamicProviders().then(providers => {
            this.providers = providers;
            if (this.providers.length > 0) {
                this.updateOptions();
            }
        });
        this.updateOptions();
    }
    setActionContext(context) {
        this.context = context;
    }
    isEnabled() {
        return true;
    }
    focus(fromRight) {
        if (fromRight) {
            this.selectBox.focus();
        }
        else {
            this.start.tabIndex = 0;
            this.start.focus();
        }
    }
    blur() {
        this.start.tabIndex = -1;
        this.selectBox.blur();
        this.container.blur();
    }
    setFocusable(focusable) {
        if (focusable) {
            this.start.tabIndex = 0;
        }
        else {
            this.start.tabIndex = -1;
            this.selectBox.setFocusable(false);
        }
    }
    dispose() {
        this.toDispose = dispose(this.toDispose);
    }
    updateOptions() {
        this.selected = 0;
        this.debugOptions = [];
        const manager = this.debugService.getConfigurationManager();
        const inWorkspace = this.contextService.getWorkbenchState() === 3 ;
        let lastGroup;
        const disabledIdxs = [];
        manager.getAllConfigurations().forEach(({ launch, name, presentation }) => {
            if (lastGroup !== presentation?.group) {
                lastGroup = presentation?.group;
                if (this.debugOptions.length) {
                    this.debugOptions.push({ label: StartDebugActionViewItem.SEPARATOR, handler: () => Promise.resolve(false) });
                    disabledIdxs.push(this.debugOptions.length - 1);
                }
            }
            if (name === manager.selectedConfiguration.name && launch === manager.selectedConfiguration.launch) {
                this.selected = this.debugOptions.length;
            }
            const label = inWorkspace ? `${name} (${launch.name})` : name;
            this.debugOptions.push({
                label, handler: async () => {
                    await manager.selectConfiguration(launch, name);
                    return true;
                }
            });
        });
        manager.getRecentDynamicConfigurations().slice(0, 3).forEach(({ name, type }) => {
            if (type === manager.selectedConfiguration.type && manager.selectedConfiguration.name === name) {
                this.selected = this.debugOptions.length;
            }
            this.debugOptions.push({
                label: name,
                handler: async () => {
                    await manager.selectConfiguration(undefined, name, undefined, { type });
                    return true;
                }
            });
        });
        if (this.debugOptions.length === 0) {
            this.debugOptions.push({ label: ( (localize('noConfigurations', "No Configurations"))), handler: async () => false });
        }
        this.debugOptions.push({ label: StartDebugActionViewItem.SEPARATOR, handler: () => Promise.resolve(false) });
        disabledIdxs.push(this.debugOptions.length - 1);
        this.providers.forEach(p => {
            this.debugOptions.push({
                label: `${p.label}...`,
                handler: async () => {
                    const picked = await p.pick();
                    if (picked) {
                        await manager.selectConfiguration(picked.launch, picked.config.name, picked.config, { type: p.type });
                        return true;
                    }
                    return false;
                }
            });
        });
        manager.getLaunches().filter(l => !l.hidden).forEach(l => {
            const label = inWorkspace ? ( (localize("addConfigTo", "Add Config ({0})...", l.name))) : ( (localize('addConfiguration', "Add Configuration...")));
            this.debugOptions.push({
                label, handler: async () => {
                    await this.commandService.executeCommand(ADD_CONFIGURATION_ID, ( (l.uri.toString())));
                    return false;
                }
            });
        });
        this.selectBox.setOptions(( (this.debugOptions.map(
            (data, index) => ({ text: data.label, isDisabled: disabledIdxs.indexOf(index) !== -1 })
        ))), this.selected);
    }
};
StartDebugActionViewItem.SEPARATOR = '\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500';
StartDebugActionViewItem = ( (__decorate([
    ( (__param(2, IDebugService))),
    ( (__param(3, IConfigurationService))),
    ( (__param(4, ICommandService))),
    ( (__param(5, IWorkspaceContextService))),
    ( (__param(6, IContextViewService))),
    ( (__param(7, IKeybindingService)))
], StartDebugActionViewItem)));
let FocusSessionActionViewItem = class FocusSessionActionViewItem extends SelectActionViewItem {
    constructor(action, session, debugService, contextViewService, configurationService) {
        super(null, action, [], -1, contextViewService, defaultSelectBoxStyles, { ariaLabel: ( (localize('debugSession', 'Debug Session'))) });
        this.debugService = debugService;
        this.configurationService = configurationService;
        this._register(this.debugService.getViewModel().onDidFocusSession(() => {
            const session = this.getSelectedSession();
            if (session) {
                const index = this.getSessions().indexOf(session);
                this.select(index);
            }
        }));
        this._register(this.debugService.onDidNewSession(session => {
            const sessionListeners = [];
            sessionListeners.push(session.onDidChangeName(() => this.update()));
            sessionListeners.push(session.onDidEndAdapter(() => dispose(sessionListeners)));
            this.update();
        }));
        this.getSessions().forEach(session => {
            this._register(session.onDidChangeName(() => this.update()));
        });
        this._register(this.debugService.onDidEndSession(() => this.update()));
        const selectedSession = session ? this.mapFocusedSessionToSelected(session) : undefined;
        this.update(selectedSession);
    }
    getActionContext(_, index) {
        return this.getSessions()[index];
    }
    update(session) {
        if (!session) {
            session = this.getSelectedSession();
        }
        const sessions = this.getSessions();
        const names = ( (sessions.map(s => {
            const label = s.getLabel();
            if (s.parentSession) {
                return `\u00A0\u00A0${label}`;
            }
            return label;
        })));
        this.setOptions(( (names.map(data => ({ text: data })))), session ? sessions.indexOf(session) : undefined);
    }
    getSelectedSession() {
        const session = this.debugService.getViewModel().focusedSession;
        return session ? this.mapFocusedSessionToSelected(session) : undefined;
    }
    getSessions() {
        const showSubSessions = this.configurationService.getValue('debug').showSubSessionsInToolBar;
        const sessions = this.debugService.getModel().getSessions();
        return showSubSessions ? sessions : sessions.filter(s => !s.parentSession);
    }
    mapFocusedSessionToSelected(focusedSession) {
        const showSubSessions = this.configurationService.getValue('debug').showSubSessionsInToolBar;
        while (focusedSession.parentSession && !showSubSessions) {
            focusedSession = focusedSession.parentSession;
        }
        return focusedSession;
    }
};
FocusSessionActionViewItem = ( (__decorate([
    ( (__param(2, IDebugService))),
    ( (__param(3, IContextViewService))),
    ( (__param(4, IConfigurationService)))
], FocusSessionActionViewItem)));
const debugToolBarBackground = registerColor('debugToolBar.background', {
    dark: '#333333',
    light: '#F3F3F3',
    hcDark: '#000000',
    hcLight: '#FFFFFF'
}, ( (localize('debugToolBarBackground', "Debug toolbar background color."))));
const debugToolBarBorder = registerColor('debugToolBar.border', {
    dark: null,
    light: null,
    hcDark: null,
    hcLight: null
}, ( (localize('debugToolBarBorder', "Debug toolbar border color."))));
const debugIconStartForeground = registerColor('debugIcon.startForeground', {
    dark: '#89D185',
    light: '#388A34',
    hcDark: '#89D185',
    hcLight: '#388A34'
}, ( (localize('debugIcon.startForeground', "Debug toolbar icon for start debugging."))));
function registerColors() {
    const debugTokenExpressionName = registerColor('debugTokenExpression.name', { dark: '#c586c0', light: '#9b46b0', hcDark: foreground, hcLight: foreground }, 'Foreground color for the token names shown in the debug views (ie. the Variables or Watch view).');
    const debugTokenExpressionValue = registerColor('debugTokenExpression.value', { dark: '#cccccc99', light: '#6c6c6ccc', hcDark: foreground, hcLight: foreground }, 'Foreground color for the token values shown in the debug views (ie. the Variables or Watch view).');
    const debugTokenExpressionString = registerColor('debugTokenExpression.string', { dark: '#ce9178', light: '#a31515', hcDark: '#f48771', hcLight: '#a31515' }, 'Foreground color for strings in the debug views (ie. the Variables or Watch view).');
    const debugTokenExpressionBoolean = registerColor('debugTokenExpression.boolean', { dark: '#4e94ce', light: '#0000ff', hcDark: '#75bdfe', hcLight: '#0000ff' }, 'Foreground color for booleans in the debug views (ie. the Variables or Watch view).');
    const debugTokenExpressionNumber = registerColor('debugTokenExpression.number', { dark: '#b5cea8', light: '#098658', hcDark: '#89d185', hcLight: '#098658' }, 'Foreground color for numbers in the debug views (ie. the Variables or Watch view).');
    const debugTokenExpressionError = registerColor('debugTokenExpression.error', { dark: '#f48771', light: '#e51400', hcDark: '#f48771', hcLight: '#e51400' }, 'Foreground color for expression errors in the debug views (ie. the Variables or Watch view) and for error logs shown in the debug console.');
    const debugViewExceptionLabelForeground = registerColor('debugView.exceptionLabelForeground', { dark: foreground, light: '#FFF', hcDark: foreground, hcLight: foreground }, 'Foreground color for a label shown in the CALL STACK view when the debugger breaks on an exception.');
    const debugViewExceptionLabelBackground = registerColor('debugView.exceptionLabelBackground', { dark: '#6C2022', light: '#A31515', hcDark: '#6C2022', hcLight: '#A31515' }, 'Background color for a label shown in the CALL STACK view when the debugger breaks on an exception.');
    const debugViewStateLabelForeground = registerColor('debugView.stateLabelForeground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, 'Foreground color for a label in the CALL STACK view showing the current session\'s or thread\'s state.');
    const debugViewStateLabelBackground = registerColor('debugView.stateLabelBackground', { dark: '#88888844', light: '#88888844', hcDark: '#88888844', hcLight: '#88888844' }, 'Background color for a label in the CALL STACK view showing the current session\'s or thread\'s state.');
    const debugViewValueChangedHighlight = registerColor('debugView.valueChangedHighlight', { dark: '#569CD6', light: '#569CD6', hcDark: '#569CD6', hcLight: '#569CD6' }, 'Color used to highlight value changes in the debug views (ie. in the Variables view).');
    const debugConsoleInfoForeground = registerColor('debugConsole.infoForeground', { dark: editorInfoForeground, light: editorInfoForeground, hcDark: foreground, hcLight: foreground }, 'Foreground color for info messages in debug REPL console.');
    const debugConsoleWarningForeground = registerColor('debugConsole.warningForeground', { dark: editorWarningForeground, light: editorWarningForeground, hcDark: '#008000', hcLight: editorWarningForeground }, 'Foreground color for warning messages in debug REPL console.');
    const debugConsoleErrorForeground = registerColor('debugConsole.errorForeground', { dark: errorForeground, light: errorForeground, hcDark: errorForeground, hcLight: errorForeground }, 'Foreground color for error messages in debug REPL console.');
    const debugConsoleSourceForeground = registerColor('debugConsole.sourceForeground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, 'Foreground color for source filenames in debug REPL console.');
    const debugConsoleInputIconForeground = registerColor('debugConsoleInputIcon.foreground', { dark: foreground, light: foreground, hcDark: foreground, hcLight: foreground }, 'Foreground color for debug console input marker icon.');
    const debugIconPauseForeground = registerColor('debugIcon.pauseForeground', {
        dark: '#75BEFF',
        light: '#007ACC',
        hcDark: '#75BEFF',
        hcLight: '#007ACC'
    }, ( (localize('debugIcon.pauseForeground', "Debug toolbar icon for pause."))));
    const debugIconStopForeground = registerColor('debugIcon.stopForeground', {
        dark: '#F48771',
        light: '#A1260D',
        hcDark: '#F48771',
        hcLight: '#A1260D'
    }, ( (localize('debugIcon.stopForeground', "Debug toolbar icon for stop."))));
    const debugIconDisconnectForeground = registerColor('debugIcon.disconnectForeground', {
        dark: '#F48771',
        light: '#A1260D',
        hcDark: '#F48771',
        hcLight: '#A1260D'
    }, ( (localize('debugIcon.disconnectForeground', "Debug toolbar icon for disconnect."))));
    const debugIconRestartForeground = registerColor('debugIcon.restartForeground', {
        dark: '#89D185',
        light: '#388A34',
        hcDark: '#89D185',
        hcLight: '#388A34'
    }, ( (localize('debugIcon.restartForeground', "Debug toolbar icon for restart."))));
    const debugIconStepOverForeground = registerColor('debugIcon.stepOverForeground', {
        dark: '#75BEFF',
        light: '#007ACC',
        hcDark: '#75BEFF',
        hcLight: '#007ACC'
    }, ( (localize('debugIcon.stepOverForeground', "Debug toolbar icon for step over."))));
    const debugIconStepIntoForeground = registerColor('debugIcon.stepIntoForeground', {
        dark: '#75BEFF',
        light: '#007ACC',
        hcDark: '#75BEFF',
        hcLight: '#007ACC'
    }, ( (localize('debugIcon.stepIntoForeground', "Debug toolbar icon for step into."))));
    const debugIconStepOutForeground = registerColor('debugIcon.stepOutForeground', {
        dark: '#75BEFF',
        light: '#007ACC',
        hcDark: '#75BEFF',
        hcLight: '#007ACC'
    }, ( (localize('debugIcon.stepOutForeground', "Debug toolbar icon for step over."))));
    const debugIconContinueForeground = registerColor('debugIcon.continueForeground', {
        dark: '#75BEFF',
        light: '#007ACC',
        hcDark: '#75BEFF',
        hcLight: '#007ACC'
    }, ( (localize('debugIcon.continueForeground', "Debug toolbar icon for continue."))));
    const debugIconStepBackForeground = registerColor('debugIcon.stepBackForeground', {
        dark: '#75BEFF',
        light: '#007ACC',
        hcDark: '#75BEFF',
        hcLight: '#007ACC'
    }, ( (localize('debugIcon.stepBackForeground', "Debug toolbar icon for step back."))));
    registerThemingParticipant((theme, collector) => {
        const badgeBackgroundColor = theme.getColor(badgeBackground);
        const badgeForegroundColor = theme.getColor(badgeForeground);
        const listDeemphasizedForegroundColor = theme.getColor(listDeemphasizedForeground);
        const debugViewExceptionLabelForegroundColor = theme.getColor(debugViewExceptionLabelForeground);
        const debugViewExceptionLabelBackgroundColor = theme.getColor(debugViewExceptionLabelBackground);
        const debugViewStateLabelForegroundColor = theme.getColor(debugViewStateLabelForeground);
        const debugViewStateLabelBackgroundColor = theme.getColor(debugViewStateLabelBackground);
        const debugViewValueChangedHighlightColor = theme.getColor(debugViewValueChangedHighlight);
        const toolbarHoverBackgroundColor = theme.getColor(toolbarHoverBackground);
        collector.addRule(`
			/* Text colour of the call stack row's filename */
			.debug-pane .debug-call-stack .monaco-list-row:not(.selected) .stack-frame > .file .file-name {
				color: ${listDeemphasizedForegroundColor}
			}

			/* Line & column number "badge" for selected call stack row */
			.debug-pane .monaco-list-row.selected .line-number {
				background-color: ${badgeBackgroundColor};
				color: ${badgeForegroundColor};
			}

			/* Line & column number "badge" for unselected call stack row (basically all other rows) */
			.debug-pane .line-number {
				background-color: ${( ( badgeBackgroundColor.transparent(0.6)))};
				color: ${( ( badgeForegroundColor.transparent(0.6)))};
			}

			/* State "badge" displaying the active session's current state.
			* Only visible when there are more active debug sessions/threads running.
			*/
			.debug-pane .debug-call-stack .thread > .state.label,
			.debug-pane .debug-call-stack .session > .state.label {
				background-color: ${debugViewStateLabelBackgroundColor};
				color: ${debugViewStateLabelForegroundColor};
			}

			/* State "badge" displaying the active session's current state.
			* Only visible when there are more active debug sessions/threads running
			* and thread paused due to a thrown exception.
			*/
			.debug-pane .debug-call-stack .thread > .state.label.exception,
			.debug-pane .debug-call-stack .session > .state.label.exception {
				background-color: ${debugViewExceptionLabelBackgroundColor};
				color: ${debugViewExceptionLabelForegroundColor};
			}

			/* Info "badge" shown when the debugger pauses due to a thrown exception. */
			.debug-pane .call-stack-state-message > .label.exception {
				background-color: ${debugViewExceptionLabelBackgroundColor};
				color: ${debugViewExceptionLabelForegroundColor};
			}

			/* Animation of changed values in Debug viewlet */
			@keyframes debugViewletValueChanged {
				0%   { background-color: ${( ( debugViewValueChangedHighlightColor.transparent(0)))} }
				5%   { background-color: ${( ( debugViewValueChangedHighlightColor.transparent(0.9)))} }
				100% { background-color: ${( ( debugViewValueChangedHighlightColor.transparent(0.3)))} }
			}

			.debug-pane .monaco-list-row .expression .value.changed {
				background-color: ${( ( debugViewValueChangedHighlightColor.transparent(0.3)))};
				animation-name: debugViewletValueChanged;
				animation-duration: 1s;
				animation-fill-mode: forwards;
			}

			.monaco-list-row .expression .lazy-button:hover {
				background-color: ${toolbarHoverBackgroundColor}
			}
		`);
        const contrastBorderColor = theme.getColor(contrastBorder);
        if (contrastBorderColor) {
            collector.addRule(`
			.debug-pane .line-number {
				border: 1px solid ${contrastBorderColor};
			}
			`);
        }
        if (isHighContrast(theme.type)) {
            collector.addRule(`
			.debug-pane .line-number {
				background-color: ${badgeBackgroundColor};
				color: ${badgeForegroundColor};
			}`);
        }
        const tokenNameColor = theme.getColor(debugTokenExpressionName);
        const tokenValueColor = theme.getColor(debugTokenExpressionValue);
        const tokenStringColor = theme.getColor(debugTokenExpressionString);
        const tokenBooleanColor = theme.getColor(debugTokenExpressionBoolean);
        const tokenErrorColor = theme.getColor(debugTokenExpressionError);
        const tokenNumberColor = theme.getColor(debugTokenExpressionNumber);
        collector.addRule(`
			.monaco-workbench .monaco-list-row .expression .name {
				color: ${tokenNameColor};
			}

			.monaco-workbench .monaco-list-row .expression .value,
			.monaco-workbench .debug-hover-widget .value {
				color: ${tokenValueColor};
			}

			.monaco-workbench .monaco-list-row .expression .value.string,
			.monaco-workbench .debug-hover-widget .value.string {
				color: ${tokenStringColor};
			}

			.monaco-workbench .monaco-list-row .expression .value.boolean,
			.monaco-workbench .debug-hover-widget .value.boolean {
				color: ${tokenBooleanColor};
			}

			.monaco-workbench .monaco-list-row .expression .error,
			.monaco-workbench .debug-hover-widget .error,
			.monaco-workbench .debug-pane .debug-variables .scope .error {
				color: ${tokenErrorColor};
			}

			.monaco-workbench .monaco-list-row .expression .value.number,
			.monaco-workbench .debug-hover-widget .value.number {
				color: ${tokenNumberColor};
			}
		`);
        const debugConsoleInputBorderColor = theme.getColor(inputBorder) || ( (Color.fromHex('#80808060')));
        const debugConsoleInfoForegroundColor = theme.getColor(debugConsoleInfoForeground);
        const debugConsoleWarningForegroundColor = theme.getColor(debugConsoleWarningForeground);
        const debugConsoleErrorForegroundColor = theme.getColor(debugConsoleErrorForeground);
        const debugConsoleSourceForegroundColor = theme.getColor(debugConsoleSourceForeground);
        const debugConsoleInputIconForegroundColor = theme.getColor(debugConsoleInputIconForeground);
        collector.addRule(`
			.repl .repl-input-wrapper {
				border-top: 1px solid ${debugConsoleInputBorderColor};
			}

			.monaco-workbench .repl .repl-tree .output .expression .value.info {
				color: ${debugConsoleInfoForegroundColor};
			}

			.monaco-workbench .repl .repl-tree .output .expression .value.warn {
				color: ${debugConsoleWarningForegroundColor};
			}

			.monaco-workbench .repl .repl-tree .output .expression .value.error {
				color: ${debugConsoleErrorForegroundColor};
			}

			.monaco-workbench .repl .repl-tree .output .expression .source {
				color: ${debugConsoleSourceForegroundColor};
			}

			.monaco-workbench .repl .repl-tree .monaco-tl-contents .arrow {
				color: ${debugConsoleInputIconForegroundColor};
			}
		`);
        if (!theme.defines(debugConsoleInputIconForeground)) {
            collector.addRule(`
				.monaco-workbench.vs .repl .repl-tree .monaco-tl-contents .arrow {
					opacity: 0.25;
				}

				.monaco-workbench.vs-dark .repl .repl-tree .monaco-tl-contents .arrow {
					opacity: 0.4;
				}

				.monaco-workbench.hc-black .repl .repl-tree .monaco-tl-contents .arrow,
				.monaco-workbench.hc-light .repl .repl-tree .monaco-tl-contents .arrow {
					opacity: 1;
				}
			`);
        }
        const debugIconStartColor = theme.getColor(debugIconStartForeground);
        if (debugIconStartColor) {
            collector.addRule(`.monaco-workbench ${ThemeIcon.asCSSSelector(debugStart)} { color: ${debugIconStartColor}; }`);
        }
        const debugIconPauseColor = theme.getColor(debugIconPauseForeground);
        if (debugIconPauseColor) {
            collector.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugPause)}, .monaco-workbench ${ThemeIcon.asCSSSelector(debugPause)} { color: ${debugIconPauseColor}; }`);
        }
        const debugIconStopColor = theme.getColor(debugIconStopForeground);
        if (debugIconStopColor) {
            collector.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugStop)},.monaco-workbench ${ThemeIcon.asCSSSelector(debugStop)} { color: ${debugIconStopColor}; }`);
        }
        const debugIconDisconnectColor = theme.getColor(debugIconDisconnectForeground);
        if (debugIconDisconnectColor) {
            collector.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugDisconnect)},.monaco-workbench .debug-view-content ${ThemeIcon.asCSSSelector(debugDisconnect)}, .monaco-workbench .debug-toolbar ${ThemeIcon.asCSSSelector(debugDisconnect)} { color: ${debugIconDisconnectColor}; }`);
        }
        const debugIconRestartColor = theme.getColor(debugIconRestartForeground);
        if (debugIconRestartColor) {
            collector.addRule(`.monaco-workbench ${ThemeIcon.asCSSSelector(debugRestart)}, .monaco-workbench ${ThemeIcon.asCSSSelector(debugRestartFrame)}, .monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugRestart)}, .monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugRestartFrame)} { color: ${debugIconRestartColor}; }`);
        }
        const debugIconStepOverColor = theme.getColor(debugIconStepOverForeground);
        if (debugIconStepOverColor) {
            collector.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugStepOver)}, .monaco-workbench ${ThemeIcon.asCSSSelector(debugStepOver)} { color: ${debugIconStepOverColor}; }`);
        }
        const debugIconStepIntoColor = theme.getColor(debugIconStepIntoForeground);
        if (debugIconStepIntoColor) {
            collector.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugStepInto)}, .monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugStepInto)}, .monaco-workbench ${ThemeIcon.asCSSSelector(debugStepInto)} { color: ${debugIconStepIntoColor}; }`);
        }
        const debugIconStepOutColor = theme.getColor(debugIconStepOutForeground);
        if (debugIconStepOutColor) {
            collector.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugStepOut)}, .monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugStepOut)}, .monaco-workbench ${ThemeIcon.asCSSSelector(debugStepOut)} { color: ${debugIconStepOutColor}; }`);
        }
        const debugIconContinueColor = theme.getColor(debugIconContinueForeground);
        if (debugIconContinueColor) {
            collector.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugContinue)}, .monaco-workbench ${ThemeIcon.asCSSSelector(debugContinue)}, .monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugReverseContinue)}, .monaco-workbench ${ThemeIcon.asCSSSelector(debugReverseContinue)} { color: ${debugIconContinueColor}; }`);
        }
        const debugIconStepBackColor = theme.getColor(debugIconStepBackForeground);
        if (debugIconStepBackColor) {
            collector.addRule(`.monaco-workbench .part > .title > .title-actions .action-label${ThemeIcon.asCSSSelector(debugStepBack)}, .monaco-workbench ${ThemeIcon.asCSSSelector(debugStepBack)} { color: ${debugIconStepBackColor}; }`);
        }
    });
}
const DEBUG_TOOLBAR_POSITION_KEY = 'debug.actionswidgetposition';
const DEBUG_TOOLBAR_Y_KEY = 'debug.actionswidgety';
let DebugToolBar = class DebugToolBar extends Themable {
    constructor(notificationService, telemetryService, debugService, layoutService, storageService, configurationService, themeService, instantiationService, menuService, contextKeyService) {
        super(themeService);
        this.notificationService = notificationService;
        this.telemetryService = telemetryService;
        this.debugService = debugService;
        this.layoutService = layoutService;
        this.storageService = storageService;
        this.configurationService = configurationService;
        this.instantiationService = instantiationService;
        this.yCoordinate = 0;
        this.isVisible = false;
        this.isBuilt = false;
        this.stopActionViewItemDisposables = this._register(( (new DisposableStore())));
        this.$el = $$7('div.debug-toolbar');
        this.$el.style.top = `${layoutService.offset.top}px`;
        this.dragArea = append(this.$el, $$7('div.drag-area' + ThemeIcon.asCSSSelector(debugGripper)));
        const actionBarContainer = append(this.$el, $$7('div.action-bar-container'));
        this.debugToolBarMenu = menuService.createMenu(MenuId.DebugToolBar, contextKeyService);
        this._register(this.debugToolBarMenu);
        this.activeActions = [];
        this.actionBar = this._register(( (new ActionBar(actionBarContainer, {
            orientation: 0 ,
            actionViewItemProvider: (action) => {
                if (action.id === FOCUS_SESSION_ID) {
                    return this.instantiationService.createInstance(FocusSessionActionViewItem, action, undefined);
                }
                else if (action.id === STOP_ID || action.id === DISCONNECT_ID) {
                    this.stopActionViewItemDisposables.clear();
                    const item = this.instantiationService.invokeFunction(accessor => createDisconnectMenuItemAction(action, this.stopActionViewItemDisposables, accessor));
                    if (item) {
                        return item;
                    }
                }
                return createActionViewItem(this.instantiationService, action);
            }
        }))));
        this.updateScheduler = this._register(( (new RunOnceScheduler(() => {
            const state = this.debugService.state;
            const toolBarLocation = this.configurationService.getValue('debug').toolBarLocation;
            if (state === 0  ||
                toolBarLocation === 'docked' ||
                toolBarLocation === 'hidden' ||
                this.debugService.getModel().getSessions().every(s => s.suppressDebugToolbar) ||
                (state === 1  && this.debugService.initializingOptions?.suppressDebugToolbar)) {
                return this.hide();
            }
            const actions = [];
            createAndFillInActionBarActions(this.debugToolBarMenu, { shouldForwardArgs: true }, actions);
            if (!equals$1(actions, this.activeActions, (first, second) => first.id === second.id && first.enabled === second.enabled)) {
                this.actionBar.clear();
                this.actionBar.push(actions, { icon: true, label: false });
                this.activeActions = actions;
            }
            this.show();
        }, 20))));
        this.updateStyles();
        this.registerListeners();
        this.hide();
    }
    registerListeners() {
        this._register(this.debugService.onDidChangeState(() => this.updateScheduler.schedule()));
        this._register(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('debug.toolBarLocation')) {
                this.updateScheduler.schedule();
            }
        }));
        this._register(this.debugToolBarMenu.onDidChange(() => this.updateScheduler.schedule()));
        this._register(this.actionBar.actionRunner.onDidRun((e) => {
            if (e.error && !isCancellationError(e.error)) {
                this.notificationService.error(e.error);
            }
            this.telemetryService.publicLog2('workbenchActionExecuted', { id: e.action.id, from: 'debugActionsWidget' });
        }));
        this._register(addDisposableListener$1(window, EventType$1.RESIZE, () => this.setCoordinates()));
        this._register(addDisposableGenericMouseUpListener(this.dragArea, (event) => {
            const mouseClickEvent = ( (new StandardMouseEvent(event)));
            if (mouseClickEvent.detail === 2) {
                const widgetWidth = this.$el.clientWidth;
                this.setCoordinates(0.5 * window.innerWidth - 0.5 * widgetWidth, 0);
                this.storePosition();
            }
        }));
        this._register(addDisposableGenericMouseDownListener(this.dragArea, (event) => {
            this.dragArea.classList.add('dragged');
            const mouseMoveListener = addDisposableGenericMouseMoveListener(window, (e) => {
                const mouseMoveEvent = ( (new StandardMouseEvent(e)));
                mouseMoveEvent.preventDefault();
                this.setCoordinates(mouseMoveEvent.posx - 14, mouseMoveEvent.posy - (this.layoutService.offset.top));
            });
            const mouseUpListener = addDisposableGenericMouseUpListener(window, (e) => {
                this.storePosition();
                this.dragArea.classList.remove('dragged');
                mouseMoveListener.dispose();
                mouseUpListener.dispose();
            });
        }));
        this._register(this.layoutService.onDidChangePartVisibility(() => this.setYCoordinate()));
        this._register(PixelRatio.onDidChange(() => this.setYCoordinate()));
    }
    storePosition() {
        const left = getComputedStyle(this.$el).left;
        if (left) {
            const position = parseFloat(left) / window.innerWidth;
            this.storageService.store(DEBUG_TOOLBAR_POSITION_KEY, position, 0 , 1 );
        }
    }
    updateStyles() {
        super.updateStyles();
        if (this.$el) {
            this.$el.style.backgroundColor = this.getColor(debugToolBarBackground) || '';
            const widgetShadowColor = this.getColor(widgetShadow);
            this.$el.style.boxShadow = widgetShadowColor ? `0 0 8px 2px ${widgetShadowColor}` : '';
            const contrastBorderColor = this.getColor(widgetBorder);
            const borderColor = this.getColor(debugToolBarBorder);
            if (contrastBorderColor) {
                this.$el.style.border = `1px solid ${contrastBorderColor}`;
            }
            else {
                this.$el.style.border = borderColor ? `solid ${borderColor}` : 'none';
                this.$el.style.border = '1px 0';
            }
        }
    }
    setYCoordinate(y = this.yCoordinate) {
        const titlebarOffset = this.layoutService.offset.top;
        this.$el.style.top = `${titlebarOffset + y}px`;
        this.yCoordinate = y;
    }
    setCoordinates(x, y) {
        if (!this.isVisible) {
            return;
        }
        const widgetWidth = this.$el.clientWidth;
        if (x === undefined) {
            const positionPercentage = this.storageService.get(DEBUG_TOOLBAR_POSITION_KEY, 0 );
            x = positionPercentage !== undefined ? parseFloat(positionPercentage) * window.innerWidth : (0.5 * window.innerWidth - 0.5 * widgetWidth);
        }
        x = Math.max(0, Math.min(x, window.innerWidth - widgetWidth));
        this.$el.style.left = `${x}px`;
        if (y === undefined) {
            y = this.storageService.getNumber(DEBUG_TOOLBAR_Y_KEY, 0 , 0);
        }
        const titleAreaHeight = 35;
        if ((y < titleAreaHeight / 2) || (y > titleAreaHeight + titleAreaHeight / 2)) {
            const moveToTop = y < titleAreaHeight;
            this.setYCoordinate(moveToTop ? 0 : titleAreaHeight);
            this.storageService.store(DEBUG_TOOLBAR_Y_KEY, moveToTop ? 0 : 2 * titleAreaHeight, 0 , 1 );
        }
    }
    show() {
        if (this.isVisible) {
            this.setCoordinates();
            return;
        }
        if (!this.isBuilt) {
            this.isBuilt = true;
            this.layoutService.container.appendChild(this.$el);
        }
        this.isVisible = true;
        show(this.$el);
        this.setCoordinates();
    }
    hide() {
        this.isVisible = false;
        hide(this.$el);
    }
    dispose() {
        super.dispose();
        this.$el?.remove();
    }
};
DebugToolBar = ( (__decorate([
    ( (__param(0, INotificationService))),
    ( (__param(1, ITelemetryService))),
    ( (__param(2, IDebugService))),
    ( (__param(3, IWorkbenchLayoutService))),
    ( (__param(4, IStorageService))),
    ( (__param(5, IConfigurationService))),
    ( (__param(6, IThemeService))),
    ( (__param(7, IInstantiationService))),
    ( (__param(8, IMenuService))),
    ( (__param(9, IContextKeyService)))
], DebugToolBar)));
function createDisconnectMenuItemAction(action, disposables, accessor) {
    const menuService = accessor.get(IMenuService);
    const contextKeyService = accessor.get(IContextKeyService);
    const instantiationService = accessor.get(IInstantiationService);
    const contextMenuService = accessor.get(IContextMenuService);
    const menu = menuService.createMenu(MenuId.DebugToolBarStop, contextKeyService);
    const secondary = [];
    createAndFillInActionBarActions(menu, { shouldForwardArgs: true }, secondary);
    if (!secondary.length) {
        return undefined;
    }
    const dropdownAction = disposables.add(( (new Action(
        'notebook.moreRunActions',
         (localize('notebook.moreRunActionsLabel', "More...")),
        'codicon-chevron-down',
        true
    ))));
    const item = instantiationService.createInstance(DropdownWithPrimaryActionViewItem, action, dropdownAction, secondary, 'debug-stop-actions', contextMenuService, {});
    return item;
}
const debugViewTitleItems = [];
const registerDebugToolBarItem = (id, title, order, icon, when, precondition, alt) => {
    MenuRegistry.appendMenuItem(MenuId.DebugToolBar, {
        group: 'navigation',
        when,
        order,
        command: {
            id,
            title,
            icon,
            precondition
        },
        alt
    });
    debugViewTitleItems.push(MenuRegistry.appendMenuItem(MenuId.ViewContainerTitle, {
        group: 'navigation',
        when: ( (ContextKeyExpr.and(
            when,
            ContextKeyExpr.equals('viewContainer', VIEWLET_ID$1),
             (CONTEXT_DEBUG_STATE.notEqualsTo('inactive')),
            ContextKeyExpr.equals('config.debug.toolBarLocation', 'docked')
        ))),
        order,
        command: {
            id,
            title,
            icon,
            precondition
        }
    }));
};
MenuRegistry.onDidChangeMenu(e => {
    if (e.has(MenuId.DebugToolBar)) {
        dispose(debugViewTitleItems);
        const items = MenuRegistry.getMenuItems(MenuId.DebugToolBar);
        for (const i of items) {
            debugViewTitleItems.push(MenuRegistry.appendMenuItem(MenuId.ViewContainerTitle, {
                ...i,
                when: ( (ContextKeyExpr.and(
                    i.when,
                    ContextKeyExpr.equals('viewContainer', VIEWLET_ID$1),
                     (CONTEXT_DEBUG_STATE.notEqualsTo('inactive')),
                    ContextKeyExpr.equals('config.debug.toolBarLocation', 'docked')
                )))
            }));
        }
    }
});
registerDebugToolBarItem(CONTINUE_ID, CONTINUE_LABEL, 10, debugContinue, ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))));
registerDebugToolBarItem(PAUSE_ID, PAUSE_LABEL, 10, debugPause, ( (CONTEXT_DEBUG_STATE.notEqualsTo('stopped'))), ( (CONTEXT_DEBUG_STATE.isEqualTo('running'))));
registerDebugToolBarItem(STOP_ID, STOP_LABEL, 70, debugStop, ( (CONTEXT_FOCUSED_SESSION_IS_ATTACH.toNegated())), undefined, { id: DISCONNECT_ID, title: DISCONNECT_LABEL, icon: debugDisconnect, precondition: ( (ContextKeyExpr.and(
     (CONTEXT_FOCUSED_SESSION_IS_ATTACH.toNegated()),
    CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED
))), });
registerDebugToolBarItem(DISCONNECT_ID, DISCONNECT_LABEL, 70, debugDisconnect, CONTEXT_FOCUSED_SESSION_IS_ATTACH, undefined, { id: STOP_ID, title: STOP_LABEL, icon: debugStop, precondition: ( (ContextKeyExpr.and(CONTEXT_FOCUSED_SESSION_IS_ATTACH, CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED))), });
registerDebugToolBarItem(STEP_OVER_ID, STEP_OVER_LABEL, 20, debugStepOver, undefined, ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))));
registerDebugToolBarItem(STEP_INTO_ID, STEP_INTO_LABEL, 30, debugStepInto, undefined, ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))));
registerDebugToolBarItem(STEP_OUT_ID, STEP_OUT_LABEL, 40, debugStepOut, undefined, ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))));
registerDebugToolBarItem(RESTART_SESSION_ID, RESTART_LABEL, 60, debugRestart);
registerDebugToolBarItem(STEP_BACK_ID, ( (localize('stepBackDebug', "Step Back"))), 50, debugStepBack, CONTEXT_STEP_BACK_SUPPORTED, ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))));
registerDebugToolBarItem(REVERSE_CONTINUE_ID, ( (localize('reverseContinue', "Reverse"))), 55, debugReverseContinue, CONTEXT_STEP_BACK_SUPPORTED, ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped'))));
registerDebugToolBarItem(FOCUS_SESSION_ID, FOCUS_SESSION_LABEL, 100, undefined, CONTEXT_MULTI_SESSION_DEBUG);
MenuRegistry.appendMenuItem(MenuId.DebugToolBarStop, {
    group: 'navigation',
    when: ( (ContextKeyExpr.and(
         (CONTEXT_FOCUSED_SESSION_IS_ATTACH.toNegated()),
        CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED
    ))),
    order: 0,
    command: {
        id: DISCONNECT_ID,
        title: DISCONNECT_LABEL,
        icon: debugDisconnect
    }
});
MenuRegistry.appendMenuItem(MenuId.DebugToolBarStop, {
    group: 'navigation',
    when: ( (ContextKeyExpr.and(CONTEXT_FOCUSED_SESSION_IS_ATTACH, CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED))),
    order: 0,
    command: {
        id: STOP_ID,
        title: STOP_LABEL,
        icon: debugStop
    }
});
MenuRegistry.appendMenuItem(MenuId.DebugToolBarStop, {
    group: 'navigation',
    when: ( (ContextKeyExpr.or( (ContextKeyExpr.and(
         (CONTEXT_FOCUSED_SESSION_IS_ATTACH.toNegated()),
        CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED,
        CONTEXT_TERMINATE_DEBUGGEE_SUPPORTED
    )),  (ContextKeyExpr.and(CONTEXT_FOCUSED_SESSION_IS_ATTACH, CONTEXT_SUSPEND_DEBUGGEE_SUPPORTED))))),
    order: 0,
    command: {
        id: DISCONNECT_AND_SUSPEND_ID,
        title: DISCONNECT_AND_SUSPEND_LABEL,
        icon: debugDisconnect
    }
});
let DebugContentProvider = class DebugContentProvider {
    constructor(textModelResolverService, debugService, modelService, languageService, editorWorkerService) {
        this.debugService = debugService;
        this.modelService = modelService;
        this.languageService = languageService;
        this.editorWorkerService = editorWorkerService;
        this.pendingUpdates = ( (new Map()));
        textModelResolverService.registerTextModelContentProvider(DEBUG_SCHEME, this);
        DebugContentProvider.INSTANCE = this;
    }
    dispose() {
        this.pendingUpdates.forEach(cancellationSource => cancellationSource.dispose());
    }
    provideTextContent(resource) {
        return this.createOrUpdateContentModel(resource, true);
    }
    static refreshDebugContent(resource) {
        DebugContentProvider.INSTANCE?.createOrUpdateContentModel(resource, false);
    }
    createOrUpdateContentModel(resource, createIfNotExists) {
        const model = this.modelService.getModel(resource);
        if (!model && !createIfNotExists) {
            return null;
        }
        let session;
        if (resource.query) {
            const data = Source.getEncodedDebugData(resource);
            session = this.debugService.getModel().getSession(data.sessionId);
        }
        if (!session) {
            session = this.debugService.getViewModel().focusedSession;
        }
        if (!session) {
            return Promise.reject(( (new ErrorNoTelemetry(
                 (localize('unable', "Unable to resolve the resource without a debug session"))
            ))));
        }
        const createErrModel = (errMsg) => {
            this.debugService.sourceIsNotAvailable(resource);
            const languageSelection = this.languageService.createById(PLAINTEXT_LANGUAGE_ID);
            const message = errMsg
                ? ( (localize(
                'canNotResolveSourceWithError',
                "Could not load source '{0}': {1}.",
                resource.path,
                errMsg
            )))
                : ( (localize('canNotResolveSource', "Could not load source '{0}'.", resource.path)));
            return this.modelService.createModel(message, languageSelection, resource);
        };
        return session.loadSource(resource).then(response => {
            if (response && response.body) {
                if (model) {
                    const newContent = response.body.content;
                    const cancellationSource = this.pendingUpdates.get(model.id);
                    cancellationSource?.cancel();
                    const myToken = ( (new CancellationTokenSource()));
                    this.pendingUpdates.set(model.id, myToken);
                    return this.editorWorkerService.computeMoreMinimalEdits(model.uri, [{ text: newContent, range: model.getFullModelRange() }]).then(edits => {
                        this.pendingUpdates.delete(model.id);
                        if (!myToken.token.isCancellationRequested && edits && edits.length > 0) {
                            model.applyEdits(( (edits.map(edit => EditOperation.replace(Range.lift(edit.range), edit.text)))));
                        }
                        return model;
                    });
                }
                else {
                    const mime = response.body.mimeType || getMimeTypes(resource)[0];
                    const languageSelection = this.languageService.createByMimeType(mime);
                    return this.modelService.createModel(response.body.content, languageSelection, resource);
                }
            }
            return createErrModel();
        }, (err) => createErrModel(err.message));
    }
};
DebugContentProvider = ( (__decorate([
    ( (__param(0, ITextModelService))),
    ( (__param(1, IDebugService))),
    ( (__param(2, IModelService))),
    ( (__param(3, ILanguageService))),
    ( (__param(4, IEditorWorkerService)))
], DebugContentProvider)));
var css$4 = ".codicon-debug-hint{cursor:pointer}.codicon-debug-hint:not([class*=codicon-debug-breakpoint]):not([class*=codicon-debug-stackframe]){opacity:.4!important}.inline-breakpoint-widget.codicon{align-items:center;display:flex!important}.inline-breakpoint-widget.codicon-debug-breakpoint-disabled{opacity:.7}.monaco-editor .inline-breakpoint-widget.line-start{left:-8px!important}.monaco-editor .debug-breakpoint-placeholder{display:inline-flex;margin-top:-1px;vertical-align:middle;width:.9em}.codicon-debug-breakpoint.codicon-debug-stackframe-focused:after,.codicon-debug-breakpoint.codicon-debug-stackframe:after{content:\"\\eb8a\";position:absolute}.monaco-editor .debug-top-stack-frame-column{text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;align-items:center;display:inline-flex;font:normal normal normal 16px/1 codicon;margin-left:0;margin-right:4px;margin-top:-1px;vertical-align:middle;width:.9em}.monaco-editor .debug-top-stack-frame-column.start-of-line{margin-top:0;position:absolute;top:50%;transform:translate(-17px,-50%)}.monaco-editor .inline-breakpoint-widget{cursor:pointer}.monaco-workbench .debug-view-content .monaco-list-row .monaco-tl-contents{overflow:hidden;text-overflow:ellipsis}.monaco-workbench .monaco-list-row .expression{display:flex}.monaco-workbench .debug-hover-widget .monaco-list-row .expression,.monaco-workbench .debug-pane .monaco-list-row .expression{font-family:var(--monaco-monospace-font);font-size:13px;overflow:hidden;text-overflow:ellipsis;white-space:pre}.monaco-workbench.mac .debug-hover-widget .monaco-list-row .expression,.monaco-workbench.mac .debug-pane .monaco-list-row .expression{font-size:11px}.monaco-workbench .monaco-list-row .expression .value{margin-left:6px}.monaco-workbench .monaco-list-row .expression .lazy-button{align-self:center;border-radius:5px;display:none;margin-left:3px}.monaco-workbench .monaco-list-row .expression.lazy .lazy-button{display:inline}.monaco-workbench .monaco-list-row .expression .value a.link:hover{text-decoration:underline}.monaco-workbench .monaco-list-row .expression .value a.link.pointer{cursor:pointer}.monaco-workbench .monaco-list:focus .monaco-list-row.selected .expression .name,.monaco-workbench .monaco-list:focus .monaco-list-row.selected .expression .value{color:inherit}.monaco-workbench .monaco-list-row .expression .name.internal,.monaco-workbench .monaco-list-row .expression .name.virtual{opacity:.5}.monaco-workbench .monaco-list-row .expression .unavailable{font-style:italic}.monaco-workbench .debug-inline-value{background-color:var(--vscode-editor-inlineValuesBackground);color:var(--vscode-editor-inlineValuesForeground)}";
n(css$4,{});
var css$3 = ".monaco-editor .debug-hover-widget{animation-duration:.15s;animation-name:fadeIn;position:absolute;user-select:text;-webkit-user-select:text;white-space:pre;word-break:break-all;z-index:50}.monaco-editor .debug-hover-widget .complex-value{max-width:550px}.monaco-editor .debug-hover-widget .complex-value .tip,.monaco-editor .debug-hover-widget .complex-value .title{font-size:11px;height:18px;line-height:18px;overflow:hidden;padding-left:15px;padding-right:2px;text-overflow:ellipsis;white-space:pre;word-break:normal}.monaco-editor .debug-hover-widget .complex-value .title{border-bottom:1px solid hsla(0,0%,50%,.35)}.monaco-editor .debug-hover-widget .complex-value .tip{border-top:1px solid hsla(0,0%,50%,.35);opacity:.5}.monaco-editor .debug-hover-widget .debug-hover-tree{cursor:pointer;line-height:18px}.monaco-editor .debug-hover-widget .debug-hover-tree .monaco-list-row .monaco-tl-contents{user-select:text;-webkit-user-select:text;white-space:pre}.monaco-editor .debug-hover-widget .debug-hover-tree .monaco-list-rows .monaco-list-row:hover:not(.highlighted):not(.selected):not(.focused){background-color:inherit}.monaco-editor .debug-hover-widget pre{margin-bottom:0;margin-top:0}.monaco-editor .debugHoverHighlight{background-color:rgba(173,214,255,.15)}.monaco-editor .debug-hover-widget>.monaco-scrollable-element>.value{color:hsla(0,0%,42%,.8);font-family:var(--monaco-monospace-font);max-height:500px;overflow:auto;padding:4px 5px;white-space:pre-wrap}.monaco-editor.hc-theme .debugHoverHighlight,.monaco-editor.vs-dark .debugHoverHighlight{background-color:rgba(38,79,120,.25)}";
n(css$3,{});
var css$2 = ".monaco-editor .zone-widget .zone-widget-container.breakpoint-widget{border-color:#007acc;display:flex}.monaco-editor .zone-widget .zone-widget-container.breakpoint-widget .breakpoint-select-container{display:flex;flex-direction:column;flex-shrink:0;justify-content:center;padding:0 10px}.monaco-editor .zone-widget .zone-widget-container.breakpoint-widget .breakpoint-select-container .monaco-select-box{min-height:18px;min-width:100px;padding:2px 20px 2px 8px}.monaco-editor .zone-widget .zone-widget-container.breakpoint-widget .breakpoint-select-container:after{right:14px}.monaco-editor .zone-widget .zone-widget-container.breakpoint-widget .inputContainer{flex:1}";
n(css$2,{});
class MenuPreventer extends Disposable {
    constructor(editor) {
        super();
        this._editor = editor;
        this._altListeningMouse = false;
        this._altMouseTriggered = false;
        this._register(this._editor.onMouseDown((e) => {
            if (this._altListeningMouse) {
                this._altMouseTriggered = true;
            }
        }));
        this._register(this._editor.onKeyDown((e) => {
            if (e.equals(512 )) {
                if (!this._altListeningMouse) {
                    this._altMouseTriggered = false;
                }
                this._altListeningMouse = true;
            }
        }));
        this._register(this._editor.onKeyUp((e) => {
            if (e.equals(512 )) {
                if (this._altMouseTriggered) {
                    e.preventDefault();
                }
                this._altListeningMouse = false;
                this._altMouseTriggered = false;
            }
        }));
    }
}
MenuPreventer.ID = 'editor.contrib.menuPreventer';
registerEditorContribution(MenuPreventer.ID, MenuPreventer, 2 );
const SelectionClipboardContributionID = 'editor.contrib.selectionClipboard';
let TabCompletionController = class TabCompletionController {
    static get(editor) {
        return editor.getContribution(TabCompletionController.ID);
    }
    constructor(_editor, _snippetService, _clipboardService, _languageFeaturesService, contextKeyService) {
        this._editor = _editor;
        this._snippetService = _snippetService;
        this._clipboardService = _clipboardService;
        this._languageFeaturesService = _languageFeaturesService;
        this._activeSnippets = [];
        this._hasSnippets = TabCompletionController.ContextKey.bindTo(contextKeyService);
        this._configListener = this._editor.onDidChangeConfiguration(e => {
            if (e.hasChanged(117 )) {
                this._update();
            }
        });
        this._update();
    }
    dispose() {
        this._configListener.dispose();
        this._selectionListener?.dispose();
    }
    _update() {
        const enabled = this._editor.getOption(117 ) === 'onlySnippets';
        if (this._enabled !== enabled) {
            this._enabled = enabled;
            if (!this._enabled) {
                this._selectionListener?.dispose();
            }
            else {
                this._selectionListener = this._editor.onDidChangeCursorSelection(e => this._updateSnippets());
                if (this._editor.getModel()) {
                    this._updateSnippets();
                }
            }
        }
    }
    _updateSnippets() {
        this._activeSnippets = [];
        this._completionProvider?.dispose();
        if (!this._editor.hasModel()) {
            return;
        }
        const selection = this._editor.getSelection();
        const model = this._editor.getModel();
        model.tokenization.tokenizeIfCheap(selection.positionLineNumber);
        const id = model.getLanguageIdAtPosition(selection.positionLineNumber, selection.positionColumn);
        const snippets = this._snippetService.getSnippetsSync(id);
        if (!snippets) {
            this._hasSnippets.set(false);
            return;
        }
        if (Range.isEmpty(selection)) {
            const prefix = getNonWhitespacePrefix(model, selection.getPosition());
            if (prefix) {
                for (const snippet of snippets) {
                    if (prefix.endsWith(snippet.prefix)) {
                        this._activeSnippets.push(snippet);
                    }
                }
            }
        }
        else if (!Range.spansMultipleLines(selection) && model.getValueLengthInRange(selection) <= 100) {
            const selected = model.getValueInRange(selection);
            if (selected) {
                for (const snippet of snippets) {
                    if (selected === snippet.prefix) {
                        this._activeSnippets.push(snippet);
                    }
                }
            }
        }
        const len = this._activeSnippets.length;
        if (len === 0) {
            this._hasSnippets.set(false);
        }
        else if (len === 1) {
            this._hasSnippets.set(true);
        }
        else {
            this._hasSnippets.set(true);
            this._completionProvider = {
                dispose: () => {
                    registration.dispose();
                },
                provideCompletionItems: (_model, position) => {
                    if (_model !== model || !selection.containsPosition(position)) {
                        return;
                    }
                    const suggestions = ( (this._activeSnippets.map(snippet => {
                        const range = Range.fromPositions(position.delta(0, -snippet.prefix.length), position);
                        return (
                             (new SnippetCompletion(snippet, range))
                        );
                    })));
                    return { suggestions };
                }
            };
            const registration = this._languageFeaturesService.completionProvider.register({ language: model.getLanguageId(), pattern: model.uri.fsPath, scheme: model.uri.scheme }, this._completionProvider);
        }
    }
    async performSnippetCompletions() {
        if (!this._editor.hasModel()) {
            return;
        }
        if (this._activeSnippets.length === 1) {
            const [snippet] = this._activeSnippets;
            let clipboardText;
            if (snippet.needsClipboard) {
                const state = ( (new EditorState(
                    this._editor,
                    1  | 4
                )));
                clipboardText = await this._clipboardService.readText();
                if (!state.validate(this._editor)) {
                    return;
                }
            }
            SnippetController2.get(this._editor)?.insert(snippet.codeSnippet, {
                overwriteBefore: snippet.prefix.length, overwriteAfter: 0,
                clipboardText
            });
        }
        else if (this._activeSnippets.length > 1) {
            if (this._completionProvider) {
                showSimpleSuggestions(this._editor, this._completionProvider);
            }
        }
    }
};
TabCompletionController.ID = 'editor.tabCompletionController';
TabCompletionController.ContextKey = ( (new RawContextKey('hasSnippetCompletions', undefined)));
TabCompletionController = ( (__decorate([
    ( (__param(1, ISnippetsService))),
    ( (__param(2, IClipboardService))),
    ( (__param(3, ILanguageFeaturesService))),
    ( (__param(4, IContextKeyService)))
], TabCompletionController)));
registerEditorContribution(TabCompletionController.ID, TabCompletionController, 0 );
const TabCompletionCommand = EditorCommand.bindToContribution(TabCompletionController.get);
registerEditorCommand(( (new TabCompletionCommand({
    id: 'insertSnippet',
    precondition: TabCompletionController.ContextKey,
    handler: x => x.performSnippetCompletions(),
    kbOpts: {
        weight: 100 ,
        kbExpr: ( (ContextKeyExpr.and(
            EditorContextKeys.editorTextFocus,
            EditorContextKeys.tabDoesNotMoveFocus,
             (SnippetController2.InSnippetMode.toNegated())
        ))),
        primary: 2
    }
}))));
function getSimpleEditorOptions() {
    return {
        wordWrap: 'on',
        overviewRulerLanes: 0,
        glyphMargin: false,
        lineNumbers: 'off',
        folding: false,
        selectOnLineNumbers: false,
        hideCursorInOverviewRuler: true,
        selectionHighlight: false,
        scrollbar: {
            horizontal: 'hidden'
        },
        lineDecorationsWidth: 0,
        overviewRulerBorder: false,
        scrollBeyondLastLine: false,
        renderLineHighlight: 'none',
        fixedOverflowWidgets: true,
        acceptSuggestionOnEnter: 'smart',
        dragAndDrop: false,
        revealHorizontalRightPadding: 5,
        minimap: {
            enabled: false
        },
        guides: {
            indentation: false
        }
    };
}
function getSimpleCodeEditorWidgetOptions() {
    return {
        isSimpleWidget: true,
        contributions: EditorExtensionsRegistry.getSomeEditorContributions([
            MenuPreventer.ID,
            SelectionClipboardContributionID,
            ContextMenuController.ID,
            SuggestController.ID,
            SnippetController2.ID,
            TabCompletionController.ID,
        ])
    };
}
const $$4 = $$7;
const IPrivateBreakpointWidgetService = ( (createDecorator('privateBreakpointWidgetService')));
const DECORATION_KEY = 'breakpointwidgetdecoration';
function isPositionInCurlyBracketBlock(input) {
    const model = input.getModel();
    const bracketPairs = model.bracketPairs.getBracketPairsInRange(Range.fromPositions(input.getPosition()));
    return bracketPairs.some(p => p.openingBracketInfo.bracketText === '{');
}
function createDecorations(theme, placeHolder) {
    const transparentForeground = theme.getColor(editorForeground)?.transparent(0.4);
    return [{
            range: {
                startLineNumber: 0,
                endLineNumber: 0,
                startColumn: 0,
                endColumn: 1
            },
            renderOptions: {
                after: {
                    contentText: placeHolder,
                    color: transparentForeground ? ( (transparentForeground.toString())) : undefined
                }
            }
        }];
}
let BreakpointWidget = class BreakpointWidget extends ZoneWidget {
    constructor(editor, lineNumber, column, context, contextViewService, debugService, themeService, contextKeyService, instantiationService, modelService, codeEditorService, _configurationService, languageFeaturesService) {
        super(editor, { showFrame: true, showArrow: false, frameWidth: 1, isAccessible: true });
        this.lineNumber = lineNumber;
        this.column = column;
        this.contextViewService = contextViewService;
        this.debugService = debugService;
        this.themeService = themeService;
        this.contextKeyService = contextKeyService;
        this.instantiationService = instantiationService;
        this.modelService = modelService;
        this.codeEditorService = codeEditorService;
        this._configurationService = _configurationService;
        this.languageFeaturesService = languageFeaturesService;
        this.conditionInput = '';
        this.hitCountInput = '';
        this.logMessageInput = '';
        this.toDispose = [];
        const model = this.editor.getModel();
        if (model) {
            const uri = model.uri;
            const breakpoints = this.debugService.getModel().getBreakpoints({ lineNumber: this.lineNumber, column: this.column, uri });
            this.breakpoint = breakpoints.length ? breakpoints[0] : undefined;
        }
        if (context === undefined) {
            if (this.breakpoint && !this.breakpoint.condition && !this.breakpoint.hitCondition && this.breakpoint.logMessage) {
                this.context = 2 ;
            }
            else if (this.breakpoint && !this.breakpoint.condition && this.breakpoint.hitCondition) {
                this.context = 1 ;
            }
            else {
                this.context = 0 ;
            }
        }
        else {
            this.context = context;
        }
        this.toDispose.push(this.debugService.getModel().onDidChangeBreakpoints(e => {
            if (this.breakpoint && e && e.removed && e.removed.indexOf(this.breakpoint) >= 0) {
                this.dispose();
            }
        }));
        this.codeEditorService.registerDecorationType('breakpoint-widget', DECORATION_KEY, {});
        this.create();
    }
    get placeholder() {
        switch (this.context) {
            case 2 :
                return (
                     (localize(
                        'breakpointWidgetLogMessagePlaceholder',
                        "Message to log when breakpoint is hit. Expressions within {} are interpolated. 'Enter' to accept, 'esc' to cancel."
                    ))
                );
            case 1 :
                return (
                     (localize(
                        'breakpointWidgetHitCountPlaceholder',
                        "Break when hit count condition is met. 'Enter' to accept, 'esc' to cancel."
                    ))
                );
            default:
                return (
                     (localize(
                        'breakpointWidgetExpressionPlaceholder',
                        "Break when expression evaluates to true. 'Enter' to accept, 'esc' to cancel."
                    ))
                );
        }
    }
    getInputValue(breakpoint) {
        switch (this.context) {
            case 2 :
                return breakpoint && breakpoint.logMessage ? breakpoint.logMessage : this.logMessageInput;
            case 1 :
                return breakpoint && breakpoint.hitCondition ? breakpoint.hitCondition : this.hitCountInput;
            default:
                return breakpoint && breakpoint.condition ? breakpoint.condition : this.conditionInput;
        }
    }
    rememberInput() {
        const value = this.input.getModel().getValue();
        switch (this.context) {
            case 2 :
                this.logMessageInput = value;
                break;
            case 1 :
                this.hitCountInput = value;
                break;
            default:
                this.conditionInput = value;
        }
    }
    setInputMode() {
        if (this.editor.hasModel()) {
            const languageId = this.context === 2  ? PLAINTEXT_LANGUAGE_ID : this.editor.getModel().getLanguageId();
            this.input.getModel().setMode(languageId);
        }
    }
    show(rangeOrPos) {
        const lineNum = this.input.getModel().getLineCount();
        super.show(rangeOrPos, lineNum + 1);
    }
    fitHeightToContent() {
        const lineNum = this.input.getModel().getLineCount();
        this._relayout(lineNum + 1);
    }
    _fillContainer(container) {
        this.setCssClass('breakpoint-widget');
        const selectBox = ( (new SelectBox(
            [{ text: ( (localize('expression', "Expression"))) }, { text: ( (localize('hitCount', "Hit Count"))) }, { text: ( (localize('logMessage', "Log Message"))) }],
            this.context,
            this.contextViewService,
            defaultSelectBoxStyles,
            { ariaLabel: ( (localize('breakpointType', 'Breakpoint Type'))) }
        )));
        this.selectContainer = $$4('.breakpoint-select-container');
        selectBox.render(append(container, this.selectContainer));
        selectBox.onDidSelect(e => {
            this.rememberInput();
            this.context = e.index;
            this.setInputMode();
            const value = this.getInputValue(this.breakpoint);
            this.input.getModel().setValue(value);
            this.input.focus();
        });
        this.inputContainer = $$4('.inputContainer');
        this.createBreakpointInput(append(container, this.inputContainer));
        this.input.getModel().setValue(this.getInputValue(this.breakpoint));
        this.toDispose.push(this.input.getModel().onDidChangeContent(() => {
            this.fitHeightToContent();
        }));
        this.input.setPosition({ lineNumber: 1, column: this.input.getModel().getLineMaxColumn(1) });
        setTimeout(() => this.input.focus(), 150);
    }
    _doLayout(heightInPixel, widthInPixel) {
        this.heightInPx = heightInPixel;
        this.input.layout({ height: heightInPixel, width: widthInPixel - 113 });
        this.centerInputVertically();
    }
    createBreakpointInput(container) {
        const scopedContextKeyService = this.contextKeyService.createScoped(container);
        this.toDispose.push(scopedContextKeyService);
        const scopedInstatiationService = this.instantiationService.createChild(( (new ServiceCollection(
            [IContextKeyService, scopedContextKeyService],
            [IPrivateBreakpointWidgetService, this]
        ))));
        const options = this.createEditorOptions();
        const codeEditorWidgetOptions = getSimpleCodeEditorWidgetOptions();
        this.input = scopedInstatiationService.createInstance(CodeEditorWidget, container, options, codeEditorWidgetOptions);
        CONTEXT_IN_BREAKPOINT_WIDGET.bindTo(scopedContextKeyService).set(true);
        const model = this.modelService.createModel('', null, ( URI.parse(`${DEBUG_SCHEME}:${this.editor.getId()}:breakpointinput`)), true);
        if (this.editor.hasModel()) {
            model.setMode(this.editor.getModel().getLanguageId());
        }
        this.input.setModel(model);
        this.setInputMode();
        this.toDispose.push(model);
        const setDecorations = () => {
            const value = this.input.getModel().getValue();
            const decorations = !!value ? [] : createDecorations(this.themeService.getColorTheme(), this.placeholder);
            this.input.setDecorationsByType('breakpoint-widget', DECORATION_KEY, decorations);
        };
        this.input.getModel().onDidChangeContent(() => setDecorations());
        this.themeService.onDidColorThemeChange(() => setDecorations());
        this.toDispose.push(this.languageFeaturesService.completionProvider.register({ scheme: DEBUG_SCHEME, hasAccessToAllModels: true }, {
            provideCompletionItems: (model, position, _context, token) => {
                let suggestionsPromise;
                const underlyingModel = this.editor.getModel();
                if (underlyingModel && (this.context === 0  || (this.context === 2  && isPositionInCurlyBracketBlock(this.input)))) {
                    suggestionsPromise = provideSuggestionItems(this.languageFeaturesService.completionProvider, underlyingModel, ( (new Position(this.lineNumber, 1))), ( (new CompletionOptions(
                        undefined,
                        ( (new Set())).add(27 )
                    ))), _context, token).then(suggestions => {
                        let overwriteBefore = 0;
                        if (this.context === 0 ) {
                            overwriteBefore = position.column - 1;
                        }
                        else {
                            const value = this.input.getModel().getValue();
                            while ((position.column - 2 - overwriteBefore >= 0) && value[position.column - 2 - overwriteBefore] !== '{' && value[position.column - 2 - overwriteBefore] !== ' ') {
                                overwriteBefore++;
                            }
                        }
                        return {
                            suggestions: ( (suggestions.items.map(s => {
                                s.completion.range = Range.fromPositions(position.delta(0, -overwriteBefore), position);
                                return s.completion;
                            })))
                        };
                    });
                }
                else {
                    suggestionsPromise = Promise.resolve({ suggestions: [] });
                }
                return suggestionsPromise;
            }
        }));
        this.toDispose.push(this._configurationService.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration('editor.fontSize') || e.affectsConfiguration('editor.lineHeight')) {
                this.input.updateOptions(this.createEditorOptions());
                this.centerInputVertically();
            }
        }));
    }
    createEditorOptions() {
        const editorConfig = this._configurationService.getValue('editor');
        const options = getSimpleEditorOptions();
        options.fontSize = editorConfig.fontSize;
        options.fontFamily = editorConfig.fontFamily;
        options.lineHeight = editorConfig.lineHeight;
        options.fontLigatures = editorConfig.fontLigatures;
        options.ariaLabel = this.placeholder;
        return options;
    }
    centerInputVertically() {
        if (this.container && typeof this.heightInPx === 'number') {
            const lineHeight = this.input.getOption(63 );
            const lineNum = this.input.getModel().getLineCount();
            const newTopMargin = (this.heightInPx - lineNum * lineHeight) / 2;
            this.inputContainer.style.marginTop = newTopMargin + 'px';
        }
    }
    close(success) {
        if (success) {
            let condition = this.breakpoint && this.breakpoint.condition;
            let hitCondition = this.breakpoint && this.breakpoint.hitCondition;
            let logMessage = this.breakpoint && this.breakpoint.logMessage;
            this.rememberInput();
            if (this.conditionInput || this.context === 0 ) {
                condition = this.conditionInput;
            }
            if (this.hitCountInput || this.context === 1 ) {
                hitCondition = this.hitCountInput;
            }
            if (this.logMessageInput || this.context === 2 ) {
                logMessage = this.logMessageInput;
            }
            if (this.breakpoint) {
                const data = ( (new Map()));
                data.set(this.breakpoint.getId(), {
                    condition,
                    hitCondition,
                    logMessage
                });
                this.debugService.updateBreakpoints(this.breakpoint.uri, data, false).then(undefined, onUnexpectedError);
            }
            else {
                const model = this.editor.getModel();
                if (model) {
                    this.debugService.addBreakpoints(model.uri, [{
                            lineNumber: this.lineNumber,
                            column: this.column,
                            enabled: true,
                            condition,
                            hitCondition,
                            logMessage
                        }]);
                }
            }
        }
        this.dispose();
    }
    dispose() {
        super.dispose();
        this.input.dispose();
        dispose(this.toDispose);
        setTimeout(() => this.editor.focus(), 0);
    }
};
BreakpointWidget = ( (__decorate([
    ( (__param(4, IContextViewService))),
    ( (__param(5, IDebugService))),
    ( (__param(6, IThemeService))),
    ( (__param(7, IContextKeyService))),
    ( (__param(8, IInstantiationService))),
    ( (__param(9, IModelService))),
    ( (__param(10, ICodeEditorService))),
    ( (__param(11, IConfigurationService))),
    ( (__param(12, ILanguageFeaturesService)))
], BreakpointWidget)));
class AcceptBreakpointWidgetInputAction extends EditorCommand {
    constructor() {
        super({
            id: 'breakpointWidget.action.acceptInput',
            precondition: CONTEXT_BREAKPOINT_WIDGET_VISIBLE,
            kbOpts: {
                kbExpr: CONTEXT_IN_BREAKPOINT_WIDGET,
                primary: 3 ,
                weight: 100
            }
        });
    }
    runEditorCommand(accessor, editor) {
        accessor.get(IPrivateBreakpointWidgetService).close(true);
    }
}
class CloseBreakpointWidgetCommand extends EditorCommand {
    constructor() {
        super({
            id: 'closeBreakpointWidget',
            precondition: CONTEXT_BREAKPOINT_WIDGET_VISIBLE,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 9 ,
                secondary: [1024  | 9 ],
                weight: 100
            }
        });
    }
    runEditorCommand(accessor, editor, args) {
        const debugContribution = editor.getContribution(BREAKPOINT_EDITOR_CONTRIBUTION_ID);
        if (debugContribution) {
            return debugContribution.closeBreakpointWidget();
        }
        accessor.get(IPrivateBreakpointWidgetService).close(false);
    }
}
registerEditorCommand(( (new AcceptBreakpointWidgetInputAction())));
registerEditorCommand(( (new CloseBreakpointWidgetCommand())));
const $$3 = $$7;
const breakpointHelperDecoration = {
    description: 'breakpoint-helper-decoration',
    glyphMarginClassName: ThemeIcon.asClassName(debugBreakpointHint),
    stickiness: 1
};
function createBreakpointDecorations(accessor, model, breakpoints, state, breakpointsActivated, showBreakpointsInOverviewRuler) {
    const result = [];
    breakpoints.forEach((breakpoint) => {
        if (breakpoint.lineNumber > model.getLineCount()) {
            return;
        }
        const column = model.getLineFirstNonWhitespaceColumn(breakpoint.lineNumber);
        const range = model.validateRange(breakpoint.column ? ( (new Range(
            breakpoint.lineNumber,
            breakpoint.column,
            breakpoint.lineNumber,
            breakpoint.column + 1
        )))
            : ( (new Range(breakpoint.lineNumber, column, breakpoint.lineNumber, column + 1)))
        );
        result.push({
            options: getBreakpointDecorationOptions(accessor, model, breakpoint, state, breakpointsActivated, showBreakpointsInOverviewRuler),
            range
        });
    });
    return result;
}
function getBreakpointDecorationOptions(accessor, model, breakpoint, state, breakpointsActivated, showBreakpointsInOverviewRuler) {
    const debugService = accessor.get(IDebugService);
    const languageService = accessor.get(ILanguageService);
    const { icon, message, showAdapterUnverifiedMessage } = getBreakpointMessageAndIcon(state, breakpointsActivated, breakpoint, undefined);
    let glyphMarginHoverMessage;
    let unverifiedMessage;
    if (showAdapterUnverifiedMessage) {
        let langId;
        unverifiedMessage = ( (debugService.getModel().getSessions().map(s => {
            const dbg = debugService.getAdapterManager().getDebugger(s.configuration.type);
            const message = dbg?.strings?.[DebuggerString.UnverifiedBreakpoints];
            if (message) {
                if (!langId) {
                    langId = withNullAsUndefined(languageService.guessLanguageIdByFilepathOrFirstLine(breakpoint.uri));
                }
                return langId && dbg.interestedInLanguage(langId) ? message : undefined;
            }
            return undefined;
        })))
            .find(messages => !!messages);
    }
    if (message) {
        glyphMarginHoverMessage = ( (new MarkdownString(undefined, { isTrusted: true, supportThemeIcons: true })));
        if (breakpoint.condition || breakpoint.hitCondition) {
            const languageId = model.getLanguageId();
            glyphMarginHoverMessage.appendCodeblock(languageId, message);
            if (unverifiedMessage) {
                glyphMarginHoverMessage.appendMarkdown('$(warning) ' + unverifiedMessage);
            }
        }
        else {
            glyphMarginHoverMessage.appendText(message);
            if (unverifiedMessage) {
                glyphMarginHoverMessage.appendMarkdown('\n\n$(warning) ' + unverifiedMessage);
            }
        }
    }
    else if (unverifiedMessage) {
        glyphMarginHoverMessage = ( (new MarkdownString(undefined, { isTrusted: true, supportThemeIcons: true }))).appendMarkdown(unverifiedMessage);
    }
    let overviewRulerDecoration = null;
    if (showBreakpointsInOverviewRuler) {
        overviewRulerDecoration = {
            color: themeColorFromId(debugIconBreakpointForeground),
            position: OverviewRulerLane.Left
        };
    }
    const renderInline = breakpoint.column && (breakpoint.column > model.getLineFirstNonWhitespaceColumn(breakpoint.lineNumber));
    return {
        description: 'breakpoint-decoration',
        glyphMarginClassName: ThemeIcon.asClassName(icon),
        glyphMarginHoverMessage,
        stickiness: 1 ,
        before: renderInline ? {
            content: noBreakWhitespace,
            inlineClassName: `debug-breakpoint-placeholder`,
            inlineClassNameAffectsLetterSpacing: true
        } : undefined,
        overviewRuler: overviewRulerDecoration
    };
}
async function createCandidateDecorations(model, breakpointDecorations, session) {
    const lineNumbers = distinct(( (breakpointDecorations.map(bpd => bpd.range.startLineNumber))));
    const result = [];
    if (session.capabilities.supportsBreakpointLocationsRequest) {
        await Promise.all(( (lineNumbers.map(async (lineNumber) => {
            try {
                const positions = await session.breakpointsLocations(model.uri, lineNumber);
                if (positions.length > 1) {
                    const firstColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
                    const lastColumn = model.getLineLastNonWhitespaceColumn(lineNumber);
                    positions.forEach(p => {
                        const range = ( (new Range(p.lineNumber, p.column, p.lineNumber, p.column + 1)));
                        if (p.column <= firstColumn || p.column > lastColumn) {
                            return;
                        }
                        const breakpointAtPosition = breakpointDecorations.find(bpd => bpd.range.equalsRange(range));
                        if (breakpointAtPosition && breakpointAtPosition.inlineWidget) {
                            return;
                        }
                        result.push({
                            range,
                            options: {
                                description: 'breakpoint-placeholder-decoration',
                                stickiness: 1 ,
                                before: breakpointAtPosition ? undefined : {
                                    content: noBreakWhitespace,
                                    inlineClassName: `debug-breakpoint-placeholder`,
                                    inlineClassNameAffectsLetterSpacing: true
                                },
                            },
                            breakpoint: breakpointAtPosition ? breakpointAtPosition.breakpoint : undefined
                        });
                    });
                }
            }
            catch (e) {
            }
        }))));
    }
    return result;
}
let BreakpointEditorContribution = class BreakpointEditorContribution {
    constructor(editor, debugService, contextMenuService, instantiationService, contextKeyService, dialogService, configurationService, labelService) {
        this.editor = editor;
        this.debugService = debugService;
        this.contextMenuService = contextMenuService;
        this.instantiationService = instantiationService;
        this.dialogService = dialogService;
        this.configurationService = configurationService;
        this.labelService = labelService;
        this.breakpointHintDecoration = null;
        this.toDispose = [];
        this.ignoreDecorationsChangedEvent = false;
        this.ignoreBreakpointsChangeEvent = false;
        this.breakpointDecorations = [];
        this.candidateDecorations = [];
        this.breakpointWidgetVisible = CONTEXT_BREAKPOINT_WIDGET_VISIBLE.bindTo(contextKeyService);
        this.setDecorationsScheduler = ( (new RunOnceScheduler(() => this.setDecorations(), 30)));
        this.setDecorationsScheduler.schedule();
        this.registerListeners();
    }
    getContextMenuActionsAtPosition(lineNumber, model) {
        if (!this.debugService.getAdapterManager().hasEnabledDebuggers()) {
            return [];
        }
        if (!this.debugService.canSetBreakpointsIn(model)) {
            return [];
        }
        const breakpoints = this.debugService.getModel().getBreakpoints({ lineNumber, uri: model.uri });
        return this.getContextMenuActions(breakpoints, model.uri, lineNumber);
    }
    registerListeners() {
        this.toDispose.push(this.editor.onMouseDown(async (e) => {
            if (!this.debugService.getAdapterManager().hasEnabledDebuggers()) {
                return;
            }
            const model = this.editor.getModel();
            if (!e.target.position || !model || e.target.type !== 2  || e.target.detail.isAfterLines || !this.marginFreeFromNonDebugDecorations(e.target.position.lineNumber)) {
                return;
            }
            const canSetBreakpoints = this.debugService.canSetBreakpointsIn(model);
            const lineNumber = e.target.position.lineNumber;
            const uri = model.uri;
            if (e.event.rightButton || (isMacintosh && e.event.leftButton && e.event.ctrlKey)) {
                if (!canSetBreakpoints) {
                    return;
                }
                const anchor = { x: e.event.posx, y: e.event.posy };
                const breakpoints = this.debugService.getModel().getBreakpoints({ lineNumber, uri });
                const actions = this.getContextMenuActions(breakpoints, uri, lineNumber);
                this.contextMenuService.showContextMenu({
                    getAnchor: () => anchor,
                    getActions: () => actions,
                    getActionsContext: () => breakpoints.length ? breakpoints[0] : undefined,
                    onHide: () => disposeIfDisposable(actions)
                });
            }
            else {
                const breakpoints = this.debugService.getModel().getBreakpoints({ uri, lineNumber });
                if (breakpoints.length) {
                    const isShiftPressed = e.event.shiftKey;
                    const enabled = breakpoints.some(bp => bp.enabled);
                    if (isShiftPressed) {
                        breakpoints.forEach(bp => this.debugService.enableOrDisableBreakpoints(!enabled, bp));
                    }
                    else if (!isLinux && breakpoints.some(bp => !!bp.condition || !!bp.logMessage || !!bp.hitCondition)) {
                        const logPoint = breakpoints.every(bp => !!bp.logMessage);
                        const breakpointType = logPoint ? ( (localize('logPoint', "Logpoint"))) : ( (localize('breakpoint', "Breakpoint")));
                        const disabledBreakpointDialogMessage = ( (localize(
                            'breakpointHasConditionDisabled',
                            "This {0} has a {1} that will get lost on remove. Consider enabling the {0} instead.",
                            breakpointType.toLowerCase(),
                            logPoint ? ( (localize('message', "message"))) : ( (localize('condition', "condition")))
                        )));
                        const enabledBreakpointDialogMessage = ( (localize(
                            'breakpointHasConditionEnabled',
                            "This {0} has a {1} that will get lost on remove. Consider disabling the {0} instead.",
                            breakpointType.toLowerCase(),
                            logPoint ? ( (localize('message', "message"))) : ( (localize('condition', "condition")))
                        )));
                        await this.dialogService.prompt({
                            type: Severity$1.Info,
                            message: enabled ? enabledBreakpointDialogMessage : disabledBreakpointDialogMessage,
                            buttons: [
                                {
                                    label: ( (localize(
                                        { key: 'removeLogPoint', comment: ['&& denotes a mnemonic'] },
                                        "&&Remove {0}",
                                        breakpointType
                                    ))),
                                    run: () => breakpoints.forEach(bp => this.debugService.removeBreakpoints(bp.getId()))
                                },
                                {
                                    label: ( (localize(
                                        'disableLogPoint',
                                        "{0} {1}",
                                        enabled ? ( (localize({ key: 'disable', comment: ['&& denotes a mnemonic'] }, "&&Disable"))) : ( (localize({ key: 'enable', comment: ['&& denotes a mnemonic'] }, "&&Enable"))),
                                        breakpointType
                                    ))),
                                    run: () => breakpoints.forEach(bp => this.debugService.enableOrDisableBreakpoints(!enabled, bp))
                                }
                            ],
                            cancelButton: true
                        });
                    }
                    else {
                        if (!enabled) {
                            breakpoints.forEach(bp => this.debugService.enableOrDisableBreakpoints(!enabled, bp));
                        }
                        else {
                            breakpoints.forEach(bp => this.debugService.removeBreakpoints(bp.getId()));
                        }
                    }
                }
                else if (canSetBreakpoints) {
                    this.debugService.addBreakpoints(uri, [{ lineNumber }]);
                }
            }
        }));
        if (!(BrowserFeatures.pointerEvents && isSafari)) {
            this.toDispose.push(this.editor.onMouseMove((e) => {
                if (!this.debugService.getAdapterManager().hasEnabledDebuggers()) {
                    return;
                }
                let showBreakpointHintAtLineNumber = -1;
                const model = this.editor.getModel();
                if (model && e.target.position && ((e.target.type === 2  || e.target.type === 3) ) && this.debugService.canSetBreakpointsIn(model) &&
                    this.marginFreeFromNonDebugDecorations(e.target.position.lineNumber)) {
                    const data = e.target.detail;
                    if (!data.isAfterLines) {
                        showBreakpointHintAtLineNumber = e.target.position.lineNumber;
                    }
                }
                this.ensureBreakpointHintDecoration(showBreakpointHintAtLineNumber);
            }));
            this.toDispose.push(this.editor.onMouseLeave(() => {
                this.ensureBreakpointHintDecoration(-1);
            }));
        }
        this.toDispose.push(this.editor.onDidChangeModel(async () => {
            this.closeBreakpointWidget();
            await this.setDecorations();
        }));
        this.toDispose.push(this.debugService.getModel().onDidChangeBreakpoints(() => {
            if (!this.ignoreBreakpointsChangeEvent && !this.setDecorationsScheduler.isScheduled()) {
                this.setDecorationsScheduler.schedule();
            }
        }));
        this.toDispose.push(this.debugService.onDidChangeState(() => {
            if (!this.setDecorationsScheduler.isScheduled()) {
                this.setDecorationsScheduler.schedule();
            }
        }));
        this.toDispose.push(this.editor.onDidChangeModelDecorations(() => this.onModelDecorationsChanged()));
        this.toDispose.push(this.configurationService.onDidChangeConfiguration(async (e) => {
            if (e.affectsConfiguration('debug.showBreakpointsInOverviewRuler') || e.affectsConfiguration('debug.showInlineBreakpointCandidates')) {
                await this.setDecorations();
            }
        }));
    }
    getContextMenuActions(breakpoints, uri, lineNumber, column) {
        const actions = [];
        if (breakpoints.length === 1) {
            const breakpointType = breakpoints[0].logMessage ? ( (localize('logPoint', "Logpoint"))) : ( (localize('breakpoint', "Breakpoint")));
            actions.push(( (new Action(
                'debug.removeBreakpoint',
                 (localize('removeBreakpoint', "Remove {0}", breakpointType)),
                undefined,
                true,
                async () => {
                    await this.debugService.removeBreakpoints(breakpoints[0].getId());
                }
            ))));
            actions.push(( (new Action(
                'workbench.debug.action.editBreakpointAction',
                 (localize('editBreakpoint', "Edit {0}...", breakpointType)),
                undefined,
                true,
                () => Promise.resolve(this.showBreakpointWidget(breakpoints[0].lineNumber, breakpoints[0].column))
            ))));
            actions.push(( (new Action(
                `workbench.debug.viewlet.action.toggleBreakpoint`,
                breakpoints[0].enabled ? ( (localize('disableBreakpoint', "Disable {0}", breakpointType))) : ( (localize('enableBreakpoint', "Enable {0}", breakpointType))),
                undefined,
                true,
                () => this.debugService.enableOrDisableBreakpoints(!breakpoints[0].enabled, breakpoints[0])
            ))));
        }
        else if (breakpoints.length > 1) {
            const sorted = breakpoints.slice().sort((first, second) => (first.column && second.column) ? first.column - second.column : 1);
            actions.push(( (new SubmenuAction(
                'debug.removeBreakpoints',
                 (localize('removeBreakpoints', "Remove Breakpoints")),
                 (sorted.map(
                    bp => ( (new Action('removeInlineBreakpoint', bp.column ? ( (localize(
                        'removeInlineBreakpointOnColumn',
                        "Remove Inline Breakpoint on Column {0}",
                        bp.column
                    ))) : ( (localize('removeLineBreakpoint', "Remove Line Breakpoint"))), undefined, true, () => this.debugService.removeBreakpoints(bp.getId()))))
                ))
            ))));
            actions.push(( (new SubmenuAction(
                'debug.editBreakpoints',
                 (localize('editBreakpoints', "Edit Breakpoints")),
                 (sorted.map(
                    bp => ( (new Action('editBreakpoint', bp.column ? ( (localize(
                        'editInlineBreakpointOnColumn',
                        "Edit Inline Breakpoint on Column {0}",
                        bp.column
                    ))) : ( (localize('editLineBreakpoint', "Edit Line Breakpoint"))), undefined, true, () => Promise.resolve(this.showBreakpointWidget(bp.lineNumber, bp.column)))))
                ))
            ))));
            actions.push(( (new SubmenuAction(
                'debug.enableDisableBreakpoints',
                 (localize('enableDisableBreakpoints', "Enable/Disable Breakpoints")),
                 (sorted.map(bp => ( (new Action(
                    bp.enabled ? 'disableColumnBreakpoint' : 'enableColumnBreakpoint',
                    bp.enabled ? (bp.column ? ( (localize(
                        'disableInlineColumnBreakpoint',
                        "Disable Inline Breakpoint on Column {0}",
                        bp.column
                    ))) : ( (localize('disableBreakpointOnLine', "Disable Line Breakpoint"))))
                        : (bp.column ? ( (localize('enableBreakpoints', "Enable Inline Breakpoint on Column {0}", bp.column))) : ( (localize('enableBreakpointOnLine', "Enable Line Breakpoint")))),
                    undefined,
                    true,
                    () => this.debugService.enableOrDisableBreakpoints(!bp.enabled, bp)
                )))))
            ))));
        }
        else {
            actions.push(( (new Action(
                'addBreakpoint',
                 (localize('addBreakpoint', "Add Breakpoint")),
                undefined,
                true,
                () => this.debugService.addBreakpoints(uri, [{ lineNumber, column }])
            ))));
            actions.push(( (new Action(
                'addConditionalBreakpoint',
                 (localize('addConditionalBreakpoint', "Add Conditional Breakpoint...")),
                undefined,
                true,
                () => Promise.resolve(this.showBreakpointWidget(lineNumber, column, 0 ))
            ))));
            actions.push(( (new Action(
                'addLogPoint',
                 (localize('addLogPoint', "Add Logpoint...")),
                undefined,
                true,
                () => Promise.resolve(this.showBreakpointWidget(lineNumber, column, 2 ))
            ))));
        }
        if (this.debugService.state === 2 ) {
            actions.push(( (new Separator())));
            actions.push(( (new Action(
                'runToLine',
                 (localize('runToLine', "Run to Line")),
                undefined,
                true,
                () => this.debugService.runTo(uri, lineNumber).catch(onUnexpectedError)
            ))));
        }
        return actions;
    }
    marginFreeFromNonDebugDecorations(line) {
        const decorations = this.editor.getLineDecorations(line);
        if (decorations) {
            for (const { options } of decorations) {
                const clz = options.glyphMarginClassName;
                if (clz && (!clz.includes('codicon-') || clz.includes('codicon-testing-') || clz.includes('codicon-merge-') || clz.includes('codicon-arrow-'))) {
                    return false;
                }
            }
        }
        return true;
    }
    ensureBreakpointHintDecoration(showBreakpointHintAtLineNumber) {
        this.editor.changeDecorations((accessor) => {
            if (this.breakpointHintDecoration) {
                accessor.removeDecoration(this.breakpointHintDecoration);
                this.breakpointHintDecoration = null;
            }
            if (showBreakpointHintAtLineNumber !== -1) {
                this.breakpointHintDecoration = accessor.addDecoration({
                    startLineNumber: showBreakpointHintAtLineNumber,
                    startColumn: 1,
                    endLineNumber: showBreakpointHintAtLineNumber,
                    endColumn: 1
                }, breakpointHelperDecoration);
            }
        });
    }
    async setDecorations() {
        if (!this.editor.hasModel()) {
            return;
        }
        const activeCodeEditor = this.editor;
        const model = activeCodeEditor.getModel();
        const breakpoints = this.debugService.getModel().getBreakpoints({ uri: model.uri });
        const debugSettings = this.configurationService.getValue('debug');
        const desiredBreakpointDecorations = this.instantiationService.invokeFunction(accessor => createBreakpointDecorations(accessor, model, breakpoints, this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), debugSettings.showBreakpointsInOverviewRuler));
        try {
            this.ignoreDecorationsChangedEvent = true;
            activeCodeEditor.changeDecorations((changeAccessor) => {
                const decorationIds = changeAccessor.deltaDecorations(( (this.breakpointDecorations.map(bpd => bpd.decorationId))), desiredBreakpointDecorations);
                this.breakpointDecorations.forEach(bpd => {
                    bpd.inlineWidget?.dispose();
                });
                this.breakpointDecorations = ( (decorationIds.map((decorationId, index) => {
                    let inlineWidget = undefined;
                    const breakpoint = breakpoints[index];
                    if (desiredBreakpointDecorations[index].options.before) {
                        const contextMenuActions = () => this.getContextMenuActions([breakpoint], activeCodeEditor.getModel().uri, breakpoint.lineNumber, breakpoint.column);
                        inlineWidget = ( (new InlineBreakpointWidget(
                            activeCodeEditor,
                            decorationId,
                            desiredBreakpointDecorations[index].options.glyphMarginClassName,
                            breakpoint,
                            this.debugService,
                            this.contextMenuService,
                            contextMenuActions
                        )));
                    }
                    return {
                        decorationId,
                        breakpoint,
                        range: desiredBreakpointDecorations[index].range,
                        inlineWidget
                    };
                })));
            });
        }
        finally {
            this.ignoreDecorationsChangedEvent = false;
        }
        const session = this.debugService.getViewModel().focusedSession;
        const desiredCandidateDecorations = debugSettings.showInlineBreakpointCandidates && session ? await createCandidateDecorations(this.editor.getModel(), this.breakpointDecorations, session) : [];
        this.editor.changeDecorations((changeAccessor) => {
            const candidateDecorationIds = changeAccessor.deltaDecorations(( (this.candidateDecorations.map(c => c.decorationId))), desiredCandidateDecorations);
            this.candidateDecorations.forEach(candidate => {
                candidate.inlineWidget.dispose();
            });
            this.candidateDecorations = ( (candidateDecorationIds.map((decorationId, index) => {
                const candidate = desiredCandidateDecorations[index];
                const icon = candidate.breakpoint ? getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), candidate.breakpoint, this.labelService).icon : breakpoint.disabled;
                const contextMenuActions = () => this.getContextMenuActions(candidate.breakpoint ? [candidate.breakpoint] : [], activeCodeEditor.getModel().uri, candidate.range.startLineNumber, candidate.range.startColumn);
                const inlineWidget = ( (new InlineBreakpointWidget(
                    activeCodeEditor,
                    decorationId,
                    ThemeIcon.asClassName(icon),
                    candidate.breakpoint,
                    this.debugService,
                    this.contextMenuService,
                    contextMenuActions
                )));
                return {
                    decorationId,
                    inlineWidget
                };
            })));
        });
        for (const d of this.breakpointDecorations) {
            if (d.inlineWidget) {
                this.editor.layoutContentWidget(d.inlineWidget);
            }
        }
    }
    async onModelDecorationsChanged() {
        if (this.breakpointDecorations.length === 0 || this.ignoreDecorationsChangedEvent || !this.editor.hasModel()) {
            return;
        }
        let somethingChanged = false;
        const model = this.editor.getModel();
        this.breakpointDecorations.forEach(breakpointDecoration => {
            if (somethingChanged) {
                return;
            }
            const newBreakpointRange = model.getDecorationRange(breakpointDecoration.decorationId);
            if (newBreakpointRange && (!breakpointDecoration.range.equalsRange(newBreakpointRange))) {
                somethingChanged = true;
                breakpointDecoration.range = newBreakpointRange;
            }
        });
        if (!somethingChanged) {
            return;
        }
        const data = ( (new Map()));
        for (let i = 0, len = this.breakpointDecorations.length; i < len; i++) {
            const breakpointDecoration = this.breakpointDecorations[i];
            const decorationRange = model.getDecorationRange(breakpointDecoration.decorationId);
            if (decorationRange) {
                if (breakpointDecoration.breakpoint) {
                    data.set(breakpointDecoration.breakpoint.getId(), {
                        lineNumber: decorationRange.startLineNumber,
                        column: breakpointDecoration.breakpoint.column ? decorationRange.startColumn : undefined,
                    });
                }
            }
        }
        try {
            this.ignoreBreakpointsChangeEvent = true;
            await this.debugService.updateBreakpoints(model.uri, data, true);
        }
        finally {
            this.ignoreBreakpointsChangeEvent = false;
        }
    }
    showBreakpointWidget(lineNumber, column, context) {
        this.breakpointWidget?.dispose();
        this.breakpointWidget = this.instantiationService.createInstance(BreakpointWidget, this.editor, lineNumber, column, context);
        this.breakpointWidget.show({ lineNumber, column: 1 });
        this.breakpointWidgetVisible.set(true);
    }
    closeBreakpointWidget() {
        if (this.breakpointWidget) {
            this.breakpointWidget.dispose();
            this.breakpointWidget = undefined;
            this.breakpointWidgetVisible.reset();
            this.editor.focus();
        }
    }
    dispose() {
        this.breakpointWidget?.dispose();
        this.editor.removeDecorations(( (this.breakpointDecorations.map(bpd => bpd.decorationId))));
        dispose(this.toDispose);
    }
};
BreakpointEditorContribution = ( (__decorate([
    ( (__param(1, IDebugService))),
    ( (__param(2, IContextMenuService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IContextKeyService))),
    ( (__param(5, IDialogService))),
    ( (__param(6, IConfigurationService))),
    ( (__param(7, ILabelService)))
], BreakpointEditorContribution)));
class InlineBreakpointWidget {
    constructor(editor, decorationId, cssClass, breakpoint, debugService, contextMenuService, getContextMenuActions) {
        this.editor = editor;
        this.decorationId = decorationId;
        this.breakpoint = breakpoint;
        this.debugService = debugService;
        this.contextMenuService = contextMenuService;
        this.getContextMenuActions = getContextMenuActions;
        this.allowEditorOverflow = false;
        this.suppressMouseDown = true;
        this.toDispose = [];
        this.range = this.editor.getModel().getDecorationRange(decorationId);
        this.toDispose.push(this.editor.onDidChangeModelDecorations(() => {
            const model = this.editor.getModel();
            const range = model.getDecorationRange(this.decorationId);
            if (this.range && !this.range.equalsRange(range)) {
                this.range = range;
                this.editor.layoutContentWidget(this);
            }
        }));
        this.create(cssClass);
        this.editor.addContentWidget(this);
        this.editor.layoutContentWidget(this);
    }
    create(cssClass) {
        this.domNode = $$3('.inline-breakpoint-widget');
        if (cssClass) {
            this.domNode.classList.add(...cssClass.split(' '));
        }
        this.toDispose.push(addDisposableListener$1(this.domNode, EventType$1.CLICK, async (e) => {
            switch (this.breakpoint?.enabled) {
                case undefined:
                    await this.debugService.addBreakpoints(this.editor.getModel().uri, [{ lineNumber: this.range.startLineNumber, column: this.range.startColumn }]);
                    break;
                case true:
                    await this.debugService.removeBreakpoints(this.breakpoint.getId());
                    break;
                case false:
                    this.debugService.enableOrDisableBreakpoints(true, this.breakpoint);
                    break;
            }
        }));
        this.toDispose.push(addDisposableListener$1(this.domNode, EventType$1.CONTEXT_MENU, e => {
            const event = ( (new StandardMouseEvent(e)));
            const anchor = { x: event.posx, y: event.posy };
            const actions = this.getContextMenuActions();
            this.contextMenuService.showContextMenu({
                getAnchor: () => anchor,
                getActions: () => actions,
                getActionsContext: () => this.breakpoint,
                onHide: () => disposeIfDisposable(actions)
            });
        }));
        const updateSize = () => {
            const lineHeight = this.editor.getOption(63 );
            this.domNode.style.height = `${lineHeight}px`;
            this.domNode.style.width = `${Math.ceil(0.8 * lineHeight)}px`;
            this.domNode.style.marginLeft = `4px`;
        };
        updateSize();
        this.toDispose.push(this.editor.onDidChangeConfiguration(c => {
            if (c.hasChanged(49 ) || c.hasChanged(63 )) {
                updateSize();
            }
        }));
    }
    getId() {
        return generateUuid();
    }
    getDomNode() {
        return this.domNode;
    }
    getPosition() {
        if (!this.range) {
            return null;
        }
        this.domNode.classList.toggle('line-start', this.range.startColumn === 1);
        return {
            position: { lineNumber: this.range.startLineNumber, column: this.range.startColumn - 1 },
            preference: [0 ]
        };
    }
    dispose() {
        this.editor.removeContentWidget(this);
        dispose(this.toDispose);
    }
}
InlineBreakpointWidget.__decorator = ( (__decorate([
    memoize
], InlineBreakpointWidget.prototype, "getId", null)));
registerThemingParticipant((theme, collector) => {
    const debugIconBreakpointColor = theme.getColor(debugIconBreakpointForeground);
    if (debugIconBreakpointColor) {
        collector.addRule(`
		${( ( allBreakpoints.map(b => `.monaco-workbench ${ThemeIcon.asCSSSelector(b.regular)}`))).join(',\n		')},
		.monaco-workbench ${ThemeIcon.asCSSSelector(debugBreakpointUnsupported)},
		.monaco-workbench ${ThemeIcon.asCSSSelector(debugBreakpointHint)}:not([class*='codicon-debug-breakpoint']):not([class*='codicon-debug-stackframe']),
		.monaco-workbench ${ThemeIcon.asCSSSelector(breakpoint.regular)}${ThemeIcon.asCSSSelector(debugStackframeFocused)}::after,
		.monaco-workbench ${ThemeIcon.asCSSSelector(breakpoint.regular)}${ThemeIcon.asCSSSelector(debugStackframe)}::after {
			color: ${debugIconBreakpointColor} !important;
		}
		`);
    }
    const debugIconBreakpointDisabledColor = theme.getColor(debugIconBreakpointDisabledForeground);
    if (debugIconBreakpointDisabledColor) {
        collector.addRule(`
		${( ( allBreakpoints.map(b => `.monaco-workbench ${ThemeIcon.asCSSSelector(b.disabled)}`))).join(',\n		')} {
			color: ${debugIconBreakpointDisabledColor};
		}
		`);
    }
    const debugIconBreakpointUnverifiedColor = theme.getColor(debugIconBreakpointUnverifiedForeground);
    if (debugIconBreakpointUnverifiedColor) {
        collector.addRule(`
		${( ( allBreakpoints.map(b => `.monaco-workbench ${ThemeIcon.asCSSSelector(b.unverified)}`))).join(',\n		')} {
			color: ${debugIconBreakpointUnverifiedColor};
		}
		`);
    }
    const debugIconBreakpointCurrentStackframeForegroundColor = theme.getColor(debugIconBreakpointCurrentStackframeForeground);
    if (debugIconBreakpointCurrentStackframeForegroundColor) {
        collector.addRule(`
		.monaco-workbench ${ThemeIcon.asCSSSelector(debugStackframe)},
		.monaco-editor .debug-top-stack-frame-column {
			color: ${debugIconBreakpointCurrentStackframeForegroundColor} !important;
		}
		`);
    }
    const debugIconBreakpointStackframeFocusedColor = theme.getColor(debugIconBreakpointStackframeForeground);
    if (debugIconBreakpointStackframeFocusedColor) {
        collector.addRule(`
		.monaco-workbench ${ThemeIcon.asCSSSelector(debugStackframeFocused)} {
			color: ${debugIconBreakpointStackframeFocusedColor} !important;
		}
		`);
    }
});
const debugIconBreakpointForeground = registerColor('debugIcon.breakpointForeground', { dark: '#E51400', light: '#E51400', hcDark: '#E51400', hcLight: '#E51400' }, ( (localize('debugIcon.breakpointForeground', 'Icon color for breakpoints.'))));
const debugIconBreakpointDisabledForeground = registerColor('debugIcon.breakpointDisabledForeground', { dark: '#848484', light: '#848484', hcDark: '#848484', hcLight: '#848484' }, ( (localize(
    'debugIcon.breakpointDisabledForeground',
    'Icon color for disabled breakpoints.'
))));
const debugIconBreakpointUnverifiedForeground = registerColor('debugIcon.breakpointUnverifiedForeground', { dark: '#848484', light: '#848484', hcDark: '#848484', hcLight: '#848484' }, ( (localize(
    'debugIcon.breakpointUnverifiedForeground',
    'Icon color for unverified breakpoints.'
))));
const debugIconBreakpointCurrentStackframeForeground = registerColor('debugIcon.breakpointCurrentStackframeForeground', { dark: '#FFCC00', light: '#BE8700', hcDark: '#FFCC00', hcLight: '#BE8700' }, ( (localize(
    'debugIcon.breakpointCurrentStackframeForeground',
    'Icon color for the current breakpoint stack frame.'
))));
const debugIconBreakpointStackframeForeground = registerColor('debugIcon.breakpointStackframeForeground', { dark: '#89D185', light: '#89D185', hcDark: '#89D185', hcLight: '#89D185' }, ( (localize(
    'debugIcon.breakpointStackframeForeground',
    'Icon color for all breakpoint stack frames.'
))));
var css$1 = ".monaco-editor .view-overlays .debug-top-stack-frame-line{background-color:var(--vscode-editor-stackFrameHighlightBackground)}.monaco-editor .view-overlays .debug-focused-stack-frame-line{background-color:var(--vscode-editor-focusedStackFrameHighlightBackground)}";
n(css$1,{});
const topStackFrameColor = registerColor('editor.stackFrameHighlightBackground', { dark: '#ffff0033', light: '#ffff6673', hcDark: '#ffff0033', hcLight: '#ffff6673' }, ( (localize(
    'topStackFrameLineHighlight',
    'Background color for the highlight of line at the top stack frame position.'
))));
const focusedStackFrameColor = registerColor('editor.focusedStackFrameHighlightBackground', { dark: '#7abd7a4d', light: '#cee7ce73', hcDark: '#7abd7a4d', hcLight: '#cee7ce73' }, ( (localize(
    'focusedStackFrameLineHighlight',
    'Background color for the highlight of line at focused stack frame position.'
))));
const stickiness = 1 ;
const TOP_STACK_FRAME_MARGIN = {
    description: 'top-stack-frame-margin',
    glyphMarginClassName: ThemeIcon.asClassName(debugStackframe),
    stickiness,
    overviewRuler: {
        position: OverviewRulerLane.Full,
        color: themeColorFromId(topStackFrameColor)
    }
};
const FOCUSED_STACK_FRAME_MARGIN = {
    description: 'focused-stack-frame-margin',
    glyphMarginClassName: ThemeIcon.asClassName(debugStackframeFocused),
    stickiness,
    overviewRuler: {
        position: OverviewRulerLane.Full,
        color: themeColorFromId(focusedStackFrameColor)
    }
};
const TOP_STACK_FRAME_DECORATION = {
    description: 'top-stack-frame-decoration',
    isWholeLine: true,
    className: 'debug-top-stack-frame-line',
    stickiness
};
const FOCUSED_STACK_FRAME_DECORATION = {
    description: 'focused-stack-frame-decoration',
    isWholeLine: true,
    className: 'debug-focused-stack-frame-line',
    stickiness
};
function createDecorationsForStackFrame(stackFrame, isFocusedSession, noCharactersBefore) {
    const result = [];
    const columnUntilEOLRange = ( (new Range(
        stackFrame.range.startLineNumber,
        stackFrame.range.startColumn,
        stackFrame.range.startLineNumber,
        1073741824
    )));
    const range = ( (new Range(
        stackFrame.range.startLineNumber,
        stackFrame.range.startColumn,
        stackFrame.range.startLineNumber,
        stackFrame.range.startColumn + 1
    )));
    const topStackFrame = stackFrame.thread.getTopStackFrame();
    if (stackFrame.getId() === topStackFrame?.getId()) {
        if (isFocusedSession) {
            result.push({
                options: TOP_STACK_FRAME_MARGIN,
                range
            });
        }
        result.push({
            options: TOP_STACK_FRAME_DECORATION,
            range: columnUntilEOLRange
        });
        if (stackFrame.range.startColumn > 1) {
            result.push({
                options: {
                    description: 'top-stack-frame-inline-decoration',
                    before: {
                        content: '\uEB8B',
                        inlineClassName: noCharactersBefore ? 'debug-top-stack-frame-column start-of-line' : 'debug-top-stack-frame-column',
                        inlineClassNameAffectsLetterSpacing: true
                    },
                },
                range: columnUntilEOLRange
            });
        }
    }
    else {
        if (isFocusedSession) {
            result.push({
                options: FOCUSED_STACK_FRAME_MARGIN,
                range
            });
        }
        result.push({
            options: FOCUSED_STACK_FRAME_DECORATION,
            range: columnUntilEOLRange
        });
    }
    return result;
}
let CallStackEditorContribution = class CallStackEditorContribution extends Disposable {
    constructor(editor, debugService, uriIdentityService, logService) {
        super();
        this.editor = editor;
        this.debugService = debugService;
        this.uriIdentityService = uriIdentityService;
        this.logService = logService;
        this.decorations = this.editor.createDecorationsCollection();
        const setDecorations = () => this.decorations.set(this.createCallStackDecorations());
        this._register(Event.any(this.debugService.getViewModel().onDidFocusStackFrame, this.debugService.getModel().onDidChangeCallStack)(() => {
            setDecorations();
        }));
        this._register(this.editor.onDidChangeModel(e => {
            if (e.newModelUrl) {
                setDecorations();
            }
        }));
        setDecorations();
    }
    createCallStackDecorations() {
        const editor = this.editor;
        if (!editor.hasModel()) {
            return [];
        }
        const focusedStackFrame = this.debugService.getViewModel().focusedStackFrame;
        const decorations = [];
        this.debugService.getModel().getSessions().forEach(s => {
            const isSessionFocused = s === focusedStackFrame?.thread.session;
            s.getAllThreads().forEach(t => {
                if (t.stopped) {
                    const callStack = t.getCallStack();
                    const stackFrames = [];
                    if (callStack.length > 0) {
                        if (focusedStackFrame && !focusedStackFrame.equals(callStack[0])) {
                            stackFrames.push(focusedStackFrame);
                        }
                        stackFrames.push(callStack[0]);
                    }
                    stackFrames.forEach(candidateStackFrame => {
                        if (candidateStackFrame && this.uriIdentityService.extUri.isEqual(candidateStackFrame.source.uri, editor.getModel()?.uri)) {
                            if (candidateStackFrame.range.startLineNumber > editor.getModel()?.getLineCount() || candidateStackFrame.range.startLineNumber < 1) {
                                this.logService.warn(`CallStackEditorContribution: invalid stack frame line number: ${candidateStackFrame.range.startLineNumber}`);
                                return;
                            }
                            const noCharactersBefore = editor.getModel().getLineFirstNonWhitespaceColumn(candidateStackFrame.range.startLineNumber) >= candidateStackFrame.range.startColumn;
                            decorations.push(...createDecorationsForStackFrame(candidateStackFrame, isSessionFocused, noCharactersBefore));
                        }
                    });
                }
            });
        });
        return distinct(decorations, d => `${d.options.className} ${d.options.glyphMarginClassName} ${d.range.startLineNumber} ${d.range.startColumn}`);
    }
    dispose() {
        super.dispose();
        this.decorations.clear();
    }
};
CallStackEditorContribution = ( (__decorate([
    ( (__param(1, IDebugService))),
    ( (__param(2, IUriIdentityService))),
    ( (__param(3, ILogService)))
], CallStackEditorContribution)));
const MAX_VALUE_RENDER_LENGTH_IN_VIEWLET = 1024;
const booleanRegex = /^(true|false)$/i;
const stringRegex = /^(['"]).*\1$/;
const $$2 = $$7;
function renderExpressionValue(expressionOrValue, container, options) {
    let value = typeof expressionOrValue === 'string' ? expressionOrValue : expressionOrValue.value;
    container.className = 'value';
    if (value === null || ((expressionOrValue instanceof Expression || expressionOrValue instanceof Variable || expressionOrValue instanceof ReplEvaluationResult) && !expressionOrValue.available)) {
        container.classList.add('unavailable');
        if (value !== Expression.DEFAULT_VALUE) {
            container.classList.add('error');
        }
    }
    else {
        if ((expressionOrValue instanceof ExpressionContainer) && options.showChanged && expressionOrValue.valueChanged && value !== Expression.DEFAULT_VALUE) {
            container.className = 'value changed';
            expressionOrValue.valueChanged = false;
        }
        if (options.colorize && typeof expressionOrValue !== 'string') {
            if (expressionOrValue.type === 'number' || expressionOrValue.type === 'boolean' || expressionOrValue.type === 'string') {
                container.classList.add(expressionOrValue.type);
            }
            else if (!isNaN(+value)) {
                container.classList.add('number');
            }
            else if (booleanRegex.test(value)) {
                container.classList.add('boolean');
            }
            else if (stringRegex.test(value)) {
                container.classList.add('string');
            }
        }
    }
    if (options.maxValueLength && value && value.length > options.maxValueLength) {
        value = value.substring(0, options.maxValueLength) + '...';
    }
    if (!value) {
        value = '';
    }
    if (options.linkDetector) {
        container.textContent = '';
        const session = (expressionOrValue instanceof ExpressionContainer) ? expressionOrValue.getSession() : undefined;
        container.appendChild(options.linkDetector.linkify(value, false, session ? session.root : undefined, true));
    }
    else {
        container.textContent = value;
    }
    if (options.showHover) {
        container.title = value || '';
    }
}
function renderVariable(variable, data, showChanged, highlights, linkDetector) {
    if (variable.available) {
        let text = variable.name;
        if (variable.value && typeof variable.name === 'string') {
            text += ':';
        }
        data.label.set(text, highlights, variable.type ? variable.type : variable.name);
        data.name.classList.toggle('virtual', variable.presentationHint?.kind === 'virtual');
        data.name.classList.toggle('internal', variable.presentationHint?.visibility === 'internal');
    }
    else if (variable.value && typeof variable.name === 'string' && variable.name) {
        data.label.set(':');
    }
    data.expression.classList.toggle('lazy', !!variable.presentationHint?.lazy);
    renderExpressionValue(variable, data.value, {
        showChanged,
        maxValueLength: MAX_VALUE_RENDER_LENGTH_IN_VIEWLET,
        showHover: true,
        colorize: true,
        linkDetector
    });
}
let AbstractExpressionsRenderer = class AbstractExpressionsRenderer {
    constructor(debugService, contextViewService) {
        this.debugService = debugService;
        this.contextViewService = contextViewService;
    }
    renderTemplate(container) {
        const expression = append(container, $$2('.expression'));
        const name = append(expression, $$2('span.name'));
        const lazyButton = append(expression, $$2('span.lazy-button'));
        lazyButton.classList.add(...ThemeIcon.asClassNameArray(Codicon.eye));
        lazyButton.title = ( (localize('debug.lazyButton.tooltip', "Click to expand")));
        const value = append(expression, $$2('span.value'));
        const label = ( (new HighlightedLabel(name)));
        const inputBoxContainer = append(expression, $$2('.inputBoxContainer'));
        const templateDisposable = ( (new DisposableStore()));
        let actionBar;
        if (this.renderActionBar) {
            append(expression, $$2('.span.actionbar-spacer'));
            actionBar = templateDisposable.add(( (new ActionBar(expression))));
        }
        const template = { expression, name, value, label, inputBoxContainer, actionBar, elementDisposable: [], templateDisposable, lazyButton, currentElement: undefined };
        templateDisposable.add(addDisposableListener$1(lazyButton, EventType$1.CLICK, () => {
            if (template.currentElement) {
                this.debugService.getViewModel().evaluateLazyExpression(template.currentElement);
            }
        }));
        return template;
    }
    renderExpressionElement(element, node, data) {
        data.currentElement = element;
        this.renderExpression(node.element, data, createMatches(node.filterData));
        if (data.actionBar) {
            this.renderActionBar(data.actionBar, element, data);
        }
        const selectedExpression = this.debugService.getViewModel().getSelectedExpression();
        if (element === selectedExpression?.expression || (element instanceof Variable && element.errorMessage)) {
            const options = this.getInputBoxOptions(element, !!selectedExpression?.settingWatch);
            if (options) {
                data.elementDisposable.push(this.renderInputBox(data.name, data.value, data.inputBoxContainer, options));
            }
        }
    }
    renderInputBox(nameElement, valueElement, inputBoxContainer, options) {
        nameElement.style.display = 'none';
        valueElement.style.display = 'none';
        inputBoxContainer.style.display = 'initial';
        clearNode(inputBoxContainer);
        const inputBox = ( (new InputBox(
            inputBoxContainer,
            this.contextViewService,
            { ...options, inputBoxStyles: defaultInputBoxStyles }
        )));
        inputBox.value = options.initialValue;
        inputBox.focus();
        inputBox.select();
        const done = once$1((success, finishEditing) => {
            nameElement.style.display = '';
            valueElement.style.display = '';
            inputBoxContainer.style.display = 'none';
            const value = inputBox.value;
            dispose(toDispose);
            if (finishEditing) {
                this.debugService.getViewModel().setSelectedExpression(undefined, false);
                options.onFinish(value, success);
            }
        });
        const toDispose = [
            inputBox,
            addStandardDisposableListener(inputBox.inputElement, EventType$1.KEY_DOWN, (e) => {
                const isEscape = e.equals(9 );
                const isEnter = e.equals(3 );
                if (isEscape || isEnter) {
                    e.preventDefault();
                    e.stopPropagation();
                    done(isEnter, true);
                }
            }),
            addDisposableListener$1(inputBox.inputElement, EventType$1.BLUR, () => {
                done(true, true);
            }),
            addDisposableListener$1(inputBox.inputElement, EventType$1.CLICK, e => {
                e.preventDefault();
                e.stopPropagation();
            })
        ];
        return toDisposable(() => {
            done(false, false);
        });
    }
    disposeElement(node, index, templateData) {
        dispose(templateData.elementDisposable);
        templateData.elementDisposable = [];
    }
    disposeTemplate(templateData) {
        dispose(templateData.elementDisposable);
        templateData.templateDisposable.dispose();
    }
};
AbstractExpressionsRenderer = ( (__decorate([
    ( (__param(0, IDebugService))),
    ( (__param(1, IContextViewService)))
], AbstractExpressionsRenderer)));
let DebugConsoleQuickAccess = class DebugConsoleQuickAccess extends PickerQuickAccessProvider {
    constructor(_debugService, _viewsService, _commandService) {
        super(DEBUG_CONSOLE_QUICK_ACCESS_PREFIX, { canAcceptInBackground: true });
        this._debugService = _debugService;
        this._viewsService = _viewsService;
        this._commandService = _commandService;
    }
    _getPicks(filter, disposables, token) {
        const debugConsolePicks = [];
        this._debugService.getModel().getSessions(true).filter(s => s.hasSeparateRepl()).forEach((session, index) => {
            const pick = this._createPick(session, index, filter);
            if (pick) {
                debugConsolePicks.push(pick);
            }
        });
        if (debugConsolePicks.length > 0) {
            debugConsolePicks.push({ type: 'separator' });
        }
        const createTerminalLabel = ( (localize("workbench.action.debug.startDebug", "Start a New Debug Session")));
        debugConsolePicks.push({
            label: `$(plus) ${createTerminalLabel}`,
            ariaLabel: createTerminalLabel,
            accept: () => this._commandService.executeCommand(SELECT_AND_START_ID)
        });
        return debugConsolePicks;
    }
    _createPick(session, sessionIndex, filter) {
        const label = session.name;
        const highlights = matchesFuzzy(filter, label, true);
        if (highlights) {
            return {
                label,
                highlights: { label: highlights },
                accept: (keyMod, event) => {
                    this._debugService.focusStackFrame(undefined, undefined, session, { explicit: true });
                    if (!this._viewsService.isViewVisible(REPL_VIEW_ID)) {
                        this._viewsService.openView(REPL_VIEW_ID, true);
                    }
                }
            };
        }
        return undefined;
    }
};
DebugConsoleQuickAccess = ( (__decorate([
    ( (__param(0, IDebugService))),
    ( (__param(1, IViewsService))),
    ( (__param(2, ICommandService)))
], DebugConsoleQuickAccess)));
const CONTROL_CODES = '\\u0000-\\u0020\\u007f-\\u009f';
const WEB_LINK_REGEX = ( (new RegExp(
    '(?:[a-zA-Z][a-zA-Z0-9+.-]{2,}:\\/\\/|data:|www\\.)[^\\s' + CONTROL_CODES + '"]{2,}[^\\s' + CONTROL_CODES + '"\')}\\],:;.!?]',
    'ug'
)));
const WIN_ABSOLUTE_PATH = /(?:[a-zA-Z]:(?:(?:\\|\/)[\w\.-]*)+)/;
const WIN_RELATIVE_PATH = /(?:(?:\~|\.)(?:(?:\\|\/)[\w\.-]*)+)/;
const WIN_PATH = ( (new RegExp(`(${WIN_ABSOLUTE_PATH.source}|${WIN_RELATIVE_PATH.source})`)));
const POSIX_PATH = /((?:\~|\.)?(?:\/[\w\.-]*)+)/;
const LINE_COLUMN = /(?:\:([\d]+))?(?:\:([\d]+))?/;
const PATH_LINK_REGEX = ( (new RegExp(
    `${isWindows ? WIN_PATH.source : POSIX_PATH.source}${LINE_COLUMN.source}`,
    'g'
)));
const LINE_COLUMN_REGEX = /:([\d]+)(?::([\d]+))?$/;
const MAX_LENGTH = 2000;
let LinkDetector = class LinkDetector {
    constructor(editorService, fileService, openerService, pathService, tunnelService, environmentService, configurationService) {
        this.editorService = editorService;
        this.fileService = fileService;
        this.openerService = openerService;
        this.pathService = pathService;
        this.tunnelService = tunnelService;
        this.environmentService = environmentService;
        this.configurationService = configurationService;
    }
    linkify(text, splitLines, workspaceFolder, includeFulltext) {
        if (splitLines) {
            const lines = text.split('\n');
            for (let i = 0; i < lines.length - 1; i++) {
                lines[i] = lines[i] + '\n';
            }
            if (!lines[lines.length - 1]) {
                lines.pop();
            }
            const elements = ( (lines.map(line => this.linkify(line, false, workspaceFolder, includeFulltext))));
            if (elements.length === 1) {
                return elements[0];
            }
            const container = document.createElement('span');
            elements.forEach(e => container.appendChild(e));
            return container;
        }
        const container = document.createElement('span');
        for (const part of this.detectLinks(text)) {
            try {
                switch (part.kind) {
                    case 'text':
                        container.appendChild(document.createTextNode(part.value));
                        break;
                    case 'web':
                        container.appendChild(this.createWebLink(includeFulltext ? text : undefined, part.value));
                        break;
                    case 'path': {
                        const path = part.captures[0];
                        const lineNumber = part.captures[1] ? Number(part.captures[1]) : 0;
                        const columnNumber = part.captures[2] ? Number(part.captures[2]) : 0;
                        container.appendChild(this.createPathLink(includeFulltext ? text : undefined, part.value, path, lineNumber, columnNumber, workspaceFolder));
                        break;
                    }
                }
            }
            catch (e) {
                container.appendChild(document.createTextNode(part.value));
            }
        }
        return container;
    }
    createWebLink(fulltext, url) {
        const link = this.createLink(url);
        let uri = ( (URI.parse(url)));
        const lineCol = LINE_COLUMN_REGEX.exec(uri.path);
        if (lineCol) {
            uri = uri.with({
                path: uri.path.slice(0, lineCol.index),
                fragment: `L${lineCol[0].slice(1)}`
            });
        }
        this.decorateLink(link, uri, fulltext, async () => {
            if (uri.scheme === Schemas.file) {
                const fsPath = uri.fsPath;
                const path = await this.pathService.path;
                const fileUrl = normalize(((path.sep === posix.sep) && isWindows) ? fsPath.replace(/\\/g, posix.sep) : fsPath);
                const fileUri = ( (URI.parse(fileUrl)));
                const exists = await this.fileService.exists(fileUri);
                if (!exists) {
                    return;
                }
                await this.editorService.openEditor({
                    resource: fileUri,
                    options: {
                        pinned: true,
                        selection: lineCol ? { startLineNumber: +lineCol[1], startColumn: +lineCol[2] } : undefined,
                    },
                });
                return;
            }
            this.openerService.open(url, { allowTunneling: (!!this.environmentService.remoteAuthority && this.configurationService.getValue('remote.forwardOnOpen')) });
        });
        return link;
    }
    createPathLink(fulltext, text, path, lineNumber, columnNumber, workspaceFolder) {
        if (path[0] === '/' && path[1] === '/') {
            return document.createTextNode(text);
        }
        const options = { selection: { startLineNumber: lineNumber, startColumn: columnNumber } };
        if (path[0] === '.') {
            if (!workspaceFolder) {
                return document.createTextNode(text);
            }
            const uri = workspaceFolder.toResource(path);
            const link = this.createLink(text);
            this.decorateLink(link, uri, fulltext, (preserveFocus) => this.editorService.openEditor({ resource: uri, options: { ...options, preserveFocus } }));
            return link;
        }
        if (path[0] === '~') {
            const userHome = this.pathService.resolvedUserHome;
            if (userHome) {
                path = join(userHome.fsPath, path.substring(1));
            }
        }
        const link = this.createLink(text);
        link.tabIndex = 0;
        const uri = URI.file(normalize(path));
        this.fileService.stat(uri).then(stat => {
            if (stat.isDirectory) {
                return;
            }
            this.decorateLink(link, uri, fulltext, (preserveFocus) => this.editorService.openEditor({ resource: uri, options: { ...options, preserveFocus } }));
        }).catch(() => {
        });
        return link;
    }
    createLink(text) {
        const link = document.createElement('a');
        link.textContent = text;
        return link;
    }
    decorateLink(link, uri, fulltext, onClick) {
        link.classList.add('link');
        const followLink = this.tunnelService.canTunnel(uri) ? ( (localize('followForwardedLink', "follow link using forwarded port"))) : ( (localize('followLink', "follow link")));
        link.title = fulltext
            ? (isMacintosh ? ( (localize('fileLinkWithPathMac', "Cmd + click to {0}\n{1}", followLink, fulltext))) : ( (localize('fileLinkWithPath', "Ctrl + click to {0}\n{1}", followLink, fulltext))))
            : (isMacintosh ? ( (localize('fileLinkMac', "Cmd + click to {0}", followLink))) : ( (localize('fileLink', "Ctrl + click to {0}", followLink))));
        link.onmousemove = (event) => { link.classList.toggle('pointer', isMacintosh ? event.metaKey : event.ctrlKey); };
        link.onmouseleave = () => link.classList.remove('pointer');
        link.onclick = (event) => {
            const selection = window.getSelection();
            if (!selection || selection.type === 'Range') {
                return;
            }
            if (!(isMacintosh ? event.metaKey : event.ctrlKey)) {
                return;
            }
            event.preventDefault();
            event.stopImmediatePropagation();
            onClick(false);
        };
        link.onkeydown = e => {
            const event = ( (new StandardKeyboardEvent(e)));
            if (event.keyCode === 3  || event.keyCode === 10 ) {
                event.preventDefault();
                event.stopPropagation();
                onClick(event.keyCode === 10 );
            }
        };
    }
    detectLinks(text) {
        if (text.length > MAX_LENGTH) {
            return [{ kind: 'text', value: text, captures: [] }];
        }
        const regexes = [WEB_LINK_REGEX, PATH_LINK_REGEX];
        const kinds = ['web', 'path'];
        const result = [];
        const splitOne = (text, regexIndex) => {
            if (regexIndex >= regexes.length) {
                result.push({ value: text, kind: 'text', captures: [] });
                return;
            }
            const regex = regexes[regexIndex];
            let currentIndex = 0;
            let match;
            regex.lastIndex = 0;
            while ((match = regex.exec(text)) !== null) {
                const stringBeforeMatch = text.substring(currentIndex, match.index);
                if (stringBeforeMatch) {
                    splitOne(stringBeforeMatch, regexIndex + 1);
                }
                const value = match[0];
                result.push({
                    value: value,
                    kind: kinds[regexIndex],
                    captures: match.slice(1)
                });
                currentIndex = match.index + value.length;
            }
            const stringAfterMatches = text.substring(currentIndex);
            if (stringAfterMatches) {
                splitOne(stringAfterMatches, regexIndex + 1);
            }
        };
        splitOne(text, 0);
        return result;
    }
};
LinkDetector = ( (__decorate([
    ( (__param(0, IEditorService))),
    ( (__param(1, IFileService))),
    ( (__param(2, IOpenerService))),
    ( (__param(3, IPathService))),
    ( (__param(4, ITunnelService))),
    ( (__param(5, IWorkbenchEnvironmentService))),
    ( (__param(6, IConfigurationService)))
], LinkDetector)));
let variableInternalContext;
const getVariablesContext = (variable) => ({
    sessionId: variable.getSession()?.getId(),
    container: variable.parent instanceof Expression
        ? { expression: variable.parent.name }
        : variable.parent.toDebugProtocolObject(),
    variable: variable.toDebugProtocolObject()
});
function getContextForVariableMenu(parentContext, variable, additionalContext = []) {
    const session = variable.getSession();
    const contextKeys = [
        [CONTEXT_DEBUG_PROTOCOL_VARIABLE_MENU_CONTEXT.key, variable.variableMenuContext || ''],
        [CONTEXT_VARIABLE_EVALUATE_NAME_PRESENT.key, !!variable.evaluateName],
        [CONTEXT_CAN_VIEW_MEMORY.key, !!session?.capabilities.supportsReadMemoryRequest && variable.memoryReference !== undefined],
        [CONTEXT_VARIABLE_IS_READONLY.key, !!variable.presentationHint?.attributes?.includes('readOnly') || variable.presentationHint?.lazy],
        ...additionalContext,
    ];
    variableInternalContext = variable;
    return parentContext.createOverlay(contextKeys);
}
let VariablesRenderer = class VariablesRenderer extends AbstractExpressionsRenderer {
    constructor(linkDetector, menuService, contextKeyService, debugService, contextViewService) {
        super(debugService, contextViewService);
        this.linkDetector = linkDetector;
        this.menuService = menuService;
        this.contextKeyService = contextKeyService;
    }
    get templateId() {
        return VariablesRenderer.ID;
    }
    renderExpression(expression, data, highlights) {
        renderVariable(expression, data, true, highlights, this.linkDetector);
    }
    renderElement(node, index, data) {
        super.renderExpressionElement(node.element, node, data);
    }
    getInputBoxOptions(expression) {
        const variable = expression;
        return {
            initialValue: expression.value,
            ariaLabel: ( (localize('variableValueAriaLabel', "Type new variable value"))),
            validationOptions: {
                validation: () => variable.errorMessage ? ({ content: variable.errorMessage }) : null
            },
            onFinish: (value, success) => {
                variable.errorMessage = undefined;
                const focusedStackFrame = this.debugService.getViewModel().focusedStackFrame;
                if (success && variable.value !== value && focusedStackFrame) {
                    variable.setVariable(value, focusedStackFrame)
                        .then(() => {
                        this.debugService.getViewModel().updateViews();
                    });
                }
            }
        };
    }
    renderActionBar(actionBar, expression) {
        const variable = expression;
        const contextKeyService = getContextForVariableMenu(this.contextKeyService, variable);
        const menu = this.menuService.createMenu(MenuId.DebugVariablesContext, contextKeyService);
        const primary = [];
        const context = getVariablesContext(variable);
        createAndFillInContextMenuActions(menu, { arg: context, shouldForwardArgs: false }, { primary, secondary: [] }, 'inline');
        actionBar.clear();
        actionBar.context = context;
        actionBar.push(primary, { icon: true, label: false });
    }
};
VariablesRenderer.ID = 'variable';
VariablesRenderer = ( (__decorate([
    ( (__param(1, IMenuService))),
    ( (__param(2, IContextKeyService))),
    ( (__param(3, IDebugService))),
    ( (__param(4, IContextViewService)))
], VariablesRenderer)));
const SET_VARIABLE_ID = 'debug.setVariable';
CommandsRegistry.registerCommand({
    id: SET_VARIABLE_ID,
    handler: (accessor) => {
        const debugService = accessor.get(IDebugService);
        debugService.getViewModel().setSelectedExpression(variableInternalContext, false);
    }
});
const COPY_VALUE_ID = 'workbench.debug.viewlet.action.copyValue';
CommandsRegistry.registerCommand({
    id: COPY_VALUE_ID,
    handler: async (accessor, arg, ctx) => {
        const debugService = accessor.get(IDebugService);
        const clipboardService = accessor.get(IClipboardService);
        let elementContext = '';
        let elements;
        if (arg instanceof Variable || arg instanceof Expression) {
            elementContext = 'watch';
            elements = ctx ? ctx : [];
        }
        else {
            elementContext = 'variables';
            elements = variableInternalContext ? [variableInternalContext] : [];
        }
        const stackFrame = debugService.getViewModel().focusedStackFrame;
        const session = debugService.getViewModel().focusedSession;
        if (!stackFrame || !session || elements.length === 0) {
            return;
        }
        const evalContext = session.capabilities.supportsClipboardContext ? 'clipboard' : elementContext;
        const toEvaluate = ( (elements.map(
            element => element instanceof Variable ? (element.evaluateName || element.value) : element.name
        )));
        try {
            const evaluations = await Promise.all(( (toEvaluate.map(expr => session.evaluate(expr, stackFrame.frameId, evalContext)))));
            const result = ( (coalesce(evaluations).map(evaluation => evaluation.body.result)));
            if (result.length) {
                clipboardService.writeText(result.join('\n'));
            }
        }
        catch (e) {
            const result = ( (elements.map(element => element.value)));
            clipboardService.writeText(result.join('\n'));
        }
    }
});
const VIEW_MEMORY_ID = 'workbench.debug.viewlet.action.viewMemory';
const HEX_EDITOR_EXTENSION_ID = 'ms-vscode.hexeditor';
const HEX_EDITOR_EDITOR_ID = 'hexEditor.hexedit';
CommandsRegistry.registerCommand({
    id: VIEW_MEMORY_ID,
    handler: async (accessor, arg, ctx) => {
        const debugService = accessor.get(IDebugService);
        let sessionId;
        let memoryReference;
        if ('sessionId' in arg) {
            if (!arg.sessionId || !arg.variable.memoryReference) {
                return;
            }
            sessionId = arg.sessionId;
            memoryReference = arg.variable.memoryReference;
        }
        else {
            if (!arg.memoryReference) {
                return;
            }
            const focused = debugService.getViewModel().focusedSession;
            if (!focused) {
                return;
            }
            sessionId = focused.getId();
            memoryReference = arg.memoryReference;
        }
        const commandService = accessor.get(ICommandService);
        const editorService = accessor.get(IEditorService);
        const notifications = accessor.get(INotificationService);
        const progressService = accessor.get(IProgressService);
        const extensionService = accessor.get(IExtensionService);
        const telemetryService = accessor.get(ITelemetryService);
        const ext = await extensionService.getExtension(HEX_EDITOR_EXTENSION_ID);
        if (ext || (await tryInstallHexEditor(notifications, progressService, extensionService, commandService))) {
            telemetryService.publicLog('debug/didViewMemory', {
                debugType: debugService.getModel().getSession(sessionId)?.configuration.type,
            });
            await editorService.openEditor({
                resource: getUriForDebugMemory(sessionId, memoryReference),
                options: {
                    revealIfOpened: true,
                    override: HEX_EDITOR_EDITOR_ID,
                },
            }, SIDE_GROUP);
        }
    }
});
function tryInstallHexEditor(notifications, progressService, extensionService, commandService) {
    return (
         (new Promise(resolve => {
            let installing = false;
            const handle = notifications.prompt(Severity.Info, ( (localize(
                "viewMemory.prompt",
                "Inspecting binary data requires the Hex Editor extension. Would you like to install it now?"
            ))), [
                {
                    label: ( (localize("cancel", "Cancel"))),
                    run: () => resolve(false),
                },
                {
                    label: ( (localize("install", "Install"))),
                    run: async () => {
                        installing = true;
                        try {
                            await progressService.withProgress({
                                location: 15 ,
                                title: ( (localize("viewMemory.install.progress", "Installing the Hex Editor..."))),
                            }, async () => {
                                await commandService.executeCommand('workbench.extensions.installExtension', HEX_EDITOR_EXTENSION_ID);
                                while (!(await extensionService.getExtension(HEX_EDITOR_EXTENSION_ID))) {
                                    await timeout(30);
                                }
                            });
                            resolve(true);
                        }
                        catch (e) {
                            notifications.error(e);
                            resolve(false);
                        }
                    }
                },
            ], { sticky: true });
            handle.onDidClose(e => {
                if (!installing) {
                    resolve(false);
                }
            });
        }))
    );
}
const BREAK_WHEN_VALUE_CHANGES_ID = 'debug.breakWhenValueChanges';
CommandsRegistry.registerCommand({
    id: BREAK_WHEN_VALUE_CHANGES_ID,
    handler: async (accessor) => {
        accessor.get(IDebugService);
    }
});
const BREAK_WHEN_VALUE_IS_ACCESSED_ID = 'debug.breakWhenValueIsAccessed';
CommandsRegistry.registerCommand({
    id: BREAK_WHEN_VALUE_IS_ACCESSED_ID,
    handler: async (accessor) => {
        accessor.get(IDebugService);
    }
});
const BREAK_WHEN_VALUE_IS_READ_ID = 'debug.breakWhenValueIsRead';
CommandsRegistry.registerCommand({
    id: BREAK_WHEN_VALUE_IS_READ_ID,
    handler: async (accessor) => {
        accessor.get(IDebugService);
    }
});
const COPY_EVALUATE_PATH_ID = 'debug.copyEvaluatePath';
CommandsRegistry.registerCommand({
    id: COPY_EVALUATE_PATH_ID,
    handler: async (accessor, context) => {
        const clipboardService = accessor.get(IClipboardService);
        await clipboardService.writeText(context.variable.evaluateName);
    }
});
const ADD_TO_WATCH_ID = 'debug.addToWatchExpressions';
CommandsRegistry.registerCommand({
    id: ADD_TO_WATCH_ID,
    handler: async (accessor, context) => {
        const debugService = accessor.get(IDebugService);
        debugService.addWatchExpression(context.variable.evaluateName);
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'variables.collapse',
            viewId: VARIABLES_VIEW_ID,
            title: ( (localize('collapse', "Collapse All"))),
            f1: false,
            icon: Codicon.collapseAll,
            menu: {
                id: MenuId.ViewTitle,
                group: 'navigation',
                when: ContextKeyExpr.equals('view', VARIABLES_VIEW_ID)
            }
        });
    }
    runInView(_accessor, view) {
        view.collapseAll();
    }
});
const $$1 = $$7;
async function doFindExpression(container, namesToFind) {
    if (!container) {
        return null;
    }
    const children = await container.getChildren();
    const filtered = children.filter(v => namesToFind[0] === v.name);
    if (filtered.length !== 1) {
        return null;
    }
    if (namesToFind.length === 1) {
        return filtered[0];
    }
    else {
        return doFindExpression(filtered[0], namesToFind.slice(1));
    }
}
async function findExpressionInStackFrame(stackFrame, namesToFind) {
    const scopes = await stackFrame.getScopes();
    const nonExpensive = scopes.filter(s => !s.expensive);
    const expressions = coalesce(await Promise.all(( (nonExpensive.map(scope => doFindExpression(scope, namesToFind))))));
    return expressions.length > 0 && expressions.every(e => e.value === expressions[0].value) ? expressions[0] : undefined;
}
let DebugHoverWidget = class DebugHoverWidget {
    constructor(editor, debugService, instantiationService) {
        this.editor = editor;
        this.debugService = debugService;
        this.instantiationService = instantiationService;
        this.allowEditorOverflow = true;
        this.highlightDecorations = this.editor.createDecorationsCollection();
        this.toDispose = [];
        this._isVisible = false;
        this.showAtPosition = null;
        this.positionPreference = [1 , 2 ];
        this.debugHoverComputer = this.instantiationService.createInstance(DebugHoverComputer, this.editor);
    }
    create() {
        this.domNode = $$1('.debug-hover-widget');
        this.complexValueContainer = append(this.domNode, $$1('.complex-value'));
        this.complexValueTitle = append(this.complexValueContainer, $$1('.title'));
        this.treeContainer = append(this.complexValueContainer, $$1('.debug-hover-tree'));
        this.treeContainer.setAttribute('role', 'tree');
        const tip = append(this.complexValueContainer, $$1('.tip'));
        tip.textContent = ( (localize(
            { key: 'quickTip', comment: ['"switch to editor language hover" means to show the programming language hover widget instead of the debug hover'] },
            'Hold {0} key to switch to editor language hover',
            isMacintosh ? 'Option' : 'Alt'
        )));
        const dataSource = ( (new DebugHoverDataSource()));
        const linkeDetector = this.instantiationService.createInstance(LinkDetector);
        this.tree = this.instantiationService.createInstance(WorkbenchAsyncDataTree, 'DebugHover', this.treeContainer, ( (new DebugHoverDelegate())), [this.instantiationService.createInstance(VariablesRenderer, linkeDetector)], dataSource, {
            accessibilityProvider: ( (new DebugHoverAccessibilityProvider())),
            mouseSupport: false,
            horizontalScrolling: true,
            useShadows: false,
            keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: (e) => e.name },
            overrideStyles: {
                listBackground: editorHoverBackground
            }
        });
        this.valueContainer = $$1('.value');
        this.valueContainer.tabIndex = 0;
        this.valueContainer.setAttribute('role', 'tooltip');
        this.scrollbar = ( (new DomScrollableElement(this.valueContainer, { horizontal: 2  })));
        this.domNode.appendChild(this.scrollbar.getDomNode());
        this.toDispose.push(this.scrollbar);
        this.editor.applyFontInfo(this.domNode);
        this.domNode.style.backgroundColor = asCssVariable(editorHoverBackground);
        this.domNode.style.border = `1px solid ${asCssVariable(editorHoverBorder)}`;
        this.domNode.style.color = asCssVariable(editorHoverForeground);
        this.toDispose.push(this.tree.onDidChangeContentHeight(() => this.layoutTreeAndContainer(false)));
        this.registerListeners();
        this.editor.addContentWidget(this);
    }
    registerListeners() {
        this.toDispose.push(addStandardDisposableListener(this.domNode, 'keydown', (e) => {
            if (e.equals(9 )) {
                this.hide();
            }
        }));
        this.toDispose.push(this.editor.onDidChangeConfiguration((e) => {
            if (e.hasChanged(47 )) {
                this.editor.applyFontInfo(this.domNode);
            }
        }));
        this.toDispose.push(this.debugService.getViewModel().onDidEvaluateLazyExpression(async (e) => {
            if (e instanceof Variable && this.tree.hasNode(e)) {
                await this.tree.updateChildren(e, false, true);
                await this.tree.expand(e);
            }
        }));
    }
    isHovered() {
        return !!this.domNode?.matches(':hover');
    }
    isVisible() {
        return this._isVisible;
    }
    willBeVisible() {
        return !!this.showCancellationSource;
    }
    getId() {
        return DebugHoverWidget.ID;
    }
    getDomNode() {
        return this.domNode;
    }
    async showAt(position, focus) {
        this.showCancellationSource?.cancel();
        const cancellationSource = this.showCancellationSource = ( (new CancellationTokenSource()));
        const session = this.debugService.getViewModel().focusedSession;
        if (!session || !this.editor.hasModel()) {
            this.hide();
            return;
        }
        const result = await this.debugHoverComputer.compute(position, cancellationSource.token);
        if (this.isVisible() && !result.rangeChanged) {
            return;
        }
        if (!result.range || cancellationSource.token.isCancellationRequested) {
            this.hide();
            return;
        }
        const expression = await this.debugHoverComputer.evaluate(session);
        if (cancellationSource.token.isCancellationRequested || !expression || (expression instanceof Expression && !expression.available)) {
            this.hide();
            return;
        }
        this.highlightDecorations.set([{
                range: result.range,
                options: DebugHoverWidget._HOVER_HIGHLIGHT_DECORATION_OPTIONS
            }]);
        return this.doShow(result.range.getStartPosition(), expression, focus);
    }
    async doShow(position, expression, focus, forceValueHover = false) {
        if (!this.domNode) {
            this.create();
        }
        this.showAtPosition = position;
        this._isVisible = true;
        if (!expression.hasChildren || forceValueHover) {
            this.complexValueContainer.hidden = true;
            this.valueContainer.hidden = false;
            renderExpressionValue(expression, this.valueContainer, {
                showChanged: false,
                colorize: true
            });
            this.valueContainer.title = '';
            this.editor.layoutContentWidget(this);
            this.scrollbar.scanDomNode();
            if (focus) {
                this.editor.render();
                this.valueContainer.focus();
            }
            return undefined;
        }
        this.valueContainer.hidden = true;
        await this.tree.setInput(expression);
        this.complexValueTitle.textContent = expression.value;
        this.complexValueTitle.title = expression.value;
        this.layoutTreeAndContainer(true);
        this.tree.scrollTop = 0;
        this.tree.scrollLeft = 0;
        this.complexValueContainer.hidden = false;
        if (focus) {
            this.editor.render();
            this.tree.domFocus();
        }
    }
    layoutTreeAndContainer(initialLayout) {
        const scrollBarHeight = 10;
        const treeHeight = Math.min(Math.max(266, this.editor.getLayoutInfo().height * 0.55), this.tree.contentHeight + scrollBarHeight);
        this.treeContainer.style.height = `${treeHeight}px`;
        this.tree.layout(treeHeight, initialLayout ? 400 : undefined);
        this.editor.layoutContentWidget(this);
        this.scrollbar.scanDomNode();
    }
    afterRender(positionPreference) {
        if (positionPreference) {
            this.positionPreference = [positionPreference];
        }
    }
    hide() {
        if (this.showCancellationSource) {
            this.showCancellationSource.cancel();
            this.showCancellationSource = undefined;
        }
        if (!this._isVisible) {
            return;
        }
        if (isAncestor(document.activeElement, this.domNode)) {
            this.editor.focus();
        }
        this._isVisible = false;
        this.highlightDecorations.clear();
        this.editor.layoutContentWidget(this);
        this.positionPreference = [1 , 2 ];
    }
    getPosition() {
        return this._isVisible ? {
            position: this.showAtPosition,
            preference: this.positionPreference
        } : null;
    }
    dispose() {
        this.toDispose = dispose(this.toDispose);
    }
};
DebugHoverWidget.ID = 'debug.hoverWidget';
DebugHoverWidget._HOVER_HIGHLIGHT_DECORATION_OPTIONS = ModelDecorationOptions.register({
    description: 'bdebug-hover-highlight',
    className: 'hoverHighlight'
});
DebugHoverWidget = ( (__decorate([
    ( (__param(1, IDebugService))),
    ( (__param(2, IInstantiationService)))
], DebugHoverWidget)));
class DebugHoverAccessibilityProvider {
    getWidgetAriaLabel() {
        return (
             (localize('treeAriaLabel', "Debug Hover"))
        );
    }
    getAriaLabel(element) {
        return (
             (localize(
                { key: 'variableAriaLabel', comment: ['Do not translate placeholders. Placeholders are name and value of a variable.'] },
                "{0}, value {1}, variables, debug",
                element.name,
                element.value
            ))
        );
    }
}
class DebugHoverDataSource {
    hasChildren(element) {
        return element.hasChildren;
    }
    getChildren(element) {
        return element.getChildren();
    }
}
class DebugHoverDelegate {
    getHeight(element) {
        return 18;
    }
    getTemplateId(element) {
        return VariablesRenderer.ID;
    }
}
let DebugHoverComputer = class DebugHoverComputer {
    constructor(editor, debugService, languageFeaturesService, logService) {
        this.editor = editor;
        this.debugService = debugService;
        this.languageFeaturesService = languageFeaturesService;
        this.logService = logService;
    }
    async compute(position, token) {
        const session = this.debugService.getViewModel().focusedSession;
        if (!session || !this.editor.hasModel()) {
            return { rangeChanged: false };
        }
        const model = this.editor.getModel();
        const result = await getEvaluatableExpressionAtPosition(this.languageFeaturesService, model, position, token);
        if (!result) {
            return { rangeChanged: false };
        }
        const { range, matchingExpression } = result;
        const rangeChanged = this._currentRange ?
            !this._currentRange.equalsRange(range) :
            true;
        this._currentExpression = matchingExpression;
        this._currentRange = Range.lift(range);
        return { rangeChanged, range: this._currentRange };
    }
    async evaluate(session) {
        if (!this._currentExpression) {
            this.logService.error('No expression to evaluate');
            return;
        }
        if (session.capabilities.supportsEvaluateForHovers) {
            const expression = ( (new Expression(this._currentExpression)));
            await expression.evaluate(session, this.debugService.getViewModel().focusedStackFrame, 'hover');
            return expression;
        }
        else {
            const focusedStackFrame = this.debugService.getViewModel().focusedStackFrame;
            if (focusedStackFrame) {
                return await findExpressionInStackFrame(focusedStackFrame, coalesce(( (this._currentExpression.split('.').map(word => word.trim())))));
            }
        }
        return undefined;
    }
};
DebugHoverComputer = ( (__decorate([
    ( (__param(1, IDebugService))),
    ( (__param(2, ILanguageFeaturesService))),
    ( (__param(3, ILogService)))
], DebugHoverComputer)));
var css = ".monaco-editor .zone-widget.exception-widget-container{overflow:hidden}.monaco-editor .zone-widget .zone-widget-container.exception-widget{padding:6px 10px;user-select:text;-webkit-user-select:text;white-space:pre-wrap}.monaco-editor .zone-widget .zone-widget-container.exception-widget .title{display:flex}.monaco-editor .zone-widget .zone-widget-container.exception-widget .title .label{align-items:center;display:flex;font-weight:700}.monaco-editor .zone-widget .zone-widget-container.exception-widget .title .actions{flex:1}.monaco-editor .zone-widget .zone-widget-container.exception-widget .description,.monaco-editor .zone-widget .zone-widget-container.exception-widget .stack-trace{font-family:var(--monaco-monospace-font)}.monaco-editor .zone-widget .zone-widget-container.exception-widget .stack-trace{margin-top:.5em}.monaco-editor .zone-widget .zone-widget-container.exception-widget .stack-trace a{cursor:pointer;text-decoration:underline}.monaco-workbench.mac .zone-widget .zone-widget-container.exception-widget{font-size:11px}.monaco-workbench.linux .zone-widget .zone-widget-container.exception-widget,.monaco-workbench.windows .zone-widget .zone-widget-container.exception-widget{font-size:13px}";
n(css,{});
const $ = $$7;
const debugExceptionWidgetBorder = registerColor('debugExceptionWidget.border', { dark: '#a31515', light: '#a31515', hcDark: '#a31515', hcLight: '#a31515' }, ( (localize('debugExceptionWidgetBorder', 'Exception widget border color.'))));
const debugExceptionWidgetBackground = registerColor('debugExceptionWidget.background', { dark: '#420b0d', light: '#f1dfde', hcDark: '#420b0d', hcLight: '#f1dfde' }, ( (localize('debugExceptionWidgetBackground', 'Exception widget background color.'))));
let ExceptionWidget = class ExceptionWidget extends ZoneWidget {
    constructor(editor, exceptionInfo, debugSession, themeService, instantiationService) {
        super(editor, { showFrame: true, showArrow: true, isAccessible: true, frameWidth: 1, className: 'exception-widget-container' });
        this.exceptionInfo = exceptionInfo;
        this.debugSession = debugSession;
        this.instantiationService = instantiationService;
        this.applyTheme(themeService.getColorTheme());
        this._disposables.add(themeService.onDidColorThemeChange(this.applyTheme.bind(this)));
        this.create();
        const onDidLayoutChangeScheduler = ( (new RunOnceScheduler(() => this._doLayout(undefined, undefined), 50)));
        this._disposables.add(this.editor.onDidLayoutChange(() => onDidLayoutChangeScheduler.schedule()));
        this._disposables.add(onDidLayoutChangeScheduler);
    }
    applyTheme(theme) {
        this.backgroundColor = theme.getColor(debugExceptionWidgetBackground);
        const frameColor = theme.getColor(debugExceptionWidgetBorder);
        this.style({
            arrowColor: frameColor,
            frameColor: frameColor
        });
    }
    _applyStyles() {
        if (this.container) {
            this.container.style.backgroundColor = this.backgroundColor ? ( (this.backgroundColor.toString())) : '';
        }
        super._applyStyles();
    }
    _fillContainer(container) {
        this.setCssClass('exception-widget');
        const fontInfo = this.editor.getOption(47 );
        container.style.fontSize = `${fontInfo.fontSize}px`;
        container.style.lineHeight = `${fontInfo.lineHeight}px`;
        container.tabIndex = 0;
        const title = $('.title');
        const label = $('.label');
        append(title, label);
        const actions = $('.actions');
        append(title, actions);
        label.textContent = this.exceptionInfo.id ? ( (localize(
            'exceptionThrownWithId',
            'Exception has occurred: {0}',
            this.exceptionInfo.id
        ))) : ( (localize('exceptionThrown', 'Exception has occurred.')));
        let ariaLabel = label.textContent;
        const actionBar = ( (new ActionBar(actions)));
        actionBar.push(( (new Action(
            'editor.closeExceptionWidget',
             (localize('close', "Close")),
            ThemeIcon.asClassName(widgetClose),
            true,
            async () => {
                const contribution = this.editor.getContribution(EDITOR_CONTRIBUTION_ID);
                contribution?.closeExceptionWidget();
            }
        ))), { label: false, icon: true });
        append(container, title);
        if (this.exceptionInfo.description) {
            const description = $('.description');
            description.textContent = this.exceptionInfo.description;
            ariaLabel += ', ' + this.exceptionInfo.description;
            append(container, description);
        }
        if (this.exceptionInfo.details && this.exceptionInfo.details.stackTrace) {
            const stackTrace = $('.stack-trace');
            const linkDetector = this.instantiationService.createInstance(LinkDetector);
            const linkedStackTrace = linkDetector.linkify(this.exceptionInfo.details.stackTrace, true, this.debugSession ? this.debugSession.root : undefined);
            stackTrace.appendChild(linkedStackTrace);
            append(container, stackTrace);
            ariaLabel += ', ' + this.exceptionInfo.details.stackTrace;
        }
        container.setAttribute('aria-label', ariaLabel);
    }
    _doLayout(_heightInPixel, _widthInPixel) {
        this.container.style.height = 'initial';
        const lineHeight = this.editor.getOption(63 );
        const arrowHeight = Math.round(lineHeight / 3);
        const computedLinesNumber = Math.ceil((this.container.offsetHeight + arrowHeight) / lineHeight);
        this._relayout(computedLinesNumber);
    }
    focus() {
        this.container?.focus();
    }
    hasFocus() {
        return isAncestor(document.activeElement, this.container);
    }
};
ExceptionWidget = ( (__decorate([
    ( (__param(3, IThemeService))),
    ( (__param(4, IInstantiationService)))
], ExceptionWidget)));
const MAX_NUM_INLINE_VALUES = 100;
const MAX_INLINE_DECORATOR_LENGTH = 150;
const MAX_TOKENIZATION_LINE_LEN = 500;
const DEAFULT_INLINE_DEBOUNCE_DELAY = 200;
registerColor('editor.inlineValuesForeground', {
    dark: '#ffffff80',
    light: '#00000080',
    hcDark: '#ffffff80',
    hcLight: '#00000080'
}, ( (localize('editor.inlineValuesForeground', "Color for the debug inline value text."))));
registerColor('editor.inlineValuesBackground', {
    dark: '#ffc80033',
    light: '#ffc80033',
    hcDark: '#ffc80033',
    hcLight: '#ffc80033'
}, ( (localize(
    'editor.inlineValuesBackground',
    "Color for the debug inline value background."
))));
class InlineSegment {
    constructor(column, text) {
        this.column = column;
        this.text = text;
    }
}
function createInlineValueDecoration(lineNumber, contentText, column = 1073741824 ) {
    if (contentText.length > MAX_INLINE_DECORATOR_LENGTH) {
        contentText = contentText.substring(0, MAX_INLINE_DECORATOR_LENGTH) + '...';
    }
    return [
        {
            range: {
                startLineNumber: lineNumber,
                endLineNumber: lineNumber,
                startColumn: column,
                endColumn: column
            },
            options: {
                description: 'debug-inline-value-decoration-spacer',
                after: {
                    content: noBreakWhitespace,
                    cursorStops: InjectedTextCursorStops.None
                },
                showIfCollapsed: true,
            }
        },
        {
            range: {
                startLineNumber: lineNumber,
                endLineNumber: lineNumber,
                startColumn: column,
                endColumn: column
            },
            options: {
                description: 'debug-inline-value-decoration',
                after: {
                    content: replaceWsWithNoBreakWs(contentText),
                    inlineClassName: 'debug-inline-value',
                    inlineClassNameAffectsLetterSpacing: true,
                    cursorStops: InjectedTextCursorStops.None
                },
                showIfCollapsed: true,
            }
        },
    ];
}
function replaceWsWithNoBreakWs(str) {
    return str.replace(/[ \t]/g, noBreakWhitespace);
}
function createInlineValueDecorationsInsideRange(expressions, range, model, wordToLineNumbersMap) {
    const nameValueMap = ( (new Map()));
    for (const expr of expressions) {
        nameValueMap.set(expr.name, expr.value);
        if (nameValueMap.size >= MAX_NUM_INLINE_VALUES) {
            break;
        }
    }
    const lineToNamesMap = ( (new Map()));
    nameValueMap.forEach((_value, name) => {
        const lineNumbers = wordToLineNumbersMap.get(name);
        if (lineNumbers) {
            for (const lineNumber of lineNumbers) {
                if (range.containsPosition(( (new Position(lineNumber, 0))))) {
                    if (!lineToNamesMap.has(lineNumber)) {
                        lineToNamesMap.set(lineNumber, []);
                    }
                    if (lineToNamesMap.get(lineNumber).indexOf(name) === -1) {
                        lineToNamesMap.get(lineNumber).push(name);
                    }
                }
            }
        }
    });
    const decorations = [];
    lineToNamesMap.forEach((names, line) => {
        const contentText = ( (names.sort((first, second) => {
            const content = model.getLineContent(line);
            return content.indexOf(first) - content.indexOf(second);
        }).map(name => `${name} = ${nameValueMap.get(name)}`))).join(', ');
        decorations.push(...createInlineValueDecoration(line, contentText));
    });
    return decorations;
}
function getWordToLineNumbersMap(model) {
    const result = ( (new Map()));
    if (!model) {
        return result;
    }
    for (let lineNumber = 1, len = model.getLineCount(); lineNumber <= len; ++lineNumber) {
        const lineContent = model.getLineContent(lineNumber);
        if (lineContent.length > MAX_TOKENIZATION_LINE_LEN) {
            continue;
        }
        model.tokenization.forceTokenization(lineNumber);
        const lineTokens = model.tokenization.getLineTokens(lineNumber);
        for (let tokenIndex = 0, tokenCount = lineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {
            const tokenType = lineTokens.getStandardTokenType(tokenIndex);
            if (tokenType === 0 ) {
                DEFAULT_WORD_REGEXP.lastIndex = 0;
                const tokenStartOffset = lineTokens.getStartOffset(tokenIndex);
                const tokenEndOffset = lineTokens.getEndOffset(tokenIndex);
                const tokenStr = lineContent.substring(tokenStartOffset, tokenEndOffset);
                const wordMatch = DEFAULT_WORD_REGEXP.exec(tokenStr);
                if (wordMatch) {
                    const word = wordMatch[0];
                    if (!result.has(word)) {
                        result.set(word, []);
                    }
                    result.get(word).push(lineNumber);
                }
            }
        }
    }
    return result;
}
let DebugEditorContribution = class DebugEditorContribution {
    constructor(editor, debugService, instantiationService, commandService, configurationService, hostService, uriIdentityService, contextKeyService, languageFeaturesService, featureDebounceService) {
        this.editor = editor;
        this.debugService = debugService;
        this.instantiationService = instantiationService;
        this.commandService = commandService;
        this.configurationService = configurationService;
        this.hostService = hostService;
        this.uriIdentityService = uriIdentityService;
        this.languageFeaturesService = languageFeaturesService;
        this.hoverPosition = null;
        this.mouseDown = false;
        this.gutterIsHovered = false;
        this.altPressed = false;
        this.oldDecorations = this.editor.createDecorationsCollection();
        this._wordToLineNumbersMap = undefined;
        this.debounceInfo = featureDebounceService.for(languageFeaturesService.inlineValuesProvider, 'InlineValues', { min: DEAFULT_INLINE_DEBOUNCE_DELAY });
        this.hoverWidget = this.instantiationService.createInstance(DebugHoverWidget, this.editor);
        this.toDispose = [];
        this.registerListeners();
        this.exceptionWidgetVisible = CONTEXT_EXCEPTION_WIDGET_VISIBLE.bindTo(contextKeyService);
        this.toggleExceptionWidget();
    }
    registerListeners() {
        this.toDispose.push(this.debugService.getViewModel().onDidFocusStackFrame(e => this.onFocusStackFrame(e.stackFrame)));
        this.toDispose.push(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
        this.toDispose.push(this.editor.onMouseUp(() => this.mouseDown = false));
        this.toDispose.push(this.editor.onMouseMove((e) => this.onEditorMouseMove(e)));
        this.toDispose.push(this.editor.onMouseLeave((e) => {
            const hoverDomNode = this.hoverWidget.getDomNode();
            if (!hoverDomNode) {
                return;
            }
            const rect = hoverDomNode.getBoundingClientRect();
            if (e.event.posx < rect.left || e.event.posx > rect.right || e.event.posy < rect.top || e.event.posy > rect.bottom) {
                this.hideHoverWidget();
            }
        }));
        this.toDispose.push(this.editor.onKeyDown((e) => this.onKeyDown(e)));
        this.toDispose.push(this.editor.onDidChangeModelContent(() => {
            this._wordToLineNumbersMap = undefined;
            this.updateInlineValuesScheduler.schedule();
        }));
        this.toDispose.push(this.debugService.getViewModel().onWillUpdateViews(() => this.updateInlineValuesScheduler.schedule()));
        this.toDispose.push(this.debugService.getViewModel().onDidEvaluateLazyExpression(() => this.updateInlineValuesScheduler.schedule()));
        this.toDispose.push(this.editor.onDidChangeModel(async () => {
            this.updateHoverConfiguration();
            this.toggleExceptionWidget();
            this.hideHoverWidget();
            this._wordToLineNumbersMap = undefined;
            const stackFrame = this.debugService.getViewModel().focusedStackFrame;
            await this.updateInlineValueDecorations(stackFrame);
        }));
        this.toDispose.push(this.editor.onDidScrollChange(() => {
            this.hideHoverWidget();
            const model = this.editor.getModel();
            if (model && this.languageFeaturesService.inlineValuesProvider.has(model)) {
                this.updateInlineValuesScheduler.schedule();
            }
        }));
        this.toDispose.push(this.debugService.onDidChangeState((state) => {
            if (state !== 2 ) {
                this.toggleExceptionWidget();
            }
        }));
    }
    get wordToLineNumbersMap() {
        if (!this._wordToLineNumbersMap) {
            this._wordToLineNumbersMap = getWordToLineNumbersMap(this.editor.getModel());
        }
        return this._wordToLineNumbersMap;
    }
    updateHoverConfiguration() {
        const stackFrame = this.debugService.getViewModel().focusedStackFrame;
        const model = this.editor.getModel();
        if (model) {
            this.applyHoverConfiguration(model, stackFrame);
        }
    }
    applyHoverConfiguration(model, stackFrame) {
        if (stackFrame && this.uriIdentityService.extUri.isEqual(model.uri, stackFrame.source.uri)) {
            if (this.altListener) {
                this.altListener.dispose();
            }
            this.altListener = addDisposableListener$1(document, 'keydown', keydownEvent => {
                const standardKeyboardEvent = ( (new StandardKeyboardEvent(keydownEvent)));
                if (standardKeyboardEvent.keyCode === 6 ) {
                    this.altPressed = true;
                    const debugHoverWasVisible = this.hoverWidget.isVisible();
                    this.hoverWidget.hide();
                    this.enableEditorHover();
                    if (debugHoverWasVisible && this.hoverPosition) {
                        const hoverController = this.editor.getContribution(ModesHoverController.ID);
                        const range = ( (new Range(
                            this.hoverPosition.lineNumber,
                            this.hoverPosition.column,
                            this.hoverPosition.lineNumber,
                            this.hoverPosition.column
                        )));
                        hoverController?.showContentHover(range, 1 , 0 , false);
                    }
                    const onKeyUp = ( (new DomEmitter(document, 'keyup')));
                    const listener = Event.any(this.hostService.onDidChangeFocus, onKeyUp.event)(keyupEvent => {
                        let standardKeyboardEvent = undefined;
                        if (keyupEvent instanceof KeyboardEvent) {
                            standardKeyboardEvent = ( (new StandardKeyboardEvent(keyupEvent)));
                        }
                        if (!standardKeyboardEvent || standardKeyboardEvent.keyCode === 6 ) {
                            this.altPressed = false;
                            this.editor.updateOptions({ hover: { enabled: false } });
                            listener.dispose();
                            onKeyUp.dispose();
                        }
                    });
                }
            });
            this.editor.updateOptions({ hover: { enabled: false } });
        }
        else {
            this.altListener?.dispose();
            this.enableEditorHover();
        }
    }
    enableEditorHover() {
        if (this.editor.hasModel()) {
            const model = this.editor.getModel();
            const overrides = {
                resource: model.uri,
                overrideIdentifier: model.getLanguageId()
            };
            const defaultConfiguration = this.configurationService.getValue('editor.hover', overrides);
            this.editor.updateOptions({
                hover: {
                    enabled: defaultConfiguration.enabled,
                    delay: defaultConfiguration.delay,
                    sticky: defaultConfiguration.sticky
                }
            });
        }
    }
    async showHover(position, focus) {
        const sf = this.debugService.getViewModel().focusedStackFrame;
        const model = this.editor.getModel();
        if (sf && model && this.uriIdentityService.extUri.isEqual(sf.source.uri, model.uri) && !this.altPressed) {
            return this.hoverWidget.showAt(position, focus);
        }
    }
    async onFocusStackFrame(sf) {
        const model = this.editor.getModel();
        if (model) {
            this.applyHoverConfiguration(model, sf);
            if (sf && this.uriIdentityService.extUri.isEqual(sf.source.uri, model.uri)) {
                await this.toggleExceptionWidget();
            }
            else {
                this.hideHoverWidget();
            }
        }
        await this.updateInlineValueDecorations(sf);
    }
    get showHoverScheduler() {
        const hoverOption = this.editor.getOption(57 );
        const scheduler = ( (new RunOnceScheduler(() => {
            if (this.hoverPosition) {
                this.showHover(this.hoverPosition, false);
            }
        }, hoverOption.delay * 2)));
        this.toDispose.push(scheduler);
        return scheduler;
    }
    get hideHoverScheduler() {
        const scheduler = ( (new RunOnceScheduler(() => {
            if (!this.hoverWidget.isHovered()) {
                this.hoverWidget.hide();
            }
        }, 0)));
        this.toDispose.push(scheduler);
        return scheduler;
    }
    hideHoverWidget() {
        if (!this.hideHoverScheduler.isScheduled() && this.hoverWidget.willBeVisible()) {
            this.hideHoverScheduler.schedule();
        }
        this.showHoverScheduler.cancel();
    }
    onEditorMouseDown(mouseEvent) {
        this.mouseDown = true;
        if (mouseEvent.target.type === 9  && mouseEvent.target.detail === DebugHoverWidget.ID) {
            return;
        }
        this.hideHoverWidget();
    }
    onEditorMouseMove(mouseEvent) {
        if (this.debugService.state !== 2 ) {
            return;
        }
        const target = mouseEvent.target;
        const stopKey = isMacintosh ? 'metaKey' : 'ctrlKey';
        if (!this.altPressed) {
            if (target.type === 2 ) {
                this.editor.updateOptions({ hover: { enabled: true } });
                this.gutterIsHovered = true;
            }
            else if (this.gutterIsHovered) {
                this.gutterIsHovered = false;
                this.updateHoverConfiguration();
            }
        }
        if (target.type === 9  && target.detail === DebugHoverWidget.ID && !mouseEvent.event[stopKey]) {
            return;
        }
        if (target.type === 6 ) {
            if (target.position && !Position.equals(target.position, this.hoverPosition)) {
                this.hoverPosition = target.position;
                this.hideHoverScheduler.cancel();
                this.showHoverScheduler.schedule();
            }
        }
        else if (!this.mouseDown) {
            this.hideHoverWidget();
        }
    }
    onKeyDown(e) {
        const stopKey = isMacintosh ? 57  : 5 ;
        if (e.keyCode !== stopKey) {
            this.hideHoverWidget();
        }
    }
    async toggleExceptionWidget() {
        const model = this.editor.getModel();
        const focusedSf = this.debugService.getViewModel().focusedStackFrame;
        const callStack = focusedSf ? focusedSf.thread.getCallStack() : null;
        if (!model || !focusedSf || !callStack || callStack.length === 0) {
            this.closeExceptionWidget();
            return;
        }
        const exceptionSf = callStack.find(sf => !!(sf && sf.source && sf.source.available && sf.source.presentationHint !== 'deemphasize'));
        if (!exceptionSf || exceptionSf !== focusedSf) {
            this.closeExceptionWidget();
            return;
        }
        const sameUri = this.uriIdentityService.extUri.isEqual(exceptionSf.source.uri, model.uri);
        if (this.exceptionWidget && !sameUri) {
            this.closeExceptionWidget();
        }
        else if (sameUri) {
            const exceptionInfo = await focusedSf.thread.exceptionInfo;
            if (exceptionInfo) {
                this.showExceptionWidget(exceptionInfo, this.debugService.getViewModel().focusedSession, exceptionSf.range.startLineNumber, exceptionSf.range.startColumn);
            }
        }
    }
    showExceptionWidget(exceptionInfo, debugSession, lineNumber, column) {
        if (this.exceptionWidget) {
            this.exceptionWidget.dispose();
        }
        this.exceptionWidget = this.instantiationService.createInstance(ExceptionWidget, this.editor, exceptionInfo, debugSession);
        this.exceptionWidget.show({ lineNumber, column }, 0);
        this.exceptionWidget.focus();
        this.editor.revealRangeInCenter({
            startLineNumber: lineNumber,
            startColumn: column,
            endLineNumber: lineNumber,
            endColumn: column,
        });
        this.exceptionWidgetVisible.set(true);
    }
    closeExceptionWidget() {
        if (this.exceptionWidget) {
            const shouldFocusEditor = this.exceptionWidget.hasFocus();
            this.exceptionWidget.dispose();
            this.exceptionWidget = undefined;
            this.exceptionWidgetVisible.set(false);
            if (shouldFocusEditor) {
                this.editor.focus();
            }
        }
    }
    async addLaunchConfiguration() {
        const model = this.editor.getModel();
        if (!model) {
            return;
        }
        let configurationsArrayPosition;
        let lastProperty;
        const getConfigurationPosition = () => {
            let depthInArray = 0;
            visit(model.getValue(), {
                onObjectProperty: (property) => {
                    lastProperty = property;
                },
                onArrayBegin: (offset) => {
                    if (lastProperty === 'configurations' && depthInArray === 0) {
                        configurationsArrayPosition = model.getPositionAt(offset + 1);
                    }
                    depthInArray++;
                },
                onArrayEnd: () => {
                    depthInArray--;
                }
            });
        };
        getConfigurationPosition();
        if (!configurationsArrayPosition) {
            const { tabSize, insertSpaces } = model.getOptions();
            const eol = model.getEOL();
            const edit = (basename(model.uri.fsPath) === 'launch.json') ?
                setProperty(model.getValue(), ['configurations'], [], { tabSize, insertSpaces, eol })[0] :
                setProperty(model.getValue(), ['launch'], { 'configurations': [] }, { tabSize, insertSpaces, eol })[0];
            const startPosition = model.getPositionAt(edit.offset);
            const lineNumber = startPosition.lineNumber;
            const range = ( (new Range(
                lineNumber,
                startPosition.column,
                lineNumber,
                model.getLineMaxColumn(lineNumber)
            )));
            model.pushEditOperations(null, [EditOperation.replace(range, edit.content)], () => null);
            getConfigurationPosition();
        }
        if (!configurationsArrayPosition) {
            return;
        }
        this.editor.focus();
        const insertLine = (position) => {
            if (model.getLineLastNonWhitespaceColumn(position.lineNumber) > position.column) {
                this.editor.setPosition(position);
                CoreEditingCommands.LineBreakInsert.runEditorCommand(null, this.editor, null);
            }
            this.editor.setPosition(position);
            return this.commandService.executeCommand('editor.action.insertLineAfter');
        };
        await insertLine(configurationsArrayPosition);
        await this.commandService.executeCommand('editor.action.triggerSuggest');
    }
    get removeInlineValuesScheduler() {
        return (
             (new RunOnceScheduler(() => {
                this.oldDecorations.clear();
            }, 100))
        );
    }
    get updateInlineValuesScheduler() {
        const model = this.editor.getModel();
        return (
             (new RunOnceScheduler(
                async () => await this.updateInlineValueDecorations(this.debugService.getViewModel().focusedStackFrame),
                model ? this.debounceInfo.get(model) : DEAFULT_INLINE_DEBOUNCE_DELAY
            ))
        );
    }
    async updateInlineValueDecorations(stackFrame) {
        const var_value_format = '{0} = {1}';
        const separator = ', ';
        const model = this.editor.getModel();
        const inlineValuesSetting = this.configurationService.getValue('debug').inlineValues;
        const inlineValuesTurnedOn = inlineValuesSetting === true || inlineValuesSetting === 'on' || (inlineValuesSetting === 'auto' && model && this.languageFeaturesService.inlineValuesProvider.has(model));
        if (!inlineValuesTurnedOn || !model || !stackFrame || ( (model.uri.toString())) !== ( (stackFrame.source.uri.toString()))) {
            if (!this.removeInlineValuesScheduler.isScheduled()) {
                this.removeInlineValuesScheduler.schedule();
            }
            return;
        }
        this.removeInlineValuesScheduler.cancel();
        let allDecorations;
        if (this.languageFeaturesService.inlineValuesProvider.has(model)) {
            const findVariable = async (_key, caseSensitiveLookup) => {
                const scopes = await stackFrame.getMostSpecificScopes(stackFrame.range);
                const key = caseSensitiveLookup ? _key : _key.toLowerCase();
                for (const scope of scopes) {
                    const variables = await scope.getChildren();
                    const found = variables.find(v => caseSensitiveLookup ? (v.name === key) : (v.name.toLowerCase() === key));
                    if (found) {
                        return found.value;
                    }
                }
                return undefined;
            };
            const ctx = {
                frameId: stackFrame.frameId,
                stoppedLocation: ( (new Range(
                    stackFrame.range.startLineNumber,
                    stackFrame.range.startColumn + 1,
                    stackFrame.range.endLineNumber,
                    stackFrame.range.endColumn + 1
                )))
            };
            const token = ( (new CancellationTokenSource())).token;
            const ranges = this.editor.getVisibleRangesPlusViewportAboveBelow();
            const providers = this.languageFeaturesService.inlineValuesProvider.ordered(model).reverse();
            allDecorations = [];
            const lineDecorations = ( (new Map()));
            const promises = flatten(( (providers.map(provider => ( (ranges.map(
                range => Promise.resolve(provider.provideInlineValues(model, range, ctx, token)).then(async (result) => {
                    if (result) {
                        for (const iv of result) {
                            let text = undefined;
                            switch (iv.type) {
                                case 'text':
                                    text = iv.text;
                                    break;
                                case 'variable': {
                                    let va = iv.variableName;
                                    if (!va) {
                                        const lineContent = model.getLineContent(iv.range.startLineNumber);
                                        va = lineContent.substring(iv.range.startColumn - 1, iv.range.endColumn - 1);
                                    }
                                    const value = await findVariable(va, iv.caseSensitiveLookup);
                                    if (value) {
                                        text = format(var_value_format, va, value);
                                    }
                                    break;
                                }
                                case 'expression': {
                                    let expr = iv.expression;
                                    if (!expr) {
                                        const lineContent = model.getLineContent(iv.range.startLineNumber);
                                        expr = lineContent.substring(iv.range.startColumn - 1, iv.range.endColumn - 1);
                                    }
                                    if (expr) {
                                        const expression = ( (new Expression(expr)));
                                        await expression.evaluate(stackFrame.thread.session, stackFrame, 'watch', true);
                                        if (expression.available) {
                                            text = format(var_value_format, expr, expression.value);
                                        }
                                    }
                                    break;
                                }
                            }
                            if (text) {
                                const line = iv.range.startLineNumber;
                                let lineSegments = lineDecorations.get(line);
                                if (!lineSegments) {
                                    lineSegments = [];
                                    lineDecorations.set(line, lineSegments);
                                }
                                if (!lineSegments.some(iv => iv.text === text)) {
                                    lineSegments.push(( (new InlineSegment(iv.range.startColumn, text))));
                                }
                            }
                        }
                    }
                }, err => {
                    onUnexpectedExternalError(err);
                })
            )))))));
            const startTime = Date.now();
            await Promise.all(promises);
            this.updateInlineValuesScheduler.delay = this.debounceInfo.update(model, Date.now() - startTime);
            lineDecorations.forEach((segments, line) => {
                if (segments.length > 0) {
                    segments = segments.sort((a, b) => a.column - b.column);
                    const text = ( (segments.map(s => s.text))).join(separator);
                    allDecorations.push(...createInlineValueDecoration(line, text));
                }
            });
        }
        else {
            const scopes = await stackFrame.getMostSpecificScopes(stackFrame.range);
            const decorationsPerScope = await Promise.all(( (scopes.map(async (scope) => {
                const variables = await scope.getChildren();
                let range = ( (new Range(0, 0, stackFrame.range.startLineNumber, stackFrame.range.startColumn)));
                if (scope.range) {
                    range = range.setStartPosition(scope.range.startLineNumber, scope.range.startColumn);
                }
                return createInlineValueDecorationsInsideRange(variables, range, model, this.wordToLineNumbersMap);
            }))));
            allDecorations = distinct(decorationsPerScope.reduce((previous, current) => previous.concat(current), []),
            decoration => `${decoration.range.startLineNumber}:${decoration?.options.after?.content}`);
        }
        this.oldDecorations.set(allDecorations);
    }
    dispose() {
        if (this.hoverWidget) {
            this.hoverWidget.dispose();
        }
        if (this.configurationWidget) {
            this.configurationWidget.dispose();
        }
        this.toDispose = dispose(this.toDispose);
        this.oldDecorations.clear();
    }
};
DebugEditorContribution.__decorator = ( (__decorate([
    memoize
], DebugEditorContribution.prototype, "showHoverScheduler", null)));
DebugEditorContribution.__decorator = ( (__decorate([
    memoize
], DebugEditorContribution.prototype, "hideHoverScheduler", null)));
DebugEditorContribution.__decorator = ( (__decorate([
    memoize
], DebugEditorContribution.prototype, "removeInlineValuesScheduler", null)));
DebugEditorContribution.__decorator = ( (__decorate([
    memoize
], DebugEditorContribution.prototype, "updateInlineValuesScheduler", null)));
DebugEditorContribution = ( (__decorate([
    ( (__param(1, IDebugService))),
    ( (__param(2, IInstantiationService))),
    ( (__param(3, ICommandService))),
    ( (__param(4, IConfigurationService))),
    ( (__param(5, IHostService))),
    ( (__param(6, IUriIdentityService))),
    ( (__param(7, IContextKeyService))),
    ( (__param(8, ILanguageFeaturesService))),
    ( (__param(9, ILanguageFeatureDebounceService)))
], DebugEditorContribution)));
let StartDebugQuickAccessProvider = class StartDebugQuickAccessProvider extends PickerQuickAccessProvider {
    constructor(debugService, contextService, commandService, notificationService) {
        super(DEBUG_QUICK_ACCESS_PREFIX, {
            noResultsPick: {
                label: ( (localize('noDebugResults', "No matching launch configurations")))
            }
        });
        this.debugService = debugService;
        this.contextService = contextService;
        this.commandService = commandService;
        this.notificationService = notificationService;
    }
    async _getPicks(filter) {
        const picks = [];
        if (!this.debugService.getAdapterManager().hasEnabledDebuggers()) {
            return [];
        }
        picks.push({ type: 'separator', label: 'launch.json' });
        const configManager = this.debugService.getConfigurationManager();
        let lastGroup;
        for (const config of configManager.getAllConfigurations()) {
            const highlights = matchesFuzzy(filter, config.name, true);
            if (highlights) {
                if (lastGroup !== config.presentation?.group) {
                    picks.push({ type: 'separator' });
                    lastGroup = config.presentation?.group;
                }
                picks.push({
                    label: config.name,
                    description: this.contextService.getWorkbenchState() === 3  ? config.launch.name : '',
                    highlights: { label: highlights },
                    buttons: [{
                            iconClass: ThemeIcon.asClassName(debugConfigure),
                            tooltip: ( (localize('customizeLaunchConfig', "Configure Launch Configuration")))
                        }],
                    trigger: () => {
                        config.launch.openConfigFile({ preserveFocus: false });
                        return TriggerAction.CLOSE_PICKER;
                    },
                    accept: async () => {
                        await configManager.selectConfiguration(config.launch, config.name);
                        try {
                            await this.debugService.startDebugging(config.launch, undefined, { startedByUser: true });
                        }
                        catch (error) {
                            this.notificationService.error(error);
                        }
                    }
                });
            }
        }
        const dynamicProviders = await configManager.getDynamicProviders();
        if (dynamicProviders.length > 0) {
            picks.push({
                type: 'separator', label: ( (localize({
                    key: 'contributed',
                    comment: ['contributed is lower case because it looks better like that in UI. Nothing preceeds it. It is a name of the grouping of debug configurations.']
                }, "contributed")))
            });
        }
        configManager.getRecentDynamicConfigurations().forEach(({ name, type }) => {
            const highlights = matchesFuzzy(filter, name, true);
            if (highlights) {
                picks.push({
                    label: name,
                    highlights: { label: highlights },
                    buttons: [{
                            iconClass: ThemeIcon.asClassName(debugRemoveConfig),
                            tooltip: ( (localize('removeLaunchConfig', "Remove Launch Configuration")))
                        }],
                    trigger: () => {
                        configManager.removeRecentDynamicConfigurations(name, type);
                        return TriggerAction.CLOSE_PICKER;
                    },
                    accept: async () => {
                        await configManager.selectConfiguration(undefined, name, undefined, { type });
                        try {
                            const { launch, getConfig } = configManager.selectedConfiguration;
                            const config = await getConfig();
                            await this.debugService.startDebugging(launch, config, { startedByUser: true });
                        }
                        catch (error) {
                            this.notificationService.error(error);
                        }
                    }
                });
            }
        });
        dynamicProviders.forEach(provider => {
            picks.push({
                label: `$(folder) ${provider.label}...`,
                ariaLabel: ( (localize(
                    { key: 'providerAriaLabel', comment: ['Placeholder stands for the provider label. For example "NodeJS".'] },
                    "{0} contributed configurations",
                    provider.label
                ))),
                accept: async () => {
                    const pick = await provider.pick();
                    if (pick) {
                        await configManager.selectConfiguration(pick.launch, pick.config.name, pick.config, { type: provider.type });
                        this.debugService.startDebugging(pick.launch, pick.config, { startedByUser: true });
                    }
                }
            });
        });
        const visibleLaunches = configManager.getLaunches().filter(launch => !launch.hidden);
        if (visibleLaunches.length > 0) {
            picks.push({ type: 'separator', label: ( (localize('configure', "configure"))) });
        }
        for (const launch of visibleLaunches) {
            const label = this.contextService.getWorkbenchState() === 3  ?
                ( (localize("addConfigTo", "Add Config ({0})...", launch.name))) :
                ( (localize('addConfiguration', "Add Configuration...")));
            picks.push({
                label,
                description: this.contextService.getWorkbenchState() === 3  ? launch.name : '',
                highlights: { label: withNullAsUndefined(matchesFuzzy(filter, label, true)) },
                accept: () => this.commandService.executeCommand(ADD_CONFIGURATION_ID, ( (launch.uri.toString())))
            });
        }
        return picks;
    }
};
StartDebugQuickAccessProvider = ( (__decorate([
    ( (__param(0, IDebugService))),
    ( (__param(1, IWorkspaceContextService))),
    ( (__param(2, ICommandService))),
    ( (__param(3, INotificationService)))
], StartDebugQuickAccessProvider)));
registerColors();
( (Registry.as(Extensions.Quickaccess))).registerQuickAccessProvider({
    ctor: StartDebugQuickAccessProvider,
    prefix: DEBUG_QUICK_ACCESS_PREFIX,
    contextKey: 'inLaunchConfigurationsPicker',
    placeholder: ( (localize('startDebugPlaceholder', "Type the name of a launch configuration to run."))),
    helpEntries: [{ description: ( (localize('startDebuggingHelp', "Start Debugging"))), commandId: SELECT_AND_START_ID }]
});
( (Registry.as(Extensions.Quickaccess))).registerQuickAccessProvider({
    ctor: DebugConsoleQuickAccess,
    prefix: DEBUG_CONSOLE_QUICK_ACCESS_PREFIX,
    contextKey: 'inDebugConsolePicker',
    placeholder: ( (localize('tasksQuickAccessPlaceholder', "Type the name of a debug console to open."))),
    helpEntries: [{ description: ( (localize('tasksQuickAccessHelp', "Show All Debug Consoles"))), commandId: SELECT_DEBUG_CONSOLE_ID }]
});
registerEditorContribution('editor.contrib.callStack', CallStackEditorContribution, 1 );
registerEditorContribution(BREAKPOINT_EDITOR_CONTRIBUTION_ID, BreakpointEditorContribution, 1 );
registerEditorContribution(EDITOR_CONTRIBUTION_ID, DebugEditorContribution, 2 );
MenuRegistry.appendMenuItem(MenuId.EditorTitle, { submenu: MenuId.EditorTitleRun, rememberDefaultAction: true, title: { value: ( (localize('run', "Run or Debug..."))), original: 'Run or Debug...', }, icon: debugRun, group: 'navigation', order: -1 });
MenuRegistry.appendMenuItem(MenuId.MenubarMainMenu, {
    submenu: MenuId.MenubarDebugMenu,
    title: {
        value: 'Run',
        original: 'Run',
        mnemonicTitle: ( (localize({ key: 'mRun', comment: ['&& denotes a mnemonic'] }, "&&Run")))
    },
    order: 6
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '1_debug',
    command: {
        id: DEBUG_START_COMMAND_ID,
        title: ( (localize(
            { key: 'miStartDebugging', comment: ['&& denotes a mnemonic'] },
            "&&Start Debugging"
        )))
    },
    order: 1,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '1_debug',
    command: {
        id: DEBUG_RUN_COMMAND_ID,
        title: ( (localize(
            { key: 'miRun', comment: ['&& denotes a mnemonic'] },
            "Run &&Without Debugging"
        )))
    },
    order: 2,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '1_debug',
    command: {
        id: STOP_ID,
        title: ( (localize(
            { key: 'miStopDebugging', comment: ['&& denotes a mnemonic'] },
            "&&Stop Debugging"
        ))),
        precondition: CONTEXT_IN_DEBUG_MODE
    },
    order: 3,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '1_debug',
    command: {
        id: RESTART_SESSION_ID,
        title: ( (localize(
            { key: 'miRestart Debugging', comment: ['&& denotes a mnemonic'] },
            "&&Restart Debugging"
        ))),
        precondition: CONTEXT_IN_DEBUG_MODE
    },
    order: 4,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '2_configuration',
    command: {
        id: ADD_CONFIGURATION_ID,
        title: ( (localize(
            { key: 'miAddConfiguration', comment: ['&& denotes a mnemonic'] },
            "A&&dd Configuration..."
        )))
    },
    order: 2,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '3_step',
    command: {
        id: STEP_OVER_ID,
        title: ( (localize({ key: 'miStepOver', comment: ['&& denotes a mnemonic'] }, "Step &&Over"))),
        precondition: ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped')))
    },
    order: 1,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '3_step',
    command: {
        id: STEP_INTO_ID,
        title: ( (localize({ key: 'miStepInto', comment: ['&& denotes a mnemonic'] }, "Step &&Into"))),
        precondition: ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped')))
    },
    order: 2,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '3_step',
    command: {
        id: STEP_OUT_ID,
        title: ( (localize({ key: 'miStepOut', comment: ['&& denotes a mnemonic'] }, "Step O&&ut"))),
        precondition: ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped')))
    },
    order: 3,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '3_step',
    command: {
        id: CONTINUE_ID,
        title: ( (localize({ key: 'miContinue', comment: ['&& denotes a mnemonic'] }, "&&Continue"))),
        precondition: ( (CONTEXT_DEBUG_STATE.isEqualTo('stopped')))
    },
    order: 4,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarNewBreakpointMenu, {
    group: '1_breakpoints',
    command: {
        id: TOGGLE_INLINE_BREAKPOINT_ID,
        title: ( (localize(
            { key: 'miInlineBreakpoint', comment: ['&& denotes a mnemonic'] },
            "Inline Breakp&&oint"
        )))
    },
    order: 2,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: '4_new_breakpoint',
    title: ( (localize(
        { key: 'miNewBreakpoint', comment: ['&& denotes a mnemonic'] },
        "&&New Breakpoint"
    ))),
    submenu: MenuId.MenubarNewBreakpointMenu,
    order: 2,
    when: CONTEXT_DEBUGGERS_AVAILABLE
});
MenuRegistry.appendMenuItem(MenuId.MenubarDebugMenu, {
    group: 'z_install',
    command: {
        id: 'debug.installAdditionalDebuggers',
        title: ( (localize(
            { key: 'miInstallAdditionalDebuggers', comment: ['&& denotes a mnemonic'] },
            "&&Install Additional Debuggers..."
        )))
    },
    order: 1
});
const configurationRegistry = ( (Registry.as(Extensions$2.Configuration)));
configurationRegistry.registerConfiguration({
    id: 'debug',
    order: 20,
    title: ( (localize('debugConfigurationTitle', "Debug"))),
    type: 'object',
    properties: {
        'debug.allowBreakpointsEverywhere': {
            type: 'boolean',
            description: ( (localize(
                { comment: ['This is the description for a setting'], key: 'allowBreakpointsEverywhere' },
                "Allow setting breakpoints in any file."
            ))),
            default: false
        },
        'debug.openExplorerOnEnd': {
            type: 'boolean',
            description: ( (localize(
                { comment: ['This is the description for a setting'], key: 'openExplorerOnEnd' },
                "Automatically open the explorer view at the end of a debug session."
            ))),
            default: false
        },
        'debug.inlineValues': {
            type: 'string',
            'enum': ['on', 'off', 'auto'],
            description: ( (localize(
                { comment: ['This is the description for a setting'], key: 'inlineValues' },
                "Show variable values inline in editor while debugging."
            ))),
            'enumDescriptions': [
                ( (localize(
                'inlineValues.on',
                "Always show variable values inline in editor while debugging."
            ))),
                ( (localize(
                'inlineValues.off',
                "Never show variable values inline in editor while debugging."
            ))),
                ( (localize(
                'inlineValues.focusNoScroll',
                "Show variable values inline in editor while debugging when the language supports inline value locations."
            ))),
            ],
            default: 'auto'
        },
        'debug.toolBarLocation': {
            enum: ['floating', 'docked', 'hidden'],
            markdownDescription: ( (localize(
                { comment: ['This is the description for a setting'], key: 'toolBarLocation' },
                "Controls the location of the debug toolbar. Either `floating` in all views, `docked` in the debug view, or `hidden`."
            ))),
            default: 'floating'
        },
        'debug.showInStatusBar': {
            enum: ['never', 'always', 'onFirstSessionStart'],
            enumDescriptions: [( (localize('never', "Never show debug in Status bar"))), ( (localize('always', "Always show debug in Status bar"))), ( (localize(
                'onFirstSessionStart',
                "Show debug in Status bar only after debug was started for the first time"
            )))],
            description: ( (localize(
                { comment: ['This is the description for a setting'], key: 'showInStatusBar' },
                "Controls when the debug Status bar should be visible."
            ))),
            default: 'onFirstSessionStart'
        },
        'debug.internalConsoleOptions': INTERNAL_CONSOLE_OPTIONS_SCHEMA,
        'debug.console.closeOnEnd': {
            type: 'boolean',
            description: ( (localize(
                'debug.console.closeOnEnd',
                "Controls if the Debug Console should be automatically closed when the debug session ends."
            ))),
            default: false
        },
        'debug.terminal.clearBeforeReusing': {
            type: 'boolean',
            description: ( (localize(
                { comment: ['This is the description for a setting'], key: 'debug.terminal.clearBeforeReusing' },
                "Before starting a new debug session in an integrated or external terminal, clear the terminal."
            ))),
            default: false
        },
        'debug.openDebug': {
            enum: ['neverOpen', 'openOnSessionStart', 'openOnFirstSessionStart', 'openOnDebugBreak'],
            default: 'openOnDebugBreak',
            description: ( (localize('openDebug', "Controls when the debug view should open.")))
        },
        'debug.showSubSessionsInToolBar': {
            type: 'boolean',
            description: ( (localize(
                { comment: ['This is the description for a setting'], key: 'showSubSessionsInToolBar' },
                "Controls whether the debug sub-sessions are shown in the debug tool bar. When this setting is false the stop command on a sub-session will also stop the parent session."
            ))),
            default: false
        },
        'debug.console.fontSize': {
            type: 'number',
            description: ( (localize(
                'debug.console.fontSize',
                "Controls the font size in pixels in the Debug Console."
            ))),
            default: isMacintosh ? 12 : 14,
        },
        'debug.console.fontFamily': {
            type: 'string',
            description: ( (localize(
                'debug.console.fontFamily',
                "Controls the font family in the Debug Console."
            ))),
            default: 'default'
        },
        'debug.console.lineHeight': {
            type: 'number',
            description: ( (localize(
                'debug.console.lineHeight',
                "Controls the line height in pixels in the Debug Console. Use 0 to compute the line height from the font size."
            ))),
            default: 0
        },
        'debug.console.wordWrap': {
            type: 'boolean',
            description: ( (localize(
                'debug.console.wordWrap',
                "Controls if the lines should wrap in the Debug Console."
            ))),
            default: true
        },
        'debug.console.historySuggestions': {
            type: 'boolean',
            description: ( (localize(
                'debug.console.historySuggestions',
                "Controls if the Debug Console should suggest previously typed input."
            ))),
            default: true
        },
        'debug.console.collapseIdenticalLines': {
            type: 'boolean',
            description: ( (localize(
                'debug.console.collapseIdenticalLines',
                "Controls if the Debug Console should collapse identical lines and show a number of occurrences with a badge."
            ))),
            default: true
        },
        'debug.console.acceptSuggestionOnEnter': {
            enum: ['off', 'on'],
            description: ( (localize(
                'debug.console.acceptSuggestionOnEnter',
                "Controls whether suggestions should be accepted on Enter in the Debug Console. Enter is also used to evaluate whatever is typed in the Debug Console."
            ))),
            default: 'off'
        },
        'launch': {
            type: 'object',
            description: ( (localize(
                { comment: ['This is the description for a setting'], key: 'launch' },
                "Global debug launch configuration. Should be used as an alternative to 'launch.json' that is shared across workspaces."
            ))),
            default: { configurations: [], compounds: [] },
            $ref: launchSchemaId
        },
        'debug.focusWindowOnBreak': {
            type: 'boolean',
            description: ( (localize(
                'debug.focusWindowOnBreak',
                "Controls whether the workbench window should be focused when the debugger breaks."
            ))),
            default: true
        },
        'debug.focusEditorOnBreak': {
            type: 'boolean',
            description: ( (localize(
                'debug.focusEditorOnBreak',
                "Controls whether the editor should be focused when the debugger breaks."
            ))),
            default: true
        },
        'debug.onTaskErrors': {
            enum: ['debugAnyway', 'showErrors', 'prompt', 'abort'],
            enumDescriptions: [( (localize('debugAnyway', "Ignore task errors and start debugging."))), ( (localize('showErrors', "Show the Problems view and do not start debugging."))), ( (localize('prompt', "Prompt user."))), ( (localize('cancel', "Cancel debugging.")))],
            description: ( (localize(
                'debug.onTaskErrors',
                "Controls what to do when errors are encountered after running a preLaunchTask."
            ))),
            default: 'prompt'
        },
        'debug.showBreakpointsInOverviewRuler': {
            type: 'boolean',
            description: ( (localize(
                { comment: ['This is the description for a setting'], key: 'showBreakpointsInOverviewRuler' },
                "Controls whether breakpoints should be shown in the overview ruler."
            ))),
            default: false
        },
        'debug.showInlineBreakpointCandidates': {
            type: 'boolean',
            description: ( (localize(
                { comment: ['This is the description for a setting'], key: 'showInlineBreakpointCandidates' },
                "Controls whether inline breakpoints candidate decorations should be shown in the editor while debugging."
            ))),
            default: true
        },
        'debug.saveBeforeStart': {
            description: ( (localize(
                'debug.saveBeforeStart',
                "Controls what editors to save before starting a debug session."
            ))),
            enum: ['allEditorsInActiveGroup', 'nonUntitledEditorsInActiveGroup', 'none'],
            enumDescriptions: [
                ( (localize(
                'debug.saveBeforeStart.allEditorsInActiveGroup',
                "Save all editors in the active group before starting a debug session."
            ))),
                ( (localize(
                'debug.saveBeforeStart.nonUntitledEditorsInActiveGroup',
                "Save all editors in the active group except untitled ones before starting a debug session."
            ))),
                ( (localize(
                'debug.saveBeforeStart.none',
                "Don't save any editors before starting a debug session."
            ))),
            ],
            default: 'allEditorsInActiveGroup',
            scope: 5
        },
        'debug.confirmOnExit': {
            description: ( (localize(
                'debug.confirmOnExit',
                "Controls whether to confirm when the window closes if there are active debug sessions."
            ))),
            type: 'string',
            enum: ['never', 'always'],
            enumDescriptions: [
                ( (localize('debug.confirmOnExit.never', "Never confirm."))),
                ( (localize(
                'debug.confirmOnExit.always',
                "Always confirm if there are debug sessions."
            ))),
            ],
            default: 'never'
        },
        'debug.disassemblyView.showSourceCode': {
            type: 'boolean',
            default: true,
            description: ( (localize(
                'debug.disassemblyView.showSourceCode',
                "Show Source Code in Disassembly View."
            )))
        },
        'debug.autoExpandLazyVariables': {
            type: 'boolean',
            default: false,
            description: ( (localize(
                'debug.autoExpandLazyVariables',
                "Automatically show values for variables that are lazily resolved by the debugger, such as getters."
            )))
        },
        'debug.enableStatusBarColor': {
            type: 'boolean',
            description: ( (localize('debug.enableStatusBarColor', "Color status bar when debugger is active"))),
            default: true
        }
    }
});
function initialize(instantiationService) {
    setTimeout(() => {
        instantiationService.createInstance(DebugToolBar);
        instantiationService.createInstance(DebugContentProvider);
    });
}
const original = DebugService.prototype['showError'];
DebugService.prototype['showError'] = function (message, errorActions) {
    return original.call(this, message, errorActions, false);
};
function getServiceOverride() {
    onServicesInitialized(initialize);
    return {
        ...getServiceOverride$1(),
        [( ILanguageFeaturesService.toString())]: new SyncDescriptor(LanguageFeaturesService),
        [( IDebugService.toString())]: new SyncDescriptor(DebugService),
        [( IConfigurationResolverService.toString())]: new SyncDescriptor(ConfigurationResolverService)
    };
}
export { getServiceOverride as default };
