import { n, b as assertAllDefined, o as onServicesInitialized } from './polyfill.js';
import { bL as ILifecycleService } from './missing-services.js';
import { _ as __decorate, E as Emitter, N as NotificationsFilter, a as __param, G as NeverShowAgainScope, d as IEditorGroupsService, t as IHostService } from './services2.js';
import { N as NotificationsToastsVisibleContext, a as NOTIFICATIONS_BACKGROUND, b as NOTIFICATIONS_TOAST_BORDER, c as NotificationsCenterVisibleContext, d as NOTIFICATIONS_CENTER_BORDER, e as NOTIFICATIONS_CENTER_HEADER_FOREGROUND, f as NOTIFICATIONS_CENTER_HEADER_BACKGROUND, i as isErrorWithActions, g as NotificationFocusedContext } from './contextkeys.js';
import { Disposable, toDisposable, DisposableStore, dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { NoOpNotification, Severity, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { isCancellationError } from 'monaco-editor/esm/vs/base/common/errors.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { parseLinkedText } from 'monaco-editor/esm/vs/base/common/linkedText.js';
import { equals, isNonEmptyArray } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { Action, ActionRunner } from 'monaco-editor/esm/vs/base/common/actions.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { hash } from 'monaco-editor/esm/vs/base/common/hash.js';
import { ICommandService, CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { WorkbenchList, IListService } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { IContextKeyService, ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { MenuRegistry, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { registerIcon } from 'monaco-editor/esm/vs/platform/theme/common/iconRegistry.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { B as ButtonBar } from './button.js';
import { Dimension, addDisposableListener, EventType, EventHelper, clearNode, scheduleAtNextAnimationFrame, isAncestor, $, trackFocus, getClientArea, isEventLike } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { DomEmitter } from 'monaco-editor/esm/vs/base/browser/event.js';
import { Gesture, EventType as EventType$1 } from 'monaco-editor/esm/vs/base/browser/touch.js';
import { ActionBar } from 'monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js';
import { ProgressBar } from 'monaco-editor/esm/vs/base/browser/ui/progressbar/progressbar.js';
import { defaultProgressBarStyles, defaultButtonStyles } from 'monaco-editor/esm/vs/platform/theme/browser/defaultStyles.js';
import { IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { StandardKeyboardEvent } from 'monaco-editor/esm/vs/base/browser/keyboardEvent.js';
import { DropdownMenuActionViewItem } from 'monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js';
import { assertIsDefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { I as IWorkbenchLayoutService } from './layoutService.js';
import { widgetShadow } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { I as IntervalCounter } from './async.js';
import { Themable, IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { alert } from 'monaco-editor/esm/vs/base/browser/ui/aria/aria.js';
import { g as getServiceOverride$1 } from './layout.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { ILayoutService } from 'monaco-editor/esm/vs/platform/layout/browser/layoutService.js';
var css$3 = ".monaco-workbench>.notifications-toasts{bottom:26px;display:none;overflow:hidden;position:absolute;right:3px;z-index:1000}.monaco-workbench.nostatusbar>.notifications-toasts{bottom:3px}.monaco-workbench>.notifications-toasts.visible{display:flex;flex-direction:column}.monaco-workbench>.notifications-toasts .notification-toast-container{overflow:hidden}.monaco-workbench>.notifications-toasts .notification-toast-container>.notification-toast{border-radius:4px;margin:8px;opacity:0;transform:translate3d(0,100%,0);transition:transform .3s ease-out,opacity .3s ease-out}.monaco-workbench.reduce-motion>.notifications-toasts .notification-toast-container>.notification-toast{transition:transform 0ms ease-out,opacity 0ms ease-out}.monaco-workbench>.notifications-toasts .notification-toast-container>.notification-toast.notification-fade-in{opacity:1;transform:none}.monaco-workbench>.notifications-toasts .notification-toast-container>.notification-toast.notification-fade-in-done{opacity:1;transform:none;transition:none}.monaco-workbench>.notifications-toasts .codicon.codicon-error{color:var(--vscode-notificationsErrorIcon-foreground)!important}.monaco-workbench>.notifications-toasts .codicon.codicon-warning{color:var(--vscode-notificationsWarningIcon-foreground)!important}.monaco-workbench>.notifications-toasts .codicon.codicon-info{color:var(--vscode-notificationsInfoIcon-foreground)!important}";
n(css$3,{});
var css$2 = ".monaco-workbench .notifications-list-container{background:var(--vscode-notifications-background);border-radius:inherit;color:var(--vscode-notifications-foreground);outline-color:var(--vscode-contrastBorder)}.monaco-workbench .notifications-list-container .notification-list-item{border-radius:4px;box-sizing:border-box;display:flex;flex-direction:column;flex-direction:column-reverse;height:100%;padding:10px 5px}.monaco-workbench .notifications-list-container .notification-offset-helper{word-wrap:break-word;line-height:22px;opacity:0;position:absolute}.monaco-workbench .notifications-list-container .monaco-scrollable-element{border-radius:4px}.monaco-workbench .notifications-list-container .notification-list-item>.notification-list-item-main-row{display:flex;flex-grow:1}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-icon{align-items:center;background-position:50%;background-repeat:no-repeat;display:flex;flex:0 0 16px;font-size:18px;height:22px;margin-left:4px;margin-right:4px}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-message{flex:1;line-height:22px;overflow:hidden;text-overflow:ellipsis;user-select:text;-webkit-user-select:text}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-message a{color:var(--vscode-notificationLink-foreground)}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-message a:focus{outline-color:var(--vscode-focusBorder);outline-style:solid;outline-width:1px}.monaco-workbench .notifications-list-container .notification-list-item.expanded .notification-list-item-message{word-wrap:break-word;white-space:normal}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-toolbar-container{display:none;height:22px}.monaco-workbench .notifications-list-container .monaco-list-row.focused .notification-list-item .notification-list-item-toolbar-container,.monaco-workbench .notifications-list-container .notification-list-item.expanded .notification-list-item-toolbar-container,.monaco-workbench .notifications-list-container .notification-list-item:hover .notification-list-item-toolbar-container{display:block}.monaco-workbench .notifications-list-container .notification-list-item>.notification-list-item-details-row{align-items:center;display:none;overflow:hidden;padding-left:5px}.monaco-workbench .notifications-list-container .notification-list-item.expanded>.notification-list-item-details-row{display:flex}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-source{flex:1;font-size:12px;overflow:hidden;text-overflow:ellipsis}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container{display:flex;overflow:hidden}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container>.monaco-button,.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container>.monaco-button-dropdown{margin:4px 5px}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container .monaco-button{outline-offset:2px!important}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container .monaco-text-button{display:inline-block;font-size:12px;overflow:hidden;padding:4px 10px;text-overflow:ellipsis;width:fit-content}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-buttons-container .monaco-dropdown-button{padding:5px}.monaco-workbench .notifications-list-container .progress-bit{bottom:0;height:2px}";
n(css$2,{});
class NotificationHandle extends Disposable {
    constructor(item, onClose) {
        super();
        this.item = item;
        this.onClose = onClose;
        this._onDidClose = this._register(( (new Emitter())));
        this.onDidClose = this._onDidClose.event;
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.item.onDidChangeVisibility(visible => this._onDidChangeVisibility.fire(visible)));
        Event.once(this.item.onDidClose)(() => {
            this._onDidClose.fire();
            this.dispose();
        });
    }
    get progress() {
        return this.item.progress;
    }
    updateSeverity(severity) {
        this.item.updateSeverity(severity);
    }
    updateMessage(message) {
        this.item.updateMessage(message);
    }
    updateActions(actions) {
        this.item.updateActions(actions);
    }
    close() {
        this.onClose(this.item);
        this.dispose();
    }
}
class NotificationsModel extends Disposable {
    constructor() {
        super(...arguments);
        this._onDidChangeNotification = this._register(( (new Emitter())));
        this.onDidChangeNotification = this._onDidChangeNotification.event;
        this._onDidChangeStatusMessage = this._register(( (new Emitter())));
        this.onDidChangeStatusMessage = this._onDidChangeStatusMessage.event;
        this._onDidChangeFilter = this._register(( (new Emitter())));
        this.onDidChangeFilter = this._onDidChangeFilter.event;
        this._notifications = [];
        this.filter = NotificationsFilter.OFF;
    }
    get notifications() { return this._notifications; }
    get statusMessage() { return this._statusMessage; }
    setFilter(filter) {
        this.filter = filter;
        this._onDidChangeFilter.fire(filter);
    }
    addNotification(notification) {
        const item = this.createViewItem(notification);
        if (!item) {
            return NotificationsModel.NO_OP_NOTIFICATION;
        }
        const duplicate = this.findNotification(item);
        duplicate?.close();
        this._notifications.splice(0, 0, item);
        this._onDidChangeNotification.fire({ item, index: 0, kind: 0  });
        return (
             (new NotificationHandle(item, item => this.onClose(item)))
        );
    }
    onClose(item) {
        const liveItem = this.findNotification(item);
        if (liveItem && liveItem !== item) {
            liveItem.close();
        }
        else {
            item.close();
        }
    }
    findNotification(item) {
        return this._notifications.find(notification => notification.equals(item));
    }
    createViewItem(notification) {
        const item = NotificationViewItem.create(notification, this.filter);
        if (!item) {
            return undefined;
        }
        const fireNotificationChangeEvent = (kind, detail) => {
            const index = this._notifications.indexOf(item);
            if (index >= 0) {
                this._onDidChangeNotification.fire({ item, index, kind, detail });
            }
        };
        const itemExpansionChangeListener = item.onDidChangeExpansion(() => fireNotificationChangeEvent(2 ));
        const itemContentChangeListener = item.onDidChangeContent(e => fireNotificationChangeEvent(1 , e.kind));
        Event.once(item.onDidClose)(() => {
            itemExpansionChangeListener.dispose();
            itemContentChangeListener.dispose();
            const index = this._notifications.indexOf(item);
            if (index >= 0) {
                this._notifications.splice(index, 1);
                this._onDidChangeNotification.fire({ item, index, kind: 3  });
            }
        });
        return item;
    }
    showStatusMessage(message, options) {
        const item = StatusMessageViewItem.create(message, options);
        if (!item) {
            return Disposable.None;
        }
        this._statusMessage = item;
        this._onDidChangeStatusMessage.fire({ kind: 0 , item });
        return toDisposable(() => {
            if (this._statusMessage === item) {
                this._statusMessage = undefined;
                this._onDidChangeStatusMessage.fire({ kind: 1 , item });
            }
        });
    }
}
NotificationsModel.NO_OP_NOTIFICATION = ( (new NoOpNotification()));
function isNotificationViewItem(obj) {
    return obj instanceof NotificationViewItem;
}
class NotificationViewItemProgress extends Disposable {
    constructor() {
        super();
        this._onDidChange = this._register(( (new Emitter())));
        this.onDidChange = this._onDidChange.event;
        this._state = Object.create(null);
    }
    get state() {
        return this._state;
    }
    infinite() {
        if (this._state.infinite) {
            return;
        }
        this._state.infinite = true;
        this._state.total = undefined;
        this._state.worked = undefined;
        this._state.done = undefined;
        this._onDidChange.fire();
    }
    done() {
        if (this._state.done) {
            return;
        }
        this._state.done = true;
        this._state.infinite = undefined;
        this._state.total = undefined;
        this._state.worked = undefined;
        this._onDidChange.fire();
    }
    total(value) {
        if (this._state.total === value) {
            return;
        }
        this._state.total = value;
        this._state.infinite = undefined;
        this._state.done = undefined;
        this._onDidChange.fire();
    }
    worked(value) {
        if (typeof this._state.worked === 'number') {
            this._state.worked += value;
        }
        else {
            this._state.worked = value;
        }
        this._state.infinite = undefined;
        this._state.done = undefined;
        this._onDidChange.fire();
    }
}
class NotificationViewItem extends Disposable {
    static create(notification, filter = NotificationsFilter.OFF) {
        if (!notification || !notification.message || isCancellationError(notification.message)) {
            return undefined;
        }
        let severity;
        if (typeof notification.severity === 'number') {
            severity = notification.severity;
        }
        else {
            severity = Severity.Info;
        }
        const message = NotificationViewItem.parseNotificationMessage(notification.message);
        if (!message) {
            return undefined;
        }
        let actions;
        if (notification.actions) {
            actions = notification.actions;
        }
        else if (isErrorWithActions(notification.message)) {
            actions = { primary: notification.message.actions };
        }
        return (
             (new NotificationViewItem(
                notification.id,
                severity,
                notification.sticky,
                notification.silent || filter === NotificationsFilter.SILENT || (filter === NotificationsFilter.ERROR && notification.severity !== Severity.Error),
                message,
                notification.source,
                notification.progress,
                actions
            ))
        );
    }
    static parseNotificationMessage(input) {
        let message;
        if (input instanceof Error) {
            message = toErrorMessage(input, false);
        }
        else if (typeof input === 'string') {
            message = input;
        }
        if (!message) {
            return undefined;
        }
        const raw = message;
        if (message.length > NotificationViewItem.MAX_MESSAGE_LENGTH) {
            message = `${message.substr(0, NotificationViewItem.MAX_MESSAGE_LENGTH)}...`;
        }
        message = message.replace(/(\r\n|\n|\r)/gm, ' ').trim();
        const linkedText = parseLinkedText(message);
        return { raw, linkedText, original: input };
    }
    constructor(id, _severity, _sticky, _silent, _message, _source, progress, actions) {
        super();
        this.id = id;
        this._severity = _severity;
        this._sticky = _sticky;
        this._silent = _silent;
        this._message = _message;
        this._source = _source;
        this._visible = false;
        this._onDidChangeExpansion = this._register(( (new Emitter())));
        this.onDidChangeExpansion = this._onDidChangeExpansion.event;
        this._onDidClose = this._register(( (new Emitter())));
        this.onDidClose = this._onDidClose.event;
        this._onDidChangeContent = this._register(( (new Emitter())));
        this.onDidChangeContent = this._onDidChangeContent.event;
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        if (progress) {
            this.setProgress(progress);
        }
        this.setActions(actions);
    }
    setProgress(progress) {
        if (progress.infinite) {
            this.progress.infinite();
        }
        else if (progress.total) {
            this.progress.total(progress.total);
            if (progress.worked) {
                this.progress.worked(progress.worked);
            }
        }
    }
    setActions(actions = { primary: [], secondary: [] }) {
        this._actions = {
            primary: Array.isArray(actions.primary) ? actions.primary : [],
            secondary: Array.isArray(actions.secondary) ? actions.secondary : []
        };
        this._expanded = actions.primary && actions.primary.length > 0;
    }
    get canCollapse() {
        return !this.hasActions;
    }
    get expanded() {
        return !!this._expanded;
    }
    get severity() {
        return this._severity;
    }
    get sticky() {
        if (this._sticky) {
            return true;
        }
        const hasActions = this.hasActions;
        if ((hasActions && this._severity === Severity.Error) ||
            (!hasActions && this._expanded) ||
            (this._progress && !this._progress.state.done)
        ) {
            return true;
        }
        return false;
    }
    get silent() {
        return !!this._silent;
    }
    get hasActions() {
        if (!this._actions) {
            return false;
        }
        if (!this._actions.primary) {
            return false;
        }
        return this._actions.primary.length > 0;
    }
    get hasProgress() {
        return !!this._progress;
    }
    get progress() {
        if (!this._progress) {
            this._progress = this._register(( (new NotificationViewItemProgress())));
            this._register(this._progress.onDidChange(() => this._onDidChangeContent.fire({ kind: 3  })));
        }
        return this._progress;
    }
    get message() {
        return this._message;
    }
    get source() {
        return typeof this._source === 'string' ? this._source : (this._source ? this._source.label : undefined);
    }
    get sourceId() {
        return (this._source && typeof this._source !== 'string' && 'id' in this._source) ? this._source.id : undefined;
    }
    get actions() {
        return this._actions;
    }
    get visible() {
        return this._visible;
    }
    updateSeverity(severity) {
        if (severity === this._severity) {
            return;
        }
        this._severity = severity;
        this._onDidChangeContent.fire({ kind: 0  });
    }
    updateMessage(input) {
        const message = NotificationViewItem.parseNotificationMessage(input);
        if (!message || message.raw === this._message.raw) {
            return;
        }
        this._message = message;
        this._onDidChangeContent.fire({ kind: 1  });
    }
    updateActions(actions) {
        this.setActions(actions);
        this._onDidChangeContent.fire({ kind: 2  });
    }
    updateVisibility(visible) {
        if (this._visible !== visible) {
            this._visible = visible;
            this._onDidChangeVisibility.fire(visible);
        }
    }
    expand() {
        if (this._expanded || !this.canCollapse) {
            return;
        }
        this._expanded = true;
        this._onDidChangeExpansion.fire();
    }
    collapse(skipEvents) {
        if (!this._expanded || !this.canCollapse) {
            return;
        }
        this._expanded = false;
        if (!skipEvents) {
            this._onDidChangeExpansion.fire();
        }
    }
    toggle() {
        if (this._expanded) {
            this.collapse();
        }
        else {
            this.expand();
        }
    }
    close() {
        this._onDidClose.fire();
        this.dispose();
    }
    equals(other) {
        if (this.hasProgress || other.hasProgress) {
            return false;
        }
        if (typeof this.id === 'string' || typeof other.id === 'string') {
            return this.id === other.id;
        }
        if (typeof this._source === 'object') {
            if (this._source.label !== other.source || this._source.id !== other.sourceId) {
                return false;
            }
        }
        else if (this._source !== other.source) {
            return false;
        }
        if (this._message.raw !== other.message.raw) {
            return false;
        }
        const primaryActions = (this._actions && this._actions.primary) || [];
        const otherPrimaryActions = (other.actions && other.actions.primary) || [];
        return equals(primaryActions, otherPrimaryActions, (action, otherAction) => (action.id + action.label) === (otherAction.id + otherAction.label));
    }
}
NotificationViewItem.MAX_MESSAGE_LENGTH = 1000;
class ChoiceAction extends Action {
    constructor(id, choice) {
        super(id, choice.label, undefined, true, async () => {
            choice.run();
            this._onDidRun.fire();
        });
        this._onDidRun = this._register(( (new Emitter())));
        this.onDidRun = this._onDidRun.event;
        this._keepOpen = !!choice.keepOpen;
        this._menu = !choice.isSecondary && choice.menu ? ( (choice.menu.map((c, index) => ( (new ChoiceAction(`${id}.${index}`, c)))))) : undefined;
    }
    get menu() {
        return this._menu;
    }
    get keepOpen() {
        return this._keepOpen;
    }
}
class StatusMessageViewItem {
    static create(notification, options) {
        if (!notification || isCancellationError(notification)) {
            return undefined;
        }
        let message;
        if (notification instanceof Error) {
            message = toErrorMessage(notification, false);
        }
        else if (typeof notification === 'string') {
            message = notification;
        }
        if (!message) {
            return undefined;
        }
        return { message, options };
    }
}
var css$1 = ".monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-toolbar-container .action-item,.monaco-workbench>.notifications-center>.notifications-center-header>.notifications-center-header-toolbar .action-item{margin-right:4px}.monaco-workbench .notifications-list-container .notification-list-item .notification-list-item-toolbar-container .action-item:first-child,.monaco-workbench>.notifications-center>.notifications-center-header>.notifications-center-header-toolbar .action-item:first-child{margin-left:4px}";
n(css$1,{});
function notificationToMetrics(message, source, silent) {
    return {
        id: ( (hash(( (message.toString()))).toString())),
        silent,
        source: source || 'core'
    };
}
let NotificationsTelemetry = class NotificationsTelemetry extends Disposable {
    constructor(telemetryService, notificationService) {
        super();
        this.telemetryService = telemetryService;
        this.notificationService = notificationService;
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.notificationService.onDidAddNotification(notification => {
            const source = notification.source && typeof notification.source !== 'string' ? notification.source.id : notification.source;
            this.telemetryService.publicLog2('notification:show', notificationToMetrics(notification.message, source, !!notification.silent));
        }));
        this._register(this.notificationService.onDidRemoveNotification(notification => {
            const source = notification.source && typeof notification.source !== 'string' ? notification.source.id : notification.source;
            this.telemetryService.publicLog2('notification:close', notificationToMetrics(notification.message, source, !!notification.silent));
        }));
    }
};
NotificationsTelemetry = ( (__decorate([
    ( (__param(0, ITelemetryService))),
    ( (__param(1, INotificationService)))
], NotificationsTelemetry)));
const SHOW_NOTIFICATIONS_CENTER = 'notifications.showList';
const HIDE_NOTIFICATIONS_CENTER = 'notifications.hideList';
const TOGGLE_NOTIFICATIONS_CENTER = 'notifications.toggleList';
const HIDE_NOTIFICATION_TOAST = 'notifications.hideToasts';
const FOCUS_NOTIFICATION_TOAST = 'notifications.focusToasts';
const FOCUS_NEXT_NOTIFICATION_TOAST = 'notifications.focusNextToast';
const FOCUS_PREVIOUS_NOTIFICATION_TOAST = 'notifications.focusPreviousToast';
const FOCUS_FIRST_NOTIFICATION_TOAST = 'notifications.focusFirstToast';
const FOCUS_LAST_NOTIFICATION_TOAST = 'notifications.focusLastToast';
const COLLAPSE_NOTIFICATION = 'notification.collapse';
const EXPAND_NOTIFICATION = 'notification.expand';
const TOGGLE_NOTIFICATION = 'notification.toggle';
const CLEAR_NOTIFICATION = 'notification.clear';
const CLEAR_ALL_NOTIFICATIONS = 'notifications.clearAll';
const TOGGLE_DO_NOT_DISTURB_MODE = 'notifications.toggleDoNotDisturbMode';
function registerNotificationCommands(center, toasts, model) {
    function getNotificationFromContext(listService, context) {
        if (isNotificationViewItem(context)) {
            return context;
        }
        const list = listService.lastFocusedList;
        if (list instanceof WorkbenchList) {
            const focusedElement = list.getFocusedElements()[0];
            if (isNotificationViewItem(focusedElement)) {
                return focusedElement;
            }
        }
        return undefined;
    }
    CommandsRegistry.registerCommand(SHOW_NOTIFICATIONS_CENTER, () => {
        toasts.hide();
        center.show();
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: HIDE_NOTIFICATIONS_CENTER,
        weight: 200  + 50,
        when: NotificationsCenterVisibleContext,
        primary: 9 ,
        handler: accessor => {
            const telemetryService = accessor.get(ITelemetryService);
            for (const notification of model.notifications) {
                if (notification.visible) {
                    telemetryService.publicLog2('notification:hide', notificationToMetrics(notification.message.original, notification.sourceId, notification.silent));
                }
            }
            center.hide();
        }
    });
    CommandsRegistry.registerCommand(TOGGLE_NOTIFICATIONS_CENTER, accessor => {
        if (center.isVisible) {
            center.hide();
        }
        else {
            toasts.hide();
            center.show();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: CLEAR_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 20 ,
        mac: {
            primary: 2048  | 1
        },
        handler: (accessor, args) => {
            const notification = getNotificationFromContext(accessor.get(IListService), args);
            if (notification && !notification.hasProgress) {
                notification.close();
            }
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: EXPAND_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 17 ,
        handler: (accessor, args) => {
            const notification = getNotificationFromContext(accessor.get(IListService), args);
            notification?.expand();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: COLLAPSE_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 15 ,
        handler: (accessor, args) => {
            const notification = getNotificationFromContext(accessor.get(IListService), args);
            notification?.collapse();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: TOGGLE_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 10 ,
        secondary: [3 ],
        handler: accessor => {
            const notification = getNotificationFromContext(accessor.get(IListService));
            notification?.toggle();
        }
    });
    CommandsRegistry.registerCommand(HIDE_NOTIFICATION_TOAST, accessor => {
        const telemetryService = accessor.get(ITelemetryService);
        for (const notification of model.notifications) {
            if (notification.visible) {
                telemetryService.publicLog2('notification:hide', notificationToMetrics(notification.message.original, notification.sourceId, notification.silent));
            }
        }
        toasts.hide();
    });
    KeybindingsRegistry.registerKeybindingRule({
        id: HIDE_NOTIFICATION_TOAST,
        weight: 200  - 50,
        when: NotificationsToastsVisibleContext,
        primary: 9
    });
    KeybindingsRegistry.registerKeybindingRule({
        id: HIDE_NOTIFICATION_TOAST,
        weight: 200  + 100,
        when: ( (ContextKeyExpr.and(NotificationsToastsVisibleContext, NotificationFocusedContext))),
        primary: 9
    });
    CommandsRegistry.registerCommand(FOCUS_NOTIFICATION_TOAST, () => toasts.focus());
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_NEXT_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ( (ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext))),
        primary: 18 ,
        handler: () => {
            toasts.focusNext();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_PREVIOUS_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ( (ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext))),
        primary: 16 ,
        handler: () => {
            toasts.focusPrevious();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_FIRST_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ( (ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext))),
        primary: 11 ,
        secondary: [14 ],
        handler: () => {
            toasts.focusFirst();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_LAST_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ( (ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext))),
        primary: 12 ,
        secondary: [13 ],
        handler: () => {
            toasts.focusLast();
        }
    });
    CommandsRegistry.registerCommand(CLEAR_ALL_NOTIFICATIONS, () => center.clearAll());
    CommandsRegistry.registerCommand(TOGGLE_DO_NOT_DISTURB_MODE, accessor => {
        const notificationService = accessor.get(INotificationService);
        notificationService.doNotDisturbMode = !notificationService.doNotDisturbMode;
    });
    const category = { value: ( (localize('notifications', "Notifications"))), original: 'Notifications' };
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: SHOW_NOTIFICATIONS_CENTER, title: { value: ( (localize('showNotifications', "Show Notifications"))), original: 'Show Notifications' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: HIDE_NOTIFICATIONS_CENTER, title: { value: ( (localize('hideNotifications', "Hide Notifications"))), original: 'Hide Notifications' }, category }, when: NotificationsCenterVisibleContext });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: CLEAR_ALL_NOTIFICATIONS, title: { value: ( (localize('clearAllNotifications', "Clear All Notifications"))), original: 'Clear All Notifications' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: TOGGLE_DO_NOT_DISTURB_MODE, title: { value: ( (localize('toggleDoNotDisturbMode', "Toggle Do Not Disturb Mode"))), original: 'Toggle Do Not Disturb Mode' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: FOCUS_NOTIFICATION_TOAST, title: { value: ( (localize('focusNotificationToasts', "Focus Notification Toast"))), original: 'Focus Notification Toast' }, category }, when: NotificationsToastsVisibleContext });
}
const clearIcon = ( (registerIcon(
    'notifications-clear',
    Codicon.close,
     (localize('clearIcon', 'Icon for the clear action in notifications.'))
)));
const clearAllIcon = ( (registerIcon(
    'notifications-clear-all',
    Codicon.clearAll,
     (localize('clearAllIcon', 'Icon for the clear all action in notifications.'))
)));
const hideIcon = ( (registerIcon(
    'notifications-hide',
    Codicon.chevronDown,
     (localize('hideIcon', 'Icon for the hide action in notifications.'))
)));
const expandIcon = ( (registerIcon(
    'notifications-expand',
    Codicon.chevronUp,
     (localize('expandIcon', 'Icon for the expand action in notifications.'))
)));
const collapseIcon = ( (registerIcon(
    'notifications-collapse',
    Codicon.chevronDown,
     (localize('collapseIcon', 'Icon for the collapse action in notifications.'))
)));
const configureIcon = ( (registerIcon(
    'notifications-configure',
    Codicon.gear,
     (localize('configureIcon', 'Icon for the configure action in notifications.'))
)));
const doNotDisturbIcon = ( (registerIcon(
    'notifications-do-not-disturb',
    Codicon.bellSlash,
     (localize('doNotDisturbIcon', 'Icon for the mute all action in notifications.'))
)));
let ClearNotificationAction = class ClearNotificationAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(clearIcon));
        this.commandService = commandService;
    }
    async run(notification) {
        this.commandService.executeCommand(CLEAR_NOTIFICATION, notification);
    }
};
ClearNotificationAction.ID = CLEAR_NOTIFICATION;
ClearNotificationAction.LABEL = ( (localize('clearNotification', "Clear Notification")));
ClearNotificationAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], ClearNotificationAction)));
let ClearAllNotificationsAction = class ClearAllNotificationsAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(clearAllIcon));
        this.commandService = commandService;
    }
    async run() {
        this.commandService.executeCommand(CLEAR_ALL_NOTIFICATIONS);
    }
};
ClearAllNotificationsAction.ID = CLEAR_ALL_NOTIFICATIONS;
ClearAllNotificationsAction.LABEL = ( (localize('clearNotifications', "Clear All Notifications")));
ClearAllNotificationsAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], ClearAllNotificationsAction)));
let ToggleDoNotDisturbAction = class ToggleDoNotDisturbAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(doNotDisturbIcon));
        this.commandService = commandService;
    }
    async run() {
        this.commandService.executeCommand(TOGGLE_DO_NOT_DISTURB_MODE);
    }
};
ToggleDoNotDisturbAction.ID = TOGGLE_DO_NOT_DISTURB_MODE;
ToggleDoNotDisturbAction.LABEL = ( (localize('toggleDoNotDisturbMode', "Toggle Do Not Disturb Mode")));
ToggleDoNotDisturbAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], ToggleDoNotDisturbAction)));
let HideNotificationsCenterAction = class HideNotificationsCenterAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(hideIcon));
        this.commandService = commandService;
    }
    async run() {
        this.commandService.executeCommand(HIDE_NOTIFICATIONS_CENTER);
    }
};
HideNotificationsCenterAction.ID = HIDE_NOTIFICATIONS_CENTER;
HideNotificationsCenterAction.LABEL = ( (localize('hideNotificationsCenter', "Hide Notifications")));
HideNotificationsCenterAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], HideNotificationsCenterAction)));
let ExpandNotificationAction = class ExpandNotificationAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(expandIcon));
        this.commandService = commandService;
    }
    async run(notification) {
        this.commandService.executeCommand(EXPAND_NOTIFICATION, notification);
    }
};
ExpandNotificationAction.ID = EXPAND_NOTIFICATION;
ExpandNotificationAction.LABEL = ( (localize('expandNotification', "Expand Notification")));
ExpandNotificationAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], ExpandNotificationAction)));
let CollapseNotificationAction = class CollapseNotificationAction extends Action {
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(collapseIcon));
        this.commandService = commandService;
    }
    async run(notification) {
        this.commandService.executeCommand(COLLAPSE_NOTIFICATION, notification);
    }
};
CollapseNotificationAction.ID = COLLAPSE_NOTIFICATION;
CollapseNotificationAction.LABEL = ( (localize('collapseNotification', "Collapse Notification")));
CollapseNotificationAction = ( (__decorate([
    ( (__param(2, ICommandService)))
], CollapseNotificationAction)));
class ConfigureNotificationAction extends Action {
    constructor(id, label, configurationActions) {
        super(id, label, ThemeIcon.asClassName(configureIcon));
        this.configurationActions = configurationActions;
    }
}
ConfigureNotificationAction.ID = 'workbench.action.configureNotification';
ConfigureNotificationAction.LABEL = ( (localize('configureNotification', "Configure Notification")));
let CopyNotificationMessageAction = class CopyNotificationMessageAction extends Action {
    constructor(id, label, clipboardService) {
        super(id, label);
        this.clipboardService = clipboardService;
    }
    run(notification) {
        return this.clipboardService.writeText(notification.message.raw);
    }
};
CopyNotificationMessageAction.ID = 'workbench.action.copyNotificationMessage';
CopyNotificationMessageAction.LABEL = ( (localize('copyNotification', "Copy Text")));
CopyNotificationMessageAction = ( (__decorate([
    ( (__param(2, IClipboardService)))
], CopyNotificationMessageAction)));
let NotificationActionRunner = class NotificationActionRunner extends ActionRunner {
    constructor(telemetryService, notificationService) {
        super();
        this.telemetryService = telemetryService;
        this.notificationService = notificationService;
    }
    async runAction(action, context) {
        this.telemetryService.publicLog2('workbenchActionExecuted', { id: action.id, from: 'message' });
        if (isNotificationViewItem(context)) {
            this.telemetryService.publicLog2('notification:actionExecuted', {
                id: ( (hash(( (context.message.original.toString()))).toString())),
                actionLabel: action.label,
                source: context.sourceId || 'core',
                silent: context.silent
            });
        }
        try {
            await super.runAction(action, context);
        }
        catch (error) {
            this.notificationService.error(error);
        }
    }
};
NotificationActionRunner = ( (__decorate([
    ( (__param(0, ITelemetryService))),
    ( (__param(1, INotificationService)))
], NotificationActionRunner)));
class NotificationsListDelegate {
    constructor(container) {
        this.offsetHelper = this.createOffsetHelper(container);
    }
    createOffsetHelper(container) {
        const offsetHelper = document.createElement('div');
        offsetHelper.classList.add('notification-offset-helper');
        container.appendChild(offsetHelper);
        return offsetHelper;
    }
    getHeight(notification) {
        if (!notification.expanded) {
            return NotificationsListDelegate.ROW_HEIGHT;
        }
        let expandedHeight = NotificationsListDelegate.ROW_HEIGHT;
        const preferredMessageHeight = this.computePreferredHeight(notification);
        const messageOverflows = NotificationsListDelegate.LINE_HEIGHT < preferredMessageHeight;
        if (messageOverflows) {
            const overflow = preferredMessageHeight - NotificationsListDelegate.LINE_HEIGHT;
            expandedHeight += overflow;
        }
        if (notification.source || isNonEmptyArray(notification.actions && notification.actions.primary)) {
            expandedHeight += NotificationsListDelegate.ROW_HEIGHT;
        }
        if (expandedHeight === NotificationsListDelegate.ROW_HEIGHT) {
            notification.collapse(true );
        }
        return expandedHeight;
    }
    computePreferredHeight(notification) {
        let actions = 1;
        if (notification.canCollapse) {
            actions++;
        }
        if (isNonEmptyArray(notification.actions && notification.actions.secondary)) {
            actions++;
        }
        this.offsetHelper.style.width = `${450  - ((10  + 26  + (actions * (24 + 8))  - 4) )}px`;
        const renderedMessage = NotificationMessageRenderer.render(notification.message);
        this.offsetHelper.appendChild(renderedMessage);
        const preferredHeight = Math.max(this.offsetHelper.offsetHeight, this.offsetHelper.scrollHeight);
        clearNode(this.offsetHelper);
        return preferredHeight;
    }
    getTemplateId(element) {
        if (element instanceof NotificationViewItem) {
            return NotificationRenderer.TEMPLATE_ID;
        }
        throw new Error('unknown element type: ' + element);
    }
}
NotificationsListDelegate.ROW_HEIGHT = 42;
NotificationsListDelegate.LINE_HEIGHT = 22;
class NotificationMessageRenderer {
    static render(message, actionHandler) {
        const messageContainer = document.createElement('span');
        for (const node of message.linkedText.nodes) {
            if (typeof node === 'string') {
                messageContainer.appendChild(document.createTextNode(node));
            }
            else {
                let title = node.title;
                if (!title && node.href.startsWith('command:')) {
                    title = ( (localize(
                        'executeCommand',
                        "Click to execute command '{0}'",
                        node.href.substr('command:'.length)
                    )));
                }
                else if (!title) {
                    title = node.href;
                }
                const anchor = $('a', { href: node.href, title, tabIndex: 0 }, node.label);
                if (actionHandler) {
                    const handleOpen = (e) => {
                        if (isEventLike(e)) {
                            EventHelper.stop(e, true);
                        }
                        actionHandler.callback(node.href);
                    };
                    const onClick = actionHandler.toDispose.add(( (new DomEmitter(anchor, EventType.CLICK)))).event;
                    const onKeydown = actionHandler.toDispose.add(( (new DomEmitter(anchor, EventType.KEY_DOWN)))).event;
                    const onSpaceOrEnter = actionHandler.toDispose.add(Event.chain(onKeydown)).filter(e => {
                        const event = ( (new StandardKeyboardEvent(e)));
                        return event.equals(10 ) || event.equals(3 );
                    }).event;
                    actionHandler.toDispose.add(Gesture.addTarget(anchor));
                    const onTap = actionHandler.toDispose.add(( (new DomEmitter(anchor, EventType$1.Tap)))).event;
                    Event.any(onClick, onTap, onSpaceOrEnter)(handleOpen, null, actionHandler.toDispose);
                }
                messageContainer.appendChild(anchor);
            }
        }
        return messageContainer;
    }
}
let NotificationRenderer = class NotificationRenderer {
    constructor(actionRunner, contextMenuService, instantiationService) {
        this.actionRunner = actionRunner;
        this.contextMenuService = contextMenuService;
        this.instantiationService = instantiationService;
    }
    get templateId() {
        return NotificationRenderer.TEMPLATE_ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = ( (new DisposableStore()));
        data.container = document.createElement('div');
        data.container.classList.add('notification-list-item');
        data.mainRow = document.createElement('div');
        data.mainRow.classList.add('notification-list-item-main-row');
        data.icon = document.createElement('div');
        data.icon.classList.add('notification-list-item-icon', 'codicon');
        data.message = document.createElement('div');
        data.message.classList.add('notification-list-item-message');
        const toolbarContainer = document.createElement('div');
        toolbarContainer.classList.add('notification-list-item-toolbar-container');
        data.toolbar = ( (new ActionBar(toolbarContainer, {
            ariaLabel: ( (localize('notificationActions', "Notification Actions"))),
            actionViewItemProvider: action => {
                if (action && action instanceof ConfigureNotificationAction) {
                    const item = ( (new DropdownMenuActionViewItem(
                        action,
                        action.configurationActions,
                        this.contextMenuService,
                        { actionRunner: this.actionRunner, classNames: action.class }
                    )));
                    data.toDispose.add(item);
                    return item;
                }
                return undefined;
            },
            actionRunner: this.actionRunner
        })));
        data.toDispose.add(data.toolbar);
        data.detailsRow = document.createElement('div');
        data.detailsRow.classList.add('notification-list-item-details-row');
        data.source = document.createElement('div');
        data.source.classList.add('notification-list-item-source');
        data.buttonsContainer = document.createElement('div');
        data.buttonsContainer.classList.add('notification-list-item-buttons-container');
        container.appendChild(data.container);
        data.container.appendChild(data.detailsRow);
        data.detailsRow.appendChild(data.source);
        data.detailsRow.appendChild(data.buttonsContainer);
        data.container.appendChild(data.mainRow);
        data.mainRow.appendChild(data.icon);
        data.mainRow.appendChild(data.message);
        data.mainRow.appendChild(toolbarContainer);
        data.progress = ( (new ProgressBar(container, defaultProgressBarStyles)));
        data.toDispose.add(data.progress);
        data.renderer = this.instantiationService.createInstance(NotificationTemplateRenderer, data, this.actionRunner);
        data.toDispose.add(data.renderer);
        return data;
    }
    renderElement(notification, index, data) {
        data.renderer.setInput(notification);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
NotificationRenderer.TEMPLATE_ID = 'notification';
NotificationRenderer = ( (__decorate([
    ( (__param(1, IContextMenuService))),
    ( (__param(2, IInstantiationService)))
], NotificationRenderer)));
let NotificationTemplateRenderer = class NotificationTemplateRenderer extends Disposable {
    constructor(template, actionRunner, openerService, instantiationService, keybindingService, contextMenuService) {
        super();
        this.template = template;
        this.actionRunner = actionRunner;
        this.openerService = openerService;
        this.instantiationService = instantiationService;
        this.keybindingService = keybindingService;
        this.contextMenuService = contextMenuService;
        this.inputDisposables = this._register(( (new DisposableStore())));
        if (!NotificationTemplateRenderer.closeNotificationAction) {
            NotificationTemplateRenderer.closeNotificationAction = instantiationService.createInstance(ClearNotificationAction, ClearNotificationAction.ID, ClearNotificationAction.LABEL);
            NotificationTemplateRenderer.expandNotificationAction = instantiationService.createInstance(ExpandNotificationAction, ExpandNotificationAction.ID, ExpandNotificationAction.LABEL);
            NotificationTemplateRenderer.collapseNotificationAction = instantiationService.createInstance(CollapseNotificationAction, CollapseNotificationAction.ID, CollapseNotificationAction.LABEL);
        }
    }
    setInput(notification) {
        this.inputDisposables.clear();
        this.render(notification);
    }
    render(notification) {
        this.template.container.classList.toggle('expanded', notification.expanded);
        this.inputDisposables.add(addDisposableListener(this.template.container, EventType.MOUSE_UP, e => {
            if (e.button === 1 ) {
                EventHelper.stop(e, true);
            }
        }));
        this.inputDisposables.add(addDisposableListener(this.template.container, EventType.AUXCLICK, e => {
            if (!notification.hasProgress && e.button === 1 ) {
                EventHelper.stop(e, true);
                notification.close();
            }
        }));
        this.renderSeverity(notification);
        const messageOverflows = this.renderMessage(notification);
        this.renderSecondaryActions(notification, messageOverflows);
        this.renderSource(notification);
        this.renderButtons(notification);
        this.renderProgress(notification);
        this.inputDisposables.add(notification.onDidChangeContent(event => {
            switch (event.kind) {
                case 0 :
                    this.renderSeverity(notification);
                    break;
                case 3 :
                    this.renderProgress(notification);
                    break;
                case 1 :
                    this.renderMessage(notification);
                    break;
            }
        }));
    }
    renderSeverity(notification) {
        NotificationTemplateRenderer.SEVERITIES.forEach(severity => {
            if (notification.severity !== severity) {
                this.template.icon.classList.remove(...ThemeIcon.asClassNameArray(this.toSeverityIcon(severity)));
            }
        });
        this.template.icon.classList.add(...ThemeIcon.asClassNameArray(this.toSeverityIcon(notification.severity)));
    }
    renderMessage(notification) {
        clearNode(this.template.message);
        this.template.message.appendChild(NotificationMessageRenderer.render(notification.message, {
            callback: link => this.openerService.open(( (URI.parse(link))), { allowCommands: true }),
            toDispose: this.inputDisposables
        }));
        const messageOverflows = notification.canCollapse && !notification.expanded && this.template.message.scrollWidth > this.template.message.clientWidth;
        if (messageOverflows) {
            this.template.message.title = this.template.message.textContent + '';
        }
        else {
            this.template.message.removeAttribute('title');
        }
        return messageOverflows;
    }
    renderSecondaryActions(notification, messageOverflows) {
        const actions = [];
        const secondaryActions = notification.actions ? notification.actions.secondary : undefined;
        if (isNonEmptyArray(secondaryActions)) {
            const configureNotificationAction = this.instantiationService.createInstance(ConfigureNotificationAction, ConfigureNotificationAction.ID, ConfigureNotificationAction.LABEL, secondaryActions);
            actions.push(configureNotificationAction);
            this.inputDisposables.add(configureNotificationAction);
        }
        let showExpandCollapseAction = false;
        if (notification.canCollapse) {
            if (notification.expanded) {
                showExpandCollapseAction = true;
            }
            else if (notification.source) {
                showExpandCollapseAction = true;
            }
            else if (messageOverflows) {
                showExpandCollapseAction = true;
            }
        }
        if (showExpandCollapseAction) {
            actions.push(notification.expanded ? NotificationTemplateRenderer.collapseNotificationAction : NotificationTemplateRenderer.expandNotificationAction);
        }
        if (!notification.hasProgress) {
            actions.push(NotificationTemplateRenderer.closeNotificationAction);
        }
        this.template.toolbar.clear();
        this.template.toolbar.context = notification;
        actions.forEach(action => this.template.toolbar.push(action, { icon: true, label: false, keybinding: this.getKeybindingLabel(action) }));
    }
    renderSource(notification) {
        if (notification.expanded && notification.source) {
            this.template.source.textContent = ( (localize('notificationSource', "Source: {0}", notification.source)));
            this.template.source.title = notification.source;
        }
        else {
            this.template.source.textContent = '';
            this.template.source.removeAttribute('title');
        }
    }
    renderButtons(notification) {
        clearNode(this.template.buttonsContainer);
        const primaryActions = notification.actions ? notification.actions.primary : undefined;
        if (notification.expanded && isNonEmptyArray(primaryActions)) {
            const that = this;
            const actionRunner = new (class extends ActionRunner {
                async runAction(action) {
                    that.actionRunner.run(action, notification);
                    if (!(action instanceof ChoiceAction) || !action.keepOpen) {
                        notification.close();
                    }
                }
            })();
            const buttonToolbar = this.inputDisposables.add(( (new ButtonBar(this.template.buttonsContainer))));
            for (let i = 0; i < primaryActions.length; i++) {
                const action = primaryActions[i];
                const options = {
                    title: true,
                    secondary: i > 0,
                    ...defaultButtonStyles
                };
                const dropdownActions = action instanceof ChoiceAction ? action.menu : undefined;
                const button = this.inputDisposables.add(dropdownActions ?
                    buttonToolbar.addButtonWithDropdown({
                        ...options,
                        contextMenuProvider: this.contextMenuService,
                        actions: dropdownActions,
                        actionRunner
                    }) :
                    buttonToolbar.addButton(options));
                button.label = action.label;
                this.inputDisposables.add(button.onDidClick(e => {
                    if (e) {
                        EventHelper.stop(e, true);
                    }
                    actionRunner.run(action);
                }));
            }
        }
    }
    renderProgress(notification) {
        if (!notification.hasProgress) {
            this.template.progress.stop().hide();
            return;
        }
        const state = notification.progress.state;
        if (state.infinite) {
            this.template.progress.infinite().show();
        }
        else if (typeof state.total === 'number' || typeof state.worked === 'number') {
            if (typeof state.total === 'number' && !this.template.progress.hasTotal()) {
                this.template.progress.total(state.total);
            }
            if (typeof state.worked === 'number') {
                this.template.progress.setWorked(state.worked).show();
            }
        }
        else {
            this.template.progress.done().hide();
        }
    }
    toSeverityIcon(severity) {
        switch (severity) {
            case Severity.Warning:
                return Codicon.warning;
            case Severity.Error:
                return Codicon.error;
        }
        return Codicon.info;
    }
    getKeybindingLabel(action) {
        const keybinding = this.keybindingService.lookupKeybinding(action.id);
        return keybinding ? keybinding.getLabel() : null;
    }
};
NotificationTemplateRenderer.SEVERITIES = [Severity.Info, Severity.Warning, Severity.Error];
NotificationTemplateRenderer = ( (__decorate([
    ( (__param(2, IOpenerService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IKeybindingService))),
    ( (__param(5, IContextMenuService)))
], NotificationTemplateRenderer)));
let NotificationsList = class NotificationsList extends Disposable {
    constructor(container, options, instantiationService, contextMenuService) {
        super();
        this.container = container;
        this.options = options;
        this.instantiationService = instantiationService;
        this.contextMenuService = contextMenuService;
        this.viewModel = [];
    }
    show(focus) {
        if (this.isVisible) {
            if (focus) {
                const list = assertIsDefined(this.list);
                list.domFocus();
            }
            return;
        }
        if (!this.list) {
            this.createNotificationsList();
        }
        this.isVisible = true;
        if (focus) {
            const list = assertIsDefined(this.list);
            list.domFocus();
        }
    }
    createNotificationsList() {
        this.listContainer = document.createElement('div');
        this.listContainer.classList.add('notifications-list-container');
        const actionRunner = this._register(this.instantiationService.createInstance(NotificationActionRunner));
        const renderer = this.instantiationService.createInstance(NotificationRenderer, actionRunner);
        const listDelegate = this.listDelegate = ( (new NotificationsListDelegate(this.listContainer)));
        const options = this.options;
        const list = this.list = this._register(this.instantiationService.createInstance(WorkbenchList, 'NotificationsList', this.listContainer, listDelegate, [renderer], {
            ...options,
            setRowLineHeight: false,
            horizontalScrolling: false,
            overrideStyles: {
                listBackground: NOTIFICATIONS_BACKGROUND
            },
            accessibilityProvider: {
                getAriaLabel(element) {
                    if (!element.source) {
                        return (
                             (localize('notificationAriaLabel', "{0}, notification", element.message.raw))
                        );
                    }
                    return (
                         (localize(
                            'notificationWithSourceAriaLabel',
                            "{0}, source: {1}, notification",
                            element.message.raw,
                            element.source
                        ))
                    );
                },
                getWidgetAriaLabel() {
                    return options.widgetAriaLabel ?? ( (localize('notificationsList', "Notifications List")));
                },
                getRole() {
                    return 'dialog';
                }
            }
        }));
        const copyAction = this._register(this.instantiationService.createInstance(CopyNotificationMessageAction, CopyNotificationMessageAction.ID, CopyNotificationMessageAction.LABEL));
        this._register((list.onContextMenu(e => {
            if (!e.element) {
                return;
            }
            this.contextMenuService.showContextMenu({
                getAnchor: () => e.anchor,
                getActions: () => [copyAction],
                getActionsContext: () => e.element,
                actionRunner
            });
        })));
        this._register((list.onMouseDblClick(event => event.element.toggle())));
        const listFocusTracker = this._register(trackFocus(list.getHTMLElement()));
        this._register(listFocusTracker.onDidBlur(() => {
            if (document.hasFocus()) {
                list.setFocus([]);
            }
        }));
        NotificationFocusedContext.bindTo(list.contextKeyService);
        this._register(list.onDidChangeSelection(e => {
            if (e.indexes.length > 0) {
                list.setSelection([]);
            }
        }));
        this.container.appendChild(this.listContainer);
    }
    updateNotificationsList(start, deleteCount, items = []) {
        const [list, listContainer] = assertAllDefined(this.list, this.listContainer);
        const listHasDOMFocus = isAncestor(document.activeElement, listContainer);
        const focusedIndex = list.getFocus()[0];
        const focusedItem = this.viewModel[focusedIndex];
        let focusRelativeTop = null;
        if (typeof focusedIndex === 'number') {
            focusRelativeTop = list.getRelativeTop(focusedIndex);
        }
        this.viewModel.splice(start, deleteCount, ...items);
        list.splice(start, deleteCount, items);
        list.layout();
        if (this.viewModel.length === 0) {
            this.hide();
        }
        else if (typeof focusedIndex === 'number') {
            let indexToFocus = 0;
            if (focusedItem) {
                let indexToFocusCandidate = this.viewModel.indexOf(focusedItem);
                if (indexToFocusCandidate === -1) {
                    indexToFocusCandidate = focusedIndex - 1;
                }
                if (indexToFocusCandidate < this.viewModel.length && indexToFocusCandidate >= 0) {
                    indexToFocus = indexToFocusCandidate;
                }
            }
            if (typeof focusRelativeTop === 'number') {
                list.reveal(indexToFocus, focusRelativeTop);
            }
            list.setFocus([indexToFocus]);
        }
        if (this.isVisible && listHasDOMFocus) {
            list.domFocus();
        }
    }
    updateNotificationHeight(item) {
        const index = this.viewModel.indexOf(item);
        if (index === -1) {
            return;
        }
        const [list, listDelegate] = assertAllDefined(this.list, this.listDelegate);
        list.updateElementHeight(index, listDelegate.getHeight(item));
        list.layout();
    }
    hide() {
        if (!this.isVisible || !this.list) {
            return;
        }
        this.isVisible = false;
        this.list.splice(0, this.viewModel.length);
        this.viewModel = [];
    }
    focusFirst() {
        if (!this.isVisible || !this.list) {
            return;
        }
        this.list.focusFirst();
        this.list.domFocus();
    }
    hasFocus() {
        if (!this.isVisible || !this.listContainer) {
            return false;
        }
        return isAncestor(document.activeElement, this.listContainer);
    }
    layout(width, maxHeight) {
        if (this.listContainer && this.list) {
            this.listContainer.style.width = `${width}px`;
            if (typeof maxHeight === 'number') {
                this.list.getHTMLElement().style.maxHeight = `${maxHeight}px`;
            }
            this.list.layout();
        }
    }
    dispose() {
        this.hide();
        super.dispose();
    }
};
NotificationsList = ( (__decorate([
    ( (__param(2, IInstantiationService))),
    ( (__param(3, IContextMenuService)))
], NotificationsList)));
var ToastVisibility;
( ((function(ToastVisibility) {
    ToastVisibility[ToastVisibility["HIDDEN_OR_VISIBLE"] = 0] = "HIDDEN_OR_VISIBLE";
    ToastVisibility[ToastVisibility["HIDDEN"] = 1] = "HIDDEN";
    ToastVisibility[ToastVisibility["VISIBLE"] = 2] = "VISIBLE";
})(ToastVisibility || (ToastVisibility = {}))));
let NotificationsToasts = class NotificationsToasts extends Themable {
    get isVisible() { return !!this._isVisible; }
    constructor(container, model, instantiationService, layoutService, themeService, editorGroupService, contextKeyService, lifecycleService, hostService) {
        super(themeService);
        this.container = container;
        this.model = model;
        this.instantiationService = instantiationService;
        this.layoutService = layoutService;
        this.editorGroupService = editorGroupService;
        this.contextKeyService = contextKeyService;
        this.lifecycleService = lifecycleService;
        this.hostService = hostService;
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this._isVisible = false;
        this.mapNotificationToToast = ( (new Map()));
        this.mapNotificationToDisposable = ( (new Map()));
        this.notificationsToastsVisibleContextKey = NotificationsToastsVisibleContext.bindTo(this.contextKeyService);
        this.addedToastsIntervalCounter = ( (new IntervalCounter(NotificationsToasts.SPAM_PROTECTION.interval)));
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.layoutService.onDidLayout(dimension => this.layout(Dimension.lift(dimension))));
        this.lifecycleService.when(3 ).then(() => {
            this.model.notifications.forEach(notification => this.addToast(notification));
            this._register(this.model.onDidChangeNotification(e => this.onDidChangeNotification(e)));
        });
        this._register(this.model.onDidChangeFilter(filter => {
            if (filter === NotificationsFilter.SILENT || filter === NotificationsFilter.ERROR) {
                this.hide();
            }
        }));
    }
    onDidChangeNotification(e) {
        switch (e.kind) {
            case 0 :
                return this.addToast(e.item);
            case 3 :
                return this.removeToast(e.item);
        }
    }
    addToast(item) {
        if (this.isNotificationsCenterVisible) {
            return;
        }
        if (item.silent) {
            return;
        }
        if (this.addedToastsIntervalCounter.increment() > NotificationsToasts.SPAM_PROTECTION.limit) {
            return;
        }
        const itemDisposables = ( (new DisposableStore()));
        this.mapNotificationToDisposable.set(item, itemDisposables);
        itemDisposables.add(scheduleAtNextAnimationFrame(() => this.doAddToast(item, itemDisposables)));
    }
    doAddToast(item, itemDisposables) {
        let notificationsToastsContainer = this.notificationsToastsContainer;
        if (!notificationsToastsContainer) {
            notificationsToastsContainer = this.notificationsToastsContainer = document.createElement('div');
            notificationsToastsContainer.classList.add('notifications-toasts');
            this.container.appendChild(notificationsToastsContainer);
        }
        notificationsToastsContainer.classList.add('visible');
        const notificationToastContainer = document.createElement('div');
        notificationToastContainer.classList.add('notification-toast-container');
        const firstToast = notificationsToastsContainer.firstChild;
        if (firstToast) {
            notificationsToastsContainer.insertBefore(notificationToastContainer, firstToast);
        }
        else {
            notificationsToastsContainer.appendChild(notificationToastContainer);
        }
        const notificationToast = document.createElement('div');
        notificationToast.classList.add('notification-toast');
        notificationToastContainer.appendChild(notificationToast);
        const notificationList = this.instantiationService.createInstance(NotificationsList, notificationToast, {
            verticalScrollMode: 2 ,
            widgetAriaLabel: (() => {
                if (!item.source) {
                    return (
                         (localize('notificationAriaLabel', "{0}, notification", item.message.raw))
                    );
                }
                return (
                     (localize(
                        'notificationWithSourceAriaLabel',
                        "{0}, source: {1}, notification",
                        item.message.raw,
                        item.source
                    ))
                );
            })()
        });
        itemDisposables.add(notificationList);
        const toast = { item, list: notificationList, container: notificationToastContainer, toast: notificationToast };
        this.mapNotificationToToast.set(item, toast);
        itemDisposables.add(toDisposable(() => this.updateToastVisibility(toast, false)));
        notificationList.show();
        const maxDimensions = this.computeMaxDimensions();
        this.layoutLists(maxDimensions.width);
        notificationList.updateNotificationsList(0, 0, [item]);
        this.layoutContainer(maxDimensions.height);
        itemDisposables.add(item.onDidChangeExpansion(() => {
            notificationList.updateNotificationsList(0, 1, [item]);
        }));
        itemDisposables.add(item.onDidChangeContent(e => {
            switch (e.kind) {
                case 2 :
                    notificationList.updateNotificationsList(0, 1, [item]);
                    break;
                case 1 :
                    if (item.expanded) {
                        notificationList.updateNotificationHeight(item);
                    }
                    break;
            }
        }));
        Event.once(item.onDidClose)(() => {
            this.removeToast(item);
        });
        this.purgeNotification(item, notificationToastContainer, notificationList, itemDisposables);
        this.updateStyles();
        this.notificationsToastsVisibleContextKey.set(true);
        notificationToast.classList.add('notification-fade-in');
        itemDisposables.add(addDisposableListener(notificationToast, 'transitionend', () => {
            notificationToast.classList.remove('notification-fade-in');
            notificationToast.classList.add('notification-fade-in-done');
        }));
        item.updateVisibility(true);
        if (!this._isVisible) {
            this._isVisible = true;
            this._onDidChangeVisibility.fire();
        }
    }
    purgeNotification(item, notificationToastContainer, notificationList, disposables) {
        let isMouseOverToast = false;
        disposables.add(addDisposableListener(notificationToastContainer, EventType.MOUSE_OVER, () => isMouseOverToast = true));
        disposables.add(addDisposableListener(notificationToastContainer, EventType.MOUSE_OUT, () => isMouseOverToast = false));
        let purgeTimeoutHandle;
        let listener;
        const hideAfterTimeout = () => {
            purgeTimeoutHandle = setTimeout(() => {
                if (!this.hostService.hasFocus) {
                    if (!listener) {
                        listener = this.hostService.onDidChangeFocus(focus => {
                            if (focus) {
                                hideAfterTimeout();
                            }
                        });
                        disposables.add(listener);
                    }
                }
                else if (item.sticky ||
                    notificationList.hasFocus() ||
                    isMouseOverToast
                ) {
                    hideAfterTimeout();
                }
                else {
                    this.removeToast(item);
                }
            }, NotificationsToasts.PURGE_TIMEOUT[item.severity]);
        };
        hideAfterTimeout();
        disposables.add(toDisposable(() => clearTimeout(purgeTimeoutHandle)));
    }
    removeToast(item) {
        let focusEditor = false;
        const notificationToast = this.mapNotificationToToast.get(item);
        if (notificationToast) {
            const toastHasDOMFocus = isAncestor(document.activeElement, notificationToast.container);
            if (toastHasDOMFocus) {
                focusEditor = !(this.focusNext() || this.focusPrevious());
            }
            this.mapNotificationToToast.delete(item);
        }
        const notificationDisposables = this.mapNotificationToDisposable.get(item);
        if (notificationDisposables) {
            dispose(notificationDisposables);
            this.mapNotificationToDisposable.delete(item);
        }
        if (this.mapNotificationToToast.size > 0) {
            this.layout(this.workbenchDimensions);
        }
        else {
            this.doHide();
            if (focusEditor) {
                this.editorGroupService.activeGroup.focus();
            }
        }
    }
    removeToasts() {
        this.mapNotificationToToast.clear();
        this.mapNotificationToDisposable.forEach(disposable => dispose(disposable));
        this.mapNotificationToDisposable.clear();
        this.doHide();
    }
    doHide() {
        this.notificationsToastsContainer?.classList.remove('visible');
        this.notificationsToastsVisibleContextKey.set(false);
        if (this._isVisible) {
            this._isVisible = false;
            this._onDidChangeVisibility.fire();
        }
    }
    hide() {
        const focusEditor = this.notificationsToastsContainer ? isAncestor(document.activeElement, this.notificationsToastsContainer) : false;
        this.removeToasts();
        if (focusEditor) {
            this.editorGroupService.activeGroup.focus();
        }
    }
    focus() {
        const toasts = this.getToasts(ToastVisibility.VISIBLE);
        if (toasts.length > 0) {
            toasts[0].list.focusFirst();
            return true;
        }
        return false;
    }
    focusNext() {
        const toasts = this.getToasts(ToastVisibility.VISIBLE);
        for (let i = 0; i < toasts.length; i++) {
            const toast = toasts[i];
            if (toast.list.hasFocus()) {
                const nextToast = toasts[i + 1];
                if (nextToast) {
                    nextToast.list.focusFirst();
                    return true;
                }
                break;
            }
        }
        return false;
    }
    focusPrevious() {
        const toasts = this.getToasts(ToastVisibility.VISIBLE);
        for (let i = 0; i < toasts.length; i++) {
            const toast = toasts[i];
            if (toast.list.hasFocus()) {
                const previousToast = toasts[i - 1];
                if (previousToast) {
                    previousToast.list.focusFirst();
                    return true;
                }
                break;
            }
        }
        return false;
    }
    focusFirst() {
        const toast = this.getToasts(ToastVisibility.VISIBLE)[0];
        if (toast) {
            toast.list.focusFirst();
            return true;
        }
        return false;
    }
    focusLast() {
        const toasts = this.getToasts(ToastVisibility.VISIBLE);
        if (toasts.length > 0) {
            toasts[toasts.length - 1].list.focusFirst();
            return true;
        }
        return false;
    }
    update(isCenterVisible) {
        if (this.isNotificationsCenterVisible !== isCenterVisible) {
            this.isNotificationsCenterVisible = isCenterVisible;
            if (this.isNotificationsCenterVisible) {
                this.removeToasts();
            }
        }
    }
    updateStyles() {
        this.mapNotificationToToast.forEach(({ toast }) => {
            const backgroundColor = this.getColor(NOTIFICATIONS_BACKGROUND);
            toast.style.background = backgroundColor ? backgroundColor : '';
            const widgetShadowColor = this.getColor(widgetShadow);
            toast.style.boxShadow = widgetShadowColor ? `0 0 8px 2px ${widgetShadowColor}` : '';
            const borderColor = this.getColor(NOTIFICATIONS_TOAST_BORDER);
            toast.style.border = borderColor ? `1px solid ${borderColor}` : '';
        });
    }
    getToasts(state) {
        const notificationToasts = [];
        this.mapNotificationToToast.forEach(toast => {
            switch (state) {
                case ToastVisibility.HIDDEN_OR_VISIBLE:
                    notificationToasts.push(toast);
                    break;
                case ToastVisibility.HIDDEN:
                    if (!this.isToastInDOM(toast)) {
                        notificationToasts.push(toast);
                    }
                    break;
                case ToastVisibility.VISIBLE:
                    if (this.isToastInDOM(toast)) {
                        notificationToasts.push(toast);
                    }
                    break;
            }
        });
        return notificationToasts.reverse();
    }
    layout(dimension) {
        this.workbenchDimensions = dimension;
        const maxDimensions = this.computeMaxDimensions();
        if (maxDimensions.height) {
            this.layoutContainer(maxDimensions.height);
        }
        this.layoutLists(maxDimensions.width);
    }
    computeMaxDimensions() {
        const maxWidth = NotificationsToasts.MAX_WIDTH;
        let availableWidth = maxWidth;
        let availableHeight;
        if (this.workbenchDimensions) {
            availableWidth = this.workbenchDimensions.width;
            availableWidth -= (2 * 8);
            availableHeight = this.workbenchDimensions.height;
            if (this.layoutService.isVisible("workbench.parts.statusbar" )) {
                availableHeight -= 22;
            }
            if (this.layoutService.isVisible("workbench.parts.titlebar" )) {
                availableHeight -= 22;
            }
            availableHeight -= (2 * 12);
        }
        availableHeight = typeof availableHeight === 'number'
            ? Math.round(availableHeight * 0.618)
            : 0;
        return (
             (new Dimension(Math.min(maxWidth, availableWidth), availableHeight))
        );
    }
    layoutLists(width) {
        this.mapNotificationToToast.forEach(({ list }) => list.layout(width));
    }
    layoutContainer(heightToGive) {
        let visibleToasts = 0;
        for (const toast of this.getToasts(ToastVisibility.HIDDEN_OR_VISIBLE)) {
            toast.container.style.opacity = '0';
            this.updateToastVisibility(toast, true);
            heightToGive -= toast.container.offsetHeight;
            let makeVisible = false;
            if (visibleToasts === NotificationsToasts.MAX_NOTIFICATIONS) {
                makeVisible = false;
            }
            else if (heightToGive >= 0) {
                makeVisible = true;
            }
            this.updateToastVisibility(toast, makeVisible);
            toast.container.style.opacity = '';
            if (makeVisible) {
                visibleToasts++;
            }
        }
    }
    updateToastVisibility(toast, visible) {
        if (this.isToastInDOM(toast) === visible) {
            return;
        }
        const notificationsToastsContainer = assertIsDefined(this.notificationsToastsContainer);
        if (visible) {
            notificationsToastsContainer.appendChild(toast.container);
        }
        else {
            notificationsToastsContainer.removeChild(toast.container);
        }
        toast.item.updateVisibility(visible);
    }
    isToastInDOM(toast) {
        return !!toast.container.parentElement;
    }
};
NotificationsToasts.MAX_WIDTH = 450;
NotificationsToasts.MAX_NOTIFICATIONS = 3;
NotificationsToasts.PURGE_TIMEOUT = {
    [Severity.Info]: 15000,
    [Severity.Warning]: 18000,
    [Severity.Error]: 20000
};
NotificationsToasts.SPAM_PROTECTION = {
    interval: 800,
    limit: NotificationsToasts.MAX_NOTIFICATIONS
};
NotificationsToasts = ( (__decorate([
    ( (__param(2, IInstantiationService))),
    ( (__param(3, IWorkbenchLayoutService))),
    ( (__param(4, IThemeService))),
    ( (__param(5, IEditorGroupsService))),
    ( (__param(6, IContextKeyService))),
    ( (__param(7, ILifecycleService))),
    ( (__param(8, IHostService)))
], NotificationsToasts)));
let NotificationService = class NotificationService extends Disposable {
    constructor(storageService) {
        super();
        this.storageService = storageService;
        this.model = this._register(( (new NotificationsModel())));
        this._onDidAddNotification = this._register(( (new Emitter())));
        this.onDidAddNotification = this._onDidAddNotification.event;
        this._onDidRemoveNotification = this._register(( (new Emitter())));
        this.onDidRemoveNotification = this._onDidRemoveNotification.event;
        this._onDidChangeDoNotDisturbMode = this._register(( (new Emitter())));
        this.onDidChangeDoNotDisturbMode = this._onDidChangeDoNotDisturbMode.event;
        this._doNotDisturbMode = this.storageService.getBoolean(NotificationService.DND_SETTINGS_KEY, -1 , false);
        this.updateDoNotDisturbFilters();
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.model.onDidChangeNotification(e => {
            switch (e.kind) {
                case 0 :
                case 3 : {
                    const notification = {
                        message: e.item.message.original,
                        severity: e.item.severity,
                        source: typeof e.item.sourceId === 'string' && typeof e.item.source === 'string' ? { id: e.item.sourceId, label: e.item.source } : e.item.source,
                        silent: e.item.silent
                    };
                    if (e.kind === 0 ) {
                        this._onDidAddNotification.fire(notification);
                    }
                    if (e.kind === 3 ) {
                        this._onDidRemoveNotification.fire(notification);
                    }
                    break;
                }
            }
        }));
    }
    get doNotDisturbMode() {
        return this._doNotDisturbMode;
    }
    set doNotDisturbMode(enabled) {
        if (this._doNotDisturbMode === enabled) {
            return;
        }
        this.storageService.store(NotificationService.DND_SETTINGS_KEY, enabled, -1 , 1 );
        this._doNotDisturbMode = enabled;
        this.updateDoNotDisturbFilters();
        this._onDidChangeDoNotDisturbMode.fire();
    }
    updateDoNotDisturbFilters() {
        let filter;
        if (this._doNotDisturbMode) {
            filter = NotificationsFilter.ERROR;
        }
        else {
            filter = NotificationsFilter.OFF;
        }
        this.model.setFilter(filter);
    }
    info(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.info(m));
            return;
        }
        this.model.addNotification({ severity: Severity.Info, message });
    }
    warn(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.warn(m));
            return;
        }
        this.model.addNotification({ severity: Severity.Warning, message });
    }
    error(message) {
        if (Array.isArray(message)) {
            message.forEach(m => this.error(m));
            return;
        }
        this.model.addNotification({ severity: Severity.Error, message });
    }
    notify(notification) {
        const toDispose = ( (new DisposableStore()));
        if (notification.neverShowAgain) {
            const scope = this.toStorageScope(notification.neverShowAgain);
            const id = notification.neverShowAgain.id;
            if (this.storageService.getBoolean(id, scope)) {
                return (
                     (new NoOpNotification())
                );
            }
            const neverShowAgainAction = toDispose.add(( (new Action(
                'workbench.notification.neverShowAgain',
                 (localize('neverShowAgain', "Don't Show Again")),
                undefined,
                true,
                async () => {
                    handle.close();
                    this.storageService.store(id, true, scope, 0 );
                }
            ))));
            const actions = {
                primary: notification.actions?.primary || [],
                secondary: notification.actions?.secondary || []
            };
            if (!notification.neverShowAgain.isSecondary) {
                actions.primary = [neverShowAgainAction, ...actions.primary];
            }
            else {
                actions.secondary = [...actions.secondary, neverShowAgainAction];
            }
            notification.actions = actions;
        }
        const handle = this.model.addNotification(notification);
        Event.once(handle.onDidClose)(() => toDispose.dispose());
        return handle;
    }
    toStorageScope(options) {
        switch (options.scope) {
            case NeverShowAgainScope.APPLICATION:
                return -1 ;
            case NeverShowAgainScope.PROFILE:
                return 0 ;
            case NeverShowAgainScope.WORKSPACE:
                return 1 ;
            default:
                return -1 ;
        }
    }
    prompt(severity, message, choices, options) {
        const toDispose = ( (new DisposableStore()));
        if (options?.neverShowAgain) {
            const scope = this.toStorageScope(options.neverShowAgain);
            const id = options.neverShowAgain.id;
            if (this.storageService.getBoolean(id, scope)) {
                return (
                     (new NoOpNotification())
                );
            }
            const neverShowAgainChoice = {
                label: ( (localize('neverShowAgain', "Don't Show Again"))),
                run: () => this.storageService.store(id, true, scope, 0 ),
                isSecondary: options.neverShowAgain.isSecondary
            };
            if (!options.neverShowAgain.isSecondary) {
                choices = [neverShowAgainChoice, ...choices];
            }
            else {
                choices = [...choices, neverShowAgainChoice];
            }
        }
        let choiceClicked = false;
        const primaryActions = [];
        const secondaryActions = [];
        choices.forEach((choice, index) => {
            const action = ( (new ChoiceAction(`workbench.dialog.choice.${index}`, choice)));
            if (!choice.isSecondary) {
                primaryActions.push(action);
            }
            else {
                secondaryActions.push(action);
            }
            toDispose.add(action.onDidRun(() => {
                choiceClicked = true;
                if (!choice.keepOpen) {
                    handle.close();
                }
            }));
            toDispose.add(action);
        });
        const actions = { primary: primaryActions, secondary: secondaryActions };
        const handle = this.notify({ severity, message, actions, sticky: options?.sticky, silent: options?.silent });
        Event.once(handle.onDidClose)(() => {
            toDispose.dispose();
            if (options && typeof options.onCancel === 'function' && !choiceClicked) {
                options.onCancel();
            }
        });
        return handle;
    }
    status(message, options) {
        return this.model.showStatusMessage(message, options);
    }
};
NotificationService.DND_SETTINGS_KEY = 'notifications.doNotDisturbMode';
NotificationService = ( (__decorate([
    ( (__param(0, IStorageService)))
], NotificationService)));
var css = ".monaco-workbench>.notifications-center{border-radius:4px;bottom:31px;display:none;overflow:hidden;position:absolute;right:8px;z-index:1000}.monaco-workbench.nostatusbar>.notifications-center{bottom:8px}.monaco-workbench>.notifications-center.visible{display:block}.monaco-workbench>.notifications-center>.notifications-center-header{align-items:center;display:flex;height:35px;padding-left:8px;padding-right:5px}.monaco-workbench>.notifications-center>.notifications-center-header>.notifications-center-header-title{font-size:11px;text-transform:uppercase}.monaco-workbench>.notifications-center>.notifications-center-header>.notifications-center-header-toolbar{flex:1}.monaco-workbench>.notifications-center>.notifications-center-header>.notifications-center-header-toolbar .actions-container{justify-content:flex-end}.monaco-workbench>.notifications-center .notifications-list-container .monaco-list-row[data-last-element=false]>.notification-list-item{border-bottom:1px solid var(--vscode-notifications-border)}.monaco-workbench>.notifications-center .notifications-list-container,.monaco-workbench>.notifications-center .notifications-list-container .monaco-scrollable-element,.monaco-workbench>.notifications-center .notifications-list-container .notification-list-item{border-radius:0}.monaco-workbench>.notifications-center .codicon.codicon-error{color:var(--vscode-notificationsErrorIcon-foreground)}.monaco-workbench>.notifications-center .codicon.codicon-warning{color:var(--vscode-notificationsWarningIcon-foreground)}.monaco-workbench>.notifications-center .codicon.codicon-info{color:var(--vscode-notificationsInfoIcon-foreground)}";
n(css,{});
let NotificationsCenter = class NotificationsCenter extends Themable {
    constructor(container, model, themeService, instantiationService, layoutService, contextKeyService, editorGroupService, keybindingService, notificationService) {
        super(themeService);
        this.container = container;
        this.model = model;
        this.instantiationService = instantiationService;
        this.layoutService = layoutService;
        this.contextKeyService = contextKeyService;
        this.editorGroupService = editorGroupService;
        this.keybindingService = keybindingService;
        this.notificationService = notificationService;
        this._onDidChangeVisibility = this._register(( (new Emitter())));
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this.notificationsCenterVisibleContextKey = NotificationsCenterVisibleContext.bindTo(this.contextKeyService);
        this.notificationsCenterVisibleContextKey = NotificationsCenterVisibleContext.bindTo(contextKeyService);
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.model.onDidChangeNotification(e => this.onDidChangeNotification(e)));
        this._register(this.layoutService.onDidLayout(dimension => this.layout(Dimension.lift(dimension))));
        this._register(this.notificationService.onDidChangeDoNotDisturbMode(() => this.onDidChangeDoNotDisturbMode()));
    }
    onDidChangeDoNotDisturbMode() {
        this.hide();
    }
    get isVisible() {
        return !!this._isVisible;
    }
    show() {
        if (this._isVisible) {
            const notificationsList = assertIsDefined(this.notificationsList);
            notificationsList.show(true );
            return;
        }
        if (!this.notificationsCenterContainer) {
            this.create();
        }
        this.updateTitle();
        const [notificationsList, notificationsCenterContainer] = assertAllDefined(this.notificationsList, this.notificationsCenterContainer);
        this._isVisible = true;
        notificationsCenterContainer.classList.add('visible');
        notificationsList.show();
        this.layout(this.workbenchDimensions);
        notificationsList.updateNotificationsList(0, 0, this.model.notifications);
        notificationsList.focusFirst();
        this.updateStyles();
        this.model.notifications.forEach(notification => notification.updateVisibility(true));
        this.notificationsCenterVisibleContextKey.set(true);
        this._onDidChangeVisibility.fire();
    }
    updateTitle() {
        const [notificationsCenterTitle, clearAllAction] = assertAllDefined(this.notificationsCenterTitle, this.clearAllAction);
        if (this.model.notifications.length === 0) {
            notificationsCenterTitle.textContent = ( (localize('notificationsEmpty', "No new notifications")));
            clearAllAction.enabled = false;
        }
        else {
            notificationsCenterTitle.textContent = ( (localize('notifications', "Notifications")));
            clearAllAction.enabled = this.model.notifications.some(notification => !notification.hasProgress);
        }
    }
    create() {
        this.notificationsCenterContainer = document.createElement('div');
        this.notificationsCenterContainer.classList.add('notifications-center');
        this.notificationsCenterHeader = document.createElement('div');
        this.notificationsCenterHeader.classList.add('notifications-center-header');
        this.notificationsCenterContainer.appendChild(this.notificationsCenterHeader);
        this.notificationsCenterTitle = document.createElement('span');
        this.notificationsCenterTitle.classList.add('notifications-center-header-title');
        this.notificationsCenterHeader.appendChild(this.notificationsCenterTitle);
        const toolbarContainer = document.createElement('div');
        toolbarContainer.classList.add('notifications-center-header-toolbar');
        this.notificationsCenterHeader.appendChild(toolbarContainer);
        const actionRunner = this._register(this.instantiationService.createInstance(NotificationActionRunner));
        const notificationsToolBar = this._register(( (new ActionBar(toolbarContainer, {
            ariaLabel: ( (localize('notificationsToolbar', "Notification Center Actions"))),
            actionRunner
        }))));
        this.clearAllAction = this._register(this.instantiationService.createInstance(ClearAllNotificationsAction, ClearAllNotificationsAction.ID, ClearAllNotificationsAction.LABEL));
        notificationsToolBar.push(this.clearAllAction, { icon: true, label: false, keybinding: this.getKeybindingLabel(this.clearAllAction) });
        this.toggleDoNotDisturbAction = this._register(this.instantiationService.createInstance(ToggleDoNotDisturbAction, ToggleDoNotDisturbAction.ID, ToggleDoNotDisturbAction.LABEL));
        notificationsToolBar.push(this.toggleDoNotDisturbAction, { icon: true, label: false, keybinding: this.getKeybindingLabel(this.toggleDoNotDisturbAction) });
        const hideAllAction = this._register(this.instantiationService.createInstance(HideNotificationsCenterAction, HideNotificationsCenterAction.ID, HideNotificationsCenterAction.LABEL));
        notificationsToolBar.push(hideAllAction, { icon: true, label: false, keybinding: this.getKeybindingLabel(hideAllAction) });
        this.notificationsList = this.instantiationService.createInstance(NotificationsList, this.notificationsCenterContainer, {
            widgetAriaLabel: ( (localize('notificationsCenterWidgetAriaLabel', "Notifications Center")))
        });
        this.container.appendChild(this.notificationsCenterContainer);
    }
    getKeybindingLabel(action) {
        const keybinding = this.keybindingService.lookupKeybinding(action.id);
        return keybinding ? keybinding.getLabel() : null;
    }
    onDidChangeNotification(e) {
        if (!this._isVisible) {
            return;
        }
        let focusEditor = false;
        const [notificationsList, notificationsCenterContainer] = assertAllDefined(this.notificationsList, this.notificationsCenterContainer);
        switch (e.kind) {
            case 0 :
                notificationsList.updateNotificationsList(e.index, 0, [e.item]);
                e.item.updateVisibility(true);
                break;
            case 1 :
                switch (e.detail) {
                    case 2 :
                        notificationsList.updateNotificationsList(e.index, 1, [e.item]);
                        break;
                    case 1 :
                        if (e.item.expanded) {
                            notificationsList.updateNotificationHeight(e.item);
                        }
                        break;
                }
                break;
            case 2 :
                notificationsList.updateNotificationsList(e.index, 1, [e.item]);
                break;
            case 3 :
                focusEditor = isAncestor(document.activeElement, notificationsCenterContainer);
                notificationsList.updateNotificationsList(e.index, 1);
                e.item.updateVisibility(false);
                break;
        }
        this.updateTitle();
        if (this.model.notifications.length === 0) {
            this.hide();
            if (focusEditor) {
                this.editorGroupService.activeGroup.focus();
            }
        }
    }
    hide() {
        if (!this._isVisible || !this.notificationsCenterContainer || !this.notificationsList) {
            return;
        }
        const focusEditor = isAncestor(document.activeElement, this.notificationsCenterContainer);
        this._isVisible = false;
        this.notificationsCenterContainer.classList.remove('visible');
        this.notificationsList.hide();
        this.model.notifications.forEach(notification => notification.updateVisibility(false));
        this.notificationsCenterVisibleContextKey.set(false);
        this._onDidChangeVisibility.fire();
        if (focusEditor) {
            this.editorGroupService.activeGroup.focus();
        }
    }
    updateStyles() {
        if (this.notificationsCenterContainer && this.notificationsCenterHeader) {
            const widgetShadowColor = this.getColor(widgetShadow);
            this.notificationsCenterContainer.style.boxShadow = widgetShadowColor ? `0 0 8px 2px ${widgetShadowColor}` : '';
            const borderColor = this.getColor(NOTIFICATIONS_CENTER_BORDER);
            this.notificationsCenterContainer.style.border = borderColor ? `1px solid ${borderColor}` : '';
            const headerForeground = this.getColor(NOTIFICATIONS_CENTER_HEADER_FOREGROUND);
            this.notificationsCenterHeader.style.color = headerForeground ?? '';
            const headerBackground = this.getColor(NOTIFICATIONS_CENTER_HEADER_BACKGROUND);
            this.notificationsCenterHeader.style.background = headerBackground ?? '';
        }
    }
    layout(dimension) {
        this.workbenchDimensions = dimension;
        if (this._isVisible && this.notificationsCenterContainer) {
            const maxWidth = NotificationsCenter.MAX_DIMENSIONS.width;
            const maxHeight = NotificationsCenter.MAX_DIMENSIONS.height;
            let availableWidth = maxWidth;
            let availableHeight = maxHeight;
            if (this.workbenchDimensions) {
                availableWidth = this.workbenchDimensions.width;
                availableWidth -= (2 * 8);
                availableHeight = this.workbenchDimensions.height - 35 ;
                if (this.layoutService.isVisible("workbench.parts.statusbar" )) {
                    availableHeight -= 22;
                }
                if (this.layoutService.isVisible("workbench.parts.titlebar" )) {
                    availableHeight -= 22;
                }
                availableHeight -= (2 * 12);
            }
            const notificationsList = assertIsDefined(this.notificationsList);
            notificationsList.layout(Math.min(maxWidth, availableWidth), Math.min(maxHeight, availableHeight));
        }
    }
    clearAll() {
        this.hide();
        for (const notification of [...this.model.notifications] ) {
            if (!notification.hasProgress) {
                notification.close();
            }
        }
    }
};
NotificationsCenter.MAX_DIMENSIONS = ( (new Dimension(450, 400)));
NotificationsCenter = ( (__decorate([
    ( (__param(2, IThemeService))),
    ( (__param(3, IInstantiationService))),
    ( (__param(4, IWorkbenchLayoutService))),
    ( (__param(5, IContextKeyService))),
    ( (__param(6, IEditorGroupsService))),
    ( (__param(7, IKeybindingService))),
    ( (__param(8, INotificationService)))
], NotificationsCenter)));
class NotificationsAlerts extends Disposable {
    constructor(model) {
        super();
        this.model = model;
        for (const notification of model.notifications) {
            this.triggerAriaAlert(notification);
        }
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.model.onDidChangeNotification(e => this.onDidChangeNotification(e)));
    }
    onDidChangeNotification(e) {
        if (e.kind === 0 ) {
            this.triggerAriaAlert(e.item);
            if (e.item.severity === Severity.Error) {
                if (e.item.message.original instanceof Error) {
                    console.error(e.item.message.original);
                }
                else {
                    console.error(toErrorMessage(( (e.item.message.linkedText.toString())), true));
                }
            }
        }
    }
    triggerAriaAlert(notification) {
        if (notification.silent) {
            return;
        }
        const listener = notification.onDidChangeContent(e => {
            if (e.kind === 1 ) {
                this.doTriggerAriaAlert(notification);
            }
        });
        Event.once(notification.onDidClose)(() => listener.dispose());
        this.doTriggerAriaAlert(notification);
    }
    doTriggerAriaAlert(notification) {
        let alertText;
        if (notification.severity === Severity.Error) {
            alertText = ( (localize(
                'alertErrorMessage',
                "Error: {0}",
                 (notification.message.linkedText.toString())
            )));
        }
        else if (notification.severity === Severity.Warning) {
            alertText = ( (localize(
                'alertWarningMessage',
                "Warning: {0}",
                 (notification.message.linkedText.toString())
            )));
        }
        else {
            alertText = ( (localize(
                'alertInfoMessage',
                "Info: {0}",
                 (notification.message.linkedText.toString())
            )));
        }
        alert(alertText);
    }
}
function initialize(instantiationService) {
    const container = instantiationService.invokeFunction((accessor) => accessor.get(ILayoutService)).container;
    const model = instantiationService.invokeFunction((accessor) => accessor.get(INotificationService)).model;
    setTimeout(() => {
        const notificationsCenter = instantiationService.createInstance(NotificationsCenter, container, model);
        const notificationsToasts = instantiationService.createInstance(NotificationsToasts, container, model);
        instantiationService.createInstance(NotificationsAlerts, model);
        instantiationService.createInstance(NotificationsTelemetry);
        registerNotificationCommands(notificationsCenter, notificationsToasts, model);
        notificationsToasts.layout(getClientArea(container));
    });
}
function getServiceOverride(container) {
    onServicesInitialized(initialize);
    return {
        [( INotificationService.toString())]: new SyncDescriptor(NotificationService),
        ...getServiceOverride$1(container)
    };
}
export { getServiceOverride as default };
