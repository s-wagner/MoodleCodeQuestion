import { o as onServicesInitialized, x as registerAssets } from './polyfill.js';
import { bS as IPreferencesService } from './missing-services.js';
import { _ as __decorate, a as __param, I as IEditorService, u as IDebugService } from './services2.js';
import { Disposable, DisposableStore, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IAudioCueService, AudioCue as AudioCue$1 } from 'monaco-editor/esm/vs/platform/audioCues/browser/audioCueService.js';
import { MarkerSeverity, IMarkerService } from 'monaco-editor/esm/vs/platform/markers/common/markers.js';
import { CachedFunction } from 'monaco-editor/esm/vs/base/common/cache.js';
import { isDiffEditor, isCodeEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { FoldingController } from 'monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js';
import { GhostTextController } from 'monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextController.js';
import break_mp3 from "./assets/break.mp3";
import diffLineDeleted_mp3 from "./assets/diffLineDeleted.mp3";
import diffLineInserted_mp3 from "./assets/diffLineInserted.mp3";
import diffLineModified_mp3 from "./assets/diffLineModified.mp3";
import error_mp3 from "./assets/error.mp3";
import foldedAreas_mp3 from "./assets/foldedAreas.mp3";
import quickFixes_mp3 from "./assets/quickFixes.mp3";
import taskCompleted_mp3 from "./assets/taskCompleted.mp3";
import taskFailed_mp3 from "./assets/taskFailed.mp3";
import terminalBell_mp3 from "./assets/terminalBell.mp3";
import warning_mp3 from "./assets/warning.mp3";
import { registerAction2, Action2 } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { localize } from 'monaco-editor/esm/vs/nls.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { IAccessibilityService } from 'monaco-editor/esm/vs/platform/accessibility/common/accessibility.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { FileAccess } from 'monaco-editor/esm/vs/base/common/network.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
let _derived;
function _setDerived(derived) {
    _derived = derived;
}
class ConvenientObservable {
    get TChange() { return null; }
    read(reader) {
        reader.subscribeTo(this);
        return this.get();
    }
    map(fn) {
        return _derived(() => {
            const name = getFunctionName(fn);
            return name !== undefined ? name : `${this.debugName} (mapped)`;
        }, (reader) => fn(this.read(reader)));
    }
}
class BaseObservable extends ConvenientObservable {
    constructor() {
        super(...arguments);
        this.observers = ( (new Set()));
    }
    addObserver(observer) {
        const len = this.observers.size;
        this.observers.add(observer);
        if (len === 0) {
            this.onFirstObserverAdded();
        }
    }
    removeObserver(observer) {
        const deleted = this.observers.delete(observer);
        if (deleted && this.observers.size === 0) {
            this.onLastObserverRemoved();
        }
    }
    onFirstObserverAdded() { }
    onLastObserverRemoved() { }
}
function transaction(fn, getDebugName) {
    const tx = ( (new TransactionImpl(fn, getDebugName)));
    try {
        fn(tx);
    }
    finally {
        tx.finish();
    }
}
function getFunctionName(fn) {
    const fnSrc = ( (fn.toString()));
    const regexp = /\/\*\*\s*@description\s*([^*]*)\*\//;
    const match = regexp.exec(fnSrc);
    const result = match ? match[1] : undefined;
    return result?.trim();
}
class TransactionImpl {
    constructor(fn, _getDebugName) {
        this.fn = fn;
        this._getDebugName = _getDebugName;
        this.updatingObservers = [];
    }
    getDebugName() {
        if (this._getDebugName) {
            return this._getDebugName();
        }
        return getFunctionName(this.fn);
    }
    updateObserver(observer, observable) {
        this.updatingObservers.push({ observer, observable });
        observer.beginUpdate(observable);
    }
    finish() {
        const updatingObservers = this.updatingObservers;
        this.updatingObservers = null;
        for (const { observer, observable } of updatingObservers) {
            observer.endUpdate(observable);
        }
    }
}
function observableValue(name, initialValue) {
    return (
         (new ObservableValue(name, initialValue))
    );
}
class ObservableValue extends BaseObservable {
    constructor(debugName, initialValue) {
        super();
        this.debugName = debugName;
        this.value = initialValue;
    }
    get() {
        return this.value;
    }
    set(value, tx, change) {
        if (this.value === value) {
            return;
        }
        if (!tx) {
            transaction((tx) => {
                this.set(value, tx, change);
            }, () => `Setting ${this.debugName}`);
            return;
        }
        this.value = value;
        for (const observer of this.observers) {
            tx.updateObserver(observer, this);
            observer.handleChange(this, change);
        }
    }
    toString() {
        return `${this.debugName}: ${this.value}`;
    }
}
function derived(debugName, computeFn) {
    return (
         (new Derived(debugName, computeFn))
    );
}
_setDerived(derived);
class Derived extends BaseObservable {
    get dependencies() {
        return this._dependencies;
    }
    get debugName() {
        return typeof this._debugName === 'function' ? this._debugName() : this._debugName;
    }
    constructor(_debugName, computeFn) {
        super();
        this._debugName = _debugName;
        this.computeFn = computeFn;
        this.hadValue = false;
        this.hasValue = false;
        this.value = undefined;
        this.updateCount = 0;
        this._dependencies = ( (new Set()));
        this.staleDependencies = ( (new Set()));
    }
    onLastObserverRemoved() {
        this.hasValue = false;
        this.hadValue = false;
        this.value = undefined;
        for (const d of this._dependencies) {
            d.removeObserver(this);
        }
        this._dependencies.clear();
    }
    get() {
        if (this.observers.size === 0) {
            const result = this.computeFn(this);
            this.onLastObserverRemoved();
            return result;
        }
        if (this.updateCount > 0 && this.hasValue) {
            for (const d of this._dependencies) {
                d.get();
                if (!this.hasValue) {
                    break;
                }
            }
        }
        if (!this.hasValue) {
            const emptySet = this.staleDependencies;
            this.staleDependencies = this._dependencies;
            this._dependencies = emptySet;
            const oldValue = this.value;
            try {
                this.value = this.computeFn(this);
            }
            finally {
                for (const o of this.staleDependencies) {
                    o.removeObserver(this);
                }
                this.staleDependencies.clear();
            }
            this.hasValue = true;
            const didChange = this.hadValue && oldValue !== this.value;
            if (didChange) {
                for (const r of this.observers) {
                    r.handleChange(this, undefined);
                }
            }
        }
        return this.value;
    }
    beginUpdate() {
        if (this.updateCount === 0) {
            for (const r of this.observers) {
                r.beginUpdate(this);
            }
        }
        this.updateCount++;
    }
    handleChange(_observable, _change) {
        if (this.hasValue) {
            this.hadValue = true;
            this.hasValue = false;
        }
        if (this.updateCount === 0 && this.observers.size > 0) {
            this.get();
        }
    }
    endUpdate() {
        this.updateCount--;
        if (this.updateCount === 0) {
            if (this.observers.size > 0) {
                this.get();
            }
            for (const r of this.observers) {
                r.endUpdate(this);
            }
        }
    }
    subscribeTo(observable) {
        this._dependencies.add(observable);
        if (!this.staleDependencies.delete(observable)) {
            observable.addObserver(this);
        }
    }
    toString() {
        return `LazyDerived<${this.debugName}>`;
    }
}
function autorun(debugName, fn) {
    return (
         (new AutorunObserver(debugName, fn, undefined))
    );
}
function autorunWithStore(fn, debugName) {
    const store = ( (new DisposableStore()));
    const disposable = autorun(debugName, reader => {
        store.clear();
        fn(reader, store);
    });
    return toDisposable(() => {
        disposable.dispose();
        store.dispose();
    });
}
class AutorunObserver {
    get dependencies() {
        return this._dependencies;
    }
    constructor(debugName, runFn, _handleChange) {
        this.debugName = debugName;
        this.runFn = runFn;
        this._handleChange = _handleChange;
        this.needsToRun = true;
        this.updateCount = 0;
        this.disposed = false;
        this._dependencies = ( (new Set()));
        this.staleDependencies = ( (new Set()));
        this.runIfNeeded();
    }
    subscribeTo(observable) {
        if (this.disposed) {
            return;
        }
        this._dependencies.add(observable);
        if (!this.staleDependencies.delete(observable)) {
            observable.addObserver(this);
        }
    }
    handleChange(observable, change) {
        const shouldReact = this._handleChange ? this._handleChange({
            changedObservable: observable,
            change,
            didChange: o => o === observable,
        }) : true;
        this.needsToRun = this.needsToRun || shouldReact;
        if (this.updateCount === 0) {
            this.runIfNeeded();
        }
    }
    beginUpdate() {
        this.updateCount++;
    }
    endUpdate() {
        this.updateCount--;
        if (this.updateCount === 0) {
            this.runIfNeeded();
        }
    }
    runIfNeeded() {
        if (!this.needsToRun) {
            return;
        }
        const emptySet = this.staleDependencies;
        this.staleDependencies = this._dependencies;
        this._dependencies = emptySet;
        this.needsToRun = false;
        try {
            this.runFn(this);
        }
        finally {
            for (const o of this.staleDependencies) {
                o.removeObserver(this);
            }
            this.staleDependencies.clear();
        }
    }
    dispose() {
        this.disposed = true;
        for (const o of this._dependencies) {
            o.removeObserver(this);
        }
        this._dependencies.clear();
    }
    toString() {
        return `Autorun<${this.debugName}>`;
    }
}
( ((function(autorun) {
    autorun.Observer = AutorunObserver;
})(autorun || (autorun = {}))));
function autorunDelta(name, observable, handler) {
    let _lastValue;
    return autorun(name, (reader) => {
        const newValue = observable.read(reader);
        const lastValue = _lastValue;
        _lastValue = newValue;
        handler({ lastValue, newValue });
    });
}
function constObservable(value) {
    return (
         (new ConstObservable(value))
    );
}
class ConstObservable extends ConvenientObservable {
    constructor(value) {
        super();
        this.value = value;
    }
    get debugName() {
        return (
             (this.toString())
        );
    }
    get() {
        return this.value;
    }
    addObserver(observer) {
    }
    removeObserver(observer) {
    }
    toString() {
        return `Const: ${this.value}`;
    }
}
function observableFromPromise(promise) {
    const observable = observableValue('promiseValue', {});
    promise.then((value) => {
        observable.set({ value }, undefined);
    });
    return observable;
}
function observableFromEvent(event, getValue) {
    return (
         (new FromEventObservable(event, getValue))
    );
}
class FromEventObservable extends BaseObservable {
    constructor(event, getValue) {
        super();
        this.event = event;
        this.getValue = getValue;
        this.hasValue = false;
        this.handleEvent = (args) => {
            const newValue = this.getValue(args);
            const didChange = !this.hasValue || this.value !== newValue;
            if (didChange) {
                this.value = newValue;
                if (this.hasValue) {
                    transaction((tx) => {
                        for (const o of this.observers) {
                            tx.updateObserver(o, this);
                            o.handleChange(this, undefined);
                        }
                    }, () => {
                        const name = this.getDebugName();
                        return 'Event fired' + (name ? `: ${name}` : '');
                    });
                }
                this.hasValue = true;
            }
        };
    }
    getDebugName() {
        return getFunctionName(this.getValue);
    }
    get debugName() {
        const name = this.getDebugName();
        return 'From Event' + (name ? `: ${name}` : '');
    }
    onFirstObserverAdded() {
        this.subscription = this.event(this.handleEvent);
    }
    onLastObserverRemoved() {
        this.subscription.dispose();
        this.subscription = undefined;
        this.hasValue = false;
        this.value = undefined;
    }
    get() {
        if (this.subscription) {
            if (!this.hasValue) {
                this.handleEvent(undefined);
            }
            return this.value;
        }
        else {
            return this.getValue(undefined);
        }
    }
}
( ((function(observableFromEvent) {
    observableFromEvent.Observer = FromEventObservable;
})(observableFromEvent || (observableFromEvent = {}))));
function debouncedObservable(observable, debounceMs, disposableStore) {
    const debouncedObservable = observableValue('debounced', undefined);
    let timeout = undefined;
    disposableStore.add(autorun('debounce', reader => {
        const value = observable.read(reader);
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            transaction(tx => {
                debouncedObservable.set(value, tx);
            });
        }, debounceMs);
    }));
    return debouncedObservable;
}
function wasEventTriggeredRecently(event, timeoutMs, disposableStore) {
    const observable = observableValue('triggeredRecently', false);
    let timeout = undefined;
    disposableStore.add(event(() => {
        observable.set(true, undefined);
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            observable.set(false, undefined);
        }, timeoutMs);
    }));
    return observable;
}
let AudioCueService = class AudioCueService extends Disposable {
    constructor(configurationService, accessibilityService) {
        super();
        this.configurationService = configurationService;
        this.accessibilityService = accessibilityService;
        this.screenReaderAttached = observableFromEvent(this.accessibilityService.onDidChangeScreenReaderOptimized, () =>  this.accessibilityService.isScreenReaderOptimized());
        this.playingSounds = ( (new Set()));
        this.obsoleteAudioCuesEnabled = observableFromEvent(Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration('audioCues.enabled')), () =>  this.configurationService.getValue('audioCues.enabled'));
        this.isEnabledCache = ( (new Cache((cue) => {
            const settingObservable = observableFromEvent(Event.filter(this.configurationService.onDidChangeConfiguration, (e) => e.affectsConfiguration(cue.settingsKey)), () => this.configurationService.getValue(cue.settingsKey));
            return derived('audio cue enabled', reader => {
                const setting = settingObservable.read(reader);
                if (setting === 'on' ||
                    (setting === 'auto' && this.screenReaderAttached.read(reader))) {
                    return true;
                }
                const obsoleteSetting = this.obsoleteAudioCuesEnabled.read(reader);
                if (obsoleteSetting === 'on' ||
                    (obsoleteSetting === 'auto' && this.screenReaderAttached.read(reader))) {
                    return true;
                }
                return false;
            });
        })));
    }
    async playAudioCue(cue, allowManyInParallel = false) {
        if (this.isEnabled(cue)) {
            await this.playSound(cue.sound, allowManyInParallel);
        }
    }
    async playAudioCues(cues) {
        const sounds = ( (new Set(
             (cues.filter(cue => this.isEnabled(cue)).map(cue => cue.sound))
        )));
        await Promise.all(( (Array.from(sounds).map(sound => this.playSound(sound, true)))));
    }
    getVolumeInPercent() {
        const volume = this.configurationService.getValue('audioCues.volume');
        if (typeof volume !== 'number') {
            return 50;
        }
        return Math.max(Math.min(volume, 100), 0);
    }
    async playSound(sound, allowManyInParallel = false) {
        if (!allowManyInParallel && this.playingSounds.has(sound)) {
            return;
        }
        this.playingSounds.add(sound);
        const url = ( (( (FileAccess.asBrowserUri(`vs/platform/audioCues/browser/media/${sound.fileName}`))).toString(true)));
        try {
            await playAudio(url, this.getVolumeInPercent() / 100);
        }
        catch (e) {
            console.error('Error while playing sound', e);
        }
        finally {
            this.playingSounds.delete(sound);
        }
    }
    isEnabled(cue) {
        return this.isEnabledCache.get(cue).get();
    }
    onEnabledChanged(cue) {
        return eventFromObservable(this.isEnabledCache.get(cue));
    }
};
AudioCueService = ( (__decorate([
    ( (__param(0, IConfigurationService))),
    ( (__param(1, IAccessibilityService)))
], AudioCueService)));
function playAudio(url, volume) {
    return (
         (new Promise((resolve, reject) => {
            const audio = ( (new Audio(url)));
            audio.volume = volume;
            audio.addEventListener('ended', () => {
                resolve();
            });
            audio.addEventListener('error', (e) => {
                reject(e.error);
            });
            audio.play().catch(e => {
                reject(e);
            });
        }))
    );
}
function eventFromObservable(observable) {
    return (listener) => {
        let count = 0;
        let didChange = false;
        const observer = {
            beginUpdate() {
                count++;
            },
            endUpdate() {
                count--;
                if (count === 0 && didChange) {
                    didChange = false;
                    listener();
                }
            },
            handleChange() {
                if (count === 0) {
                    listener();
                }
                else {
                    didChange = true;
                }
            }
        };
        observable.addObserver(observer);
        return {
            dispose() {
                observable.removeObserver(observer);
            }
        };
    };
}
class Cache {
    constructor(getValue) {
        this.getValue = getValue;
        this.map = ( (new Map()));
    }
    get(arg) {
        if (this.map.has(arg)) {
            return this.map.get(arg);
        }
        const value = this.getValue(arg);
        this.map.set(arg, value);
        return value;
    }
}
class Sound {
    static register(options) {
        const sound = ( (new Sound(options.fileName)));
        return sound;
    }
    constructor(fileName) {
        this.fileName = fileName;
    }
}
Sound.error = Sound.register({ fileName: 'error.mp3' });
Sound.warning = Sound.register({ fileName: 'warning.mp3' });
Sound.foldedArea = Sound.register({ fileName: 'foldedAreas.mp3' });
Sound.break = Sound.register({ fileName: 'break.mp3' });
Sound.quickFixes = Sound.register({ fileName: 'quickFixes.mp3' });
Sound.taskCompleted = Sound.register({ fileName: 'taskCompleted.mp3' });
Sound.taskFailed = Sound.register({ fileName: 'taskFailed.mp3' });
Sound.terminalBell = Sound.register({ fileName: 'terminalBell.mp3' });
Sound.diffLineInserted = Sound.register({ fileName: 'diffLineInserted.mp3' });
Sound.diffLineDeleted = Sound.register({ fileName: 'diffLineDeleted.mp3' });
Sound.diffLineModified = Sound.register({ fileName: 'diffLineModified.mp3' });
class AudioCue {
    static register(options) {
        const audioCue = ( (new AudioCue(options.sound, options.name, options.settingsKey)));
        AudioCue._audioCues.add(audioCue);
        return audioCue;
    }
    static get allAudioCues() {
        return [...this._audioCues];
    }
    constructor(sound, name, settingsKey) {
        this.sound = sound;
        this.name = name;
        this.settingsKey = settingsKey;
    }
}
AudioCue._audioCues = ( (new Set()));
AudioCue.error = AudioCue.register({
    name: ( (localize('audioCues.lineHasError.name', 'Error on Line'))),
    sound: Sound.error,
    settingsKey: 'audioCues.lineHasError',
});
AudioCue.warning = AudioCue.register({
    name: ( (localize('audioCues.lineHasWarning.name', 'Warning on Line'))),
    sound: Sound.warning,
    settingsKey: 'audioCues.lineHasWarning',
});
AudioCue.foldedArea = AudioCue.register({
    name: ( (localize('audioCues.lineHasFoldedArea.name', 'Folded Area on Line'))),
    sound: Sound.foldedArea,
    settingsKey: 'audioCues.lineHasFoldedArea',
});
AudioCue.break = AudioCue.register({
    name: ( (localize('audioCues.lineHasBreakpoint.name', 'Breakpoint on Line'))),
    sound: Sound.break,
    settingsKey: 'audioCues.lineHasBreakpoint',
});
AudioCue.inlineSuggestion = AudioCue.register({
    name: ( (localize('audioCues.lineHasInlineSuggestion.name', 'Inline Suggestion on Line'))),
    sound: Sound.quickFixes,
    settingsKey: 'audioCues.lineHasInlineSuggestion',
});
AudioCue.terminalQuickFix = AudioCue.register({
    name: ( (localize('audioCues.terminalQuickFix.name', 'Terminal Quick Fix'))),
    sound: Sound.quickFixes,
    settingsKey: 'audioCues.terminalQuickFix',
});
AudioCue.onDebugBreak = AudioCue.register({
    name: ( (localize('audioCues.onDebugBreak.name', 'Debugger Stopped on Breakpoint'))),
    sound: Sound.break,
    settingsKey: 'audioCues.onDebugBreak',
});
AudioCue.noInlayHints = AudioCue.register({
    name: ( (localize('audioCues.noInlayHints', 'No Inlay Hints on Line'))),
    sound: Sound.error,
    settingsKey: 'audioCues.noInlayHints'
});
AudioCue.taskCompleted = AudioCue.register({
    name: ( (localize('audioCues.taskCompleted', 'Task Completed'))),
    sound: Sound.taskCompleted,
    settingsKey: 'audioCues.taskCompleted'
});
AudioCue.taskFailed = AudioCue.register({
    name: ( (localize('audioCues.taskFailed', 'Task Failed'))),
    sound: Sound.taskFailed,
    settingsKey: 'audioCues.taskFailed'
});
AudioCue.terminalCommandFailed = AudioCue.register({
    name: ( (localize('audioCues.terminalCommandFailed', 'Terminal Command Failed'))),
    sound: Sound.taskFailed,
    settingsKey: 'audioCues.terminalCommandFailed'
});
AudioCue.terminalBell = AudioCue.register({
    name: ( (localize('audioCues.terminalBell', 'Terminal Bell'))),
    sound: Sound.terminalBell,
    settingsKey: 'audioCues.terminalBell'
});
AudioCue.notebookCellCompleted = AudioCue.register({
    name: ( (localize('audioCues.notebookCellCompleted', 'Notebook Cell Completed'))),
    sound: Sound.taskCompleted,
    settingsKey: 'audioCues.notebookCellCompleted'
});
AudioCue.notebookCellFailed = AudioCue.register({
    name: ( (localize('audioCues.notebookCellFailed', 'Notebook Cell Failed'))),
    sound: Sound.taskFailed,
    settingsKey: 'audioCues.notebookCellFailed'
});
AudioCue.diffLineInserted = AudioCue.register({
    name: ( (localize('audioCues.diffLineInserted', 'Diff Line Inserted'))),
    sound: Sound.diffLineInserted,
    settingsKey: 'audioCues.diffLineInserted'
});
AudioCue.diffLineDeleted = AudioCue.register({
    name: ( (localize('audioCues.diffLineDeleted', 'Diff Line Deleted'))),
    sound: Sound.diffLineDeleted,
    settingsKey: 'audioCues.diffLineDeleted'
});
AudioCue.diffLineModified = AudioCue.register({
    name: ( (localize('audioCues.diffLineModified', 'Diff Line Modified'))),
    sound: Sound.diffLineModified,
    settingsKey: 'audioCues.diffLineModified'
});
let AudioCueLineFeatureContribution = class AudioCueLineFeatureContribution extends Disposable {
    constructor(editorService, instantiationService, audioCueService, _configurationService) {
        super();
        this.editorService = editorService;
        this.instantiationService = instantiationService;
        this.audioCueService = audioCueService;
        this._configurationService = _configurationService;
        this.store = this._register(( (new DisposableStore())));
        this.features = [
            this.instantiationService.createInstance(MarkerLineFeature, AudioCue$1.error, MarkerSeverity.Error),
            this.instantiationService.createInstance(MarkerLineFeature, AudioCue$1.warning, MarkerSeverity.Warning),
            this.instantiationService.createInstance(FoldedAreaLineFeature),
            this.instantiationService.createInstance(BreakpointLineFeature),
            this.instantiationService.createInstance(InlineCompletionLineFeature),
        ];
        this.isEnabledCache = ( (new CachedFunction(
            (cue) => observableFromEvent(this.audioCueService.onEnabledChanged(cue), () => this.audioCueService.isEnabled(cue))
        )));
        const someAudioCueFeatureIsEnabled = derived('someAudioCueFeatureIsEnabled', (reader) => this.features.some((feature) => this.isEnabledCache.get(feature.audioCue).read(reader)));
        const activeEditorObservable = observableFromEvent(this.editorService.onDidActiveEditorChange, (_) => {
            const activeTextEditorControl = this.editorService.activeTextEditorControl;
            const editor = isDiffEditor(activeTextEditorControl)
                ? activeTextEditorControl.getOriginalEditor()
                : isCodeEditor(activeTextEditorControl)
                    ? activeTextEditorControl
                    : undefined;
            return editor && editor.hasModel() ? { editor, model: editor.getModel() } : undefined;
        });
        this._register(autorun('updateAudioCuesEnabled', (reader) => {
            this.store.clear();
            if (!someAudioCueFeatureIsEnabled.read(reader)) {
                return;
            }
            const activeEditor = activeEditorObservable.read(reader);
            if (activeEditor) {
                this.registerAudioCuesForEditor(activeEditor.editor, activeEditor.model, this.store);
            }
        }));
    }
    registerAudioCuesForEditor(editor, editorModel, store) {
        const curPosition = observableFromEvent(editor.onDidChangeCursorPosition, (args) => {
            if (args &&
                args.reason !== 3  &&
                args.reason !== 0 ) {
                return undefined;
            }
            return editor.getPosition();
        });
        const debouncedPosition = debouncedObservable(curPosition, this._configurationService.getValue('audioCues.debouncePositionChanges') ? 300 : 0, store);
        const isTyping = wasEventTriggeredRecently(editorModel.onDidChangeContent.bind(editorModel), 1000, store);
        const featureStates = ( (this.features.map((feature) => {
            const lineFeatureState = feature.getObservableState(editor, editorModel);
            const isFeaturePresent = derived(`isPresentInLine:${feature.audioCue.name}`, (reader) => {
                if (!this.isEnabledCache.get(feature.audioCue).read(reader)) {
                    return false;
                }
                const position = debouncedPosition.read(reader);
                if (!position) {
                    return false;
                }
                return lineFeatureState.read(reader).isPresent(position);
            });
            return derived(`typingDebouncedFeatureState:\n${feature.audioCue.name}`, (reader) => feature.debounceWhileTyping && isTyping.read(reader)
                ? (debouncedPosition.read(reader), isFeaturePresent.get())
                : isFeaturePresent.read(reader));
        })));
        const state = derived('states', (reader) => ({
            lineNumber: debouncedPosition.read(reader),
            featureStates: ( (new Map( (this.features.map((feature, idx) => [
                feature,
                featureStates[idx].read(reader),
            ]))))),
        }));
        store.add(autorunDelta('Play Audio Cue', state, ({ lastValue, newValue }) => {
            const newFeatures = this.features.filter(feature => newValue?.featureStates.get(feature) &&
                (!lastValue?.featureStates?.get(feature) || newValue.lineNumber !== lastValue.lineNumber));
            this.audioCueService.playAudioCues(( (newFeatures.map(f => f.audioCue))));
        }));
    }
};
AudioCueLineFeatureContribution = ( (__decorate([
    ( (__param(0, IEditorService))),
    ( (__param(1, IInstantiationService))),
    ( (__param(2, IAudioCueService))),
    ( (__param(3, IConfigurationService)))
], AudioCueLineFeatureContribution)));
let MarkerLineFeature = class MarkerLineFeature {
    constructor(audioCue, severity, markerService) {
        this.audioCue = audioCue;
        this.severity = severity;
        this.markerService = markerService;
        this.debounceWhileTyping = true;
        this._previousLine = 0;
    }
    getObservableState(editor, model) {
        return observableFromEvent(Event.filter(this.markerService.onMarkerChanged, (changedUris) => changedUris.some((u) => ( (u.toString())) === ( (model.uri.toString())))), () =>  ({
            isPresent: (position) => {
                const lineChanged = position.lineNumber !== this._previousLine;
                this._previousLine = position.lineNumber;
                const hasMarker = this.markerService
                    .read({ resource: model.uri })
                    .some((m) => {
                    const onLine = m.severity === this.severity && m.startLineNumber <= position.lineNumber && position.lineNumber <= m.endLineNumber;
                    return lineChanged ? onLine : onLine && (position.lineNumber <= m.endLineNumber && m.startColumn <= position.column);
                });
                return hasMarker;
            },
        }));
    }
};
MarkerLineFeature = ( (__decorate([
    ( (__param(2, IMarkerService)))
], MarkerLineFeature)));
class FoldedAreaLineFeature {
    constructor() {
        this.audioCue = AudioCue$1.foldedArea;
    }
    getObservableState(editor, model) {
        const foldingController = FoldingController.get(editor);
        if (!foldingController) {
            return constObservable({
                isPresent: () => false,
            });
        }
        const foldingModel = observableFromPromise(foldingController.getFoldingModel() ?? Promise.resolve(undefined));
        return (
             (foldingModel.map((v) => ({
                isPresent: (position) => {
                    const regionAtLine = v.value?.getRegionAtLine(position.lineNumber);
                    const hasFolding = !regionAtLine
                        ? false
                        : regionAtLine.isCollapsed &&
                            regionAtLine.startLineNumber === position.lineNumber;
                    return hasFolding;
                },
            })))
        );
    }
}
let BreakpointLineFeature = class BreakpointLineFeature {
    constructor(debugService) {
        this.debugService = debugService;
        this.audioCue = AudioCue$1.break;
    }
    getObservableState(editor, model) {
        return observableFromEvent(this.debugService.getModel().onDidChangeBreakpoints, () =>  ({
            isPresent: (position) => {
                const breakpoints = this.debugService
                    .getModel()
                    .getBreakpoints({ uri: model.uri, lineNumber: position.lineNumber });
                const hasBreakpoints = breakpoints.length > 0;
                return hasBreakpoints;
            },
        }));
    }
};
BreakpointLineFeature = ( (__decorate([
    ( (__param(0, IDebugService)))
], BreakpointLineFeature)));
class InlineCompletionLineFeature {
    constructor() {
        this.audioCue = AudioCue$1.inlineSuggestion;
    }
    getObservableState(editor, _model) {
        const ghostTextController = GhostTextController.get(editor);
        if (!ghostTextController) {
            return constObservable({
                isPresent: () => false,
            });
        }
        const activeGhostText = ( (observableFromEvent(ghostTextController.onActiveModelDidChange, () =>  ghostTextController.activeModel).map((activeModel) => (activeModel
            ? observableFromEvent(activeModel.inlineCompletionsModel.onDidChange, () =>  activeModel.inlineCompletionsModel.ghostText)
            : undefined))));
        return derived('ghostText', reader => {
            const ghostText = activeGhostText.read(reader)?.read(reader);
            return {
                isPresent(position) {
                    return ghostText?.lineNumber === position.lineNumber;
                }
            };
        });
    }
}
let AudioCueLineDebuggerContribution = class AudioCueLineDebuggerContribution extends Disposable {
    constructor(debugService, audioCueService) {
        super();
        this.audioCueService = audioCueService;
        const isEnabled = observableFromEvent(audioCueService.onEnabledChanged(AudioCue$1.onDebugBreak), () => audioCueService.isEnabled(AudioCue$1.onDebugBreak));
        this._register(autorunWithStore((reader, store) => {
            if (!isEnabled.read(reader)) {
                return;
            }
            const sessionDisposables = ( (new Map()));
            store.add(toDisposable(() => {
                sessionDisposables.forEach(d => d.dispose());
                sessionDisposables.clear();
            }));
            store.add(debugService.onDidNewSession((session) => sessionDisposables.set(session, this.handleSession(session))));
            store.add(debugService.onDidEndSession(session => {
                sessionDisposables.get(session)?.dispose();
                sessionDisposables.delete(session);
            }));
            debugService
                .getModel()
                .getSessions()
                .forEach((session) => sessionDisposables.set(session, this.handleSession(session)));
        }, 'subscribe to debug sessions'));
    }
    handleSession(session) {
        return session.onDidChangeState(e => {
            const stoppedDetails = session.getStoppedDetails();
            const BREAKPOINT_STOP_REASON = 'breakpoint';
            if (stoppedDetails && stoppedDetails.reason === BREAKPOINT_STOP_REASON) {
                this.audioCueService.playAudioCue(AudioCue$1.onDebugBreak);
            }
        });
    }
};
AudioCueLineDebuggerContribution = ( (__decorate([
    ( (__param(0, IDebugService))),
    ( (__param(1, IAudioCueService)))
], AudioCueLineDebuggerContribution)));
var audioAssets = Object.freeze({
    __proto__: null,
    vs_platform_audioCues_browser_media_break_mp3: break_mp3,
    vs_platform_audioCues_browser_media_diffLineDeleted_mp3: diffLineDeleted_mp3,
    vs_platform_audioCues_browser_media_diffLineInserted_mp3: diffLineInserted_mp3,
    vs_platform_audioCues_browser_media_diffLineModified_mp3: diffLineModified_mp3,
    vs_platform_audioCues_browser_media_error_mp3: error_mp3,
    vs_platform_audioCues_browser_media_foldedAreas_mp3: foldedAreas_mp3,
    vs_platform_audioCues_browser_media_quickFixes_mp3: quickFixes_mp3,
    vs_platform_audioCues_browser_media_taskCompleted_mp3: taskCompleted_mp3,
    vs_platform_audioCues_browser_media_taskFailed_mp3: taskFailed_mp3,
    vs_platform_audioCues_browser_media_terminalBell_mp3: terminalBell_mp3,
    vs_platform_audioCues_browser_media_warning_mp3: warning_mp3
});
class ShowAudioCueHelp extends Action2 {
    constructor() {
        super({
            id: ShowAudioCueHelp.ID,
            title: {
                value: ( (localize('audioCues.help', "Help: List Audio Cues"))),
                original: 'Help: List Audio Cues'
            },
            f1: true,
        });
    }
    async run(accessor) {
        const audioCueService = accessor.get(IAudioCueService);
        const quickPickService = accessor.get(IQuickInputService);
        const preferencesService = accessor.get(IPreferencesService);
        const accessibilityService = accessor.get(IAccessibilityService);
        const items = ( (AudioCue$1.allAudioCues.map((cue, idx) => ({
            label: accessibilityService.isScreenReaderOptimized() ?
                `${cue.name}${audioCueService.isEnabled(cue) ? '' : ' (' + ( ( localize('disabled', "Disabled"))) + ')'}`
                : `${audioCueService.isEnabled(cue) ? '$(check)' : '     '} ${cue.name}`,
            audioCue: cue,
            buttons: [{
                    iconClass: ThemeIcon.asClassName(Codicon.settingsGear),
                    tooltip: ( (localize('audioCues.help.settings', 'Enable/Disable Audio Cue'))),
                }],
        }))));
        const quickPick = quickPickService.pick(items, {
            activeItem: items[0],
            onDidFocus: (item) => {
                audioCueService.playSound(item.audioCue.sound, true);
            },
            onDidTriggerItemButton: (context) => {
                preferencesService.openSettings({ query: context.item.audioCue.settingsKey });
            },
            placeHolder: ( (localize('audioCues.help.placeholder', 'Select an audio cue to play'))),
        });
        await quickPick;
    }
}
ShowAudioCueHelp.ID = 'audioCues.help';
const audioCueFeatureBase = {
    'type': 'string',
    'enum': ['auto', 'on', 'off'],
    'default': 'auto',
    'enumDescriptions': [
        ( (localize(
        'audioCues.enabled.auto',
        "Enable audio cue when a screen reader is attached."
    ))),
        ( (localize('audioCues.enabled.on', "Enable audio cue."))),
        ( (localize('audioCues.enabled.off', "Disable audio cue.")))
    ],
    tags: ['accessibility']
};
( (Registry.as(Extensions.Configuration))).registerConfiguration({
    'properties': {
        'audioCues.enabled': {
            markdownDeprecationMessage: 'Deprecated. Use the specific setting for each audio cue instead (`audioCues.*`).',
            tags: ['accessibility']
        },
        'audioCues.volume': {
            'description': ( (localize('audioCues.volume', "The volume of the audio cues in percent (0-100)."))),
            'type': 'number',
            'minimum': 0,
            'maximum': 100,
            'default': 70,
            tags: ['accessibility']
        },
        'audioCues.debouncePositionChanges': {
            'description': ( (localize(
                'audioCues.debouncePositionChanges',
                "Whether or not position changes should be debounced"
            ))),
            'type': 'boolean',
            'default': false,
            tags: ['accessibility']
        },
        'audioCues.lineHasBreakpoint': {
            'description': ( (localize(
                'audioCues.lineHasBreakpoint',
                "Plays a sound when the active line has a breakpoint."
            ))),
            ...audioCueFeatureBase
        },
        'audioCues.lineHasInlineSuggestion': {
            'description': ( (localize(
                'audioCues.lineHasInlineSuggestion',
                "Plays a sound when the active line has an inline suggestion."
            ))),
            ...audioCueFeatureBase
        },
        'audioCues.lineHasError': {
            'description': ( (localize(
                'audioCues.lineHasError',
                "Plays a sound when the active line has an error."
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.lineHasFoldedArea': {
            'description': ( (localize(
                'audioCues.lineHasFoldedArea',
                "Plays a sound when the active line has a folded area that can be unfolded."
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.lineHasWarning': {
            'description': ( (localize(
                'audioCues.lineHasWarning',
                "Plays a sound when the active line has a warning."
            ))),
            ...audioCueFeatureBase,
            default: 'off',
        },
        'audioCues.onDebugBreak': {
            'description': ( (localize(
                'audioCues.onDebugBreak',
                "Plays a sound when the debugger stopped on a breakpoint."
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.noInlayHints': {
            'description': ( (localize(
                'audioCues.noInlayHints',
                "Plays a sound when trying to read a line with inlay hints that has no inlay hints."
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.taskCompleted': {
            'description': ( (localize('audioCues.taskCompleted', "Plays a sound when a task is completed."))),
            ...audioCueFeatureBase,
        },
        'audioCues.taskFailed': {
            'description': ( (localize(
                'audioCues.taskFailed',
                "Plays a sound when a task fails (non-zero exit code)."
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.terminalCommandFailed': {
            'description': ( (localize(
                'audioCues.terminalCommandFailed',
                "Plays a sound when a terminal command fails (non-zero exit code)."
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.terminalQuickFix': {
            'description': ( (localize(
                'audioCues.terminalQuickFix',
                "Plays a sound when terminal Quick Fixes are available."
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.diffLineInserted': {
            'description': ( (localize(
                'audioCues.diffLineInserted',
                "Plays a sound when the focus moves to an inserted line in diff review mode or to the next/previous change"
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.diffLineDeleted': {
            'description': ( (localize(
                'audioCues.diffLineDeleted',
                "Plays a sound when the focus moves to a deleted line in diff review mode or to the next/previous change"
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.diffLineModified': {
            'description': ( (localize(
                'audioCues.diffLineModified',
                "Plays a sound when the focus moves to a modified line in diff review mode or to the next/previous change"
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.notebookCellCompleted': {
            'description': ( (localize(
                'audioCues.notebookCellCompleted',
                "Plays a sound when a notebook cell execution is successfully completed."
            ))),
            ...audioCueFeatureBase,
        },
        'audioCues.notebookCellFailed': {
            'description': ( (localize(
                'audioCues.notebookCellFailed',
                "Plays a sound when a notebook cell execution fails."
            ))),
            ...audioCueFeatureBase,
        },
    }
});
registerAction2(ShowAudioCueHelp);
registerAssets(audioAssets);
function initialize(instantiationService) {
    setTimeout(() => {
        instantiationService.createInstance(AudioCueLineFeatureContribution);
        instantiationService.createInstance(AudioCueLineDebuggerContribution);
    });
}
function getServiceOverride() {
    onServicesInitialized(initialize);
    return {
        [( IAudioCueService.toString())]: new SyncDescriptor(AudioCueService)
    };
}
export { getServiceOverride as default };
